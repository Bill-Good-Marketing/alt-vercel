
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Tenet
 * 
 */
export type Tenet = $Result.DefaultSelection<Prisma.$TenetPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Contact
 * 
 */
export type Contact = $Result.DefaultSelection<Prisma.$ContactPayload>
/**
 * Model ContactRelationship
 * 
 */
export type ContactRelationship = $Result.DefaultSelection<Prisma.$ContactRelationshipPayload>
/**
 * Model ActivityStep
 * 
 */
export type ActivityStep = $Result.DefaultSelection<Prisma.$ActivityStepPayload>
/**
 * Model ActivityStepUserJoin
 * 
 */
export type ActivityStepUserJoin = $Result.DefaultSelection<Prisma.$ActivityStepUserJoinPayload>
/**
 * Model UserWaypointJoin
 * 
 */
export type UserWaypointJoin = $Result.DefaultSelection<Prisma.$UserWaypointJoinPayload>
/**
 * Model ActivityWaypoint
 * 
 */
export type ActivityWaypoint = $Result.DefaultSelection<Prisma.$ActivityWaypointPayload>
/**
 * Model TemplateAssignment
 * 
 */
export type TemplateAssignment = $Result.DefaultSelection<Prisma.$TemplateAssignmentPayload>
/**
 * Model ActivityWaypointTemplate
 * 
 */
export type ActivityWaypointTemplate = $Result.DefaultSelection<Prisma.$ActivityWaypointTemplatePayload>
/**
 * Model ActivityTemplateStep
 * 
 */
export type ActivityTemplateStep = $Result.DefaultSelection<Prisma.$ActivityTemplateStepPayload>
/**
 * Model ActivityTemplateStepAssignment
 * 
 */
export type ActivityTemplateStepAssignment = $Result.DefaultSelection<Prisma.$ActivityTemplateStepAssignmentPayload>
/**
 * Model ActivityTemplate
 * 
 */
export type ActivityTemplate = $Result.DefaultSelection<Prisma.$ActivityTemplatePayload>
/**
 * Model Activity
 * 
 */
export type Activity = $Result.DefaultSelection<Prisma.$ActivityPayload>
/**
 * Model ContactTimelineEvent
 * 
 */
export type ContactTimelineEvent = $Result.DefaultSelection<Prisma.$ContactTimelineEventPayload>
/**
 * Model AuditEvent
 * 
 */
export type AuditEvent = $Result.DefaultSelection<Prisma.$AuditEventPayload>
/**
 * Model ContactTimelineEventContactJoin
 * 
 */
export type ContactTimelineEventContactJoin = $Result.DefaultSelection<Prisma.$ContactTimelineEventContactJoinPayload>
/**
 * Model Note
 * 
 */
export type Note = $Result.DefaultSelection<Prisma.$NotePayload>
/**
 * Model Attachment
 * 
 */
export type Attachment = $Result.DefaultSelection<Prisma.$AttachmentPayload>
/**
 * Model ActivityContactJoin
 * 
 */
export type ActivityContactJoin = $Result.DefaultSelection<Prisma.$ActivityContactJoinPayload>
/**
 * Model ActivityUserJoin
 * 
 */
export type ActivityUserJoin = $Result.DefaultSelection<Prisma.$ActivityUserJoinPayload>
/**
 * Model ContactEmail
 * 
 */
export type ContactEmail = $Result.DefaultSelection<Prisma.$ContactEmailPayload>
/**
 * Model ContactPhone
 * 
 */
export type ContactPhone = $Result.DefaultSelection<Prisma.$ContactPhonePayload>
/**
 * Model Address
 * 
 */
export type Address = $Result.DefaultSelection<Prisma.$AddressPayload>
/**
 * Model ConfigOption
 * 
 */
export type ConfigOption = $Result.DefaultSelection<Prisma.$ConfigOptionPayload>
/**
 * Model ImportantDate
 * 
 */
export type ImportantDate = $Result.DefaultSelection<Prisma.$ImportantDatePayload>
/**
 * Model Opportunity
 * 
 */
export type Opportunity = $Result.DefaultSelection<Prisma.$OpportunityPayload>
/**
 * Model ContactOpportunityJoin
 * 
 */
export type ContactOpportunityJoin = $Result.DefaultSelection<Prisma.$ContactOpportunityJoinPayload>
/**
 * Model UserOpportunityJoin
 * 
 */
export type UserOpportunityJoin = $Result.DefaultSelection<Prisma.$UserOpportunityJoinPayload>
/**
 * Model OpportunityProduct
 * 
 */
export type OpportunityProduct = $Result.DefaultSelection<Prisma.$OpportunityProductPayload>
/**
 * Model ProductType
 * 
 */
export type ProductType = $Result.DefaultSelection<Prisma.$ProductTypePayload>
/**
 * Model Log
 * 
 */
export type Log = $Result.DefaultSelection<Prisma.$LogPayload>
/**
 * Model Token
 * 
 */
export type Token = $Result.DefaultSelection<Prisma.$TokenPayload>
/**
 * Model TZData
 * 
 */
export type TZData = $Result.DefaultSelection<Prisma.$TZDataPayload>
/**
 * Model TestObject
 * 
 */
export type TestObject = $Result.DefaultSelection<Prisma.$TestObjectPayload>
/**
 * Model WrappedObject
 * 
 */
export type WrappedObject = $Result.DefaultSelection<Prisma.$WrappedObjectPayload>
/**
 * Model JoinTestObject
 * 
 */
export type JoinTestObject = $Result.DefaultSelection<Prisma.$JoinTestObjectPayload>
/**
 * Model JoinTestObject2
 * 
 */
export type JoinTestObject2 = $Result.DefaultSelection<Prisma.$JoinTestObject2Payload>
/**
 * Model JoinedObject1
 * 
 */
export type JoinedObject1 = $Result.DefaultSelection<Prisma.$JoinedObject1Payload>
/**
 * Model JoinedObject2
 * 
 */
export type JoinedObject2 = $Result.DefaultSelection<Prisma.$JoinedObject2Payload>
/**
 * Model JoinSelfReference
 * 
 */
export type JoinSelfReference = $Result.DefaultSelection<Prisma.$JoinSelfReferencePayload>
/**
 * Model SelfReferencialJoinModel
 * 
 */
export type SelfReferencialJoinModel = $Result.DefaultSelection<Prisma.$SelfReferencialJoinModelPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const ActivityStepType: {
  CHECK: 'CHECK',
  ATTACHMENT: 'ATTACHMENT',
  FORM: 'FORM'
};

export type ActivityStepType = (typeof ActivityStepType)[keyof typeof ActivityStepType]


export const DateOffsetType: {
  WAYPOINT: 'WAYPOINT',
  ACTIVITY: 'ACTIVITY',
  PATH_START: 'PATH_START'
};

export type DateOffsetType = (typeof DateOffsetType)[keyof typeof DateOffsetType]


export const ContactTimelineEventType: {
  NOTE: 'NOTE',
  ACTIVITY_CREATED: 'ACTIVITY_CREATED',
  ACTIVITY_COMPLETED: 'ACTIVITY_COMPLETED',
  ACTIVITY_CANCELLED: 'ACTIVITY_CANCELLED',
  ACTIVITY_FAILED: 'ACTIVITY_FAILED',
  ACTIVITY_STATUS_CHANGED: 'ACTIVITY_STATUS_CHANGED',
  ACTIVITY_REMOVED: 'ACTIVITY_REMOVED',
  ACTIVITY_STEP_CHANGED: 'ACTIVITY_STEP_CHANGED',
  ACTIVITY_ADDED_TO: 'ACTIVITY_ADDED_TO',
  ACTIVITY_REMOVED_FROM: 'ACTIVITY_REMOVED_FROM',
  WAYPOINT_CREATED: 'WAYPOINT_CREATED',
  CONTACT_CREATED: 'CONTACT_CREATED',
  CONTACT_REMOVED: 'CONTACT_REMOVED',
  MEMBER_ADDED: 'MEMBER_ADDED',
  MEMBER_REMOVED: 'MEMBER_REMOVED',
  RELATIONSHIP_ADDED: 'RELATIONSHIP_ADDED',
  RELATIONSHIP_REMOVED: 'RELATIONSHIP_REMOVED',
  OPPORTUNITY_CREATED: 'OPPORTUNITY_CREATED',
  OPPORTUNITY_REMOVED: 'OPPORTUNITY_REMOVED',
  OPPORTUNITY_WON: 'OPPORTUNITY_WON',
  OPPORTUNITY_LOST: 'OPPORTUNITY_LOST',
  OPPORTUNITY_CANCELLED: 'OPPORTUNITY_CANCELLED',
  OPPORTUNITY_STATUS_CHANGED: 'OPPORTUNITY_STATUS_CHANGED',
  EMAIL_SENT: 'EMAIL_SENT',
  EMAIL_RECEIVED: 'EMAIL_RECEIVED'
};

export type ContactTimelineEventType = (typeof ContactTimelineEventType)[keyof typeof ContactTimelineEventType]


export const Auditable: {
  CONTACT: 'CONTACT',
  NOTE: 'NOTE',
  ACTIVITY: 'ACTIVITY',
  OPPORTUNITY: 'OPPORTUNITY',
  USER: 'USER',
  ADDRESS: 'ADDRESS',
  CONTACT_EMAIL: 'CONTACT_EMAIL',
  CONTACT_PHONE: 'CONTACT_PHONE',
  IMPORTANT_DATE: 'IMPORTANT_DATE',
  ATTACHMENT: 'ATTACHMENT'
};

export type Auditable = (typeof Auditable)[keyof typeof Auditable]


export const AuditEventType: {
  READ: 'READ',
  CREATE: 'CREATE',
  UPDATE: 'UPDATE',
  DELETE: 'DELETE'
};

export type AuditEventType = (typeof AuditEventType)[keyof typeof AuditEventType]


export const ContactTimelineEventJoinType: {
  ACTIVITY_CONTACT: 'ACTIVITY_CONTACT',
  MEMBER_CONTACT: 'MEMBER_CONTACT',
  MEMBER_PARENT: 'MEMBER_PARENT',
  CONTACT_TARGET: 'CONTACT_TARGET',
  OPPORTUNITY_CONTACT: 'OPPORTUNITY_CONTACT',
  RELATIONSHIP_FROM: 'RELATIONSHIP_FROM',
  RELATIONSHIP_TO: 'RELATIONSHIP_TO'
};

export type ContactTimelineEventJoinType = (typeof ContactTimelineEventJoinType)[keyof typeof ContactTimelineEventJoinType]


export const NoteType: {
  NOTE: 'NOTE',
  CALL: 'CALL',
  CALL_OUTBOUND: 'CALL_OUTBOUND',
  CALL_INBOUND: 'CALL_INBOUND'
};

export type NoteType = (typeof NoteType)[keyof typeof NoteType]


export const OpportunityStatus: {
  UNSTARTED: 'UNSTARTED',
  IDENTIFIED: 'IDENTIFIED',
  FIRST_APPOINTMENT: 'FIRST_APPOINTMENT',
  SECOND_APPOINTMENT: 'SECOND_APPOINTMENT',
  THIRD_APPOINTMENT: 'THIRD_APPOINTMENT',
  CLOSING: 'CLOSING',
  PAPERWORK: 'PAPERWORK',
  WON: 'WON',
  LOST: 'LOST',
  CANCELLED: 'CANCELLED'
};

export type OpportunityStatus = (typeof OpportunityStatus)[keyof typeof OpportunityStatus]


export const ActivityType: {
  PATH: 'PATH',
  WAYPOINT: 'WAYPOINT',
  TASK: 'TASK',
  SCHEDULED: 'SCHEDULED'
};

export type ActivityType = (typeof ActivityType)[keyof typeof ActivityType]


export const ActivityPriority: {
  HIGH: 'HIGH',
  MEDIUM: 'MEDIUM',
  LOW: 'LOW'
};

export type ActivityPriority = (typeof ActivityPriority)[keyof typeof ActivityPriority]


export const TaskScheduleType: {
  COMMUNICATION: 'COMMUNICATION',
  COMMUNICATION_CALL: 'COMMUNICATION_CALL',
  COMMUNICATION_CALL_OUTBOUND: 'COMMUNICATION_CALL_OUTBOUND',
  COMMUNICATION_CALL_INBOUND: 'COMMUNICATION_CALL_INBOUND',
  COMMUNICATION_MESSAGE: 'COMMUNICATION_MESSAGE',
  COMMUNICATION_EMAIL: 'COMMUNICATION_EMAIL',
  MEETING: 'MEETING',
  MEETING_VIRTUAL: 'MEETING_VIRTUAL',
  MEETING_IN_PERSON: 'MEETING_IN_PERSON',
  MEETING_CLIENT: 'MEETING_CLIENT',
  MEETING_INTERNAL: 'MEETING_INTERNAL',
  MEETING_PERSONAL: 'MEETING_PERSONAL',
  FINANCIAL_PLANNING: 'FINANCIAL_PLANNING',
  FINANCIAL_PLANNING_PORTFOLIO_REVIEW: 'FINANCIAL_PLANNING_PORTFOLIO_REVIEW',
  FINANCIAL_PLANNING_INVESTMENT_STRATEGY: 'FINANCIAL_PLANNING_INVESTMENT_STRATEGY',
  FINANCIAL_PLANNING_TAX_PLANNING: 'FINANCIAL_PLANNING_TAX_PLANNING',
  FINANCIAL_PLANNING_ESTATE_PLANNING: 'FINANCIAL_PLANNING_ESTATE_PLANNING',
  FINANCIAL_PLANNING_RETIREMENT_PLANNING: 'FINANCIAL_PLANNING_RETIREMENT_PLANNING',
  FINANCIAL_PLANNING_RISK_ASSESSMENT: 'FINANCIAL_PLANNING_RISK_ASSESSMENT',
  TASK: 'TASK',
  TASK_ADMIN: 'TASK_ADMIN',
  TASK_COMPLIANCE_CHECK: 'TASK_COMPLIANCE_CHECK',
  TASK_DOCUMENT_PREPARATION: 'TASK_DOCUMENT_PREPARATION',
  TASK_PAPERWORK: 'TASK_PAPERWORK',
  TASK_TODO: 'TASK_TODO',
  HOLD: 'HOLD',
  HOLD_PRIVATE: 'HOLD_PRIVATE',
  HOLD_BLOCKED: 'HOLD_BLOCKED',
  HOLD_TENTATIVE: 'HOLD_TENTATIVE'
};

export type TaskScheduleType = (typeof TaskScheduleType)[keyof typeof TaskScheduleType]


export const ActivityStatus: {
  NOT_STARTED: 'NOT_STARTED',
  ASSIGNED: 'ASSIGNED',
  IN_PROGRESS: 'IN_PROGRESS',
  WAITING_FOR_INFO: 'WAITING_FOR_INFO',
  PAUSED: 'PAUSED',
  REASSIGNED: 'REASSIGNED',
  PENDING_APPROVAL: 'PENDING_APPROVAL',
  IN_REVIEW: 'IN_REVIEW',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED',
  FAILED: 'FAILED',
  SCHEDULED: 'SCHEDULED'
};

export type ActivityStatus = (typeof ActivityStatus)[keyof typeof ActivityStatus]


export const AddressType: {
  HOME: 'HOME',
  WORK: 'WORK',
  VACATION: 'VACATION',
  OTHER: 'OTHER'
};

export type AddressType = (typeof AddressType)[keyof typeof AddressType]


export const ContactType: {
  INDIVIDUAL: 'INDIVIDUAL',
  HOUSEHOLD: 'HOUSEHOLD',
  COMPANY: 'COMPANY'
};

export type ContactType = (typeof ContactType)[keyof typeof ContactType]


export const ContactStatus: {
  CLIENT: 'CLIENT',
  LEAD: 'LEAD',
  OFF: 'OFF',
  PERM_OFF: 'PERM_OFF',
  PROSPECT: 'PROSPECT',
  STRATEGIC_PARTNER: 'STRATEGIC_PARTNER',
  PLAN_PARTICIPANT: 'PLAN_PARTICIPANT',
  OTHER: 'OTHER'
};

export type ContactStatus = (typeof ContactStatus)[keyof typeof ContactStatus]


export const AccessGroup: {
  SYSADMIN: 'SYSADMIN',
  ADMIN: 'ADMIN',
  CLIENT: 'CLIENT'
};

export type AccessGroup = (typeof AccessGroup)[keyof typeof AccessGroup]


export const PhoneType: {
  HOME: 'HOME',
  WORK: 'WORK',
  VACATION: 'VACATION',
  MOBILE: 'MOBILE',
  OTHER: 'OTHER'
};

export type PhoneType = (typeof PhoneType)[keyof typeof PhoneType]


export const ImportantDateType: {
  ANNIVERSARY: 'ANNIVERSARY',
  RETIREMENT: 'RETIREMENT',
  BIRTHDAY: 'BIRTHDAY'
};

export type ImportantDateType = (typeof ImportantDateType)[keyof typeof ImportantDateType]


export const LogLevel: {
  DEBUG: 'DEBUG',
  INFO: 'INFO',
  WARNING: 'WARNING',
  HIGH: 'HIGH',
  CRITICAL: 'CRITICAL'
};

export type LogLevel = (typeof LogLevel)[keyof typeof LogLevel]


export const HouseholdRelationshipStatus: {
  HEAD_OF_HOUSEHOLD: 'HEAD_OF_HOUSEHOLD',
  SPOUSE: 'SPOUSE',
  SON: 'SON',
  DAUGHTER: 'DAUGHTER',
  AUNT: 'AUNT',
  UNCLE: 'UNCLE',
  FATHER: 'FATHER',
  MOTHER: 'MOTHER',
  BROTHER: 'BROTHER',
  SISTER: 'SISTER',
  NIECE: 'NIECE',
  NEPHEW: 'NEPHEW'
};

export type HouseholdRelationshipStatus = (typeof HouseholdRelationshipStatus)[keyof typeof HouseholdRelationshipStatus]


export const CompanyRelationshipStatus: {
  OWNS_COMPANY: 'OWNS_COMPANY',
  C_SUTIE: 'C_SUTIE',
  EXECUTIVE: 'EXECUTIVE',
  MANAGER: 'MANAGER',
  EMPLOYEE: 'EMPLOYEE',
  CONTRACTOR: 'CONTRACTOR',
  PARTNER: 'PARTNER',
  CHAIRMAN_OF_THE_BOARD: 'CHAIRMAN_OF_THE_BOARD',
  BOARD_MEMBER: 'BOARD_MEMBER'
};

export type CompanyRelationshipStatus = (typeof CompanyRelationshipStatus)[keyof typeof CompanyRelationshipStatus]


export const LifecycleStage: {
  ACCUMULATION: 'ACCUMULATION',
  PRE_RETIREMENT: 'PRE_RETIREMENT',
  RETIREMENT: 'RETIREMENT',
  SEMI_RETIRED: 'SEMI_RETIRED',
  NOT_ASSIGNED: 'NOT_ASSIGNED',
  PRE_INVESTMENT: 'PRE_INVESTMENT',
  LEGACY: 'LEGACY'
};

export type LifecycleStage = (typeof LifecycleStage)[keyof typeof LifecycleStage]


export const Role: {
  COMPUTER_OPERATOR: 'COMPUTER_OPERATOR',
  ADVISOR: 'ADVISOR',
  SERVICE_ASSISTANT: 'SERVICE_ASSISTANT',
  SALES_ASSISTANT: 'SALES_ASSISTANT'
};

export type Role = (typeof Role)[keyof typeof Role]

}

export type ActivityStepType = $Enums.ActivityStepType

export const ActivityStepType: typeof $Enums.ActivityStepType

export type DateOffsetType = $Enums.DateOffsetType

export const DateOffsetType: typeof $Enums.DateOffsetType

export type ContactTimelineEventType = $Enums.ContactTimelineEventType

export const ContactTimelineEventType: typeof $Enums.ContactTimelineEventType

export type Auditable = $Enums.Auditable

export const Auditable: typeof $Enums.Auditable

export type AuditEventType = $Enums.AuditEventType

export const AuditEventType: typeof $Enums.AuditEventType

export type ContactTimelineEventJoinType = $Enums.ContactTimelineEventJoinType

export const ContactTimelineEventJoinType: typeof $Enums.ContactTimelineEventJoinType

export type NoteType = $Enums.NoteType

export const NoteType: typeof $Enums.NoteType

export type OpportunityStatus = $Enums.OpportunityStatus

export const OpportunityStatus: typeof $Enums.OpportunityStatus

export type ActivityType = $Enums.ActivityType

export const ActivityType: typeof $Enums.ActivityType

export type ActivityPriority = $Enums.ActivityPriority

export const ActivityPriority: typeof $Enums.ActivityPriority

export type TaskScheduleType = $Enums.TaskScheduleType

export const TaskScheduleType: typeof $Enums.TaskScheduleType

export type ActivityStatus = $Enums.ActivityStatus

export const ActivityStatus: typeof $Enums.ActivityStatus

export type AddressType = $Enums.AddressType

export const AddressType: typeof $Enums.AddressType

export type ContactType = $Enums.ContactType

export const ContactType: typeof $Enums.ContactType

export type ContactStatus = $Enums.ContactStatus

export const ContactStatus: typeof $Enums.ContactStatus

export type AccessGroup = $Enums.AccessGroup

export const AccessGroup: typeof $Enums.AccessGroup

export type PhoneType = $Enums.PhoneType

export const PhoneType: typeof $Enums.PhoneType

export type ImportantDateType = $Enums.ImportantDateType

export const ImportantDateType: typeof $Enums.ImportantDateType

export type LogLevel = $Enums.LogLevel

export const LogLevel: typeof $Enums.LogLevel

export type HouseholdRelationshipStatus = $Enums.HouseholdRelationshipStatus

export const HouseholdRelationshipStatus: typeof $Enums.HouseholdRelationshipStatus

export type CompanyRelationshipStatus = $Enums.CompanyRelationshipStatus

export const CompanyRelationshipStatus: typeof $Enums.CompanyRelationshipStatus

export type LifecycleStage = $Enums.LifecycleStage

export const LifecycleStage: typeof $Enums.LifecycleStage

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Tenets
 * const tenets = await prisma.tenet.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Tenets
   * const tenets = await prisma.tenet.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Executes a typed SQL query and returns a typed result
   * @example
   * ```
   * import { myQuery } from '@prisma/client/sql'
   * 
   * const result = await prisma.$queryRawTyped(myQuery())
   * ```
   */
  $queryRawTyped<T>(typedSql: runtime.TypedSql<unknown[], T>): Prisma.PrismaPromise<T[]>

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs, $Utils.Call<Prisma.TypeMapCb, {
    extArgs: ExtArgs
  }>, ClientOptions>

      /**
   * `prisma.tenet`: Exposes CRUD operations for the **Tenet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tenets
    * const tenets = await prisma.tenet.findMany()
    * ```
    */
  get tenet(): Prisma.TenetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contact`: Exposes CRUD operations for the **Contact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contacts
    * const contacts = await prisma.contact.findMany()
    * ```
    */
  get contact(): Prisma.ContactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contactRelationship`: Exposes CRUD operations for the **ContactRelationship** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContactRelationships
    * const contactRelationships = await prisma.contactRelationship.findMany()
    * ```
    */
  get contactRelationship(): Prisma.ContactRelationshipDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.activityStep`: Exposes CRUD operations for the **ActivityStep** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActivitySteps
    * const activitySteps = await prisma.activityStep.findMany()
    * ```
    */
  get activityStep(): Prisma.ActivityStepDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.activityStepUserJoin`: Exposes CRUD operations for the **ActivityStepUserJoin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActivityStepUserJoins
    * const activityStepUserJoins = await prisma.activityStepUserJoin.findMany()
    * ```
    */
  get activityStepUserJoin(): Prisma.ActivityStepUserJoinDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userWaypointJoin`: Exposes CRUD operations for the **UserWaypointJoin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserWaypointJoins
    * const userWaypointJoins = await prisma.userWaypointJoin.findMany()
    * ```
    */
  get userWaypointJoin(): Prisma.UserWaypointJoinDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.activityWaypoint`: Exposes CRUD operations for the **ActivityWaypoint** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActivityWaypoints
    * const activityWaypoints = await prisma.activityWaypoint.findMany()
    * ```
    */
  get activityWaypoint(): Prisma.ActivityWaypointDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.templateAssignment`: Exposes CRUD operations for the **TemplateAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TemplateAssignments
    * const templateAssignments = await prisma.templateAssignment.findMany()
    * ```
    */
  get templateAssignment(): Prisma.TemplateAssignmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.activityWaypointTemplate`: Exposes CRUD operations for the **ActivityWaypointTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActivityWaypointTemplates
    * const activityWaypointTemplates = await prisma.activityWaypointTemplate.findMany()
    * ```
    */
  get activityWaypointTemplate(): Prisma.ActivityWaypointTemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.activityTemplateStep`: Exposes CRUD operations for the **ActivityTemplateStep** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActivityTemplateSteps
    * const activityTemplateSteps = await prisma.activityTemplateStep.findMany()
    * ```
    */
  get activityTemplateStep(): Prisma.ActivityTemplateStepDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.activityTemplateStepAssignment`: Exposes CRUD operations for the **ActivityTemplateStepAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActivityTemplateStepAssignments
    * const activityTemplateStepAssignments = await prisma.activityTemplateStepAssignment.findMany()
    * ```
    */
  get activityTemplateStepAssignment(): Prisma.ActivityTemplateStepAssignmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.activityTemplate`: Exposes CRUD operations for the **ActivityTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActivityTemplates
    * const activityTemplates = await prisma.activityTemplate.findMany()
    * ```
    */
  get activityTemplate(): Prisma.ActivityTemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.activity`: Exposes CRUD operations for the **Activity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Activities
    * const activities = await prisma.activity.findMany()
    * ```
    */
  get activity(): Prisma.ActivityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contactTimelineEvent`: Exposes CRUD operations for the **ContactTimelineEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContactTimelineEvents
    * const contactTimelineEvents = await prisma.contactTimelineEvent.findMany()
    * ```
    */
  get contactTimelineEvent(): Prisma.ContactTimelineEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditEvent`: Exposes CRUD operations for the **AuditEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditEvents
    * const auditEvents = await prisma.auditEvent.findMany()
    * ```
    */
  get auditEvent(): Prisma.AuditEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contactTimelineEventContactJoin`: Exposes CRUD operations for the **ContactTimelineEventContactJoin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContactTimelineEventContactJoins
    * const contactTimelineEventContactJoins = await prisma.contactTimelineEventContactJoin.findMany()
    * ```
    */
  get contactTimelineEventContactJoin(): Prisma.ContactTimelineEventContactJoinDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.note`: Exposes CRUD operations for the **Note** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notes
    * const notes = await prisma.note.findMany()
    * ```
    */
  get note(): Prisma.NoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attachment`: Exposes CRUD operations for the **Attachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attachments
    * const attachments = await prisma.attachment.findMany()
    * ```
    */
  get attachment(): Prisma.AttachmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.activityContactJoin`: Exposes CRUD operations for the **ActivityContactJoin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActivityContactJoins
    * const activityContactJoins = await prisma.activityContactJoin.findMany()
    * ```
    */
  get activityContactJoin(): Prisma.ActivityContactJoinDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.activityUserJoin`: Exposes CRUD operations for the **ActivityUserJoin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActivityUserJoins
    * const activityUserJoins = await prisma.activityUserJoin.findMany()
    * ```
    */
  get activityUserJoin(): Prisma.ActivityUserJoinDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contactEmail`: Exposes CRUD operations for the **ContactEmail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContactEmails
    * const contactEmails = await prisma.contactEmail.findMany()
    * ```
    */
  get contactEmail(): Prisma.ContactEmailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contactPhone`: Exposes CRUD operations for the **ContactPhone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContactPhones
    * const contactPhones = await prisma.contactPhone.findMany()
    * ```
    */
  get contactPhone(): Prisma.ContactPhoneDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.address`: Exposes CRUD operations for the **Address** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Addresses
    * const addresses = await prisma.address.findMany()
    * ```
    */
  get address(): Prisma.AddressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.configOption`: Exposes CRUD operations for the **ConfigOption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConfigOptions
    * const configOptions = await prisma.configOption.findMany()
    * ```
    */
  get configOption(): Prisma.ConfigOptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.importantDate`: Exposes CRUD operations for the **ImportantDate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ImportantDates
    * const importantDates = await prisma.importantDate.findMany()
    * ```
    */
  get importantDate(): Prisma.ImportantDateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.opportunity`: Exposes CRUD operations for the **Opportunity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Opportunities
    * const opportunities = await prisma.opportunity.findMany()
    * ```
    */
  get opportunity(): Prisma.OpportunityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contactOpportunityJoin`: Exposes CRUD operations for the **ContactOpportunityJoin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContactOpportunityJoins
    * const contactOpportunityJoins = await prisma.contactOpportunityJoin.findMany()
    * ```
    */
  get contactOpportunityJoin(): Prisma.ContactOpportunityJoinDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userOpportunityJoin`: Exposes CRUD operations for the **UserOpportunityJoin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserOpportunityJoins
    * const userOpportunityJoins = await prisma.userOpportunityJoin.findMany()
    * ```
    */
  get userOpportunityJoin(): Prisma.UserOpportunityJoinDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.opportunityProduct`: Exposes CRUD operations for the **OpportunityProduct** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OpportunityProducts
    * const opportunityProducts = await prisma.opportunityProduct.findMany()
    * ```
    */
  get opportunityProduct(): Prisma.OpportunityProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productType`: Exposes CRUD operations for the **ProductType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductTypes
    * const productTypes = await prisma.productType.findMany()
    * ```
    */
  get productType(): Prisma.ProductTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.log`: Exposes CRUD operations for the **Log** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Logs
    * const logs = await prisma.log.findMany()
    * ```
    */
  get log(): Prisma.LogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.token`: Exposes CRUD operations for the **Token** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tokens
    * const tokens = await prisma.token.findMany()
    * ```
    */
  get token(): Prisma.TokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tZData`: Exposes CRUD operations for the **TZData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TZData
    * const tZData = await prisma.tZData.findMany()
    * ```
    */
  get tZData(): Prisma.TZDataDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.testObject`: Exposes CRUD operations for the **TestObject** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TestObjects
    * const testObjects = await prisma.testObject.findMany()
    * ```
    */
  get testObject(): Prisma.TestObjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.wrappedObject`: Exposes CRUD operations for the **WrappedObject** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WrappedObjects
    * const wrappedObjects = await prisma.wrappedObject.findMany()
    * ```
    */
  get wrappedObject(): Prisma.WrappedObjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.joinTestObject`: Exposes CRUD operations for the **JoinTestObject** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JoinTestObjects
    * const joinTestObjects = await prisma.joinTestObject.findMany()
    * ```
    */
  get joinTestObject(): Prisma.JoinTestObjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.joinTestObject2`: Exposes CRUD operations for the **JoinTestObject2** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JoinTestObject2s
    * const joinTestObject2s = await prisma.joinTestObject2.findMany()
    * ```
    */
  get joinTestObject2(): Prisma.JoinTestObject2Delegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.joinedObject1`: Exposes CRUD operations for the **JoinedObject1** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JoinedObject1s
    * const joinedObject1s = await prisma.joinedObject1.findMany()
    * ```
    */
  get joinedObject1(): Prisma.JoinedObject1Delegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.joinedObject2`: Exposes CRUD operations for the **JoinedObject2** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JoinedObject2s
    * const joinedObject2s = await prisma.joinedObject2.findMany()
    * ```
    */
  get joinedObject2(): Prisma.JoinedObject2Delegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.joinSelfReference`: Exposes CRUD operations for the **JoinSelfReference** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JoinSelfReferences
    * const joinSelfReferences = await prisma.joinSelfReference.findMany()
    * ```
    */
  get joinSelfReference(): Prisma.JoinSelfReferenceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.selfReferencialJoinModel`: Exposes CRUD operations for the **SelfReferencialJoinModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SelfReferencialJoinModels
    * const selfReferencialJoinModels = await prisma.selfReferencialJoinModel.findMany()
    * ```
    */
  get selfReferencialJoinModel(): Prisma.SelfReferencialJoinModelDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.4.1
   * Query Engine version: a9055b89e58b4b5bfb59600785423b1db3d0e75d
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Tenet: 'Tenet',
    User: 'User',
    Contact: 'Contact',
    ContactRelationship: 'ContactRelationship',
    ActivityStep: 'ActivityStep',
    ActivityStepUserJoin: 'ActivityStepUserJoin',
    UserWaypointJoin: 'UserWaypointJoin',
    ActivityWaypoint: 'ActivityWaypoint',
    TemplateAssignment: 'TemplateAssignment',
    ActivityWaypointTemplate: 'ActivityWaypointTemplate',
    ActivityTemplateStep: 'ActivityTemplateStep',
    ActivityTemplateStepAssignment: 'ActivityTemplateStepAssignment',
    ActivityTemplate: 'ActivityTemplate',
    Activity: 'Activity',
    ContactTimelineEvent: 'ContactTimelineEvent',
    AuditEvent: 'AuditEvent',
    ContactTimelineEventContactJoin: 'ContactTimelineEventContactJoin',
    Note: 'Note',
    Attachment: 'Attachment',
    ActivityContactJoin: 'ActivityContactJoin',
    ActivityUserJoin: 'ActivityUserJoin',
    ContactEmail: 'ContactEmail',
    ContactPhone: 'ContactPhone',
    Address: 'Address',
    ConfigOption: 'ConfigOption',
    ImportantDate: 'ImportantDate',
    Opportunity: 'Opportunity',
    ContactOpportunityJoin: 'ContactOpportunityJoin',
    UserOpportunityJoin: 'UserOpportunityJoin',
    OpportunityProduct: 'OpportunityProduct',
    ProductType: 'ProductType',
    Log: 'Log',
    Token: 'Token',
    TZData: 'TZData',
    TestObject: 'TestObject',
    WrappedObject: 'WrappedObject',
    JoinTestObject: 'JoinTestObject',
    JoinTestObject2: 'JoinTestObject2',
    JoinedObject1: 'JoinedObject1',
    JoinedObject2: 'JoinedObject2',
    JoinSelfReference: 'JoinSelfReference',
    SelfReferencialJoinModel: 'SelfReferencialJoinModel'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "tenet" | "user" | "contact" | "contactRelationship" | "activityStep" | "activityStepUserJoin" | "userWaypointJoin" | "activityWaypoint" | "templateAssignment" | "activityWaypointTemplate" | "activityTemplateStep" | "activityTemplateStepAssignment" | "activityTemplate" | "activity" | "contactTimelineEvent" | "auditEvent" | "contactTimelineEventContactJoin" | "note" | "attachment" | "activityContactJoin" | "activityUserJoin" | "contactEmail" | "contactPhone" | "address" | "configOption" | "importantDate" | "opportunity" | "contactOpportunityJoin" | "userOpportunityJoin" | "opportunityProduct" | "productType" | "log" | "token" | "tZData" | "testObject" | "wrappedObject" | "joinTestObject" | "joinTestObject2" | "joinedObject1" | "joinedObject2" | "joinSelfReference" | "selfReferencialJoinModel"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Tenet: {
        payload: Prisma.$TenetPayload<ExtArgs>
        fields: Prisma.TenetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenetPayload>
          }
          findFirst: {
            args: Prisma.TenetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenetPayload>
          }
          findMany: {
            args: Prisma.TenetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenetPayload>[]
          }
          create: {
            args: Prisma.TenetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenetPayload>
          }
          createMany: {
            args: Prisma.TenetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenetPayload>[]
          }
          delete: {
            args: Prisma.TenetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenetPayload>
          }
          update: {
            args: Prisma.TenetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenetPayload>
          }
          deleteMany: {
            args: Prisma.TenetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TenetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenetPayload>[]
          }
          upsert: {
            args: Prisma.TenetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenetPayload>
          }
          aggregate: {
            args: Prisma.TenetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenet>
          }
          groupBy: {
            args: Prisma.TenetGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenetGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenetCountArgs<ExtArgs>
            result: $Utils.Optional<TenetCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Contact: {
        payload: Prisma.$ContactPayload<ExtArgs>
        fields: Prisma.ContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findFirst: {
            args: Prisma.ContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findMany: {
            args: Prisma.ContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          create: {
            args: Prisma.ContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          createMany: {
            args: Prisma.ContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          delete: {
            args: Prisma.ContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          update: {
            args: Prisma.ContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          deleteMany: {
            args: Prisma.ContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContactUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          upsert: {
            args: Prisma.ContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          aggregate: {
            args: Prisma.ContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContact>
          }
          groupBy: {
            args: Prisma.ContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactCountArgs<ExtArgs>
            result: $Utils.Optional<ContactCountAggregateOutputType> | number
          }
        }
      }
      ContactRelationship: {
        payload: Prisma.$ContactRelationshipPayload<ExtArgs>
        fields: Prisma.ContactRelationshipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactRelationshipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactRelationshipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactRelationshipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactRelationshipPayload>
          }
          findFirst: {
            args: Prisma.ContactRelationshipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactRelationshipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactRelationshipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactRelationshipPayload>
          }
          findMany: {
            args: Prisma.ContactRelationshipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactRelationshipPayload>[]
          }
          create: {
            args: Prisma.ContactRelationshipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactRelationshipPayload>
          }
          createMany: {
            args: Prisma.ContactRelationshipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactRelationshipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactRelationshipPayload>[]
          }
          delete: {
            args: Prisma.ContactRelationshipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactRelationshipPayload>
          }
          update: {
            args: Prisma.ContactRelationshipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactRelationshipPayload>
          }
          deleteMany: {
            args: Prisma.ContactRelationshipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactRelationshipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContactRelationshipUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactRelationshipPayload>[]
          }
          upsert: {
            args: Prisma.ContactRelationshipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactRelationshipPayload>
          }
          aggregate: {
            args: Prisma.ContactRelationshipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContactRelationship>
          }
          groupBy: {
            args: Prisma.ContactRelationshipGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactRelationshipGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactRelationshipCountArgs<ExtArgs>
            result: $Utils.Optional<ContactRelationshipCountAggregateOutputType> | number
          }
        }
      }
      ActivityStep: {
        payload: Prisma.$ActivityStepPayload<ExtArgs>
        fields: Prisma.ActivityStepFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityStepFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityStepPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityStepFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityStepPayload>
          }
          findFirst: {
            args: Prisma.ActivityStepFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityStepPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityStepFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityStepPayload>
          }
          findMany: {
            args: Prisma.ActivityStepFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityStepPayload>[]
          }
          create: {
            args: Prisma.ActivityStepCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityStepPayload>
          }
          createMany: {
            args: Prisma.ActivityStepCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityStepCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityStepPayload>[]
          }
          delete: {
            args: Prisma.ActivityStepDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityStepPayload>
          }
          update: {
            args: Prisma.ActivityStepUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityStepPayload>
          }
          deleteMany: {
            args: Prisma.ActivityStepDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityStepUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActivityStepUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityStepPayload>[]
          }
          upsert: {
            args: Prisma.ActivityStepUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityStepPayload>
          }
          aggregate: {
            args: Prisma.ActivityStepAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivityStep>
          }
          groupBy: {
            args: Prisma.ActivityStepGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityStepGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityStepCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityStepCountAggregateOutputType> | number
          }
        }
      }
      ActivityStepUserJoin: {
        payload: Prisma.$ActivityStepUserJoinPayload<ExtArgs>
        fields: Prisma.ActivityStepUserJoinFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityStepUserJoinFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityStepUserJoinPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityStepUserJoinFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityStepUserJoinPayload>
          }
          findFirst: {
            args: Prisma.ActivityStepUserJoinFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityStepUserJoinPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityStepUserJoinFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityStepUserJoinPayload>
          }
          findMany: {
            args: Prisma.ActivityStepUserJoinFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityStepUserJoinPayload>[]
          }
          create: {
            args: Prisma.ActivityStepUserJoinCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityStepUserJoinPayload>
          }
          createMany: {
            args: Prisma.ActivityStepUserJoinCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityStepUserJoinCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityStepUserJoinPayload>[]
          }
          delete: {
            args: Prisma.ActivityStepUserJoinDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityStepUserJoinPayload>
          }
          update: {
            args: Prisma.ActivityStepUserJoinUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityStepUserJoinPayload>
          }
          deleteMany: {
            args: Prisma.ActivityStepUserJoinDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityStepUserJoinUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActivityStepUserJoinUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityStepUserJoinPayload>[]
          }
          upsert: {
            args: Prisma.ActivityStepUserJoinUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityStepUserJoinPayload>
          }
          aggregate: {
            args: Prisma.ActivityStepUserJoinAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivityStepUserJoin>
          }
          groupBy: {
            args: Prisma.ActivityStepUserJoinGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityStepUserJoinGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityStepUserJoinCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityStepUserJoinCountAggregateOutputType> | number
          }
        }
      }
      UserWaypointJoin: {
        payload: Prisma.$UserWaypointJoinPayload<ExtArgs>
        fields: Prisma.UserWaypointJoinFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserWaypointJoinFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWaypointJoinPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserWaypointJoinFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWaypointJoinPayload>
          }
          findFirst: {
            args: Prisma.UserWaypointJoinFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWaypointJoinPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserWaypointJoinFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWaypointJoinPayload>
          }
          findMany: {
            args: Prisma.UserWaypointJoinFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWaypointJoinPayload>[]
          }
          create: {
            args: Prisma.UserWaypointJoinCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWaypointJoinPayload>
          }
          createMany: {
            args: Prisma.UserWaypointJoinCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserWaypointJoinCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWaypointJoinPayload>[]
          }
          delete: {
            args: Prisma.UserWaypointJoinDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWaypointJoinPayload>
          }
          update: {
            args: Prisma.UserWaypointJoinUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWaypointJoinPayload>
          }
          deleteMany: {
            args: Prisma.UserWaypointJoinDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserWaypointJoinUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserWaypointJoinUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWaypointJoinPayload>[]
          }
          upsert: {
            args: Prisma.UserWaypointJoinUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserWaypointJoinPayload>
          }
          aggregate: {
            args: Prisma.UserWaypointJoinAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserWaypointJoin>
          }
          groupBy: {
            args: Prisma.UserWaypointJoinGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserWaypointJoinGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserWaypointJoinCountArgs<ExtArgs>
            result: $Utils.Optional<UserWaypointJoinCountAggregateOutputType> | number
          }
        }
      }
      ActivityWaypoint: {
        payload: Prisma.$ActivityWaypointPayload<ExtArgs>
        fields: Prisma.ActivityWaypointFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityWaypointFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityWaypointPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityWaypointFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityWaypointPayload>
          }
          findFirst: {
            args: Prisma.ActivityWaypointFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityWaypointPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityWaypointFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityWaypointPayload>
          }
          findMany: {
            args: Prisma.ActivityWaypointFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityWaypointPayload>[]
          }
          create: {
            args: Prisma.ActivityWaypointCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityWaypointPayload>
          }
          createMany: {
            args: Prisma.ActivityWaypointCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityWaypointCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityWaypointPayload>[]
          }
          delete: {
            args: Prisma.ActivityWaypointDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityWaypointPayload>
          }
          update: {
            args: Prisma.ActivityWaypointUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityWaypointPayload>
          }
          deleteMany: {
            args: Prisma.ActivityWaypointDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityWaypointUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActivityWaypointUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityWaypointPayload>[]
          }
          upsert: {
            args: Prisma.ActivityWaypointUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityWaypointPayload>
          }
          aggregate: {
            args: Prisma.ActivityWaypointAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivityWaypoint>
          }
          groupBy: {
            args: Prisma.ActivityWaypointGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityWaypointGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityWaypointCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityWaypointCountAggregateOutputType> | number
          }
        }
      }
      TemplateAssignment: {
        payload: Prisma.$TemplateAssignmentPayload<ExtArgs>
        fields: Prisma.TemplateAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TemplateAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TemplateAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateAssignmentPayload>
          }
          findFirst: {
            args: Prisma.TemplateAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TemplateAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateAssignmentPayload>
          }
          findMany: {
            args: Prisma.TemplateAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateAssignmentPayload>[]
          }
          create: {
            args: Prisma.TemplateAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateAssignmentPayload>
          }
          createMany: {
            args: Prisma.TemplateAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TemplateAssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateAssignmentPayload>[]
          }
          delete: {
            args: Prisma.TemplateAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateAssignmentPayload>
          }
          update: {
            args: Prisma.TemplateAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.TemplateAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TemplateAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TemplateAssignmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateAssignmentPayload>[]
          }
          upsert: {
            args: Prisma.TemplateAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateAssignmentPayload>
          }
          aggregate: {
            args: Prisma.TemplateAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTemplateAssignment>
          }
          groupBy: {
            args: Prisma.TemplateAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<TemplateAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.TemplateAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<TemplateAssignmentCountAggregateOutputType> | number
          }
        }
      }
      ActivityWaypointTemplate: {
        payload: Prisma.$ActivityWaypointTemplatePayload<ExtArgs>
        fields: Prisma.ActivityWaypointTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityWaypointTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityWaypointTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityWaypointTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityWaypointTemplatePayload>
          }
          findFirst: {
            args: Prisma.ActivityWaypointTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityWaypointTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityWaypointTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityWaypointTemplatePayload>
          }
          findMany: {
            args: Prisma.ActivityWaypointTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityWaypointTemplatePayload>[]
          }
          create: {
            args: Prisma.ActivityWaypointTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityWaypointTemplatePayload>
          }
          createMany: {
            args: Prisma.ActivityWaypointTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityWaypointTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityWaypointTemplatePayload>[]
          }
          delete: {
            args: Prisma.ActivityWaypointTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityWaypointTemplatePayload>
          }
          update: {
            args: Prisma.ActivityWaypointTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityWaypointTemplatePayload>
          }
          deleteMany: {
            args: Prisma.ActivityWaypointTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityWaypointTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActivityWaypointTemplateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityWaypointTemplatePayload>[]
          }
          upsert: {
            args: Prisma.ActivityWaypointTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityWaypointTemplatePayload>
          }
          aggregate: {
            args: Prisma.ActivityWaypointTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivityWaypointTemplate>
          }
          groupBy: {
            args: Prisma.ActivityWaypointTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityWaypointTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityWaypointTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityWaypointTemplateCountAggregateOutputType> | number
          }
        }
      }
      ActivityTemplateStep: {
        payload: Prisma.$ActivityTemplateStepPayload<ExtArgs>
        fields: Prisma.ActivityTemplateStepFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityTemplateStepFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityTemplateStepPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityTemplateStepFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityTemplateStepPayload>
          }
          findFirst: {
            args: Prisma.ActivityTemplateStepFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityTemplateStepPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityTemplateStepFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityTemplateStepPayload>
          }
          findMany: {
            args: Prisma.ActivityTemplateStepFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityTemplateStepPayload>[]
          }
          create: {
            args: Prisma.ActivityTemplateStepCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityTemplateStepPayload>
          }
          createMany: {
            args: Prisma.ActivityTemplateStepCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityTemplateStepCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityTemplateStepPayload>[]
          }
          delete: {
            args: Prisma.ActivityTemplateStepDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityTemplateStepPayload>
          }
          update: {
            args: Prisma.ActivityTemplateStepUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityTemplateStepPayload>
          }
          deleteMany: {
            args: Prisma.ActivityTemplateStepDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityTemplateStepUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActivityTemplateStepUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityTemplateStepPayload>[]
          }
          upsert: {
            args: Prisma.ActivityTemplateStepUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityTemplateStepPayload>
          }
          aggregate: {
            args: Prisma.ActivityTemplateStepAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivityTemplateStep>
          }
          groupBy: {
            args: Prisma.ActivityTemplateStepGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityTemplateStepGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityTemplateStepCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityTemplateStepCountAggregateOutputType> | number
          }
        }
      }
      ActivityTemplateStepAssignment: {
        payload: Prisma.$ActivityTemplateStepAssignmentPayload<ExtArgs>
        fields: Prisma.ActivityTemplateStepAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityTemplateStepAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityTemplateStepAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityTemplateStepAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityTemplateStepAssignmentPayload>
          }
          findFirst: {
            args: Prisma.ActivityTemplateStepAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityTemplateStepAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityTemplateStepAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityTemplateStepAssignmentPayload>
          }
          findMany: {
            args: Prisma.ActivityTemplateStepAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityTemplateStepAssignmentPayload>[]
          }
          create: {
            args: Prisma.ActivityTemplateStepAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityTemplateStepAssignmentPayload>
          }
          createMany: {
            args: Prisma.ActivityTemplateStepAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityTemplateStepAssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityTemplateStepAssignmentPayload>[]
          }
          delete: {
            args: Prisma.ActivityTemplateStepAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityTemplateStepAssignmentPayload>
          }
          update: {
            args: Prisma.ActivityTemplateStepAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityTemplateStepAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.ActivityTemplateStepAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityTemplateStepAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActivityTemplateStepAssignmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityTemplateStepAssignmentPayload>[]
          }
          upsert: {
            args: Prisma.ActivityTemplateStepAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityTemplateStepAssignmentPayload>
          }
          aggregate: {
            args: Prisma.ActivityTemplateStepAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivityTemplateStepAssignment>
          }
          groupBy: {
            args: Prisma.ActivityTemplateStepAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityTemplateStepAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityTemplateStepAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityTemplateStepAssignmentCountAggregateOutputType> | number
          }
        }
      }
      ActivityTemplate: {
        payload: Prisma.$ActivityTemplatePayload<ExtArgs>
        fields: Prisma.ActivityTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityTemplatePayload>
          }
          findFirst: {
            args: Prisma.ActivityTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityTemplatePayload>
          }
          findMany: {
            args: Prisma.ActivityTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityTemplatePayload>[]
          }
          create: {
            args: Prisma.ActivityTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityTemplatePayload>
          }
          createMany: {
            args: Prisma.ActivityTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityTemplatePayload>[]
          }
          delete: {
            args: Prisma.ActivityTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityTemplatePayload>
          }
          update: {
            args: Prisma.ActivityTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityTemplatePayload>
          }
          deleteMany: {
            args: Prisma.ActivityTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActivityTemplateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityTemplatePayload>[]
          }
          upsert: {
            args: Prisma.ActivityTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityTemplatePayload>
          }
          aggregate: {
            args: Prisma.ActivityTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivityTemplate>
          }
          groupBy: {
            args: Prisma.ActivityTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityTemplateCountAggregateOutputType> | number
          }
        }
      }
      Activity: {
        payload: Prisma.$ActivityPayload<ExtArgs>
        fields: Prisma.ActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          findFirst: {
            args: Prisma.ActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          findMany: {
            args: Prisma.ActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          create: {
            args: Prisma.ActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          createMany: {
            args: Prisma.ActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          delete: {
            args: Prisma.ActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          update: {
            args: Prisma.ActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          deleteMany: {
            args: Prisma.ActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActivityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          upsert: {
            args: Prisma.ActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          aggregate: {
            args: Prisma.ActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivity>
          }
          groupBy: {
            args: Prisma.ActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityCountAggregateOutputType> | number
          }
        }
      }
      ContactTimelineEvent: {
        payload: Prisma.$ContactTimelineEventPayload<ExtArgs>
        fields: Prisma.ContactTimelineEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactTimelineEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTimelineEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactTimelineEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTimelineEventPayload>
          }
          findFirst: {
            args: Prisma.ContactTimelineEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTimelineEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactTimelineEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTimelineEventPayload>
          }
          findMany: {
            args: Prisma.ContactTimelineEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTimelineEventPayload>[]
          }
          create: {
            args: Prisma.ContactTimelineEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTimelineEventPayload>
          }
          createMany: {
            args: Prisma.ContactTimelineEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactTimelineEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTimelineEventPayload>[]
          }
          delete: {
            args: Prisma.ContactTimelineEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTimelineEventPayload>
          }
          update: {
            args: Prisma.ContactTimelineEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTimelineEventPayload>
          }
          deleteMany: {
            args: Prisma.ContactTimelineEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactTimelineEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContactTimelineEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTimelineEventPayload>[]
          }
          upsert: {
            args: Prisma.ContactTimelineEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTimelineEventPayload>
          }
          aggregate: {
            args: Prisma.ContactTimelineEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContactTimelineEvent>
          }
          groupBy: {
            args: Prisma.ContactTimelineEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactTimelineEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactTimelineEventCountArgs<ExtArgs>
            result: $Utils.Optional<ContactTimelineEventCountAggregateOutputType> | number
          }
        }
      }
      AuditEvent: {
        payload: Prisma.$AuditEventPayload<ExtArgs>
        fields: Prisma.AuditEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload>
          }
          findFirst: {
            args: Prisma.AuditEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload>
          }
          findMany: {
            args: Prisma.AuditEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload>[]
          }
          create: {
            args: Prisma.AuditEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload>
          }
          createMany: {
            args: Prisma.AuditEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload>[]
          }
          delete: {
            args: Prisma.AuditEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload>
          }
          update: {
            args: Prisma.AuditEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload>
          }
          deleteMany: {
            args: Prisma.AuditEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload>[]
          }
          upsert: {
            args: Prisma.AuditEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload>
          }
          aggregate: {
            args: Prisma.AuditEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditEvent>
          }
          groupBy: {
            args: Prisma.AuditEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditEventCountArgs<ExtArgs>
            result: $Utils.Optional<AuditEventCountAggregateOutputType> | number
          }
        }
      }
      ContactTimelineEventContactJoin: {
        payload: Prisma.$ContactTimelineEventContactJoinPayload<ExtArgs>
        fields: Prisma.ContactTimelineEventContactJoinFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactTimelineEventContactJoinFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTimelineEventContactJoinPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactTimelineEventContactJoinFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTimelineEventContactJoinPayload>
          }
          findFirst: {
            args: Prisma.ContactTimelineEventContactJoinFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTimelineEventContactJoinPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactTimelineEventContactJoinFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTimelineEventContactJoinPayload>
          }
          findMany: {
            args: Prisma.ContactTimelineEventContactJoinFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTimelineEventContactJoinPayload>[]
          }
          create: {
            args: Prisma.ContactTimelineEventContactJoinCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTimelineEventContactJoinPayload>
          }
          createMany: {
            args: Prisma.ContactTimelineEventContactJoinCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactTimelineEventContactJoinCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTimelineEventContactJoinPayload>[]
          }
          delete: {
            args: Prisma.ContactTimelineEventContactJoinDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTimelineEventContactJoinPayload>
          }
          update: {
            args: Prisma.ContactTimelineEventContactJoinUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTimelineEventContactJoinPayload>
          }
          deleteMany: {
            args: Prisma.ContactTimelineEventContactJoinDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactTimelineEventContactJoinUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContactTimelineEventContactJoinUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTimelineEventContactJoinPayload>[]
          }
          upsert: {
            args: Prisma.ContactTimelineEventContactJoinUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTimelineEventContactJoinPayload>
          }
          aggregate: {
            args: Prisma.ContactTimelineEventContactJoinAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContactTimelineEventContactJoin>
          }
          groupBy: {
            args: Prisma.ContactTimelineEventContactJoinGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactTimelineEventContactJoinGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactTimelineEventContactJoinCountArgs<ExtArgs>
            result: $Utils.Optional<ContactTimelineEventContactJoinCountAggregateOutputType> | number
          }
        }
      }
      Note: {
        payload: Prisma.$NotePayload<ExtArgs>
        fields: Prisma.NoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          findFirst: {
            args: Prisma.NoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          findMany: {
            args: Prisma.NoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>[]
          }
          create: {
            args: Prisma.NoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          createMany: {
            args: Prisma.NoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>[]
          }
          delete: {
            args: Prisma.NoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          update: {
            args: Prisma.NoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          deleteMany: {
            args: Prisma.NoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NoteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>[]
          }
          upsert: {
            args: Prisma.NoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          aggregate: {
            args: Prisma.NoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNote>
          }
          groupBy: {
            args: Prisma.NoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<NoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.NoteCountArgs<ExtArgs>
            result: $Utils.Optional<NoteCountAggregateOutputType> | number
          }
        }
      }
      Attachment: {
        payload: Prisma.$AttachmentPayload<ExtArgs>
        fields: Prisma.AttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          findFirst: {
            args: Prisma.AttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          findMany: {
            args: Prisma.AttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>[]
          }
          create: {
            args: Prisma.AttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          createMany: {
            args: Prisma.AttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttachmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>[]
          }
          delete: {
            args: Prisma.AttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          update: {
            args: Prisma.AttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          deleteMany: {
            args: Prisma.AttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AttachmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>[]
          }
          upsert: {
            args: Prisma.AttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          aggregate: {
            args: Prisma.AttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttachment>
          }
          groupBy: {
            args: Prisma.AttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<AttachmentCountAggregateOutputType> | number
          }
        }
      }
      ActivityContactJoin: {
        payload: Prisma.$ActivityContactJoinPayload<ExtArgs>
        fields: Prisma.ActivityContactJoinFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityContactJoinFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityContactJoinPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityContactJoinFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityContactJoinPayload>
          }
          findFirst: {
            args: Prisma.ActivityContactJoinFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityContactJoinPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityContactJoinFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityContactJoinPayload>
          }
          findMany: {
            args: Prisma.ActivityContactJoinFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityContactJoinPayload>[]
          }
          create: {
            args: Prisma.ActivityContactJoinCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityContactJoinPayload>
          }
          createMany: {
            args: Prisma.ActivityContactJoinCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityContactJoinCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityContactJoinPayload>[]
          }
          delete: {
            args: Prisma.ActivityContactJoinDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityContactJoinPayload>
          }
          update: {
            args: Prisma.ActivityContactJoinUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityContactJoinPayload>
          }
          deleteMany: {
            args: Prisma.ActivityContactJoinDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityContactJoinUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActivityContactJoinUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityContactJoinPayload>[]
          }
          upsert: {
            args: Prisma.ActivityContactJoinUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityContactJoinPayload>
          }
          aggregate: {
            args: Prisma.ActivityContactJoinAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivityContactJoin>
          }
          groupBy: {
            args: Prisma.ActivityContactJoinGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityContactJoinGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityContactJoinCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityContactJoinCountAggregateOutputType> | number
          }
        }
      }
      ActivityUserJoin: {
        payload: Prisma.$ActivityUserJoinPayload<ExtArgs>
        fields: Prisma.ActivityUserJoinFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityUserJoinFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityUserJoinPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityUserJoinFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityUserJoinPayload>
          }
          findFirst: {
            args: Prisma.ActivityUserJoinFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityUserJoinPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityUserJoinFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityUserJoinPayload>
          }
          findMany: {
            args: Prisma.ActivityUserJoinFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityUserJoinPayload>[]
          }
          create: {
            args: Prisma.ActivityUserJoinCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityUserJoinPayload>
          }
          createMany: {
            args: Prisma.ActivityUserJoinCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityUserJoinCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityUserJoinPayload>[]
          }
          delete: {
            args: Prisma.ActivityUserJoinDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityUserJoinPayload>
          }
          update: {
            args: Prisma.ActivityUserJoinUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityUserJoinPayload>
          }
          deleteMany: {
            args: Prisma.ActivityUserJoinDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityUserJoinUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActivityUserJoinUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityUserJoinPayload>[]
          }
          upsert: {
            args: Prisma.ActivityUserJoinUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityUserJoinPayload>
          }
          aggregate: {
            args: Prisma.ActivityUserJoinAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivityUserJoin>
          }
          groupBy: {
            args: Prisma.ActivityUserJoinGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityUserJoinGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityUserJoinCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityUserJoinCountAggregateOutputType> | number
          }
        }
      }
      ContactEmail: {
        payload: Prisma.$ContactEmailPayload<ExtArgs>
        fields: Prisma.ContactEmailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactEmailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactEmailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactEmailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactEmailPayload>
          }
          findFirst: {
            args: Prisma.ContactEmailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactEmailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactEmailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactEmailPayload>
          }
          findMany: {
            args: Prisma.ContactEmailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactEmailPayload>[]
          }
          create: {
            args: Prisma.ContactEmailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactEmailPayload>
          }
          createMany: {
            args: Prisma.ContactEmailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactEmailCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactEmailPayload>[]
          }
          delete: {
            args: Prisma.ContactEmailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactEmailPayload>
          }
          update: {
            args: Prisma.ContactEmailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactEmailPayload>
          }
          deleteMany: {
            args: Prisma.ContactEmailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactEmailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContactEmailUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactEmailPayload>[]
          }
          upsert: {
            args: Prisma.ContactEmailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactEmailPayload>
          }
          aggregate: {
            args: Prisma.ContactEmailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContactEmail>
          }
          groupBy: {
            args: Prisma.ContactEmailGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactEmailGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactEmailCountArgs<ExtArgs>
            result: $Utils.Optional<ContactEmailCountAggregateOutputType> | number
          }
        }
      }
      ContactPhone: {
        payload: Prisma.$ContactPhonePayload<ExtArgs>
        fields: Prisma.ContactPhoneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactPhoneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPhonePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactPhoneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPhonePayload>
          }
          findFirst: {
            args: Prisma.ContactPhoneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPhonePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactPhoneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPhonePayload>
          }
          findMany: {
            args: Prisma.ContactPhoneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPhonePayload>[]
          }
          create: {
            args: Prisma.ContactPhoneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPhonePayload>
          }
          createMany: {
            args: Prisma.ContactPhoneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactPhoneCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPhonePayload>[]
          }
          delete: {
            args: Prisma.ContactPhoneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPhonePayload>
          }
          update: {
            args: Prisma.ContactPhoneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPhonePayload>
          }
          deleteMany: {
            args: Prisma.ContactPhoneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactPhoneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContactPhoneUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPhonePayload>[]
          }
          upsert: {
            args: Prisma.ContactPhoneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPhonePayload>
          }
          aggregate: {
            args: Prisma.ContactPhoneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContactPhone>
          }
          groupBy: {
            args: Prisma.ContactPhoneGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactPhoneGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactPhoneCountArgs<ExtArgs>
            result: $Utils.Optional<ContactPhoneCountAggregateOutputType> | number
          }
        }
      }
      Address: {
        payload: Prisma.$AddressPayload<ExtArgs>
        fields: Prisma.AddressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AddressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AddressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          findFirst: {
            args: Prisma.AddressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AddressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          findMany: {
            args: Prisma.AddressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          create: {
            args: Prisma.AddressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          createMany: {
            args: Prisma.AddressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AddressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          delete: {
            args: Prisma.AddressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          update: {
            args: Prisma.AddressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          deleteMany: {
            args: Prisma.AddressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AddressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AddressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          upsert: {
            args: Prisma.AddressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          aggregate: {
            args: Prisma.AddressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAddress>
          }
          groupBy: {
            args: Prisma.AddressGroupByArgs<ExtArgs>
            result: $Utils.Optional<AddressGroupByOutputType>[]
          }
          count: {
            args: Prisma.AddressCountArgs<ExtArgs>
            result: $Utils.Optional<AddressCountAggregateOutputType> | number
          }
        }
      }
      ConfigOption: {
        payload: Prisma.$ConfigOptionPayload<ExtArgs>
        fields: Prisma.ConfigOptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConfigOptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigOptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConfigOptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigOptionPayload>
          }
          findFirst: {
            args: Prisma.ConfigOptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigOptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConfigOptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigOptionPayload>
          }
          findMany: {
            args: Prisma.ConfigOptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigOptionPayload>[]
          }
          create: {
            args: Prisma.ConfigOptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigOptionPayload>
          }
          createMany: {
            args: Prisma.ConfigOptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConfigOptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigOptionPayload>[]
          }
          delete: {
            args: Prisma.ConfigOptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigOptionPayload>
          }
          update: {
            args: Prisma.ConfigOptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigOptionPayload>
          }
          deleteMany: {
            args: Prisma.ConfigOptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConfigOptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConfigOptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigOptionPayload>[]
          }
          upsert: {
            args: Prisma.ConfigOptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigOptionPayload>
          }
          aggregate: {
            args: Prisma.ConfigOptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConfigOption>
          }
          groupBy: {
            args: Prisma.ConfigOptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConfigOptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConfigOptionCountArgs<ExtArgs>
            result: $Utils.Optional<ConfigOptionCountAggregateOutputType> | number
          }
        }
      }
      ImportantDate: {
        payload: Prisma.$ImportantDatePayload<ExtArgs>
        fields: Prisma.ImportantDateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ImportantDateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportantDatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ImportantDateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportantDatePayload>
          }
          findFirst: {
            args: Prisma.ImportantDateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportantDatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ImportantDateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportantDatePayload>
          }
          findMany: {
            args: Prisma.ImportantDateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportantDatePayload>[]
          }
          create: {
            args: Prisma.ImportantDateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportantDatePayload>
          }
          createMany: {
            args: Prisma.ImportantDateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ImportantDateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportantDatePayload>[]
          }
          delete: {
            args: Prisma.ImportantDateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportantDatePayload>
          }
          update: {
            args: Prisma.ImportantDateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportantDatePayload>
          }
          deleteMany: {
            args: Prisma.ImportantDateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ImportantDateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ImportantDateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportantDatePayload>[]
          }
          upsert: {
            args: Prisma.ImportantDateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportantDatePayload>
          }
          aggregate: {
            args: Prisma.ImportantDateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateImportantDate>
          }
          groupBy: {
            args: Prisma.ImportantDateGroupByArgs<ExtArgs>
            result: $Utils.Optional<ImportantDateGroupByOutputType>[]
          }
          count: {
            args: Prisma.ImportantDateCountArgs<ExtArgs>
            result: $Utils.Optional<ImportantDateCountAggregateOutputType> | number
          }
        }
      }
      Opportunity: {
        payload: Prisma.$OpportunityPayload<ExtArgs>
        fields: Prisma.OpportunityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OpportunityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OpportunityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>
          }
          findFirst: {
            args: Prisma.OpportunityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OpportunityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>
          }
          findMany: {
            args: Prisma.OpportunityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>[]
          }
          create: {
            args: Prisma.OpportunityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>
          }
          createMany: {
            args: Prisma.OpportunityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OpportunityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>[]
          }
          delete: {
            args: Prisma.OpportunityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>
          }
          update: {
            args: Prisma.OpportunityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>
          }
          deleteMany: {
            args: Prisma.OpportunityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OpportunityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OpportunityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>[]
          }
          upsert: {
            args: Prisma.OpportunityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityPayload>
          }
          aggregate: {
            args: Prisma.OpportunityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOpportunity>
          }
          groupBy: {
            args: Prisma.OpportunityGroupByArgs<ExtArgs>
            result: $Utils.Optional<OpportunityGroupByOutputType>[]
          }
          count: {
            args: Prisma.OpportunityCountArgs<ExtArgs>
            result: $Utils.Optional<OpportunityCountAggregateOutputType> | number
          }
        }
      }
      ContactOpportunityJoin: {
        payload: Prisma.$ContactOpportunityJoinPayload<ExtArgs>
        fields: Prisma.ContactOpportunityJoinFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactOpportunityJoinFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactOpportunityJoinPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactOpportunityJoinFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactOpportunityJoinPayload>
          }
          findFirst: {
            args: Prisma.ContactOpportunityJoinFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactOpportunityJoinPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactOpportunityJoinFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactOpportunityJoinPayload>
          }
          findMany: {
            args: Prisma.ContactOpportunityJoinFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactOpportunityJoinPayload>[]
          }
          create: {
            args: Prisma.ContactOpportunityJoinCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactOpportunityJoinPayload>
          }
          createMany: {
            args: Prisma.ContactOpportunityJoinCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactOpportunityJoinCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactOpportunityJoinPayload>[]
          }
          delete: {
            args: Prisma.ContactOpportunityJoinDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactOpportunityJoinPayload>
          }
          update: {
            args: Prisma.ContactOpportunityJoinUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactOpportunityJoinPayload>
          }
          deleteMany: {
            args: Prisma.ContactOpportunityJoinDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactOpportunityJoinUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContactOpportunityJoinUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactOpportunityJoinPayload>[]
          }
          upsert: {
            args: Prisma.ContactOpportunityJoinUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactOpportunityJoinPayload>
          }
          aggregate: {
            args: Prisma.ContactOpportunityJoinAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContactOpportunityJoin>
          }
          groupBy: {
            args: Prisma.ContactOpportunityJoinGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactOpportunityJoinGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactOpportunityJoinCountArgs<ExtArgs>
            result: $Utils.Optional<ContactOpportunityJoinCountAggregateOutputType> | number
          }
        }
      }
      UserOpportunityJoin: {
        payload: Prisma.$UserOpportunityJoinPayload<ExtArgs>
        fields: Prisma.UserOpportunityJoinFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserOpportunityJoinFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOpportunityJoinPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserOpportunityJoinFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOpportunityJoinPayload>
          }
          findFirst: {
            args: Prisma.UserOpportunityJoinFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOpportunityJoinPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserOpportunityJoinFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOpportunityJoinPayload>
          }
          findMany: {
            args: Prisma.UserOpportunityJoinFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOpportunityJoinPayload>[]
          }
          create: {
            args: Prisma.UserOpportunityJoinCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOpportunityJoinPayload>
          }
          createMany: {
            args: Prisma.UserOpportunityJoinCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserOpportunityJoinCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOpportunityJoinPayload>[]
          }
          delete: {
            args: Prisma.UserOpportunityJoinDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOpportunityJoinPayload>
          }
          update: {
            args: Prisma.UserOpportunityJoinUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOpportunityJoinPayload>
          }
          deleteMany: {
            args: Prisma.UserOpportunityJoinDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserOpportunityJoinUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserOpportunityJoinUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOpportunityJoinPayload>[]
          }
          upsert: {
            args: Prisma.UserOpportunityJoinUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserOpportunityJoinPayload>
          }
          aggregate: {
            args: Prisma.UserOpportunityJoinAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserOpportunityJoin>
          }
          groupBy: {
            args: Prisma.UserOpportunityJoinGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserOpportunityJoinGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserOpportunityJoinCountArgs<ExtArgs>
            result: $Utils.Optional<UserOpportunityJoinCountAggregateOutputType> | number
          }
        }
      }
      OpportunityProduct: {
        payload: Prisma.$OpportunityProductPayload<ExtArgs>
        fields: Prisma.OpportunityProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OpportunityProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OpportunityProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityProductPayload>
          }
          findFirst: {
            args: Prisma.OpportunityProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OpportunityProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityProductPayload>
          }
          findMany: {
            args: Prisma.OpportunityProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityProductPayload>[]
          }
          create: {
            args: Prisma.OpportunityProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityProductPayload>
          }
          createMany: {
            args: Prisma.OpportunityProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OpportunityProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityProductPayload>[]
          }
          delete: {
            args: Prisma.OpportunityProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityProductPayload>
          }
          update: {
            args: Prisma.OpportunityProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityProductPayload>
          }
          deleteMany: {
            args: Prisma.OpportunityProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OpportunityProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OpportunityProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityProductPayload>[]
          }
          upsert: {
            args: Prisma.OpportunityProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpportunityProductPayload>
          }
          aggregate: {
            args: Prisma.OpportunityProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOpportunityProduct>
          }
          groupBy: {
            args: Prisma.OpportunityProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<OpportunityProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.OpportunityProductCountArgs<ExtArgs>
            result: $Utils.Optional<OpportunityProductCountAggregateOutputType> | number
          }
        }
      }
      ProductType: {
        payload: Prisma.$ProductTypePayload<ExtArgs>
        fields: Prisma.ProductTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTypePayload>
          }
          findFirst: {
            args: Prisma.ProductTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTypePayload>
          }
          findMany: {
            args: Prisma.ProductTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTypePayload>[]
          }
          create: {
            args: Prisma.ProductTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTypePayload>
          }
          createMany: {
            args: Prisma.ProductTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTypePayload>[]
          }
          delete: {
            args: Prisma.ProductTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTypePayload>
          }
          update: {
            args: Prisma.ProductTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTypePayload>
          }
          deleteMany: {
            args: Prisma.ProductTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTypePayload>[]
          }
          upsert: {
            args: Prisma.ProductTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTypePayload>
          }
          aggregate: {
            args: Prisma.ProductTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductType>
          }
          groupBy: {
            args: Prisma.ProductTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductTypeCountArgs<ExtArgs>
            result: $Utils.Optional<ProductTypeCountAggregateOutputType> | number
          }
        }
      }
      Log: {
        payload: Prisma.$LogPayload<ExtArgs>
        fields: Prisma.LogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          findFirst: {
            args: Prisma.LogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          findMany: {
            args: Prisma.LogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>[]
          }
          create: {
            args: Prisma.LogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          createMany: {
            args: Prisma.LogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>[]
          }
          delete: {
            args: Prisma.LogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          update: {
            args: Prisma.LogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          deleteMany: {
            args: Prisma.LogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>[]
          }
          upsert: {
            args: Prisma.LogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          aggregate: {
            args: Prisma.LogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLog>
          }
          groupBy: {
            args: Prisma.LogGroupByArgs<ExtArgs>
            result: $Utils.Optional<LogGroupByOutputType>[]
          }
          count: {
            args: Prisma.LogCountArgs<ExtArgs>
            result: $Utils.Optional<LogCountAggregateOutputType> | number
          }
        }
      }
      Token: {
        payload: Prisma.$TokenPayload<ExtArgs>
        fields: Prisma.TokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          findFirst: {
            args: Prisma.TokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          findMany: {
            args: Prisma.TokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>[]
          }
          create: {
            args: Prisma.TokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          createMany: {
            args: Prisma.TokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>[]
          }
          delete: {
            args: Prisma.TokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          update: {
            args: Prisma.TokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          deleteMany: {
            args: Prisma.TokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>[]
          }
          upsert: {
            args: Prisma.TokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          aggregate: {
            args: Prisma.TokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateToken>
          }
          groupBy: {
            args: Prisma.TokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<TokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.TokenCountArgs<ExtArgs>
            result: $Utils.Optional<TokenCountAggregateOutputType> | number
          }
        }
      }
      TZData: {
        payload: Prisma.$TZDataPayload<ExtArgs>
        fields: Prisma.TZDataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TZDataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TZDataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TZDataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TZDataPayload>
          }
          findFirst: {
            args: Prisma.TZDataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TZDataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TZDataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TZDataPayload>
          }
          findMany: {
            args: Prisma.TZDataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TZDataPayload>[]
          }
          create: {
            args: Prisma.TZDataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TZDataPayload>
          }
          createMany: {
            args: Prisma.TZDataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TZDataCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TZDataPayload>[]
          }
          delete: {
            args: Prisma.TZDataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TZDataPayload>
          }
          update: {
            args: Prisma.TZDataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TZDataPayload>
          }
          deleteMany: {
            args: Prisma.TZDataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TZDataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TZDataUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TZDataPayload>[]
          }
          upsert: {
            args: Prisma.TZDataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TZDataPayload>
          }
          aggregate: {
            args: Prisma.TZDataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTZData>
          }
          groupBy: {
            args: Prisma.TZDataGroupByArgs<ExtArgs>
            result: $Utils.Optional<TZDataGroupByOutputType>[]
          }
          count: {
            args: Prisma.TZDataCountArgs<ExtArgs>
            result: $Utils.Optional<TZDataCountAggregateOutputType> | number
          }
        }
      }
      TestObject: {
        payload: Prisma.$TestObjectPayload<ExtArgs>
        fields: Prisma.TestObjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TestObjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestObjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TestObjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestObjectPayload>
          }
          findFirst: {
            args: Prisma.TestObjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestObjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TestObjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestObjectPayload>
          }
          findMany: {
            args: Prisma.TestObjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestObjectPayload>[]
          }
          create: {
            args: Prisma.TestObjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestObjectPayload>
          }
          createMany: {
            args: Prisma.TestObjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TestObjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestObjectPayload>[]
          }
          delete: {
            args: Prisma.TestObjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestObjectPayload>
          }
          update: {
            args: Prisma.TestObjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestObjectPayload>
          }
          deleteMany: {
            args: Prisma.TestObjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TestObjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TestObjectUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestObjectPayload>[]
          }
          upsert: {
            args: Prisma.TestObjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestObjectPayload>
          }
          aggregate: {
            args: Prisma.TestObjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTestObject>
          }
          groupBy: {
            args: Prisma.TestObjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<TestObjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.TestObjectCountArgs<ExtArgs>
            result: $Utils.Optional<TestObjectCountAggregateOutputType> | number
          }
        }
      }
      WrappedObject: {
        payload: Prisma.$WrappedObjectPayload<ExtArgs>
        fields: Prisma.WrappedObjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WrappedObjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WrappedObjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WrappedObjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WrappedObjectPayload>
          }
          findFirst: {
            args: Prisma.WrappedObjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WrappedObjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WrappedObjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WrappedObjectPayload>
          }
          findMany: {
            args: Prisma.WrappedObjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WrappedObjectPayload>[]
          }
          create: {
            args: Prisma.WrappedObjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WrappedObjectPayload>
          }
          createMany: {
            args: Prisma.WrappedObjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WrappedObjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WrappedObjectPayload>[]
          }
          delete: {
            args: Prisma.WrappedObjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WrappedObjectPayload>
          }
          update: {
            args: Prisma.WrappedObjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WrappedObjectPayload>
          }
          deleteMany: {
            args: Prisma.WrappedObjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WrappedObjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WrappedObjectUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WrappedObjectPayload>[]
          }
          upsert: {
            args: Prisma.WrappedObjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WrappedObjectPayload>
          }
          aggregate: {
            args: Prisma.WrappedObjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWrappedObject>
          }
          groupBy: {
            args: Prisma.WrappedObjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<WrappedObjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.WrappedObjectCountArgs<ExtArgs>
            result: $Utils.Optional<WrappedObjectCountAggregateOutputType> | number
          }
        }
      }
      JoinTestObject: {
        payload: Prisma.$JoinTestObjectPayload<ExtArgs>
        fields: Prisma.JoinTestObjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JoinTestObjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinTestObjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JoinTestObjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinTestObjectPayload>
          }
          findFirst: {
            args: Prisma.JoinTestObjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinTestObjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JoinTestObjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinTestObjectPayload>
          }
          findMany: {
            args: Prisma.JoinTestObjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinTestObjectPayload>[]
          }
          create: {
            args: Prisma.JoinTestObjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinTestObjectPayload>
          }
          createMany: {
            args: Prisma.JoinTestObjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JoinTestObjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinTestObjectPayload>[]
          }
          delete: {
            args: Prisma.JoinTestObjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinTestObjectPayload>
          }
          update: {
            args: Prisma.JoinTestObjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinTestObjectPayload>
          }
          deleteMany: {
            args: Prisma.JoinTestObjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JoinTestObjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JoinTestObjectUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinTestObjectPayload>[]
          }
          upsert: {
            args: Prisma.JoinTestObjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinTestObjectPayload>
          }
          aggregate: {
            args: Prisma.JoinTestObjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJoinTestObject>
          }
          groupBy: {
            args: Prisma.JoinTestObjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<JoinTestObjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.JoinTestObjectCountArgs<ExtArgs>
            result: $Utils.Optional<JoinTestObjectCountAggregateOutputType> | number
          }
        }
      }
      JoinTestObject2: {
        payload: Prisma.$JoinTestObject2Payload<ExtArgs>
        fields: Prisma.JoinTestObject2FieldRefs
        operations: {
          findUnique: {
            args: Prisma.JoinTestObject2FindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinTestObject2Payload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JoinTestObject2FindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinTestObject2Payload>
          }
          findFirst: {
            args: Prisma.JoinTestObject2FindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinTestObject2Payload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JoinTestObject2FindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinTestObject2Payload>
          }
          findMany: {
            args: Prisma.JoinTestObject2FindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinTestObject2Payload>[]
          }
          create: {
            args: Prisma.JoinTestObject2CreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinTestObject2Payload>
          }
          createMany: {
            args: Prisma.JoinTestObject2CreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JoinTestObject2CreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinTestObject2Payload>[]
          }
          delete: {
            args: Prisma.JoinTestObject2DeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinTestObject2Payload>
          }
          update: {
            args: Prisma.JoinTestObject2UpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinTestObject2Payload>
          }
          deleteMany: {
            args: Prisma.JoinTestObject2DeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JoinTestObject2UpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JoinTestObject2UpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinTestObject2Payload>[]
          }
          upsert: {
            args: Prisma.JoinTestObject2UpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinTestObject2Payload>
          }
          aggregate: {
            args: Prisma.JoinTestObject2AggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJoinTestObject2>
          }
          groupBy: {
            args: Prisma.JoinTestObject2GroupByArgs<ExtArgs>
            result: $Utils.Optional<JoinTestObject2GroupByOutputType>[]
          }
          count: {
            args: Prisma.JoinTestObject2CountArgs<ExtArgs>
            result: $Utils.Optional<JoinTestObject2CountAggregateOutputType> | number
          }
        }
      }
      JoinedObject1: {
        payload: Prisma.$JoinedObject1Payload<ExtArgs>
        fields: Prisma.JoinedObject1FieldRefs
        operations: {
          findUnique: {
            args: Prisma.JoinedObject1FindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinedObject1Payload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JoinedObject1FindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinedObject1Payload>
          }
          findFirst: {
            args: Prisma.JoinedObject1FindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinedObject1Payload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JoinedObject1FindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinedObject1Payload>
          }
          findMany: {
            args: Prisma.JoinedObject1FindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinedObject1Payload>[]
          }
          create: {
            args: Prisma.JoinedObject1CreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinedObject1Payload>
          }
          createMany: {
            args: Prisma.JoinedObject1CreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JoinedObject1CreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinedObject1Payload>[]
          }
          delete: {
            args: Prisma.JoinedObject1DeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinedObject1Payload>
          }
          update: {
            args: Prisma.JoinedObject1UpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinedObject1Payload>
          }
          deleteMany: {
            args: Prisma.JoinedObject1DeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JoinedObject1UpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JoinedObject1UpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinedObject1Payload>[]
          }
          upsert: {
            args: Prisma.JoinedObject1UpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinedObject1Payload>
          }
          aggregate: {
            args: Prisma.JoinedObject1AggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJoinedObject1>
          }
          groupBy: {
            args: Prisma.JoinedObject1GroupByArgs<ExtArgs>
            result: $Utils.Optional<JoinedObject1GroupByOutputType>[]
          }
          count: {
            args: Prisma.JoinedObject1CountArgs<ExtArgs>
            result: $Utils.Optional<JoinedObject1CountAggregateOutputType> | number
          }
        }
      }
      JoinedObject2: {
        payload: Prisma.$JoinedObject2Payload<ExtArgs>
        fields: Prisma.JoinedObject2FieldRefs
        operations: {
          findUnique: {
            args: Prisma.JoinedObject2FindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinedObject2Payload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JoinedObject2FindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinedObject2Payload>
          }
          findFirst: {
            args: Prisma.JoinedObject2FindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinedObject2Payload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JoinedObject2FindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinedObject2Payload>
          }
          findMany: {
            args: Prisma.JoinedObject2FindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinedObject2Payload>[]
          }
          create: {
            args: Prisma.JoinedObject2CreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinedObject2Payload>
          }
          createMany: {
            args: Prisma.JoinedObject2CreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JoinedObject2CreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinedObject2Payload>[]
          }
          delete: {
            args: Prisma.JoinedObject2DeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinedObject2Payload>
          }
          update: {
            args: Prisma.JoinedObject2UpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinedObject2Payload>
          }
          deleteMany: {
            args: Prisma.JoinedObject2DeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JoinedObject2UpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JoinedObject2UpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinedObject2Payload>[]
          }
          upsert: {
            args: Prisma.JoinedObject2UpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinedObject2Payload>
          }
          aggregate: {
            args: Prisma.JoinedObject2AggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJoinedObject2>
          }
          groupBy: {
            args: Prisma.JoinedObject2GroupByArgs<ExtArgs>
            result: $Utils.Optional<JoinedObject2GroupByOutputType>[]
          }
          count: {
            args: Prisma.JoinedObject2CountArgs<ExtArgs>
            result: $Utils.Optional<JoinedObject2CountAggregateOutputType> | number
          }
        }
      }
      JoinSelfReference: {
        payload: Prisma.$JoinSelfReferencePayload<ExtArgs>
        fields: Prisma.JoinSelfReferenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JoinSelfReferenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinSelfReferencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JoinSelfReferenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinSelfReferencePayload>
          }
          findFirst: {
            args: Prisma.JoinSelfReferenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinSelfReferencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JoinSelfReferenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinSelfReferencePayload>
          }
          findMany: {
            args: Prisma.JoinSelfReferenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinSelfReferencePayload>[]
          }
          create: {
            args: Prisma.JoinSelfReferenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinSelfReferencePayload>
          }
          createMany: {
            args: Prisma.JoinSelfReferenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JoinSelfReferenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinSelfReferencePayload>[]
          }
          delete: {
            args: Prisma.JoinSelfReferenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinSelfReferencePayload>
          }
          update: {
            args: Prisma.JoinSelfReferenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinSelfReferencePayload>
          }
          deleteMany: {
            args: Prisma.JoinSelfReferenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JoinSelfReferenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JoinSelfReferenceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinSelfReferencePayload>[]
          }
          upsert: {
            args: Prisma.JoinSelfReferenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinSelfReferencePayload>
          }
          aggregate: {
            args: Prisma.JoinSelfReferenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJoinSelfReference>
          }
          groupBy: {
            args: Prisma.JoinSelfReferenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<JoinSelfReferenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.JoinSelfReferenceCountArgs<ExtArgs>
            result: $Utils.Optional<JoinSelfReferenceCountAggregateOutputType> | number
          }
        }
      }
      SelfReferencialJoinModel: {
        payload: Prisma.$SelfReferencialJoinModelPayload<ExtArgs>
        fields: Prisma.SelfReferencialJoinModelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SelfReferencialJoinModelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SelfReferencialJoinModelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SelfReferencialJoinModelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SelfReferencialJoinModelPayload>
          }
          findFirst: {
            args: Prisma.SelfReferencialJoinModelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SelfReferencialJoinModelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SelfReferencialJoinModelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SelfReferencialJoinModelPayload>
          }
          findMany: {
            args: Prisma.SelfReferencialJoinModelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SelfReferencialJoinModelPayload>[]
          }
          create: {
            args: Prisma.SelfReferencialJoinModelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SelfReferencialJoinModelPayload>
          }
          createMany: {
            args: Prisma.SelfReferencialJoinModelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SelfReferencialJoinModelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SelfReferencialJoinModelPayload>[]
          }
          delete: {
            args: Prisma.SelfReferencialJoinModelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SelfReferencialJoinModelPayload>
          }
          update: {
            args: Prisma.SelfReferencialJoinModelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SelfReferencialJoinModelPayload>
          }
          deleteMany: {
            args: Prisma.SelfReferencialJoinModelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SelfReferencialJoinModelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SelfReferencialJoinModelUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SelfReferencialJoinModelPayload>[]
          }
          upsert: {
            args: Prisma.SelfReferencialJoinModelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SelfReferencialJoinModelPayload>
          }
          aggregate: {
            args: Prisma.SelfReferencialJoinModelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSelfReferencialJoinModel>
          }
          groupBy: {
            args: Prisma.SelfReferencialJoinModelGroupByArgs<ExtArgs>
            result: $Utils.Optional<SelfReferencialJoinModelGroupByOutputType>[]
          }
          count: {
            args: Prisma.SelfReferencialJoinModelCountArgs<ExtArgs>
            result: $Utils.Optional<SelfReferencialJoinModelCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRawTyped: {
          args: runtime.UnknownTypedSql,
          result: Prisma.JsonObject
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    tenet?: TenetOmit
    user?: UserOmit
    contact?: ContactOmit
    contactRelationship?: ContactRelationshipOmit
    activityStep?: ActivityStepOmit
    activityStepUserJoin?: ActivityStepUserJoinOmit
    userWaypointJoin?: UserWaypointJoinOmit
    activityWaypoint?: ActivityWaypointOmit
    templateAssignment?: TemplateAssignmentOmit
    activityWaypointTemplate?: ActivityWaypointTemplateOmit
    activityTemplateStep?: ActivityTemplateStepOmit
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentOmit
    activityTemplate?: ActivityTemplateOmit
    activity?: ActivityOmit
    contactTimelineEvent?: ContactTimelineEventOmit
    auditEvent?: AuditEventOmit
    contactTimelineEventContactJoin?: ContactTimelineEventContactJoinOmit
    note?: NoteOmit
    attachment?: AttachmentOmit
    activityContactJoin?: ActivityContactJoinOmit
    activityUserJoin?: ActivityUserJoinOmit
    contactEmail?: ContactEmailOmit
    contactPhone?: ContactPhoneOmit
    address?: AddressOmit
    configOption?: ConfigOptionOmit
    importantDate?: ImportantDateOmit
    opportunity?: OpportunityOmit
    contactOpportunityJoin?: ContactOpportunityJoinOmit
    userOpportunityJoin?: UserOpportunityJoinOmit
    opportunityProduct?: OpportunityProductOmit
    productType?: ProductTypeOmit
    log?: LogOmit
    token?: TokenOmit
    tZData?: TZDataOmit
    testObject?: TestObjectOmit
    wrappedObject?: WrappedObjectOmit
    joinTestObject?: JoinTestObjectOmit
    joinTestObject2?: JoinTestObject2Omit
    joinedObject1?: JoinedObject1Omit
    joinedObject2?: JoinedObject2Omit
    joinSelfReference?: JoinSelfReferenceOmit
    selfReferencialJoinModel?: SelfReferencialJoinModelOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type TenetCountOutputType
   */

  export type TenetCountOutputType = {
    users: number
    logs: number
    contacts: number
    activities: number
    addresses: number
    contactEmails: number
    contactPhones: number
    importantDates: number
    attachments: number
    notes: number
    auditEvents: number
    contactTimelineEvents: number
    activitySteps: number
    activityWaypoints: number
    templateAssignments: number
    activityWaypointTemplates: number
    activityTemplates: number
    activityTemplateSteps: number
    opportunities: number
    products: number
    activityTemplateStepAssignment: number
  }

  export type TenetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | TenetCountOutputTypeCountUsersArgs
    logs?: boolean | TenetCountOutputTypeCountLogsArgs
    contacts?: boolean | TenetCountOutputTypeCountContactsArgs
    activities?: boolean | TenetCountOutputTypeCountActivitiesArgs
    addresses?: boolean | TenetCountOutputTypeCountAddressesArgs
    contactEmails?: boolean | TenetCountOutputTypeCountContactEmailsArgs
    contactPhones?: boolean | TenetCountOutputTypeCountContactPhonesArgs
    importantDates?: boolean | TenetCountOutputTypeCountImportantDatesArgs
    attachments?: boolean | TenetCountOutputTypeCountAttachmentsArgs
    notes?: boolean | TenetCountOutputTypeCountNotesArgs
    auditEvents?: boolean | TenetCountOutputTypeCountAuditEventsArgs
    contactTimelineEvents?: boolean | TenetCountOutputTypeCountContactTimelineEventsArgs
    activitySteps?: boolean | TenetCountOutputTypeCountActivityStepsArgs
    activityWaypoints?: boolean | TenetCountOutputTypeCountActivityWaypointsArgs
    templateAssignments?: boolean | TenetCountOutputTypeCountTemplateAssignmentsArgs
    activityWaypointTemplates?: boolean | TenetCountOutputTypeCountActivityWaypointTemplatesArgs
    activityTemplates?: boolean | TenetCountOutputTypeCountActivityTemplatesArgs
    activityTemplateSteps?: boolean | TenetCountOutputTypeCountActivityTemplateStepsArgs
    opportunities?: boolean | TenetCountOutputTypeCountOpportunitiesArgs
    products?: boolean | TenetCountOutputTypeCountProductsArgs
    activityTemplateStepAssignment?: boolean | TenetCountOutputTypeCountActivityTemplateStepAssignmentArgs
  }

  // Custom InputTypes
  /**
   * TenetCountOutputType without action
   */
  export type TenetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenetCountOutputType
     */
    select?: TenetCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TenetCountOutputType without action
   */
  export type TenetCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * TenetCountOutputType without action
   */
  export type TenetCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogWhereInput
  }

  /**
   * TenetCountOutputType without action
   */
  export type TenetCountOutputTypeCountContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
  }

  /**
   * TenetCountOutputType without action
   */
  export type TenetCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
  }

  /**
   * TenetCountOutputType without action
   */
  export type TenetCountOutputTypeCountAddressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressWhereInput
  }

  /**
   * TenetCountOutputType without action
   */
  export type TenetCountOutputTypeCountContactEmailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactEmailWhereInput
  }

  /**
   * TenetCountOutputType without action
   */
  export type TenetCountOutputTypeCountContactPhonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactPhoneWhereInput
  }

  /**
   * TenetCountOutputType without action
   */
  export type TenetCountOutputTypeCountImportantDatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImportantDateWhereInput
  }

  /**
   * TenetCountOutputType without action
   */
  export type TenetCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttachmentWhereInput
  }

  /**
   * TenetCountOutputType without action
   */
  export type TenetCountOutputTypeCountNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoteWhereInput
  }

  /**
   * TenetCountOutputType without action
   */
  export type TenetCountOutputTypeCountAuditEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditEventWhereInput
  }

  /**
   * TenetCountOutputType without action
   */
  export type TenetCountOutputTypeCountContactTimelineEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactTimelineEventWhereInput
  }

  /**
   * TenetCountOutputType without action
   */
  export type TenetCountOutputTypeCountActivityStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityStepWhereInput
  }

  /**
   * TenetCountOutputType without action
   */
  export type TenetCountOutputTypeCountActivityWaypointsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWaypointWhereInput
  }

  /**
   * TenetCountOutputType without action
   */
  export type TenetCountOutputTypeCountTemplateAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TemplateAssignmentWhereInput
  }

  /**
   * TenetCountOutputType without action
   */
  export type TenetCountOutputTypeCountActivityWaypointTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWaypointTemplateWhereInput
  }

  /**
   * TenetCountOutputType without action
   */
  export type TenetCountOutputTypeCountActivityTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityTemplateWhereInput
  }

  /**
   * TenetCountOutputType without action
   */
  export type TenetCountOutputTypeCountActivityTemplateStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityTemplateStepWhereInput
  }

  /**
   * TenetCountOutputType without action
   */
  export type TenetCountOutputTypeCountOpportunitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OpportunityWhereInput
  }

  /**
   * TenetCountOutputType without action
   */
  export type TenetCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductTypeWhereInput
  }

  /**
   * TenetCountOutputType without action
   */
  export type TenetCountOutputTypeCountActivityTemplateStepAssignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityTemplateStepAssignmentWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    tokens: number
    activities: number
    notes: number
    waypoints: number
    events: number
    auditEvents: number
    templateAssignments: number
    assignedActivities: number
    opportunities: number
    activitySteps: number
    templateStepAssignments: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tokens?: boolean | UserCountOutputTypeCountTokensArgs
    activities?: boolean | UserCountOutputTypeCountActivitiesArgs
    notes?: boolean | UserCountOutputTypeCountNotesArgs
    waypoints?: boolean | UserCountOutputTypeCountWaypointsArgs
    events?: boolean | UserCountOutputTypeCountEventsArgs
    auditEvents?: boolean | UserCountOutputTypeCountAuditEventsArgs
    templateAssignments?: boolean | UserCountOutputTypeCountTemplateAssignmentsArgs
    assignedActivities?: boolean | UserCountOutputTypeCountAssignedActivitiesArgs
    opportunities?: boolean | UserCountOutputTypeCountOpportunitiesArgs
    activitySteps?: boolean | UserCountOutputTypeCountActivityStepsArgs
    templateStepAssignments?: boolean | UserCountOutputTypeCountTemplateStepAssignmentsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityUserJoinWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWaypointsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWaypointJoinWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactTimelineEventWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditEventWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTemplateAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TemplateAssignmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOpportunitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserOpportunityJoinWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountActivityStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityStepUserJoinWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTemplateStepAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityTemplateStepAssignmentWhereInput
  }


  /**
   * Count Type ContactCountOutputType
   */

  export type ContactCountOutputType = {
    notes: number
    timelineEvents: number
    addresses: number
    emails: number
    phones: number
    importantDates: number
    activities: number
    householdMembers: number
    employees: number
    opportunities: number
    relationAsSource: number
    relationAsTarget: number
  }

  export type ContactCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notes?: boolean | ContactCountOutputTypeCountNotesArgs
    timelineEvents?: boolean | ContactCountOutputTypeCountTimelineEventsArgs
    addresses?: boolean | ContactCountOutputTypeCountAddressesArgs
    emails?: boolean | ContactCountOutputTypeCountEmailsArgs
    phones?: boolean | ContactCountOutputTypeCountPhonesArgs
    importantDates?: boolean | ContactCountOutputTypeCountImportantDatesArgs
    activities?: boolean | ContactCountOutputTypeCountActivitiesArgs
    householdMembers?: boolean | ContactCountOutputTypeCountHouseholdMembersArgs
    employees?: boolean | ContactCountOutputTypeCountEmployeesArgs
    opportunities?: boolean | ContactCountOutputTypeCountOpportunitiesArgs
    relationAsSource?: boolean | ContactCountOutputTypeCountRelationAsSourceArgs
    relationAsTarget?: boolean | ContactCountOutputTypeCountRelationAsTargetArgs
  }

  // Custom InputTypes
  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactCountOutputType
     */
    select?: ContactCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoteWhereInput
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountTimelineEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactTimelineEventContactJoinWhereInput
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountAddressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressWhereInput
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountEmailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactEmailWhereInput
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountPhonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactPhoneWhereInput
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountImportantDatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImportantDateWhereInput
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityContactJoinWhereInput
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountHouseholdMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountOpportunitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactOpportunityJoinWhereInput
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountRelationAsSourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactRelationshipWhereInput
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountRelationAsTargetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactRelationshipWhereInput
  }


  /**
   * Count Type ActivityStepCountOutputType
   */

  export type ActivityStepCountOutputType = {
    assignedTo: number
  }

  export type ActivityStepCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedTo?: boolean | ActivityStepCountOutputTypeCountAssignedToArgs
  }

  // Custom InputTypes
  /**
   * ActivityStepCountOutputType without action
   */
  export type ActivityStepCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityStepCountOutputType
     */
    select?: ActivityStepCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ActivityStepCountOutputType without action
   */
  export type ActivityStepCountOutputTypeCountAssignedToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityStepUserJoinWhereInput
  }


  /**
   * Count Type ActivityWaypointCountOutputType
   */

  export type ActivityWaypointCountOutputType = {
    users: number
    childActivities: number
    events: number
    Note: number
  }

  export type ActivityWaypointCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | ActivityWaypointCountOutputTypeCountUsersArgs
    childActivities?: boolean | ActivityWaypointCountOutputTypeCountChildActivitiesArgs
    events?: boolean | ActivityWaypointCountOutputTypeCountEventsArgs
    Note?: boolean | ActivityWaypointCountOutputTypeCountNoteArgs
  }

  // Custom InputTypes
  /**
   * ActivityWaypointCountOutputType without action
   */
  export type ActivityWaypointCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityWaypointCountOutputType
     */
    select?: ActivityWaypointCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ActivityWaypointCountOutputType without action
   */
  export type ActivityWaypointCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWaypointJoinWhereInput
  }

  /**
   * ActivityWaypointCountOutputType without action
   */
  export type ActivityWaypointCountOutputTypeCountChildActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
  }

  /**
   * ActivityWaypointCountOutputType without action
   */
  export type ActivityWaypointCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactTimelineEventWhereInput
  }

  /**
   * ActivityWaypointCountOutputType without action
   */
  export type ActivityWaypointCountOutputTypeCountNoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoteWhereInput
  }


  /**
   * Count Type ActivityWaypointTemplateCountOutputType
   */

  export type ActivityWaypointTemplateCountOutputType = {
    activities: number
    waypoints: number
    assignments: number
  }

  export type ActivityWaypointTemplateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activities?: boolean | ActivityWaypointTemplateCountOutputTypeCountActivitiesArgs
    waypoints?: boolean | ActivityWaypointTemplateCountOutputTypeCountWaypointsArgs
    assignments?: boolean | ActivityWaypointTemplateCountOutputTypeCountAssignmentsArgs
  }

  // Custom InputTypes
  /**
   * ActivityWaypointTemplateCountOutputType without action
   */
  export type ActivityWaypointTemplateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityWaypointTemplateCountOutputType
     */
    select?: ActivityWaypointTemplateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ActivityWaypointTemplateCountOutputType without action
   */
  export type ActivityWaypointTemplateCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityTemplateWhereInput
  }

  /**
   * ActivityWaypointTemplateCountOutputType without action
   */
  export type ActivityWaypointTemplateCountOutputTypeCountWaypointsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWaypointWhereInput
  }

  /**
   * ActivityWaypointTemplateCountOutputType without action
   */
  export type ActivityWaypointTemplateCountOutputTypeCountAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TemplateAssignmentWhereInput
  }


  /**
   * Count Type ActivityTemplateStepCountOutputType
   */

  export type ActivityTemplateStepCountOutputType = {
    assignedTo: number
  }

  export type ActivityTemplateStepCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedTo?: boolean | ActivityTemplateStepCountOutputTypeCountAssignedToArgs
  }

  // Custom InputTypes
  /**
   * ActivityTemplateStepCountOutputType without action
   */
  export type ActivityTemplateStepCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityTemplateStepCountOutputType
     */
    select?: ActivityTemplateStepCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ActivityTemplateStepCountOutputType without action
   */
  export type ActivityTemplateStepCountOutputTypeCountAssignedToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityTemplateStepAssignmentWhereInput
  }


  /**
   * Count Type ActivityTemplateCountOutputType
   */

  export type ActivityTemplateCountOutputType = {
    steps: number
    dependents: number
    waypoints: number
    childActivities: number
    activities: number
    assignments: number
  }

  export type ActivityTemplateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    steps?: boolean | ActivityTemplateCountOutputTypeCountStepsArgs
    dependents?: boolean | ActivityTemplateCountOutputTypeCountDependentsArgs
    waypoints?: boolean | ActivityTemplateCountOutputTypeCountWaypointsArgs
    childActivities?: boolean | ActivityTemplateCountOutputTypeCountChildActivitiesArgs
    activities?: boolean | ActivityTemplateCountOutputTypeCountActivitiesArgs
    assignments?: boolean | ActivityTemplateCountOutputTypeCountAssignmentsArgs
  }

  // Custom InputTypes
  /**
   * ActivityTemplateCountOutputType without action
   */
  export type ActivityTemplateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityTemplateCountOutputType
     */
    select?: ActivityTemplateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ActivityTemplateCountOutputType without action
   */
  export type ActivityTemplateCountOutputTypeCountStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityTemplateStepWhereInput
  }

  /**
   * ActivityTemplateCountOutputType without action
   */
  export type ActivityTemplateCountOutputTypeCountDependentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityTemplateWhereInput
  }

  /**
   * ActivityTemplateCountOutputType without action
   */
  export type ActivityTemplateCountOutputTypeCountWaypointsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWaypointTemplateWhereInput
  }

  /**
   * ActivityTemplateCountOutputType without action
   */
  export type ActivityTemplateCountOutputTypeCountChildActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityTemplateWhereInput
  }

  /**
   * ActivityTemplateCountOutputType without action
   */
  export type ActivityTemplateCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
  }

  /**
   * ActivityTemplateCountOutputType without action
   */
  export type ActivityTemplateCountOutputTypeCountAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TemplateAssignmentWhereInput
  }


  /**
   * Count Type ActivityCountOutputType
   */

  export type ActivityCountOutputType = {
    steps: number
    waypoints: number
    activities: number
    contacts: number
    users: number
    attachments: number
    notes: number
    events: number
  }

  export type ActivityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    steps?: boolean | ActivityCountOutputTypeCountStepsArgs
    waypoints?: boolean | ActivityCountOutputTypeCountWaypointsArgs
    activities?: boolean | ActivityCountOutputTypeCountActivitiesArgs
    contacts?: boolean | ActivityCountOutputTypeCountContactsArgs
    users?: boolean | ActivityCountOutputTypeCountUsersArgs
    attachments?: boolean | ActivityCountOutputTypeCountAttachmentsArgs
    notes?: boolean | ActivityCountOutputTypeCountNotesArgs
    events?: boolean | ActivityCountOutputTypeCountEventsArgs
  }

  // Custom InputTypes
  /**
   * ActivityCountOutputType without action
   */
  export type ActivityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityCountOutputType
     */
    select?: ActivityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ActivityCountOutputType without action
   */
  export type ActivityCountOutputTypeCountStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityStepWhereInput
  }

  /**
   * ActivityCountOutputType without action
   */
  export type ActivityCountOutputTypeCountWaypointsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWaypointWhereInput
  }

  /**
   * ActivityCountOutputType without action
   */
  export type ActivityCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
  }

  /**
   * ActivityCountOutputType without action
   */
  export type ActivityCountOutputTypeCountContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityContactJoinWhereInput
  }

  /**
   * ActivityCountOutputType without action
   */
  export type ActivityCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityUserJoinWhereInput
  }

  /**
   * ActivityCountOutputType without action
   */
  export type ActivityCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttachmentWhereInput
  }

  /**
   * ActivityCountOutputType without action
   */
  export type ActivityCountOutputTypeCountNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoteWhereInput
  }

  /**
   * ActivityCountOutputType without action
   */
  export type ActivityCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactTimelineEventWhereInput
  }


  /**
   * Count Type ContactTimelineEventCountOutputType
   */

  export type ContactTimelineEventCountOutputType = {
    contacts: number
  }

  export type ContactTimelineEventCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contacts?: boolean | ContactTimelineEventCountOutputTypeCountContactsArgs
  }

  // Custom InputTypes
  /**
   * ContactTimelineEventCountOutputType without action
   */
  export type ContactTimelineEventCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTimelineEventCountOutputType
     */
    select?: ContactTimelineEventCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContactTimelineEventCountOutputType without action
   */
  export type ContactTimelineEventCountOutputTypeCountContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactTimelineEventContactJoinWhereInput
  }


  /**
   * Count Type NoteCountOutputType
   */

  export type NoteCountOutputType = {
    events: number
  }

  export type NoteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    events?: boolean | NoteCountOutputTypeCountEventsArgs
  }

  // Custom InputTypes
  /**
   * NoteCountOutputType without action
   */
  export type NoteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteCountOutputType
     */
    select?: NoteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NoteCountOutputType without action
   */
  export type NoteCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactTimelineEventWhereInput
  }


  /**
   * Count Type OpportunityCountOutputType
   */

  export type OpportunityCountOutputType = {
    contacts: number
    teamMembers: number
    activities: number
    products: number
    events: number
    notes: number
  }

  export type OpportunityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contacts?: boolean | OpportunityCountOutputTypeCountContactsArgs
    teamMembers?: boolean | OpportunityCountOutputTypeCountTeamMembersArgs
    activities?: boolean | OpportunityCountOutputTypeCountActivitiesArgs
    products?: boolean | OpportunityCountOutputTypeCountProductsArgs
    events?: boolean | OpportunityCountOutputTypeCountEventsArgs
    notes?: boolean | OpportunityCountOutputTypeCountNotesArgs
  }

  // Custom InputTypes
  /**
   * OpportunityCountOutputType without action
   */
  export type OpportunityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpportunityCountOutputType
     */
    select?: OpportunityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OpportunityCountOutputType without action
   */
  export type OpportunityCountOutputTypeCountContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactOpportunityJoinWhereInput
  }

  /**
   * OpportunityCountOutputType without action
   */
  export type OpportunityCountOutputTypeCountTeamMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserOpportunityJoinWhereInput
  }

  /**
   * OpportunityCountOutputType without action
   */
  export type OpportunityCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
  }

  /**
   * OpportunityCountOutputType without action
   */
  export type OpportunityCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OpportunityProductWhereInput
  }

  /**
   * OpportunityCountOutputType without action
   */
  export type OpportunityCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactTimelineEventWhereInput
  }

  /**
   * OpportunityCountOutputType without action
   */
  export type OpportunityCountOutputTypeCountNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoteWhereInput
  }


  /**
   * Count Type ProductTypeCountOutputType
   */

  export type ProductTypeCountOutputType = {
    opportunities: number
  }

  export type ProductTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    opportunities?: boolean | ProductTypeCountOutputTypeCountOpportunitiesArgs
  }

  // Custom InputTypes
  /**
   * ProductTypeCountOutputType without action
   */
  export type ProductTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTypeCountOutputType
     */
    select?: ProductTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductTypeCountOutputType without action
   */
  export type ProductTypeCountOutputTypeCountOpportunitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OpportunityProductWhereInput
  }


  /**
   * Count Type TestObjectCountOutputType
   */

  export type TestObjectCountOutputType = {
    wrapped: number
    join1: number
    join2: number
  }

  export type TestObjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wrapped?: boolean | TestObjectCountOutputTypeCountWrappedArgs
    join1?: boolean | TestObjectCountOutputTypeCountJoin1Args
    join2?: boolean | TestObjectCountOutputTypeCountJoin2Args
  }

  // Custom InputTypes
  /**
   * TestObjectCountOutputType without action
   */
  export type TestObjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestObjectCountOutputType
     */
    select?: TestObjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TestObjectCountOutputType without action
   */
  export type TestObjectCountOutputTypeCountWrappedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WrappedObjectWhereInput
  }

  /**
   * TestObjectCountOutputType without action
   */
  export type TestObjectCountOutputTypeCountJoin1Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JoinTestObjectWhereInput
  }

  /**
   * TestObjectCountOutputType without action
   */
  export type TestObjectCountOutputTypeCountJoin2Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JoinTestObject2WhereInput
  }


  /**
   * Count Type JoinedObject1CountOutputType
   */

  export type JoinedObject1CountOutputType = {
    testObjects: number
  }

  export type JoinedObject1CountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    testObjects?: boolean | JoinedObject1CountOutputTypeCountTestObjectsArgs
  }

  // Custom InputTypes
  /**
   * JoinedObject1CountOutputType without action
   */
  export type JoinedObject1CountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinedObject1CountOutputType
     */
    select?: JoinedObject1CountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * JoinedObject1CountOutputType without action
   */
  export type JoinedObject1CountOutputTypeCountTestObjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JoinTestObjectWhereInput
  }


  /**
   * Count Type JoinedObject2CountOutputType
   */

  export type JoinedObject2CountOutputType = {
    testObjects: number
  }

  export type JoinedObject2CountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    testObjects?: boolean | JoinedObject2CountOutputTypeCountTestObjectsArgs
  }

  // Custom InputTypes
  /**
   * JoinedObject2CountOutputType without action
   */
  export type JoinedObject2CountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinedObject2CountOutputType
     */
    select?: JoinedObject2CountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * JoinedObject2CountOutputType without action
   */
  export type JoinedObject2CountOutputTypeCountTestObjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JoinTestObject2WhereInput
  }


  /**
   * Count Type SelfReferencialJoinModelCountOutputType
   */

  export type SelfReferencialJoinModelCountOutputType = {
    joinsAsSource: number
    joinsAsTarget: number
  }

  export type SelfReferencialJoinModelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    joinsAsSource?: boolean | SelfReferencialJoinModelCountOutputTypeCountJoinsAsSourceArgs
    joinsAsTarget?: boolean | SelfReferencialJoinModelCountOutputTypeCountJoinsAsTargetArgs
  }

  // Custom InputTypes
  /**
   * SelfReferencialJoinModelCountOutputType without action
   */
  export type SelfReferencialJoinModelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelfReferencialJoinModelCountOutputType
     */
    select?: SelfReferencialJoinModelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SelfReferencialJoinModelCountOutputType without action
   */
  export type SelfReferencialJoinModelCountOutputTypeCountJoinsAsSourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JoinSelfReferenceWhereInput
  }

  /**
   * SelfReferencialJoinModelCountOutputType without action
   */
  export type SelfReferencialJoinModelCountOutputTypeCountJoinsAsTargetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JoinSelfReferenceWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Tenet
   */

  export type AggregateTenet = {
    _count: TenetCountAggregateOutputType | null
    _min: TenetMinAggregateOutputType | null
    _max: TenetMaxAggregateOutputType | null
  }

  export type TenetMinAggregateOutputType = {
    id: Uint8Array | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenetMaxAggregateOutputType = {
    id: Uint8Array | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenetCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TenetMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenetMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenetCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TenetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenet to aggregate.
     */
    where?: TenetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenets to fetch.
     */
    orderBy?: TenetOrderByWithRelationInput | TenetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tenets
    **/
    _count?: true | TenetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenetMaxAggregateInputType
  }

  export type GetTenetAggregateType<T extends TenetAggregateArgs> = {
        [P in keyof T & keyof AggregateTenet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenet[P]>
      : GetScalarType<T[P], AggregateTenet[P]>
  }




  export type TenetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenetWhereInput
    orderBy?: TenetOrderByWithAggregationInput | TenetOrderByWithAggregationInput[]
    by: TenetScalarFieldEnum[] | TenetScalarFieldEnum
    having?: TenetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenetCountAggregateInputType | true
    _min?: TenetMinAggregateInputType
    _max?: TenetMaxAggregateInputType
  }

  export type TenetGroupByOutputType = {
    id: Uint8Array
    name: string
    createdAt: Date
    updatedAt: Date
    _count: TenetCountAggregateOutputType | null
    _min: TenetMinAggregateOutputType | null
    _max: TenetMaxAggregateOutputType | null
  }

  type GetTenetGroupByPayload<T extends TenetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenetGroupByOutputType[P]>
            : GetScalarType<T[P], TenetGroupByOutputType[P]>
        }
      >
    >


  export type TenetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Tenet$usersArgs<ExtArgs>
    logs?: boolean | Tenet$logsArgs<ExtArgs>
    contacts?: boolean | Tenet$contactsArgs<ExtArgs>
    activities?: boolean | Tenet$activitiesArgs<ExtArgs>
    addresses?: boolean | Tenet$addressesArgs<ExtArgs>
    contactEmails?: boolean | Tenet$contactEmailsArgs<ExtArgs>
    contactPhones?: boolean | Tenet$contactPhonesArgs<ExtArgs>
    importantDates?: boolean | Tenet$importantDatesArgs<ExtArgs>
    attachments?: boolean | Tenet$attachmentsArgs<ExtArgs>
    notes?: boolean | Tenet$notesArgs<ExtArgs>
    auditEvents?: boolean | Tenet$auditEventsArgs<ExtArgs>
    contactTimelineEvents?: boolean | Tenet$contactTimelineEventsArgs<ExtArgs>
    activitySteps?: boolean | Tenet$activityStepsArgs<ExtArgs>
    activityWaypoints?: boolean | Tenet$activityWaypointsArgs<ExtArgs>
    templateAssignments?: boolean | Tenet$templateAssignmentsArgs<ExtArgs>
    activityWaypointTemplates?: boolean | Tenet$activityWaypointTemplatesArgs<ExtArgs>
    activityTemplates?: boolean | Tenet$activityTemplatesArgs<ExtArgs>
    activityTemplateSteps?: boolean | Tenet$activityTemplateStepsArgs<ExtArgs>
    opportunities?: boolean | Tenet$opportunitiesArgs<ExtArgs>
    products?: boolean | Tenet$productsArgs<ExtArgs>
    activityTemplateStepAssignment?: boolean | Tenet$activityTemplateStepAssignmentArgs<ExtArgs>
    _count?: boolean | TenetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenet"]>

  export type TenetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tenet"]>

  export type TenetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tenet"]>

  export type TenetSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TenetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["tenet"]>
  export type TenetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Tenet$usersArgs<ExtArgs>
    logs?: boolean | Tenet$logsArgs<ExtArgs>
    contacts?: boolean | Tenet$contactsArgs<ExtArgs>
    activities?: boolean | Tenet$activitiesArgs<ExtArgs>
    addresses?: boolean | Tenet$addressesArgs<ExtArgs>
    contactEmails?: boolean | Tenet$contactEmailsArgs<ExtArgs>
    contactPhones?: boolean | Tenet$contactPhonesArgs<ExtArgs>
    importantDates?: boolean | Tenet$importantDatesArgs<ExtArgs>
    attachments?: boolean | Tenet$attachmentsArgs<ExtArgs>
    notes?: boolean | Tenet$notesArgs<ExtArgs>
    auditEvents?: boolean | Tenet$auditEventsArgs<ExtArgs>
    contactTimelineEvents?: boolean | Tenet$contactTimelineEventsArgs<ExtArgs>
    activitySteps?: boolean | Tenet$activityStepsArgs<ExtArgs>
    activityWaypoints?: boolean | Tenet$activityWaypointsArgs<ExtArgs>
    templateAssignments?: boolean | Tenet$templateAssignmentsArgs<ExtArgs>
    activityWaypointTemplates?: boolean | Tenet$activityWaypointTemplatesArgs<ExtArgs>
    activityTemplates?: boolean | Tenet$activityTemplatesArgs<ExtArgs>
    activityTemplateSteps?: boolean | Tenet$activityTemplateStepsArgs<ExtArgs>
    opportunities?: boolean | Tenet$opportunitiesArgs<ExtArgs>
    products?: boolean | Tenet$productsArgs<ExtArgs>
    activityTemplateStepAssignment?: boolean | Tenet$activityTemplateStepAssignmentArgs<ExtArgs>
    _count?: boolean | TenetCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TenetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TenetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TenetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tenet"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      logs: Prisma.$LogPayload<ExtArgs>[]
      contacts: Prisma.$ContactPayload<ExtArgs>[]
      activities: Prisma.$ActivityPayload<ExtArgs>[]
      addresses: Prisma.$AddressPayload<ExtArgs>[]
      contactEmails: Prisma.$ContactEmailPayload<ExtArgs>[]
      contactPhones: Prisma.$ContactPhonePayload<ExtArgs>[]
      importantDates: Prisma.$ImportantDatePayload<ExtArgs>[]
      attachments: Prisma.$AttachmentPayload<ExtArgs>[]
      notes: Prisma.$NotePayload<ExtArgs>[]
      auditEvents: Prisma.$AuditEventPayload<ExtArgs>[]
      contactTimelineEvents: Prisma.$ContactTimelineEventPayload<ExtArgs>[]
      activitySteps: Prisma.$ActivityStepPayload<ExtArgs>[]
      activityWaypoints: Prisma.$ActivityWaypointPayload<ExtArgs>[]
      templateAssignments: Prisma.$TemplateAssignmentPayload<ExtArgs>[]
      activityWaypointTemplates: Prisma.$ActivityWaypointTemplatePayload<ExtArgs>[]
      activityTemplates: Prisma.$ActivityTemplatePayload<ExtArgs>[]
      activityTemplateSteps: Prisma.$ActivityTemplateStepPayload<ExtArgs>[]
      opportunities: Prisma.$OpportunityPayload<ExtArgs>[]
      products: Prisma.$ProductTypePayload<ExtArgs>[]
      activityTemplateStepAssignment: Prisma.$ActivityTemplateStepAssignmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: Uint8Array
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tenet"]>
    composites: {}
  }

  type TenetGetPayload<S extends boolean | null | undefined | TenetDefaultArgs> = $Result.GetResult<Prisma.$TenetPayload, S>

  type TenetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TenetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: TenetCountAggregateInputType | true
    }

  export interface TenetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tenet'], meta: { name: 'Tenet' } }
    /**
     * Find zero or one Tenet that matches the filter.
     * @param {TenetFindUniqueArgs} args - Arguments to find a Tenet
     * @example
     * // Get one Tenet
     * const tenet = await prisma.tenet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenetFindUniqueArgs>(args: SelectSubset<T, TenetFindUniqueArgs<ExtArgs>>): Prisma__TenetClient<$Result.GetResult<Prisma.$TenetPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Tenet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TenetFindUniqueOrThrowArgs} args - Arguments to find a Tenet
     * @example
     * // Get one Tenet
     * const tenet = await prisma.tenet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenetFindUniqueOrThrowArgs>(args: SelectSubset<T, TenetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenetClient<$Result.GetResult<Prisma.$TenetPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Tenet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenetFindFirstArgs} args - Arguments to find a Tenet
     * @example
     * // Get one Tenet
     * const tenet = await prisma.tenet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenetFindFirstArgs>(args?: SelectSubset<T, TenetFindFirstArgs<ExtArgs>>): Prisma__TenetClient<$Result.GetResult<Prisma.$TenetPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Tenet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenetFindFirstOrThrowArgs} args - Arguments to find a Tenet
     * @example
     * // Get one Tenet
     * const tenet = await prisma.tenet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenetFindFirstOrThrowArgs>(args?: SelectSubset<T, TenetFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenetClient<$Result.GetResult<Prisma.$TenetPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Tenets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tenets
     * const tenets = await prisma.tenet.findMany()
     * 
     * // Get first 10 Tenets
     * const tenets = await prisma.tenet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenetWithIdOnly = await prisma.tenet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenetFindManyArgs>(args?: SelectSubset<T, TenetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenetPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Tenet.
     * @param {TenetCreateArgs} args - Arguments to create a Tenet.
     * @example
     * // Create one Tenet
     * const Tenet = await prisma.tenet.create({
     *   data: {
     *     // ... data to create a Tenet
     *   }
     * })
     * 
     */
    create<T extends TenetCreateArgs>(args: SelectSubset<T, TenetCreateArgs<ExtArgs>>): Prisma__TenetClient<$Result.GetResult<Prisma.$TenetPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Tenets.
     * @param {TenetCreateManyArgs} args - Arguments to create many Tenets.
     * @example
     * // Create many Tenets
     * const tenet = await prisma.tenet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenetCreateManyArgs>(args?: SelectSubset<T, TenetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tenets and returns the data saved in the database.
     * @param {TenetCreateManyAndReturnArgs} args - Arguments to create many Tenets.
     * @example
     * // Create many Tenets
     * const tenet = await prisma.tenet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tenets and only return the `id`
     * const tenetWithIdOnly = await prisma.tenet.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenetCreateManyAndReturnArgs>(args?: SelectSubset<T, TenetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenetPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Tenet.
     * @param {TenetDeleteArgs} args - Arguments to delete one Tenet.
     * @example
     * // Delete one Tenet
     * const Tenet = await prisma.tenet.delete({
     *   where: {
     *     // ... filter to delete one Tenet
     *   }
     * })
     * 
     */
    delete<T extends TenetDeleteArgs>(args: SelectSubset<T, TenetDeleteArgs<ExtArgs>>): Prisma__TenetClient<$Result.GetResult<Prisma.$TenetPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Tenet.
     * @param {TenetUpdateArgs} args - Arguments to update one Tenet.
     * @example
     * // Update one Tenet
     * const tenet = await prisma.tenet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenetUpdateArgs>(args: SelectSubset<T, TenetUpdateArgs<ExtArgs>>): Prisma__TenetClient<$Result.GetResult<Prisma.$TenetPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Tenets.
     * @param {TenetDeleteManyArgs} args - Arguments to filter Tenets to delete.
     * @example
     * // Delete a few Tenets
     * const { count } = await prisma.tenet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenetDeleteManyArgs>(args?: SelectSubset<T, TenetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tenets
     * const tenet = await prisma.tenet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenetUpdateManyArgs>(args: SelectSubset<T, TenetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenets and returns the data updated in the database.
     * @param {TenetUpdateManyAndReturnArgs} args - Arguments to update many Tenets.
     * @example
     * // Update many Tenets
     * const tenet = await prisma.tenet.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tenets and only return the `id`
     * const tenetWithIdOnly = await prisma.tenet.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TenetUpdateManyAndReturnArgs>(args: SelectSubset<T, TenetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenetPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Tenet.
     * @param {TenetUpsertArgs} args - Arguments to update or create a Tenet.
     * @example
     * // Update or create a Tenet
     * const tenet = await prisma.tenet.upsert({
     *   create: {
     *     // ... data to create a Tenet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tenet we want to update
     *   }
     * })
     */
    upsert<T extends TenetUpsertArgs>(args: SelectSubset<T, TenetUpsertArgs<ExtArgs>>): Prisma__TenetClient<$Result.GetResult<Prisma.$TenetPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Tenets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenetCountArgs} args - Arguments to filter Tenets to count.
     * @example
     * // Count the number of Tenets
     * const count = await prisma.tenet.count({
     *   where: {
     *     // ... the filter for the Tenets we want to count
     *   }
     * })
    **/
    count<T extends TenetCountArgs>(
      args?: Subset<T, TenetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tenet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenetAggregateArgs>(args: Subset<T, TenetAggregateArgs>): Prisma.PrismaPromise<GetTenetAggregateType<T>>

    /**
     * Group by Tenet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenetGroupByArgs['orderBy'] }
        : { orderBy?: TenetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tenet model
   */
  readonly fields: TenetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tenet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Tenet$usersArgs<ExtArgs> = {}>(args?: Subset<T, Tenet$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    logs<T extends Tenet$logsArgs<ExtArgs> = {}>(args?: Subset<T, Tenet$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    contacts<T extends Tenet$contactsArgs<ExtArgs> = {}>(args?: Subset<T, Tenet$contactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    activities<T extends Tenet$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, Tenet$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    addresses<T extends Tenet$addressesArgs<ExtArgs> = {}>(args?: Subset<T, Tenet$addressesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    contactEmails<T extends Tenet$contactEmailsArgs<ExtArgs> = {}>(args?: Subset<T, Tenet$contactEmailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactEmailPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    contactPhones<T extends Tenet$contactPhonesArgs<ExtArgs> = {}>(args?: Subset<T, Tenet$contactPhonesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPhonePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    importantDates<T extends Tenet$importantDatesArgs<ExtArgs> = {}>(args?: Subset<T, Tenet$importantDatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImportantDatePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    attachments<T extends Tenet$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Tenet$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    notes<T extends Tenet$notesArgs<ExtArgs> = {}>(args?: Subset<T, Tenet$notesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    auditEvents<T extends Tenet$auditEventsArgs<ExtArgs> = {}>(args?: Subset<T, Tenet$auditEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    contactTimelineEvents<T extends Tenet$contactTimelineEventsArgs<ExtArgs> = {}>(args?: Subset<T, Tenet$contactTimelineEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactTimelineEventPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    activitySteps<T extends Tenet$activityStepsArgs<ExtArgs> = {}>(args?: Subset<T, Tenet$activityStepsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityStepPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    activityWaypoints<T extends Tenet$activityWaypointsArgs<ExtArgs> = {}>(args?: Subset<T, Tenet$activityWaypointsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityWaypointPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    templateAssignments<T extends Tenet$templateAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Tenet$templateAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplateAssignmentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    activityWaypointTemplates<T extends Tenet$activityWaypointTemplatesArgs<ExtArgs> = {}>(args?: Subset<T, Tenet$activityWaypointTemplatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityWaypointTemplatePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    activityTemplates<T extends Tenet$activityTemplatesArgs<ExtArgs> = {}>(args?: Subset<T, Tenet$activityTemplatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityTemplatePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    activityTemplateSteps<T extends Tenet$activityTemplateStepsArgs<ExtArgs> = {}>(args?: Subset<T, Tenet$activityTemplateStepsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityTemplateStepPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    opportunities<T extends Tenet$opportunitiesArgs<ExtArgs> = {}>(args?: Subset<T, Tenet$opportunitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    products<T extends Tenet$productsArgs<ExtArgs> = {}>(args?: Subset<T, Tenet$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductTypePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    activityTemplateStepAssignment<T extends Tenet$activityTemplateStepAssignmentArgs<ExtArgs> = {}>(args?: Subset<T, Tenet$activityTemplateStepAssignmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityTemplateStepAssignmentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tenet model
   */ 
  interface TenetFieldRefs {
    readonly id: FieldRef<"Tenet", 'Bytes'>
    readonly name: FieldRef<"Tenet", 'String'>
    readonly createdAt: FieldRef<"Tenet", 'DateTime'>
    readonly updatedAt: FieldRef<"Tenet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tenet findUnique
   */
  export type TenetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenet
     */
    select?: TenetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenet
     */
    omit?: TenetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenetInclude<ExtArgs> | null
    /**
     * Filter, which Tenet to fetch.
     */
    where: TenetWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Tenet findUniqueOrThrow
   */
  export type TenetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenet
     */
    select?: TenetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenet
     */
    omit?: TenetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenetInclude<ExtArgs> | null
    /**
     * Filter, which Tenet to fetch.
     */
    where: TenetWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Tenet findFirst
   */
  export type TenetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenet
     */
    select?: TenetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenet
     */
    omit?: TenetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenetInclude<ExtArgs> | null
    /**
     * Filter, which Tenet to fetch.
     */
    where?: TenetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenets to fetch.
     */
    orderBy?: TenetOrderByWithRelationInput | TenetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenets.
     */
    cursor?: TenetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenets.
     */
    distinct?: TenetScalarFieldEnum | TenetScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Tenet findFirstOrThrow
   */
  export type TenetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenet
     */
    select?: TenetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenet
     */
    omit?: TenetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenetInclude<ExtArgs> | null
    /**
     * Filter, which Tenet to fetch.
     */
    where?: TenetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenets to fetch.
     */
    orderBy?: TenetOrderByWithRelationInput | TenetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenets.
     */
    cursor?: TenetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenets.
     */
    distinct?: TenetScalarFieldEnum | TenetScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Tenet findMany
   */
  export type TenetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenet
     */
    select?: TenetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenet
     */
    omit?: TenetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenetInclude<ExtArgs> | null
    /**
     * Filter, which Tenets to fetch.
     */
    where?: TenetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenets to fetch.
     */
    orderBy?: TenetOrderByWithRelationInput | TenetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tenets.
     */
    cursor?: TenetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenets.
     */
    skip?: number
    distinct?: TenetScalarFieldEnum | TenetScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Tenet create
   */
  export type TenetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenet
     */
    select?: TenetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenet
     */
    omit?: TenetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenetInclude<ExtArgs> | null
    /**
     * The data needed to create a Tenet.
     */
    data: XOR<TenetCreateInput, TenetUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Tenet createMany
   */
  export type TenetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tenets.
     */
    data: TenetCreateManyInput | TenetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenet createManyAndReturn
   */
  export type TenetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenet
     */
    select?: TenetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tenet
     */
    omit?: TenetOmit<ExtArgs> | null
    /**
     * The data used to create many Tenets.
     */
    data: TenetCreateManyInput | TenetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenet update
   */
  export type TenetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenet
     */
    select?: TenetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenet
     */
    omit?: TenetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenetInclude<ExtArgs> | null
    /**
     * The data needed to update a Tenet.
     */
    data: XOR<TenetUpdateInput, TenetUncheckedUpdateInput>
    /**
     * Choose, which Tenet to update.
     */
    where: TenetWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Tenet updateMany
   */
  export type TenetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tenets.
     */
    data: XOR<TenetUpdateManyMutationInput, TenetUncheckedUpdateManyInput>
    /**
     * Filter which Tenets to update
     */
    where?: TenetWhereInput
    /**
     * Limit how many Tenets to update.
     */
    limit?: number
  }

  /**
   * Tenet updateManyAndReturn
   */
  export type TenetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenet
     */
    select?: TenetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tenet
     */
    omit?: TenetOmit<ExtArgs> | null
    /**
     * The data used to update Tenets.
     */
    data: XOR<TenetUpdateManyMutationInput, TenetUncheckedUpdateManyInput>
    /**
     * Filter which Tenets to update
     */
    where?: TenetWhereInput
    /**
     * Limit how many Tenets to update.
     */
    limit?: number
  }

  /**
   * Tenet upsert
   */
  export type TenetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenet
     */
    select?: TenetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenet
     */
    omit?: TenetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenetInclude<ExtArgs> | null
    /**
     * The filter to search for the Tenet to update in case it exists.
     */
    where: TenetWhereUniqueInput
    /**
     * In case the Tenet found by the `where` argument doesn't exist, create a new Tenet with this data.
     */
    create: XOR<TenetCreateInput, TenetUncheckedCreateInput>
    /**
     * In case the Tenet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenetUpdateInput, TenetUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Tenet delete
   */
  export type TenetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenet
     */
    select?: TenetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenet
     */
    omit?: TenetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenetInclude<ExtArgs> | null
    /**
     * Filter which Tenet to delete.
     */
    where: TenetWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Tenet deleteMany
   */
  export type TenetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenets to delete
     */
    where?: TenetWhereInput
    /**
     * Limit how many Tenets to delete.
     */
    limit?: number
  }

  /**
   * Tenet.users
   */
  export type Tenet$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Tenet.logs
   */
  export type Tenet$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    where?: LogWhereInput
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    cursor?: LogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * Tenet.contacts
   */
  export type Tenet$contactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    cursor?: ContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Tenet.activities
   */
  export type Tenet$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    cursor?: ActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Tenet.addresses
   */
  export type Tenet$addressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    where?: AddressWhereInput
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    cursor?: AddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Tenet.contactEmails
   */
  export type Tenet$contactEmailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactEmail
     */
    select?: ContactEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactEmail
     */
    omit?: ContactEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactEmailInclude<ExtArgs> | null
    where?: ContactEmailWhereInput
    orderBy?: ContactEmailOrderByWithRelationInput | ContactEmailOrderByWithRelationInput[]
    cursor?: ContactEmailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactEmailScalarFieldEnum | ContactEmailScalarFieldEnum[]
  }

  /**
   * Tenet.contactPhones
   */
  export type Tenet$contactPhonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactPhone
     */
    select?: ContactPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactPhone
     */
    omit?: ContactPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactPhoneInclude<ExtArgs> | null
    where?: ContactPhoneWhereInput
    orderBy?: ContactPhoneOrderByWithRelationInput | ContactPhoneOrderByWithRelationInput[]
    cursor?: ContactPhoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactPhoneScalarFieldEnum | ContactPhoneScalarFieldEnum[]
  }

  /**
   * Tenet.importantDates
   */
  export type Tenet$importantDatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportantDate
     */
    select?: ImportantDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportantDate
     */
    omit?: ImportantDateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportantDateInclude<ExtArgs> | null
    where?: ImportantDateWhereInput
    orderBy?: ImportantDateOrderByWithRelationInput | ImportantDateOrderByWithRelationInput[]
    cursor?: ImportantDateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ImportantDateScalarFieldEnum | ImportantDateScalarFieldEnum[]
  }

  /**
   * Tenet.attachments
   */
  export type Tenet$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    where?: AttachmentWhereInput
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    cursor?: AttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Tenet.notes
   */
  export type Tenet$notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    where?: NoteWhereInput
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    cursor?: NoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * Tenet.auditEvents
   */
  export type Tenet$auditEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditEvent
     */
    omit?: AuditEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventInclude<ExtArgs> | null
    where?: AuditEventWhereInput
    orderBy?: AuditEventOrderByWithRelationInput | AuditEventOrderByWithRelationInput[]
    cursor?: AuditEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditEventScalarFieldEnum | AuditEventScalarFieldEnum[]
  }

  /**
   * Tenet.contactTimelineEvents
   */
  export type Tenet$contactTimelineEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTimelineEvent
     */
    select?: ContactTimelineEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTimelineEvent
     */
    omit?: ContactTimelineEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTimelineEventInclude<ExtArgs> | null
    where?: ContactTimelineEventWhereInput
    orderBy?: ContactTimelineEventOrderByWithRelationInput | ContactTimelineEventOrderByWithRelationInput[]
    cursor?: ContactTimelineEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactTimelineEventScalarFieldEnum | ContactTimelineEventScalarFieldEnum[]
  }

  /**
   * Tenet.activitySteps
   */
  export type Tenet$activityStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityStep
     */
    select?: ActivityStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityStep
     */
    omit?: ActivityStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityStepInclude<ExtArgs> | null
    where?: ActivityStepWhereInput
    orderBy?: ActivityStepOrderByWithRelationInput | ActivityStepOrderByWithRelationInput[]
    cursor?: ActivityStepWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityStepScalarFieldEnum | ActivityStepScalarFieldEnum[]
  }

  /**
   * Tenet.activityWaypoints
   */
  export type Tenet$activityWaypointsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityWaypoint
     */
    select?: ActivityWaypointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityWaypoint
     */
    omit?: ActivityWaypointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityWaypointInclude<ExtArgs> | null
    where?: ActivityWaypointWhereInput
    orderBy?: ActivityWaypointOrderByWithRelationInput | ActivityWaypointOrderByWithRelationInput[]
    cursor?: ActivityWaypointWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityWaypointScalarFieldEnum | ActivityWaypointScalarFieldEnum[]
  }

  /**
   * Tenet.templateAssignments
   */
  export type Tenet$templateAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateAssignment
     */
    select?: TemplateAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateAssignment
     */
    omit?: TemplateAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateAssignmentInclude<ExtArgs> | null
    where?: TemplateAssignmentWhereInput
    orderBy?: TemplateAssignmentOrderByWithRelationInput | TemplateAssignmentOrderByWithRelationInput[]
    cursor?: TemplateAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TemplateAssignmentScalarFieldEnum | TemplateAssignmentScalarFieldEnum[]
  }

  /**
   * Tenet.activityWaypointTemplates
   */
  export type Tenet$activityWaypointTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityWaypointTemplate
     */
    select?: ActivityWaypointTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityWaypointTemplate
     */
    omit?: ActivityWaypointTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityWaypointTemplateInclude<ExtArgs> | null
    where?: ActivityWaypointTemplateWhereInput
    orderBy?: ActivityWaypointTemplateOrderByWithRelationInput | ActivityWaypointTemplateOrderByWithRelationInput[]
    cursor?: ActivityWaypointTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityWaypointTemplateScalarFieldEnum | ActivityWaypointTemplateScalarFieldEnum[]
  }

  /**
   * Tenet.activityTemplates
   */
  export type Tenet$activityTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityTemplate
     */
    select?: ActivityTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityTemplate
     */
    omit?: ActivityTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityTemplateInclude<ExtArgs> | null
    where?: ActivityTemplateWhereInput
    orderBy?: ActivityTemplateOrderByWithRelationInput | ActivityTemplateOrderByWithRelationInput[]
    cursor?: ActivityTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityTemplateScalarFieldEnum | ActivityTemplateScalarFieldEnum[]
  }

  /**
   * Tenet.activityTemplateSteps
   */
  export type Tenet$activityTemplateStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityTemplateStep
     */
    select?: ActivityTemplateStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityTemplateStep
     */
    omit?: ActivityTemplateStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityTemplateStepInclude<ExtArgs> | null
    where?: ActivityTemplateStepWhereInput
    orderBy?: ActivityTemplateStepOrderByWithRelationInput | ActivityTemplateStepOrderByWithRelationInput[]
    cursor?: ActivityTemplateStepWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityTemplateStepScalarFieldEnum | ActivityTemplateStepScalarFieldEnum[]
  }

  /**
   * Tenet.opportunities
   */
  export type Tenet$opportunitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    where?: OpportunityWhereInput
    orderBy?: OpportunityOrderByWithRelationInput | OpportunityOrderByWithRelationInput[]
    cursor?: OpportunityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OpportunityScalarFieldEnum | OpportunityScalarFieldEnum[]
  }

  /**
   * Tenet.products
   */
  export type Tenet$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductType
     */
    select?: ProductTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductType
     */
    omit?: ProductTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTypeInclude<ExtArgs> | null
    where?: ProductTypeWhereInput
    orderBy?: ProductTypeOrderByWithRelationInput | ProductTypeOrderByWithRelationInput[]
    cursor?: ProductTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductTypeScalarFieldEnum | ProductTypeScalarFieldEnum[]
  }

  /**
   * Tenet.activityTemplateStepAssignment
   */
  export type Tenet$activityTemplateStepAssignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityTemplateStepAssignment
     */
    select?: ActivityTemplateStepAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityTemplateStepAssignment
     */
    omit?: ActivityTemplateStepAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityTemplateStepAssignmentInclude<ExtArgs> | null
    where?: ActivityTemplateStepAssignmentWhereInput
    orderBy?: ActivityTemplateStepAssignmentOrderByWithRelationInput | ActivityTemplateStepAssignmentOrderByWithRelationInput[]
    cursor?: ActivityTemplateStepAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityTemplateStepAssignmentScalarFieldEnum | ActivityTemplateStepAssignmentScalarFieldEnum[]
  }

  /**
   * Tenet without action
   */
  export type TenetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenet
     */
    select?: TenetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenet
     */
    omit?: TenetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenetInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: Uint8Array | null
    email: string | null
    firstName: string | null
    lastName: string | null
    fullName: string | null
    createdAt: Date | null
    updatedAt: Date | null
    password: string | null
    enabled: boolean | null
    type: $Enums.AccessGroup | null
    tenetId: Uint8Array | null
    system: boolean | null
    deleted: boolean | null
    deletedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: Uint8Array | null
    email: string | null
    firstName: string | null
    lastName: string | null
    fullName: string | null
    createdAt: Date | null
    updatedAt: Date | null
    password: string | null
    enabled: boolean | null
    type: $Enums.AccessGroup | null
    tenetId: Uint8Array | null
    system: boolean | null
    deleted: boolean | null
    deletedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    firstName: number
    lastName: number
    fullName: number
    createdAt: number
    updatedAt: number
    password: number
    enabled: number
    type: number
    tenetId: number
    system: number
    deleted: number
    deletedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    firstName?: true
    lastName?: true
    fullName?: true
    createdAt?: true
    updatedAt?: true
    password?: true
    enabled?: true
    type?: true
    tenetId?: true
    system?: true
    deleted?: true
    deletedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    firstName?: true
    lastName?: true
    fullName?: true
    createdAt?: true
    updatedAt?: true
    password?: true
    enabled?: true
    type?: true
    tenetId?: true
    system?: true
    deleted?: true
    deletedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    firstName?: true
    lastName?: true
    fullName?: true
    createdAt?: true
    updatedAt?: true
    password?: true
    enabled?: true
    type?: true
    tenetId?: true
    system?: true
    deleted?: true
    deletedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: Uint8Array
    email: string
    firstName: string
    lastName: string
    fullName: string
    createdAt: Date
    updatedAt: Date
    password: string
    enabled: boolean
    type: $Enums.AccessGroup
    tenetId: Uint8Array | null
    system: boolean
    deleted: boolean
    deletedAt: Date | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    fullName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    password?: boolean
    enabled?: boolean
    type?: boolean
    tenetId?: boolean
    system?: boolean
    deleted?: boolean
    deletedAt?: boolean
    tokens?: boolean | User$tokensArgs<ExtArgs>
    tenet?: boolean | User$tenetArgs<ExtArgs>
    activities?: boolean | User$activitiesArgs<ExtArgs>
    notes?: boolean | User$notesArgs<ExtArgs>
    waypoints?: boolean | User$waypointsArgs<ExtArgs>
    events?: boolean | User$eventsArgs<ExtArgs>
    auditEvents?: boolean | User$auditEventsArgs<ExtArgs>
    templateAssignments?: boolean | User$templateAssignmentsArgs<ExtArgs>
    assignedActivities?: boolean | User$assignedActivitiesArgs<ExtArgs>
    opportunities?: boolean | User$opportunitiesArgs<ExtArgs>
    activitySteps?: boolean | User$activityStepsArgs<ExtArgs>
    templateStepAssignments?: boolean | User$templateStepAssignmentsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    fullName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    password?: boolean
    enabled?: boolean
    type?: boolean
    tenetId?: boolean
    system?: boolean
    deleted?: boolean
    deletedAt?: boolean
    tenet?: boolean | User$tenetArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    fullName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    password?: boolean
    enabled?: boolean
    type?: boolean
    tenetId?: boolean
    system?: boolean
    deleted?: boolean
    deletedAt?: boolean
    tenet?: boolean | User$tenetArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    fullName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    password?: boolean
    enabled?: boolean
    type?: boolean
    tenetId?: boolean
    system?: boolean
    deleted?: boolean
    deletedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "firstName" | "lastName" | "fullName" | "createdAt" | "updatedAt" | "password" | "enabled" | "type" | "tenetId" | "system" | "deleted" | "deletedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tokens?: boolean | User$tokensArgs<ExtArgs>
    tenet?: boolean | User$tenetArgs<ExtArgs>
    activities?: boolean | User$activitiesArgs<ExtArgs>
    notes?: boolean | User$notesArgs<ExtArgs>
    waypoints?: boolean | User$waypointsArgs<ExtArgs>
    events?: boolean | User$eventsArgs<ExtArgs>
    auditEvents?: boolean | User$auditEventsArgs<ExtArgs>
    templateAssignments?: boolean | User$templateAssignmentsArgs<ExtArgs>
    assignedActivities?: boolean | User$assignedActivitiesArgs<ExtArgs>
    opportunities?: boolean | User$opportunitiesArgs<ExtArgs>
    activitySteps?: boolean | User$activityStepsArgs<ExtArgs>
    templateStepAssignments?: boolean | User$templateStepAssignmentsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenet?: boolean | User$tenetArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenet?: boolean | User$tenetArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      tokens: Prisma.$TokenPayload<ExtArgs>[]
      tenet: Prisma.$TenetPayload<ExtArgs> | null
      /**
       * @jointable(Activity, activityRelation)
       * @ai-field
       */
      activities: Prisma.$ActivityUserJoinPayload<ExtArgs>[]
      /**
       * @ai-field(notes this user authored)
       */
      notes: Prisma.$NotePayload<ExtArgs>[]
      /**
       * @jointable(ActivityWaypoint, waypointRelation)
       * @ai-field(Waypoints assigned to this user)
       */
      waypoints: Prisma.$UserWaypointJoinPayload<ExtArgs>[]
      /**
       * @ai-field(Events that this user triggered)
       */
      events: Prisma.$ContactTimelineEventPayload<ExtArgs>[]
      auditEvents: Prisma.$AuditEventPayload<ExtArgs>[]
      templateAssignments: Prisma.$TemplateAssignmentPayload<ExtArgs>[]
      assignedActivities: Prisma.$ActivityPayload<ExtArgs>[]
      /**
       * @jointable(Opportunity, opportunityRelation)
       * @ai-field(Opportunities this user is involved in)
       */
      opportunities: Prisma.$UserOpportunityJoinPayload<ExtArgs>[]
      /**
       * @jointable(ActivityStep, stepRelation)
       */
      activitySteps: Prisma.$ActivityStepUserJoinPayload<ExtArgs>[]
      templateStepAssignments: Prisma.$ActivityTemplateStepAssignmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      /**
       * @@ai-enabled
       */
      id: Uint8Array
      /**
       * @ai-field
       */
      email: string
      /**
       * @ai-field
       */
      firstName: string
      /**
       * @ai-field
       */
      lastName: string
      /**
       * @computed('fullName')
       * @ai-field
       */
      fullName: string
      createdAt: Date
      updatedAt: Date
      password: string
      enabled: boolean
      type: $Enums.AccessGroup
      tenetId: Uint8Array | null
      system: boolean
      /**
       * @@soft-delete
       */
      deleted: boolean
      deletedAt: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tokens<T extends User$tokensArgs<ExtArgs> = {}>(args?: Subset<T, User$tokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    tenet<T extends User$tenetArgs<ExtArgs> = {}>(args?: Subset<T, User$tenetArgs<ExtArgs>>): Prisma__TenetClient<$Result.GetResult<Prisma.$TenetPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    activities<T extends User$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, User$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityUserJoinPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    notes<T extends User$notesArgs<ExtArgs> = {}>(args?: Subset<T, User$notesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    waypoints<T extends User$waypointsArgs<ExtArgs> = {}>(args?: Subset<T, User$waypointsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserWaypointJoinPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    events<T extends User$eventsArgs<ExtArgs> = {}>(args?: Subset<T, User$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactTimelineEventPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    auditEvents<T extends User$auditEventsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    templateAssignments<T extends User$templateAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$templateAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplateAssignmentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    assignedActivities<T extends User$assignedActivitiesArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedActivitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    opportunities<T extends User$opportunitiesArgs<ExtArgs> = {}>(args?: Subset<T, User$opportunitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserOpportunityJoinPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    activitySteps<T extends User$activityStepsArgs<ExtArgs> = {}>(args?: Subset<T, User$activityStepsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityStepUserJoinPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    templateStepAssignments<T extends User$templateStepAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$templateStepAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityTemplateStepAssignmentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Bytes'>
    readonly email: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly fullName: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly password: FieldRef<"User", 'String'>
    readonly enabled: FieldRef<"User", 'Boolean'>
    readonly type: FieldRef<"User", 'AccessGroup'>
    readonly tenetId: FieldRef<"User", 'Bytes'>
    readonly system: FieldRef<"User", 'Boolean'>
    readonly deleted: FieldRef<"User", 'Boolean'>
    readonly deletedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.tokens
   */
  export type User$tokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    where?: TokenWhereInput
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    cursor?: TokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TokenScalarFieldEnum | TokenScalarFieldEnum[]
  }

  /**
   * User.tenet
   */
  export type User$tenetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenet
     */
    select?: TenetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenet
     */
    omit?: TenetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenetInclude<ExtArgs> | null
    where?: TenetWhereInput
  }

  /**
   * User.activities
   */
  export type User$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityUserJoin
     */
    select?: ActivityUserJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityUserJoin
     */
    omit?: ActivityUserJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityUserJoinInclude<ExtArgs> | null
    where?: ActivityUserJoinWhereInput
    orderBy?: ActivityUserJoinOrderByWithRelationInput | ActivityUserJoinOrderByWithRelationInput[]
    cursor?: ActivityUserJoinWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityUserJoinScalarFieldEnum | ActivityUserJoinScalarFieldEnum[]
  }

  /**
   * User.notes
   */
  export type User$notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    where?: NoteWhereInput
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    cursor?: NoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * User.waypoints
   */
  export type User$waypointsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWaypointJoin
     */
    select?: UserWaypointJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserWaypointJoin
     */
    omit?: UserWaypointJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWaypointJoinInclude<ExtArgs> | null
    where?: UserWaypointJoinWhereInput
    orderBy?: UserWaypointJoinOrderByWithRelationInput | UserWaypointJoinOrderByWithRelationInput[]
    cursor?: UserWaypointJoinWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserWaypointJoinScalarFieldEnum | UserWaypointJoinScalarFieldEnum[]
  }

  /**
   * User.events
   */
  export type User$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTimelineEvent
     */
    select?: ContactTimelineEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTimelineEvent
     */
    omit?: ContactTimelineEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTimelineEventInclude<ExtArgs> | null
    where?: ContactTimelineEventWhereInput
    orderBy?: ContactTimelineEventOrderByWithRelationInput | ContactTimelineEventOrderByWithRelationInput[]
    cursor?: ContactTimelineEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactTimelineEventScalarFieldEnum | ContactTimelineEventScalarFieldEnum[]
  }

  /**
   * User.auditEvents
   */
  export type User$auditEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditEvent
     */
    omit?: AuditEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventInclude<ExtArgs> | null
    where?: AuditEventWhereInput
    orderBy?: AuditEventOrderByWithRelationInput | AuditEventOrderByWithRelationInput[]
    cursor?: AuditEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditEventScalarFieldEnum | AuditEventScalarFieldEnum[]
  }

  /**
   * User.templateAssignments
   */
  export type User$templateAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateAssignment
     */
    select?: TemplateAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateAssignment
     */
    omit?: TemplateAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateAssignmentInclude<ExtArgs> | null
    where?: TemplateAssignmentWhereInput
    orderBy?: TemplateAssignmentOrderByWithRelationInput | TemplateAssignmentOrderByWithRelationInput[]
    cursor?: TemplateAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TemplateAssignmentScalarFieldEnum | TemplateAssignmentScalarFieldEnum[]
  }

  /**
   * User.assignedActivities
   */
  export type User$assignedActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    cursor?: ActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * User.opportunities
   */
  export type User$opportunitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOpportunityJoin
     */
    select?: UserOpportunityJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserOpportunityJoin
     */
    omit?: UserOpportunityJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOpportunityJoinInclude<ExtArgs> | null
    where?: UserOpportunityJoinWhereInput
    orderBy?: UserOpportunityJoinOrderByWithRelationInput | UserOpportunityJoinOrderByWithRelationInput[]
    cursor?: UserOpportunityJoinWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserOpportunityJoinScalarFieldEnum | UserOpportunityJoinScalarFieldEnum[]
  }

  /**
   * User.activitySteps
   */
  export type User$activityStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityStepUserJoin
     */
    select?: ActivityStepUserJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityStepUserJoin
     */
    omit?: ActivityStepUserJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityStepUserJoinInclude<ExtArgs> | null
    where?: ActivityStepUserJoinWhereInput
    orderBy?: ActivityStepUserJoinOrderByWithRelationInput | ActivityStepUserJoinOrderByWithRelationInput[]
    cursor?: ActivityStepUserJoinWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityStepUserJoinScalarFieldEnum | ActivityStepUserJoinScalarFieldEnum[]
  }

  /**
   * User.templateStepAssignments
   */
  export type User$templateStepAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityTemplateStepAssignment
     */
    select?: ActivityTemplateStepAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityTemplateStepAssignment
     */
    omit?: ActivityTemplateStepAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityTemplateStepAssignmentInclude<ExtArgs> | null
    where?: ActivityTemplateStepAssignmentWhereInput
    orderBy?: ActivityTemplateStepAssignmentOrderByWithRelationInput | ActivityTemplateStepAssignmentOrderByWithRelationInput[]
    cursor?: ActivityTemplateStepAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityTemplateStepAssignmentScalarFieldEnum | ActivityTemplateStepAssignmentScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Contact
   */

  export type AggregateContact = {
    _count: ContactCountAggregateOutputType | null
    _avg: ContactAvgAggregateOutputType | null
    _sum: ContactSumAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  export type ContactAvgAggregateOutputType = {
    size: number | null
  }

  export type ContactSumAggregateOutputType = {
    size: number | null
  }

  export type ContactMinAggregateOutputType = {
    id: Uint8Array | null
    firstName: string | null
    lastName: string | null
    fullName: string | null
    tenetId: Uint8Array | null
    importantNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    type: $Enums.ContactType | null
    status: $Enums.ContactStatus | null
    lifecycleStage: $Enums.LifecycleStage | null
    lastContactedDate: Date | null
    followUpDate: Date | null
    householdId: Uint8Array | null
    householdStatus: $Enums.HouseholdRelationshipStatus | null
    companyId: Uint8Array | null
    position: string | null
    companyStatus: $Enums.CompanyRelationshipStatus | null
    headOfHouseholdId: Uint8Array | null
    industry: string | null
    website: string | null
    size: number | null
    primaryContactId: Uint8Array | null
    deleted: boolean | null
    deletedAt: Date | null
  }

  export type ContactMaxAggregateOutputType = {
    id: Uint8Array | null
    firstName: string | null
    lastName: string | null
    fullName: string | null
    tenetId: Uint8Array | null
    importantNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    type: $Enums.ContactType | null
    status: $Enums.ContactStatus | null
    lifecycleStage: $Enums.LifecycleStage | null
    lastContactedDate: Date | null
    followUpDate: Date | null
    householdId: Uint8Array | null
    householdStatus: $Enums.HouseholdRelationshipStatus | null
    companyId: Uint8Array | null
    position: string | null
    companyStatus: $Enums.CompanyRelationshipStatus | null
    headOfHouseholdId: Uint8Array | null
    industry: string | null
    website: string | null
    size: number | null
    primaryContactId: Uint8Array | null
    deleted: boolean | null
    deletedAt: Date | null
  }

  export type ContactCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    fullName: number
    tenetId: number
    importantNotes: number
    createdAt: number
    updatedAt: number
    type: number
    status: number
    lifecycleStage: number
    lastContactedDate: number
    followUpDate: number
    householdId: number
    householdStatus: number
    companyId: number
    position: number
    companyStatus: number
    headOfHouseholdId: number
    industry: number
    website: number
    size: number
    primaryContactId: number
    deleted: number
    deletedAt: number
    _all: number
  }


  export type ContactAvgAggregateInputType = {
    size?: true
  }

  export type ContactSumAggregateInputType = {
    size?: true
  }

  export type ContactMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    fullName?: true
    tenetId?: true
    importantNotes?: true
    createdAt?: true
    updatedAt?: true
    type?: true
    status?: true
    lifecycleStage?: true
    lastContactedDate?: true
    followUpDate?: true
    householdId?: true
    householdStatus?: true
    companyId?: true
    position?: true
    companyStatus?: true
    headOfHouseholdId?: true
    industry?: true
    website?: true
    size?: true
    primaryContactId?: true
    deleted?: true
    deletedAt?: true
  }

  export type ContactMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    fullName?: true
    tenetId?: true
    importantNotes?: true
    createdAt?: true
    updatedAt?: true
    type?: true
    status?: true
    lifecycleStage?: true
    lastContactedDate?: true
    followUpDate?: true
    householdId?: true
    householdStatus?: true
    companyId?: true
    position?: true
    companyStatus?: true
    headOfHouseholdId?: true
    industry?: true
    website?: true
    size?: true
    primaryContactId?: true
    deleted?: true
    deletedAt?: true
  }

  export type ContactCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    fullName?: true
    tenetId?: true
    importantNotes?: true
    createdAt?: true
    updatedAt?: true
    type?: true
    status?: true
    lifecycleStage?: true
    lastContactedDate?: true
    followUpDate?: true
    householdId?: true
    householdStatus?: true
    companyId?: true
    position?: true
    companyStatus?: true
    headOfHouseholdId?: true
    industry?: true
    website?: true
    size?: true
    primaryContactId?: true
    deleted?: true
    deletedAt?: true
    _all?: true
  }

  export type ContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contact to aggregate.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contacts
    **/
    _count?: true | ContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContactAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContactSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactMaxAggregateInputType
  }

  export type GetContactAggregateType<T extends ContactAggregateArgs> = {
        [P in keyof T & keyof AggregateContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContact[P]>
      : GetScalarType<T[P], AggregateContact[P]>
  }




  export type ContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithAggregationInput | ContactOrderByWithAggregationInput[]
    by: ContactScalarFieldEnum[] | ContactScalarFieldEnum
    having?: ContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactCountAggregateInputType | true
    _avg?: ContactAvgAggregateInputType
    _sum?: ContactSumAggregateInputType
    _min?: ContactMinAggregateInputType
    _max?: ContactMaxAggregateInputType
  }

  export type ContactGroupByOutputType = {
    id: Uint8Array
    firstName: string | null
    lastName: string
    fullName: string
    tenetId: Uint8Array
    importantNotes: string | null
    createdAt: Date
    updatedAt: Date
    type: $Enums.ContactType
    status: $Enums.ContactStatus
    lifecycleStage: $Enums.LifecycleStage | null
    lastContactedDate: Date | null
    followUpDate: Date | null
    householdId: Uint8Array | null
    householdStatus: $Enums.HouseholdRelationshipStatus | null
    companyId: Uint8Array | null
    position: string | null
    companyStatus: $Enums.CompanyRelationshipStatus | null
    headOfHouseholdId: Uint8Array | null
    industry: string | null
    website: string | null
    size: number | null
    primaryContactId: Uint8Array | null
    deleted: boolean
    deletedAt: Date | null
    _count: ContactCountAggregateOutputType | null
    _avg: ContactAvgAggregateOutputType | null
    _sum: ContactSumAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  type GetContactGroupByPayload<T extends ContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactGroupByOutputType[P]>
            : GetScalarType<T[P], ContactGroupByOutputType[P]>
        }
      >
    >


  export type ContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    fullName?: boolean
    tenetId?: boolean
    importantNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    type?: boolean
    status?: boolean
    lifecycleStage?: boolean
    lastContactedDate?: boolean
    followUpDate?: boolean
    householdId?: boolean
    householdStatus?: boolean
    companyId?: boolean
    position?: boolean
    companyStatus?: boolean
    headOfHouseholdId?: boolean
    industry?: boolean
    website?: boolean
    size?: boolean
    primaryContactId?: boolean
    deleted?: boolean
    deletedAt?: boolean
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
    notes?: boolean | Contact$notesArgs<ExtArgs>
    timelineEvents?: boolean | Contact$timelineEventsArgs<ExtArgs>
    addresses?: boolean | Contact$addressesArgs<ExtArgs>
    emails?: boolean | Contact$emailsArgs<ExtArgs>
    phones?: boolean | Contact$phonesArgs<ExtArgs>
    importantDates?: boolean | Contact$importantDatesArgs<ExtArgs>
    activities?: boolean | Contact$activitiesArgs<ExtArgs>
    household?: boolean | Contact$householdArgs<ExtArgs>
    headOfHouseholdFor?: boolean | Contact$headOfHouseholdForArgs<ExtArgs>
    company?: boolean | Contact$companyArgs<ExtArgs>
    primaryContactFor?: boolean | Contact$primaryContactForArgs<ExtArgs>
    headOfHousehold?: boolean | Contact$headOfHouseholdArgs<ExtArgs>
    householdMembers?: boolean | Contact$householdMembersArgs<ExtArgs>
    employees?: boolean | Contact$employeesArgs<ExtArgs>
    primaryContact?: boolean | Contact$primaryContactArgs<ExtArgs>
    opportunities?: boolean | Contact$opportunitiesArgs<ExtArgs>
    relationAsSource?: boolean | Contact$relationAsSourceArgs<ExtArgs>
    relationAsTarget?: boolean | Contact$relationAsTargetArgs<ExtArgs>
    _count?: boolean | ContactCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    fullName?: boolean
    tenetId?: boolean
    importantNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    type?: boolean
    status?: boolean
    lifecycleStage?: boolean
    lastContactedDate?: boolean
    followUpDate?: boolean
    householdId?: boolean
    householdStatus?: boolean
    companyId?: boolean
    position?: boolean
    companyStatus?: boolean
    headOfHouseholdId?: boolean
    industry?: boolean
    website?: boolean
    size?: boolean
    primaryContactId?: boolean
    deleted?: boolean
    deletedAt?: boolean
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
    household?: boolean | Contact$householdArgs<ExtArgs>
    company?: boolean | Contact$companyArgs<ExtArgs>
    headOfHousehold?: boolean | Contact$headOfHouseholdArgs<ExtArgs>
    primaryContact?: boolean | Contact$primaryContactArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    fullName?: boolean
    tenetId?: boolean
    importantNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    type?: boolean
    status?: boolean
    lifecycleStage?: boolean
    lastContactedDate?: boolean
    followUpDate?: boolean
    householdId?: boolean
    householdStatus?: boolean
    companyId?: boolean
    position?: boolean
    companyStatus?: boolean
    headOfHouseholdId?: boolean
    industry?: boolean
    website?: boolean
    size?: boolean
    primaryContactId?: boolean
    deleted?: boolean
    deletedAt?: boolean
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
    household?: boolean | Contact$householdArgs<ExtArgs>
    company?: boolean | Contact$companyArgs<ExtArgs>
    headOfHousehold?: boolean | Contact$headOfHouseholdArgs<ExtArgs>
    primaryContact?: boolean | Contact$primaryContactArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    fullName?: boolean
    tenetId?: boolean
    importantNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    type?: boolean
    status?: boolean
    lifecycleStage?: boolean
    lastContactedDate?: boolean
    followUpDate?: boolean
    householdId?: boolean
    householdStatus?: boolean
    companyId?: boolean
    position?: boolean
    companyStatus?: boolean
    headOfHouseholdId?: boolean
    industry?: boolean
    website?: boolean
    size?: boolean
    primaryContactId?: boolean
    deleted?: boolean
    deletedAt?: boolean
  }

  export type ContactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "firstName" | "lastName" | "fullName" | "tenetId" | "importantNotes" | "createdAt" | "updatedAt" | "type" | "status" | "lifecycleStage" | "lastContactedDate" | "followUpDate" | "householdId" | "householdStatus" | "companyId" | "position" | "companyStatus" | "headOfHouseholdId" | "industry" | "website" | "size" | "primaryContactId" | "deleted" | "deletedAt", ExtArgs["result"]["contact"]>
  export type ContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
    notes?: boolean | Contact$notesArgs<ExtArgs>
    timelineEvents?: boolean | Contact$timelineEventsArgs<ExtArgs>
    addresses?: boolean | Contact$addressesArgs<ExtArgs>
    emails?: boolean | Contact$emailsArgs<ExtArgs>
    phones?: boolean | Contact$phonesArgs<ExtArgs>
    importantDates?: boolean | Contact$importantDatesArgs<ExtArgs>
    activities?: boolean | Contact$activitiesArgs<ExtArgs>
    household?: boolean | Contact$householdArgs<ExtArgs>
    headOfHouseholdFor?: boolean | Contact$headOfHouseholdForArgs<ExtArgs>
    company?: boolean | Contact$companyArgs<ExtArgs>
    primaryContactFor?: boolean | Contact$primaryContactForArgs<ExtArgs>
    headOfHousehold?: boolean | Contact$headOfHouseholdArgs<ExtArgs>
    householdMembers?: boolean | Contact$householdMembersArgs<ExtArgs>
    employees?: boolean | Contact$employeesArgs<ExtArgs>
    primaryContact?: boolean | Contact$primaryContactArgs<ExtArgs>
    opportunities?: boolean | Contact$opportunitiesArgs<ExtArgs>
    relationAsSource?: boolean | Contact$relationAsSourceArgs<ExtArgs>
    relationAsTarget?: boolean | Contact$relationAsTargetArgs<ExtArgs>
    _count?: boolean | ContactCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ContactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
    household?: boolean | Contact$householdArgs<ExtArgs>
    company?: boolean | Contact$companyArgs<ExtArgs>
    headOfHousehold?: boolean | Contact$headOfHouseholdArgs<ExtArgs>
    primaryContact?: boolean | Contact$primaryContactArgs<ExtArgs>
  }
  export type ContactIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
    household?: boolean | Contact$householdArgs<ExtArgs>
    company?: boolean | Contact$companyArgs<ExtArgs>
    headOfHousehold?: boolean | Contact$headOfHouseholdArgs<ExtArgs>
    primaryContact?: boolean | Contact$primaryContactArgs<ExtArgs>
  }

  export type $ContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contact"
    objects: {
      tenet: Prisma.$TenetPayload<ExtArgs>
      /**
       * @ai-field
       */
      notes: Prisma.$NotePayload<ExtArgs>[]
      /**
       * @ai-field(Events associated with this contact's activities, this is used for a timeline of interactions with the contact)
       * @jointable(ContactTimelineEvent, contactEventRelation)
       * @join(type, contactTimelineRelationshipType)
       */
      timelineEvents: Prisma.$ContactTimelineEventContactJoinPayload<ExtArgs>[]
      /**
       * @ai-field
       */
      addresses: Prisma.$AddressPayload<ExtArgs>[]
      /**
       * @ai-field
       */
      emails: Prisma.$ContactEmailPayload<ExtArgs>[]
      /**
       * @ai-field
       */
      phones: Prisma.$ContactPhonePayload<ExtArgs>[]
      /**
       * @ai-field
       */
      importantDates: Prisma.$ImportantDatePayload<ExtArgs>[]
      /**
       * @jointable(Activity, activityRelation)
       * @ai-field(Activities that the contact is involved in)
       */
      activities: Prisma.$ActivityContactJoinPayload<ExtArgs>[]
      /**
       * @ai-field
       */
      household: Prisma.$ContactPayload<ExtArgs> | null
      headOfHouseholdFor: Prisma.$ContactPayload<ExtArgs> | null
      /**
       * @ai-field
       */
      company: Prisma.$ContactPayload<ExtArgs> | null
      primaryContactFor: Prisma.$ContactPayload<ExtArgs> | null
      /**
       * @ai-field(For household-type contacts only, who is the head of the household)
       */
      headOfHousehold: Prisma.$ContactPayload<ExtArgs> | null
      /**
       * @ai-field
       */
      householdMembers: Prisma.$ContactPayload<ExtArgs>[]
      /**
       * @ai-field(This company's employees)
       */
      employees: Prisma.$ContactPayload<ExtArgs>[]
      /**
       * @ai-field(The primary contact for the company)
       */
      primaryContact: Prisma.$ContactPayload<ExtArgs> | null
      /**
       * @jointable(Opportunity, opportunityRelation)
       * @ai-field(Related opportunities)
       */
      opportunities: Prisma.$ContactOpportunityJoinPayload<ExtArgs>[]
      /**
       * @jointable(Contact, target)
       * @ai-field(Related contacts where this contact is considered the source of the relationship)
       * @join(type, contactRelationType)
       * @join(established, contactRelationEstablished)
       * @join(notes, contactRelationNotes)
       * @joinid(relationId)
       */
      relationAsSource: Prisma.$ContactRelationshipPayload<ExtArgs>[]
      /**
       * @jointable(Contact, source)
       * @ai-field(Related contacts where this contact is considered the target of the relationship)
       * @join(type, contactRelationType)
       * @join(established, contactRelationEstablished)
       * @join(notes, contactRelationNotes)
       * @joinid(relationId)
       */
      relationAsTarget: Prisma.$ContactRelationshipPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      /**
       * @@ai-enabled
       */
      id: Uint8Array
      /**
       * @ai-field
       */
      firstName: string | null
      /**
       * @ai-field
       */
      lastName: string
      /**
       * @wrapper-ignore
       */
      fullName: string
      tenetId: Uint8Array
      /**
       * @ai-field
       */
      importantNotes: string | null
      createdAt: Date
      updatedAt: Date
      /**
       * @graph
       * @ai-field(Contact type, either individual, household, or company)
       */
      type: $Enums.ContactType
      /**
       * @ai-field
       */
      status: $Enums.ContactStatus
      /**
       * @ai-field(Contact's investment lifecycle stage)
       */
      lifecycleStage: $Enums.LifecycleStage | null
      lastContactedDate: Date | null
      followUpDate: Date | null
      /**
       * @ai-field
       */
      householdId: Uint8Array | null
      /**
       * @ai-field
       */
      householdStatus: $Enums.HouseholdRelationshipStatus | null
      /**
       * @ai-field
       */
      companyId: Uint8Array | null
      /**
       * @ai-field
       */
      position: string | null
      /**
       * @ai-field
       */
      companyStatus: $Enums.CompanyRelationshipStatus | null
      /**
       * @ai-field
       */
      headOfHouseholdId: Uint8Array | null
      /**
       * @ai-field
       */
      industry: string | null
      /**
       * @ai-field(This company's website)
       */
      website: string | null
      /**
       * @ai-field(This company's size)
       */
      size: number | null
      /**
       * @ai-field
       */
      primaryContactId: Uint8Array | null
      /**
       * @@soft-delete
       */
      deleted: boolean
      deletedAt: Date | null
    }, ExtArgs["result"]["contact"]>
    composites: {}
  }

  type ContactGetPayload<S extends boolean | null | undefined | ContactDefaultArgs> = $Result.GetResult<Prisma.$ContactPayload, S>

  type ContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: ContactCountAggregateInputType | true
    }

  export interface ContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contact'], meta: { name: 'Contact' } }
    /**
     * Find zero or one Contact that matches the filter.
     * @param {ContactFindUniqueArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactFindUniqueArgs>(args: SelectSubset<T, ContactFindUniqueArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Contact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactFindUniqueOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Contact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactFindFirstArgs>(args?: SelectSubset<T, ContactFindFirstArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Contact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contacts
     * const contacts = await prisma.contact.findMany()
     * 
     * // Get first 10 Contacts
     * const contacts = await prisma.contact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactWithIdOnly = await prisma.contact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactFindManyArgs>(args?: SelectSubset<T, ContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Contact.
     * @param {ContactCreateArgs} args - Arguments to create a Contact.
     * @example
     * // Create one Contact
     * const Contact = await prisma.contact.create({
     *   data: {
     *     // ... data to create a Contact
     *   }
     * })
     * 
     */
    create<T extends ContactCreateArgs>(args: SelectSubset<T, ContactCreateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Contacts.
     * @param {ContactCreateManyArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactCreateManyArgs>(args?: SelectSubset<T, ContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contacts and returns the data saved in the database.
     * @param {ContactCreateManyAndReturnArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contacts and only return the `id`
     * const contactWithIdOnly = await prisma.contact.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Contact.
     * @param {ContactDeleteArgs} args - Arguments to delete one Contact.
     * @example
     * // Delete one Contact
     * const Contact = await prisma.contact.delete({
     *   where: {
     *     // ... filter to delete one Contact
     *   }
     * })
     * 
     */
    delete<T extends ContactDeleteArgs>(args: SelectSubset<T, ContactDeleteArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Contact.
     * @param {ContactUpdateArgs} args - Arguments to update one Contact.
     * @example
     * // Update one Contact
     * const contact = await prisma.contact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactUpdateArgs>(args: SelectSubset<T, ContactUpdateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Contacts.
     * @param {ContactDeleteManyArgs} args - Arguments to filter Contacts to delete.
     * @example
     * // Delete a few Contacts
     * const { count } = await prisma.contact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactDeleteManyArgs>(args?: SelectSubset<T, ContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactUpdateManyArgs>(args: SelectSubset<T, ContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts and returns the data updated in the database.
     * @param {ContactUpdateManyAndReturnArgs} args - Arguments to update many Contacts.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Contacts and only return the `id`
     * const contactWithIdOnly = await prisma.contact.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContactUpdateManyAndReturnArgs>(args: SelectSubset<T, ContactUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Contact.
     * @param {ContactUpsertArgs} args - Arguments to update or create a Contact.
     * @example
     * // Update or create a Contact
     * const contact = await prisma.contact.upsert({
     *   create: {
     *     // ... data to create a Contact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contact we want to update
     *   }
     * })
     */
    upsert<T extends ContactUpsertArgs>(args: SelectSubset<T, ContactUpsertArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactCountArgs} args - Arguments to filter Contacts to count.
     * @example
     * // Count the number of Contacts
     * const count = await prisma.contact.count({
     *   where: {
     *     // ... the filter for the Contacts we want to count
     *   }
     * })
    **/
    count<T extends ContactCountArgs>(
      args?: Subset<T, ContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactAggregateArgs>(args: Subset<T, ContactAggregateArgs>): Prisma.PrismaPromise<GetContactAggregateType<T>>

    /**
     * Group by Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactGroupByArgs['orderBy'] }
        : { orderBy?: ContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contact model
   */
  readonly fields: ContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenet<T extends TenetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenetDefaultArgs<ExtArgs>>): Prisma__TenetClient<$Result.GetResult<Prisma.$TenetPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    notes<T extends Contact$notesArgs<ExtArgs> = {}>(args?: Subset<T, Contact$notesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    timelineEvents<T extends Contact$timelineEventsArgs<ExtArgs> = {}>(args?: Subset<T, Contact$timelineEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactTimelineEventContactJoinPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    addresses<T extends Contact$addressesArgs<ExtArgs> = {}>(args?: Subset<T, Contact$addressesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    emails<T extends Contact$emailsArgs<ExtArgs> = {}>(args?: Subset<T, Contact$emailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactEmailPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    phones<T extends Contact$phonesArgs<ExtArgs> = {}>(args?: Subset<T, Contact$phonesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPhonePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    importantDates<T extends Contact$importantDatesArgs<ExtArgs> = {}>(args?: Subset<T, Contact$importantDatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImportantDatePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    activities<T extends Contact$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, Contact$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityContactJoinPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    household<T extends Contact$householdArgs<ExtArgs> = {}>(args?: Subset<T, Contact$householdArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    headOfHouseholdFor<T extends Contact$headOfHouseholdForArgs<ExtArgs> = {}>(args?: Subset<T, Contact$headOfHouseholdForArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    company<T extends Contact$companyArgs<ExtArgs> = {}>(args?: Subset<T, Contact$companyArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    primaryContactFor<T extends Contact$primaryContactForArgs<ExtArgs> = {}>(args?: Subset<T, Contact$primaryContactForArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    headOfHousehold<T extends Contact$headOfHouseholdArgs<ExtArgs> = {}>(args?: Subset<T, Contact$headOfHouseholdArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    householdMembers<T extends Contact$householdMembersArgs<ExtArgs> = {}>(args?: Subset<T, Contact$householdMembersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    employees<T extends Contact$employeesArgs<ExtArgs> = {}>(args?: Subset<T, Contact$employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    primaryContact<T extends Contact$primaryContactArgs<ExtArgs> = {}>(args?: Subset<T, Contact$primaryContactArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    opportunities<T extends Contact$opportunitiesArgs<ExtArgs> = {}>(args?: Subset<T, Contact$opportunitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactOpportunityJoinPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    relationAsSource<T extends Contact$relationAsSourceArgs<ExtArgs> = {}>(args?: Subset<T, Contact$relationAsSourceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactRelationshipPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    relationAsTarget<T extends Contact$relationAsTargetArgs<ExtArgs> = {}>(args?: Subset<T, Contact$relationAsTargetArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactRelationshipPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contact model
   */ 
  interface ContactFieldRefs {
    readonly id: FieldRef<"Contact", 'Bytes'>
    readonly firstName: FieldRef<"Contact", 'String'>
    readonly lastName: FieldRef<"Contact", 'String'>
    readonly fullName: FieldRef<"Contact", 'String'>
    readonly tenetId: FieldRef<"Contact", 'Bytes'>
    readonly importantNotes: FieldRef<"Contact", 'String'>
    readonly createdAt: FieldRef<"Contact", 'DateTime'>
    readonly updatedAt: FieldRef<"Contact", 'DateTime'>
    readonly type: FieldRef<"Contact", 'ContactType'>
    readonly status: FieldRef<"Contact", 'ContactStatus'>
    readonly lifecycleStage: FieldRef<"Contact", 'LifecycleStage'>
    readonly lastContactedDate: FieldRef<"Contact", 'DateTime'>
    readonly followUpDate: FieldRef<"Contact", 'DateTime'>
    readonly householdId: FieldRef<"Contact", 'Bytes'>
    readonly householdStatus: FieldRef<"Contact", 'HouseholdRelationshipStatus'>
    readonly companyId: FieldRef<"Contact", 'Bytes'>
    readonly position: FieldRef<"Contact", 'String'>
    readonly companyStatus: FieldRef<"Contact", 'CompanyRelationshipStatus'>
    readonly headOfHouseholdId: FieldRef<"Contact", 'Bytes'>
    readonly industry: FieldRef<"Contact", 'String'>
    readonly website: FieldRef<"Contact", 'String'>
    readonly size: FieldRef<"Contact", 'Int'>
    readonly primaryContactId: FieldRef<"Contact", 'Bytes'>
    readonly deleted: FieldRef<"Contact", 'Boolean'>
    readonly deletedAt: FieldRef<"Contact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Contact findUnique
   */
  export type ContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Contact findUniqueOrThrow
   */
  export type ContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Contact findFirst
   */
  export type ContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Contact findFirstOrThrow
   */
  export type ContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Contact findMany
   */
  export type ContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Contact create
   */
  export type ContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to create a Contact.
     */
    data: XOR<ContactCreateInput, ContactUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Contact createMany
   */
  export type ContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contact createManyAndReturn
   */
  export type ContactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contact update
   */
  export type ContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to update a Contact.
     */
    data: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
    /**
     * Choose, which Contact to update.
     */
    where: ContactWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Contact updateMany
   */
  export type ContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to update.
     */
    limit?: number
  }

  /**
   * Contact updateManyAndReturn
   */
  export type ContactUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contact upsert
   */
  export type ContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The filter to search for the Contact to update in case it exists.
     */
    where: ContactWhereUniqueInput
    /**
     * In case the Contact found by the `where` argument doesn't exist, create a new Contact with this data.
     */
    create: XOR<ContactCreateInput, ContactUncheckedCreateInput>
    /**
     * In case the Contact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Contact delete
   */
  export type ContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter which Contact to delete.
     */
    where: ContactWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Contact deleteMany
   */
  export type ContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contacts to delete
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to delete.
     */
    limit?: number
  }

  /**
   * Contact.notes
   */
  export type Contact$notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    where?: NoteWhereInput
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    cursor?: NoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * Contact.timelineEvents
   */
  export type Contact$timelineEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTimelineEventContactJoin
     */
    select?: ContactTimelineEventContactJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTimelineEventContactJoin
     */
    omit?: ContactTimelineEventContactJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTimelineEventContactJoinInclude<ExtArgs> | null
    where?: ContactTimelineEventContactJoinWhereInput
    orderBy?: ContactTimelineEventContactJoinOrderByWithRelationInput | ContactTimelineEventContactJoinOrderByWithRelationInput[]
    cursor?: ContactTimelineEventContactJoinWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactTimelineEventContactJoinScalarFieldEnum | ContactTimelineEventContactJoinScalarFieldEnum[]
  }

  /**
   * Contact.addresses
   */
  export type Contact$addressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    where?: AddressWhereInput
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    cursor?: AddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Contact.emails
   */
  export type Contact$emailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactEmail
     */
    select?: ContactEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactEmail
     */
    omit?: ContactEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactEmailInclude<ExtArgs> | null
    where?: ContactEmailWhereInput
    orderBy?: ContactEmailOrderByWithRelationInput | ContactEmailOrderByWithRelationInput[]
    cursor?: ContactEmailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactEmailScalarFieldEnum | ContactEmailScalarFieldEnum[]
  }

  /**
   * Contact.phones
   */
  export type Contact$phonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactPhone
     */
    select?: ContactPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactPhone
     */
    omit?: ContactPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactPhoneInclude<ExtArgs> | null
    where?: ContactPhoneWhereInput
    orderBy?: ContactPhoneOrderByWithRelationInput | ContactPhoneOrderByWithRelationInput[]
    cursor?: ContactPhoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactPhoneScalarFieldEnum | ContactPhoneScalarFieldEnum[]
  }

  /**
   * Contact.importantDates
   */
  export type Contact$importantDatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportantDate
     */
    select?: ImportantDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportantDate
     */
    omit?: ImportantDateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportantDateInclude<ExtArgs> | null
    where?: ImportantDateWhereInput
    orderBy?: ImportantDateOrderByWithRelationInput | ImportantDateOrderByWithRelationInput[]
    cursor?: ImportantDateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ImportantDateScalarFieldEnum | ImportantDateScalarFieldEnum[]
  }

  /**
   * Contact.activities
   */
  export type Contact$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityContactJoin
     */
    select?: ActivityContactJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityContactJoin
     */
    omit?: ActivityContactJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityContactJoinInclude<ExtArgs> | null
    where?: ActivityContactJoinWhereInput
    orderBy?: ActivityContactJoinOrderByWithRelationInput | ActivityContactJoinOrderByWithRelationInput[]
    cursor?: ActivityContactJoinWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityContactJoinScalarFieldEnum | ActivityContactJoinScalarFieldEnum[]
  }

  /**
   * Contact.household
   */
  export type Contact$householdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
  }

  /**
   * Contact.headOfHouseholdFor
   */
  export type Contact$headOfHouseholdForArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
  }

  /**
   * Contact.company
   */
  export type Contact$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
  }

  /**
   * Contact.primaryContactFor
   */
  export type Contact$primaryContactForArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
  }

  /**
   * Contact.headOfHousehold
   */
  export type Contact$headOfHouseholdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
  }

  /**
   * Contact.householdMembers
   */
  export type Contact$householdMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    cursor?: ContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact.employees
   */
  export type Contact$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    cursor?: ContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact.primaryContact
   */
  export type Contact$primaryContactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
  }

  /**
   * Contact.opportunities
   */
  export type Contact$opportunitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactOpportunityJoin
     */
    select?: ContactOpportunityJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactOpportunityJoin
     */
    omit?: ContactOpportunityJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactOpportunityJoinInclude<ExtArgs> | null
    where?: ContactOpportunityJoinWhereInput
    orderBy?: ContactOpportunityJoinOrderByWithRelationInput | ContactOpportunityJoinOrderByWithRelationInput[]
    cursor?: ContactOpportunityJoinWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactOpportunityJoinScalarFieldEnum | ContactOpportunityJoinScalarFieldEnum[]
  }

  /**
   * Contact.relationAsSource
   */
  export type Contact$relationAsSourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactRelationship
     */
    select?: ContactRelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactRelationship
     */
    omit?: ContactRelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactRelationshipInclude<ExtArgs> | null
    where?: ContactRelationshipWhereInput
    orderBy?: ContactRelationshipOrderByWithRelationInput | ContactRelationshipOrderByWithRelationInput[]
    cursor?: ContactRelationshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactRelationshipScalarFieldEnum | ContactRelationshipScalarFieldEnum[]
  }

  /**
   * Contact.relationAsTarget
   */
  export type Contact$relationAsTargetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactRelationship
     */
    select?: ContactRelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactRelationship
     */
    omit?: ContactRelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactRelationshipInclude<ExtArgs> | null
    where?: ContactRelationshipWhereInput
    orderBy?: ContactRelationshipOrderByWithRelationInput | ContactRelationshipOrderByWithRelationInput[]
    cursor?: ContactRelationshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactRelationshipScalarFieldEnum | ContactRelationshipScalarFieldEnum[]
  }

  /**
   * Contact without action
   */
  export type ContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
  }


  /**
   * Model ContactRelationship
   */

  export type AggregateContactRelationship = {
    _count: ContactRelationshipCountAggregateOutputType | null
    _min: ContactRelationshipMinAggregateOutputType | null
    _max: ContactRelationshipMaxAggregateOutputType | null
  }

  export type ContactRelationshipMinAggregateOutputType = {
    id: Uint8Array | null
    sourceId: Uint8Array | null
    targetId: Uint8Array | null
    type: string | null
    established: Date | null
    notes: string | null
  }

  export type ContactRelationshipMaxAggregateOutputType = {
    id: Uint8Array | null
    sourceId: Uint8Array | null
    targetId: Uint8Array | null
    type: string | null
    established: Date | null
    notes: string | null
  }

  export type ContactRelationshipCountAggregateOutputType = {
    id: number
    sourceId: number
    targetId: number
    type: number
    established: number
    notes: number
    _all: number
  }


  export type ContactRelationshipMinAggregateInputType = {
    id?: true
    sourceId?: true
    targetId?: true
    type?: true
    established?: true
    notes?: true
  }

  export type ContactRelationshipMaxAggregateInputType = {
    id?: true
    sourceId?: true
    targetId?: true
    type?: true
    established?: true
    notes?: true
  }

  export type ContactRelationshipCountAggregateInputType = {
    id?: true
    sourceId?: true
    targetId?: true
    type?: true
    established?: true
    notes?: true
    _all?: true
  }

  export type ContactRelationshipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactRelationship to aggregate.
     */
    where?: ContactRelationshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactRelationships to fetch.
     */
    orderBy?: ContactRelationshipOrderByWithRelationInput | ContactRelationshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactRelationshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactRelationships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactRelationships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContactRelationships
    **/
    _count?: true | ContactRelationshipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactRelationshipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactRelationshipMaxAggregateInputType
  }

  export type GetContactRelationshipAggregateType<T extends ContactRelationshipAggregateArgs> = {
        [P in keyof T & keyof AggregateContactRelationship]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContactRelationship[P]>
      : GetScalarType<T[P], AggregateContactRelationship[P]>
  }




  export type ContactRelationshipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactRelationshipWhereInput
    orderBy?: ContactRelationshipOrderByWithAggregationInput | ContactRelationshipOrderByWithAggregationInput[]
    by: ContactRelationshipScalarFieldEnum[] | ContactRelationshipScalarFieldEnum
    having?: ContactRelationshipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactRelationshipCountAggregateInputType | true
    _min?: ContactRelationshipMinAggregateInputType
    _max?: ContactRelationshipMaxAggregateInputType
  }

  export type ContactRelationshipGroupByOutputType = {
    id: Uint8Array
    sourceId: Uint8Array
    targetId: Uint8Array
    type: string
    established: Date | null
    notes: string | null
    _count: ContactRelationshipCountAggregateOutputType | null
    _min: ContactRelationshipMinAggregateOutputType | null
    _max: ContactRelationshipMaxAggregateOutputType | null
  }

  type GetContactRelationshipGroupByPayload<T extends ContactRelationshipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactRelationshipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactRelationshipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactRelationshipGroupByOutputType[P]>
            : GetScalarType<T[P], ContactRelationshipGroupByOutputType[P]>
        }
      >
    >


  export type ContactRelationshipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sourceId?: boolean
    targetId?: boolean
    type?: boolean
    established?: boolean
    notes?: boolean
    source?: boolean | ContactDefaultArgs<ExtArgs>
    target?: boolean | ContactDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactRelationship"]>

  export type ContactRelationshipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sourceId?: boolean
    targetId?: boolean
    type?: boolean
    established?: boolean
    notes?: boolean
    source?: boolean | ContactDefaultArgs<ExtArgs>
    target?: boolean | ContactDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactRelationship"]>

  export type ContactRelationshipSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sourceId?: boolean
    targetId?: boolean
    type?: boolean
    established?: boolean
    notes?: boolean
    source?: boolean | ContactDefaultArgs<ExtArgs>
    target?: boolean | ContactDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactRelationship"]>

  export type ContactRelationshipSelectScalar = {
    id?: boolean
    sourceId?: boolean
    targetId?: boolean
    type?: boolean
    established?: boolean
    notes?: boolean
  }

  export type ContactRelationshipOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sourceId" | "targetId" | "type" | "established" | "notes", ExtArgs["result"]["contactRelationship"]>
  export type ContactRelationshipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    source?: boolean | ContactDefaultArgs<ExtArgs>
    target?: boolean | ContactDefaultArgs<ExtArgs>
  }
  export type ContactRelationshipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    source?: boolean | ContactDefaultArgs<ExtArgs>
    target?: boolean | ContactDefaultArgs<ExtArgs>
  }
  export type ContactRelationshipIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    source?: boolean | ContactDefaultArgs<ExtArgs>
    target?: boolean | ContactDefaultArgs<ExtArgs>
  }

  export type $ContactRelationshipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContactRelationship"
    objects: {
      source: Prisma.$ContactPayload<ExtArgs>
      target: Prisma.$ContactPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      /**
       * @@wrapper-ignore
       */
      id: Uint8Array
      sourceId: Uint8Array
      targetId: Uint8Array
      type: string
      established: Date | null
      notes: string | null
    }, ExtArgs["result"]["contactRelationship"]>
    composites: {}
  }

  type ContactRelationshipGetPayload<S extends boolean | null | undefined | ContactRelationshipDefaultArgs> = $Result.GetResult<Prisma.$ContactRelationshipPayload, S>

  type ContactRelationshipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactRelationshipFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: ContactRelationshipCountAggregateInputType | true
    }

  export interface ContactRelationshipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContactRelationship'], meta: { name: 'ContactRelationship' } }
    /**
     * Find zero or one ContactRelationship that matches the filter.
     * @param {ContactRelationshipFindUniqueArgs} args - Arguments to find a ContactRelationship
     * @example
     * // Get one ContactRelationship
     * const contactRelationship = await prisma.contactRelationship.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactRelationshipFindUniqueArgs>(args: SelectSubset<T, ContactRelationshipFindUniqueArgs<ExtArgs>>): Prisma__ContactRelationshipClient<$Result.GetResult<Prisma.$ContactRelationshipPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ContactRelationship that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactRelationshipFindUniqueOrThrowArgs} args - Arguments to find a ContactRelationship
     * @example
     * // Get one ContactRelationship
     * const contactRelationship = await prisma.contactRelationship.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactRelationshipFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactRelationshipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactRelationshipClient<$Result.GetResult<Prisma.$ContactRelationshipPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ContactRelationship that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactRelationshipFindFirstArgs} args - Arguments to find a ContactRelationship
     * @example
     * // Get one ContactRelationship
     * const contactRelationship = await prisma.contactRelationship.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactRelationshipFindFirstArgs>(args?: SelectSubset<T, ContactRelationshipFindFirstArgs<ExtArgs>>): Prisma__ContactRelationshipClient<$Result.GetResult<Prisma.$ContactRelationshipPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ContactRelationship that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactRelationshipFindFirstOrThrowArgs} args - Arguments to find a ContactRelationship
     * @example
     * // Get one ContactRelationship
     * const contactRelationship = await prisma.contactRelationship.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactRelationshipFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactRelationshipFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactRelationshipClient<$Result.GetResult<Prisma.$ContactRelationshipPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ContactRelationships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactRelationshipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContactRelationships
     * const contactRelationships = await prisma.contactRelationship.findMany()
     * 
     * // Get first 10 ContactRelationships
     * const contactRelationships = await prisma.contactRelationship.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactRelationshipWithIdOnly = await prisma.contactRelationship.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactRelationshipFindManyArgs>(args?: SelectSubset<T, ContactRelationshipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactRelationshipPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ContactRelationship.
     * @param {ContactRelationshipCreateArgs} args - Arguments to create a ContactRelationship.
     * @example
     * // Create one ContactRelationship
     * const ContactRelationship = await prisma.contactRelationship.create({
     *   data: {
     *     // ... data to create a ContactRelationship
     *   }
     * })
     * 
     */
    create<T extends ContactRelationshipCreateArgs>(args: SelectSubset<T, ContactRelationshipCreateArgs<ExtArgs>>): Prisma__ContactRelationshipClient<$Result.GetResult<Prisma.$ContactRelationshipPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ContactRelationships.
     * @param {ContactRelationshipCreateManyArgs} args - Arguments to create many ContactRelationships.
     * @example
     * // Create many ContactRelationships
     * const contactRelationship = await prisma.contactRelationship.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactRelationshipCreateManyArgs>(args?: SelectSubset<T, ContactRelationshipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContactRelationships and returns the data saved in the database.
     * @param {ContactRelationshipCreateManyAndReturnArgs} args - Arguments to create many ContactRelationships.
     * @example
     * // Create many ContactRelationships
     * const contactRelationship = await prisma.contactRelationship.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContactRelationships and only return the `id`
     * const contactRelationshipWithIdOnly = await prisma.contactRelationship.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactRelationshipCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactRelationshipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactRelationshipPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a ContactRelationship.
     * @param {ContactRelationshipDeleteArgs} args - Arguments to delete one ContactRelationship.
     * @example
     * // Delete one ContactRelationship
     * const ContactRelationship = await prisma.contactRelationship.delete({
     *   where: {
     *     // ... filter to delete one ContactRelationship
     *   }
     * })
     * 
     */
    delete<T extends ContactRelationshipDeleteArgs>(args: SelectSubset<T, ContactRelationshipDeleteArgs<ExtArgs>>): Prisma__ContactRelationshipClient<$Result.GetResult<Prisma.$ContactRelationshipPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ContactRelationship.
     * @param {ContactRelationshipUpdateArgs} args - Arguments to update one ContactRelationship.
     * @example
     * // Update one ContactRelationship
     * const contactRelationship = await prisma.contactRelationship.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactRelationshipUpdateArgs>(args: SelectSubset<T, ContactRelationshipUpdateArgs<ExtArgs>>): Prisma__ContactRelationshipClient<$Result.GetResult<Prisma.$ContactRelationshipPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ContactRelationships.
     * @param {ContactRelationshipDeleteManyArgs} args - Arguments to filter ContactRelationships to delete.
     * @example
     * // Delete a few ContactRelationships
     * const { count } = await prisma.contactRelationship.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactRelationshipDeleteManyArgs>(args?: SelectSubset<T, ContactRelationshipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactRelationships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactRelationshipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContactRelationships
     * const contactRelationship = await prisma.contactRelationship.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactRelationshipUpdateManyArgs>(args: SelectSubset<T, ContactRelationshipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactRelationships and returns the data updated in the database.
     * @param {ContactRelationshipUpdateManyAndReturnArgs} args - Arguments to update many ContactRelationships.
     * @example
     * // Update many ContactRelationships
     * const contactRelationship = await prisma.contactRelationship.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContactRelationships and only return the `id`
     * const contactRelationshipWithIdOnly = await prisma.contactRelationship.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContactRelationshipUpdateManyAndReturnArgs>(args: SelectSubset<T, ContactRelationshipUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactRelationshipPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one ContactRelationship.
     * @param {ContactRelationshipUpsertArgs} args - Arguments to update or create a ContactRelationship.
     * @example
     * // Update or create a ContactRelationship
     * const contactRelationship = await prisma.contactRelationship.upsert({
     *   create: {
     *     // ... data to create a ContactRelationship
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContactRelationship we want to update
     *   }
     * })
     */
    upsert<T extends ContactRelationshipUpsertArgs>(args: SelectSubset<T, ContactRelationshipUpsertArgs<ExtArgs>>): Prisma__ContactRelationshipClient<$Result.GetResult<Prisma.$ContactRelationshipPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ContactRelationships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactRelationshipCountArgs} args - Arguments to filter ContactRelationships to count.
     * @example
     * // Count the number of ContactRelationships
     * const count = await prisma.contactRelationship.count({
     *   where: {
     *     // ... the filter for the ContactRelationships we want to count
     *   }
     * })
    **/
    count<T extends ContactRelationshipCountArgs>(
      args?: Subset<T, ContactRelationshipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactRelationshipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContactRelationship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactRelationshipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactRelationshipAggregateArgs>(args: Subset<T, ContactRelationshipAggregateArgs>): Prisma.PrismaPromise<GetContactRelationshipAggregateType<T>>

    /**
     * Group by ContactRelationship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactRelationshipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactRelationshipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactRelationshipGroupByArgs['orderBy'] }
        : { orderBy?: ContactRelationshipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactRelationshipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactRelationshipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContactRelationship model
   */
  readonly fields: ContactRelationshipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContactRelationship.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactRelationshipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    source<T extends ContactDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContactDefaultArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    target<T extends ContactDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContactDefaultArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContactRelationship model
   */ 
  interface ContactRelationshipFieldRefs {
    readonly id: FieldRef<"ContactRelationship", 'Bytes'>
    readonly sourceId: FieldRef<"ContactRelationship", 'Bytes'>
    readonly targetId: FieldRef<"ContactRelationship", 'Bytes'>
    readonly type: FieldRef<"ContactRelationship", 'String'>
    readonly established: FieldRef<"ContactRelationship", 'DateTime'>
    readonly notes: FieldRef<"ContactRelationship", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ContactRelationship findUnique
   */
  export type ContactRelationshipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactRelationship
     */
    select?: ContactRelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactRelationship
     */
    omit?: ContactRelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactRelationshipInclude<ExtArgs> | null
    /**
     * Filter, which ContactRelationship to fetch.
     */
    where: ContactRelationshipWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactRelationship findUniqueOrThrow
   */
  export type ContactRelationshipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactRelationship
     */
    select?: ContactRelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactRelationship
     */
    omit?: ContactRelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactRelationshipInclude<ExtArgs> | null
    /**
     * Filter, which ContactRelationship to fetch.
     */
    where: ContactRelationshipWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactRelationship findFirst
   */
  export type ContactRelationshipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactRelationship
     */
    select?: ContactRelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactRelationship
     */
    omit?: ContactRelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactRelationshipInclude<ExtArgs> | null
    /**
     * Filter, which ContactRelationship to fetch.
     */
    where?: ContactRelationshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactRelationships to fetch.
     */
    orderBy?: ContactRelationshipOrderByWithRelationInput | ContactRelationshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactRelationships.
     */
    cursor?: ContactRelationshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactRelationships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactRelationships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactRelationships.
     */
    distinct?: ContactRelationshipScalarFieldEnum | ContactRelationshipScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactRelationship findFirstOrThrow
   */
  export type ContactRelationshipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactRelationship
     */
    select?: ContactRelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactRelationship
     */
    omit?: ContactRelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactRelationshipInclude<ExtArgs> | null
    /**
     * Filter, which ContactRelationship to fetch.
     */
    where?: ContactRelationshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactRelationships to fetch.
     */
    orderBy?: ContactRelationshipOrderByWithRelationInput | ContactRelationshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactRelationships.
     */
    cursor?: ContactRelationshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactRelationships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactRelationships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactRelationships.
     */
    distinct?: ContactRelationshipScalarFieldEnum | ContactRelationshipScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactRelationship findMany
   */
  export type ContactRelationshipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactRelationship
     */
    select?: ContactRelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactRelationship
     */
    omit?: ContactRelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactRelationshipInclude<ExtArgs> | null
    /**
     * Filter, which ContactRelationships to fetch.
     */
    where?: ContactRelationshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactRelationships to fetch.
     */
    orderBy?: ContactRelationshipOrderByWithRelationInput | ContactRelationshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContactRelationships.
     */
    cursor?: ContactRelationshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactRelationships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactRelationships.
     */
    skip?: number
    distinct?: ContactRelationshipScalarFieldEnum | ContactRelationshipScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactRelationship create
   */
  export type ContactRelationshipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactRelationship
     */
    select?: ContactRelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactRelationship
     */
    omit?: ContactRelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactRelationshipInclude<ExtArgs> | null
    /**
     * The data needed to create a ContactRelationship.
     */
    data: XOR<ContactRelationshipCreateInput, ContactRelationshipUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactRelationship createMany
   */
  export type ContactRelationshipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContactRelationships.
     */
    data: ContactRelationshipCreateManyInput | ContactRelationshipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactRelationship createManyAndReturn
   */
  export type ContactRelationshipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactRelationship
     */
    select?: ContactRelationshipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactRelationship
     */
    omit?: ContactRelationshipOmit<ExtArgs> | null
    /**
     * The data used to create many ContactRelationships.
     */
    data: ContactRelationshipCreateManyInput | ContactRelationshipCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactRelationshipIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContactRelationship update
   */
  export type ContactRelationshipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactRelationship
     */
    select?: ContactRelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactRelationship
     */
    omit?: ContactRelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactRelationshipInclude<ExtArgs> | null
    /**
     * The data needed to update a ContactRelationship.
     */
    data: XOR<ContactRelationshipUpdateInput, ContactRelationshipUncheckedUpdateInput>
    /**
     * Choose, which ContactRelationship to update.
     */
    where: ContactRelationshipWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactRelationship updateMany
   */
  export type ContactRelationshipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContactRelationships.
     */
    data: XOR<ContactRelationshipUpdateManyMutationInput, ContactRelationshipUncheckedUpdateManyInput>
    /**
     * Filter which ContactRelationships to update
     */
    where?: ContactRelationshipWhereInput
    /**
     * Limit how many ContactRelationships to update.
     */
    limit?: number
  }

  /**
   * ContactRelationship updateManyAndReturn
   */
  export type ContactRelationshipUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactRelationship
     */
    select?: ContactRelationshipSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactRelationship
     */
    omit?: ContactRelationshipOmit<ExtArgs> | null
    /**
     * The data used to update ContactRelationships.
     */
    data: XOR<ContactRelationshipUpdateManyMutationInput, ContactRelationshipUncheckedUpdateManyInput>
    /**
     * Filter which ContactRelationships to update
     */
    where?: ContactRelationshipWhereInput
    /**
     * Limit how many ContactRelationships to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactRelationshipIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContactRelationship upsert
   */
  export type ContactRelationshipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactRelationship
     */
    select?: ContactRelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactRelationship
     */
    omit?: ContactRelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactRelationshipInclude<ExtArgs> | null
    /**
     * The filter to search for the ContactRelationship to update in case it exists.
     */
    where: ContactRelationshipWhereUniqueInput
    /**
     * In case the ContactRelationship found by the `where` argument doesn't exist, create a new ContactRelationship with this data.
     */
    create: XOR<ContactRelationshipCreateInput, ContactRelationshipUncheckedCreateInput>
    /**
     * In case the ContactRelationship was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactRelationshipUpdateInput, ContactRelationshipUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactRelationship delete
   */
  export type ContactRelationshipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactRelationship
     */
    select?: ContactRelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactRelationship
     */
    omit?: ContactRelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactRelationshipInclude<ExtArgs> | null
    /**
     * Filter which ContactRelationship to delete.
     */
    where: ContactRelationshipWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactRelationship deleteMany
   */
  export type ContactRelationshipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactRelationships to delete
     */
    where?: ContactRelationshipWhereInput
    /**
     * Limit how many ContactRelationships to delete.
     */
    limit?: number
  }

  /**
   * ContactRelationship without action
   */
  export type ContactRelationshipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactRelationship
     */
    select?: ContactRelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactRelationship
     */
    omit?: ContactRelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactRelationshipInclude<ExtArgs> | null
  }


  /**
   * Model ActivityStep
   */

  export type AggregateActivityStep = {
    _count: ActivityStepCountAggregateOutputType | null
    _avg: ActivityStepAvgAggregateOutputType | null
    _sum: ActivityStepSumAggregateOutputType | null
    _min: ActivityStepMinAggregateOutputType | null
    _max: ActivityStepMaxAggregateOutputType | null
  }

  export type ActivityStepAvgAggregateOutputType = {
    order: number | null
  }

  export type ActivityStepSumAggregateOutputType = {
    order: number | null
  }

  export type ActivityStepMinAggregateOutputType = {
    id: Uint8Array | null
    title: string | null
    completed: boolean | null
    activityId: Uint8Array | null
    createdAt: Date | null
    updatedAt: Date | null
    tenetId: Uint8Array | null
    type: $Enums.ActivityStepType | null
    order: number | null
  }

  export type ActivityStepMaxAggregateOutputType = {
    id: Uint8Array | null
    title: string | null
    completed: boolean | null
    activityId: Uint8Array | null
    createdAt: Date | null
    updatedAt: Date | null
    tenetId: Uint8Array | null
    type: $Enums.ActivityStepType | null
    order: number | null
  }

  export type ActivityStepCountAggregateOutputType = {
    id: number
    title: number
    completed: number
    activityId: number
    createdAt: number
    updatedAt: number
    tenetId: number
    type: number
    order: number
    _all: number
  }


  export type ActivityStepAvgAggregateInputType = {
    order?: true
  }

  export type ActivityStepSumAggregateInputType = {
    order?: true
  }

  export type ActivityStepMinAggregateInputType = {
    id?: true
    title?: true
    completed?: true
    activityId?: true
    createdAt?: true
    updatedAt?: true
    tenetId?: true
    type?: true
    order?: true
  }

  export type ActivityStepMaxAggregateInputType = {
    id?: true
    title?: true
    completed?: true
    activityId?: true
    createdAt?: true
    updatedAt?: true
    tenetId?: true
    type?: true
    order?: true
  }

  export type ActivityStepCountAggregateInputType = {
    id?: true
    title?: true
    completed?: true
    activityId?: true
    createdAt?: true
    updatedAt?: true
    tenetId?: true
    type?: true
    order?: true
    _all?: true
  }

  export type ActivityStepAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityStep to aggregate.
     */
    where?: ActivityStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivitySteps to fetch.
     */
    orderBy?: ActivityStepOrderByWithRelationInput | ActivityStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivitySteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivitySteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActivitySteps
    **/
    _count?: true | ActivityStepCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActivityStepAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActivityStepSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityStepMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityStepMaxAggregateInputType
  }

  export type GetActivityStepAggregateType<T extends ActivityStepAggregateArgs> = {
        [P in keyof T & keyof AggregateActivityStep]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivityStep[P]>
      : GetScalarType<T[P], AggregateActivityStep[P]>
  }




  export type ActivityStepGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityStepWhereInput
    orderBy?: ActivityStepOrderByWithAggregationInput | ActivityStepOrderByWithAggregationInput[]
    by: ActivityStepScalarFieldEnum[] | ActivityStepScalarFieldEnum
    having?: ActivityStepScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityStepCountAggregateInputType | true
    _avg?: ActivityStepAvgAggregateInputType
    _sum?: ActivityStepSumAggregateInputType
    _min?: ActivityStepMinAggregateInputType
    _max?: ActivityStepMaxAggregateInputType
  }

  export type ActivityStepGroupByOutputType = {
    id: Uint8Array
    title: string
    completed: boolean
    activityId: Uint8Array
    createdAt: Date
    updatedAt: Date
    tenetId: Uint8Array
    type: $Enums.ActivityStepType
    order: number
    _count: ActivityStepCountAggregateOutputType | null
    _avg: ActivityStepAvgAggregateOutputType | null
    _sum: ActivityStepSumAggregateOutputType | null
    _min: ActivityStepMinAggregateOutputType | null
    _max: ActivityStepMaxAggregateOutputType | null
  }

  type GetActivityStepGroupByPayload<T extends ActivityStepGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityStepGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityStepGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityStepGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityStepGroupByOutputType[P]>
        }
      >
    >


  export type ActivityStepSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    completed?: boolean
    activityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenetId?: boolean
    type?: boolean
    order?: boolean
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
    assignedTo?: boolean | ActivityStep$assignedToArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
    _count?: boolean | ActivityStepCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityStep"]>

  export type ActivityStepSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    completed?: boolean
    activityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenetId?: boolean
    type?: boolean
    order?: boolean
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityStep"]>

  export type ActivityStepSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    completed?: boolean
    activityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenetId?: boolean
    type?: boolean
    order?: boolean
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityStep"]>

  export type ActivityStepSelectScalar = {
    id?: boolean
    title?: boolean
    completed?: boolean
    activityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenetId?: boolean
    type?: boolean
    order?: boolean
  }

  export type ActivityStepOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "completed" | "activityId" | "createdAt" | "updatedAt" | "tenetId" | "type" | "order", ExtArgs["result"]["activityStep"]>
  export type ActivityStepInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
    assignedTo?: boolean | ActivityStep$assignedToArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
    _count?: boolean | ActivityStepCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ActivityStepIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }
  export type ActivityStepIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }

  export type $ActivityStepPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActivityStep"
    objects: {
      /**
       * @ai-field(Parent activity of this step)
       */
      activity: Prisma.$ActivityPayload<ExtArgs>
      /**
       * @jointable(User, userRelation)
       * @ai-field(Assigned users, if empty this is the same as the parent activity)
       */
      assignedTo: Prisma.$ActivityStepUserJoinPayload<ExtArgs>[]
      tenet: Prisma.$TenetPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      /**
       * @@ai-enabled
       */
      id: Uint8Array
      /**
       * @ai-field
       */
      title: string
      /**
       * @ai-field
       */
      completed: boolean
      /**
       * @ai-field
       */
      activityId: Uint8Array
      createdAt: Date
      updatedAt: Date
      tenetId: Uint8Array
      /**
       * @ai-field(Type of step, either checkbox, attachment, or form)
       */
      type: $Enums.ActivityStepType
      /**
       * @ai-field(Step order)
       */
      order: number
    }, ExtArgs["result"]["activityStep"]>
    composites: {}
  }

  type ActivityStepGetPayload<S extends boolean | null | undefined | ActivityStepDefaultArgs> = $Result.GetResult<Prisma.$ActivityStepPayload, S>

  type ActivityStepCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActivityStepFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: ActivityStepCountAggregateInputType | true
    }

  export interface ActivityStepDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActivityStep'], meta: { name: 'ActivityStep' } }
    /**
     * Find zero or one ActivityStep that matches the filter.
     * @param {ActivityStepFindUniqueArgs} args - Arguments to find a ActivityStep
     * @example
     * // Get one ActivityStep
     * const activityStep = await prisma.activityStep.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityStepFindUniqueArgs>(args: SelectSubset<T, ActivityStepFindUniqueArgs<ExtArgs>>): Prisma__ActivityStepClient<$Result.GetResult<Prisma.$ActivityStepPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ActivityStep that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActivityStepFindUniqueOrThrowArgs} args - Arguments to find a ActivityStep
     * @example
     * // Get one ActivityStep
     * const activityStep = await prisma.activityStep.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityStepFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityStepFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityStepClient<$Result.GetResult<Prisma.$ActivityStepPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ActivityStep that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityStepFindFirstArgs} args - Arguments to find a ActivityStep
     * @example
     * // Get one ActivityStep
     * const activityStep = await prisma.activityStep.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityStepFindFirstArgs>(args?: SelectSubset<T, ActivityStepFindFirstArgs<ExtArgs>>): Prisma__ActivityStepClient<$Result.GetResult<Prisma.$ActivityStepPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ActivityStep that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityStepFindFirstOrThrowArgs} args - Arguments to find a ActivityStep
     * @example
     * // Get one ActivityStep
     * const activityStep = await prisma.activityStep.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityStepFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityStepFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityStepClient<$Result.GetResult<Prisma.$ActivityStepPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ActivitySteps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityStepFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActivitySteps
     * const activitySteps = await prisma.activityStep.findMany()
     * 
     * // Get first 10 ActivitySteps
     * const activitySteps = await prisma.activityStep.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityStepWithIdOnly = await prisma.activityStep.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityStepFindManyArgs>(args?: SelectSubset<T, ActivityStepFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityStepPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ActivityStep.
     * @param {ActivityStepCreateArgs} args - Arguments to create a ActivityStep.
     * @example
     * // Create one ActivityStep
     * const ActivityStep = await prisma.activityStep.create({
     *   data: {
     *     // ... data to create a ActivityStep
     *   }
     * })
     * 
     */
    create<T extends ActivityStepCreateArgs>(args: SelectSubset<T, ActivityStepCreateArgs<ExtArgs>>): Prisma__ActivityStepClient<$Result.GetResult<Prisma.$ActivityStepPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ActivitySteps.
     * @param {ActivityStepCreateManyArgs} args - Arguments to create many ActivitySteps.
     * @example
     * // Create many ActivitySteps
     * const activityStep = await prisma.activityStep.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityStepCreateManyArgs>(args?: SelectSubset<T, ActivityStepCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActivitySteps and returns the data saved in the database.
     * @param {ActivityStepCreateManyAndReturnArgs} args - Arguments to create many ActivitySteps.
     * @example
     * // Create many ActivitySteps
     * const activityStep = await prisma.activityStep.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActivitySteps and only return the `id`
     * const activityStepWithIdOnly = await prisma.activityStep.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityStepCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityStepCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityStepPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a ActivityStep.
     * @param {ActivityStepDeleteArgs} args - Arguments to delete one ActivityStep.
     * @example
     * // Delete one ActivityStep
     * const ActivityStep = await prisma.activityStep.delete({
     *   where: {
     *     // ... filter to delete one ActivityStep
     *   }
     * })
     * 
     */
    delete<T extends ActivityStepDeleteArgs>(args: SelectSubset<T, ActivityStepDeleteArgs<ExtArgs>>): Prisma__ActivityStepClient<$Result.GetResult<Prisma.$ActivityStepPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ActivityStep.
     * @param {ActivityStepUpdateArgs} args - Arguments to update one ActivityStep.
     * @example
     * // Update one ActivityStep
     * const activityStep = await prisma.activityStep.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityStepUpdateArgs>(args: SelectSubset<T, ActivityStepUpdateArgs<ExtArgs>>): Prisma__ActivityStepClient<$Result.GetResult<Prisma.$ActivityStepPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ActivitySteps.
     * @param {ActivityStepDeleteManyArgs} args - Arguments to filter ActivitySteps to delete.
     * @example
     * // Delete a few ActivitySteps
     * const { count } = await prisma.activityStep.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityStepDeleteManyArgs>(args?: SelectSubset<T, ActivityStepDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivitySteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityStepUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActivitySteps
     * const activityStep = await prisma.activityStep.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityStepUpdateManyArgs>(args: SelectSubset<T, ActivityStepUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivitySteps and returns the data updated in the database.
     * @param {ActivityStepUpdateManyAndReturnArgs} args - Arguments to update many ActivitySteps.
     * @example
     * // Update many ActivitySteps
     * const activityStep = await prisma.activityStep.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ActivitySteps and only return the `id`
     * const activityStepWithIdOnly = await prisma.activityStep.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActivityStepUpdateManyAndReturnArgs>(args: SelectSubset<T, ActivityStepUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityStepPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one ActivityStep.
     * @param {ActivityStepUpsertArgs} args - Arguments to update or create a ActivityStep.
     * @example
     * // Update or create a ActivityStep
     * const activityStep = await prisma.activityStep.upsert({
     *   create: {
     *     // ... data to create a ActivityStep
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActivityStep we want to update
     *   }
     * })
     */
    upsert<T extends ActivityStepUpsertArgs>(args: SelectSubset<T, ActivityStepUpsertArgs<ExtArgs>>): Prisma__ActivityStepClient<$Result.GetResult<Prisma.$ActivityStepPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ActivitySteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityStepCountArgs} args - Arguments to filter ActivitySteps to count.
     * @example
     * // Count the number of ActivitySteps
     * const count = await prisma.activityStep.count({
     *   where: {
     *     // ... the filter for the ActivitySteps we want to count
     *   }
     * })
    **/
    count<T extends ActivityStepCountArgs>(
      args?: Subset<T, ActivityStepCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityStepCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActivityStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityStepAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityStepAggregateArgs>(args: Subset<T, ActivityStepAggregateArgs>): Prisma.PrismaPromise<GetActivityStepAggregateType<T>>

    /**
     * Group by ActivityStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityStepGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityStepGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityStepGroupByArgs['orderBy'] }
        : { orderBy?: ActivityStepGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityStepGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityStepGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActivityStep model
   */
  readonly fields: ActivityStepFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActivityStep.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityStepClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    activity<T extends ActivityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ActivityDefaultArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    assignedTo<T extends ActivityStep$assignedToArgs<ExtArgs> = {}>(args?: Subset<T, ActivityStep$assignedToArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityStepUserJoinPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    tenet<T extends TenetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenetDefaultArgs<ExtArgs>>): Prisma__TenetClient<$Result.GetResult<Prisma.$TenetPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActivityStep model
   */ 
  interface ActivityStepFieldRefs {
    readonly id: FieldRef<"ActivityStep", 'Bytes'>
    readonly title: FieldRef<"ActivityStep", 'String'>
    readonly completed: FieldRef<"ActivityStep", 'Boolean'>
    readonly activityId: FieldRef<"ActivityStep", 'Bytes'>
    readonly createdAt: FieldRef<"ActivityStep", 'DateTime'>
    readonly updatedAt: FieldRef<"ActivityStep", 'DateTime'>
    readonly tenetId: FieldRef<"ActivityStep", 'Bytes'>
    readonly type: FieldRef<"ActivityStep", 'ActivityStepType'>
    readonly order: FieldRef<"ActivityStep", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ActivityStep findUnique
   */
  export type ActivityStepFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityStep
     */
    select?: ActivityStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityStep
     */
    omit?: ActivityStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityStepInclude<ExtArgs> | null
    /**
     * Filter, which ActivityStep to fetch.
     */
    where: ActivityStepWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityStep findUniqueOrThrow
   */
  export type ActivityStepFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityStep
     */
    select?: ActivityStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityStep
     */
    omit?: ActivityStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityStepInclude<ExtArgs> | null
    /**
     * Filter, which ActivityStep to fetch.
     */
    where: ActivityStepWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityStep findFirst
   */
  export type ActivityStepFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityStep
     */
    select?: ActivityStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityStep
     */
    omit?: ActivityStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityStepInclude<ExtArgs> | null
    /**
     * Filter, which ActivityStep to fetch.
     */
    where?: ActivityStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivitySteps to fetch.
     */
    orderBy?: ActivityStepOrderByWithRelationInput | ActivityStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivitySteps.
     */
    cursor?: ActivityStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivitySteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivitySteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivitySteps.
     */
    distinct?: ActivityStepScalarFieldEnum | ActivityStepScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityStep findFirstOrThrow
   */
  export type ActivityStepFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityStep
     */
    select?: ActivityStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityStep
     */
    omit?: ActivityStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityStepInclude<ExtArgs> | null
    /**
     * Filter, which ActivityStep to fetch.
     */
    where?: ActivityStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivitySteps to fetch.
     */
    orderBy?: ActivityStepOrderByWithRelationInput | ActivityStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivitySteps.
     */
    cursor?: ActivityStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivitySteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivitySteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivitySteps.
     */
    distinct?: ActivityStepScalarFieldEnum | ActivityStepScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityStep findMany
   */
  export type ActivityStepFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityStep
     */
    select?: ActivityStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityStep
     */
    omit?: ActivityStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityStepInclude<ExtArgs> | null
    /**
     * Filter, which ActivitySteps to fetch.
     */
    where?: ActivityStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivitySteps to fetch.
     */
    orderBy?: ActivityStepOrderByWithRelationInput | ActivityStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActivitySteps.
     */
    cursor?: ActivityStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivitySteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivitySteps.
     */
    skip?: number
    distinct?: ActivityStepScalarFieldEnum | ActivityStepScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityStep create
   */
  export type ActivityStepCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityStep
     */
    select?: ActivityStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityStep
     */
    omit?: ActivityStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityStepInclude<ExtArgs> | null
    /**
     * The data needed to create a ActivityStep.
     */
    data: XOR<ActivityStepCreateInput, ActivityStepUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityStep createMany
   */
  export type ActivityStepCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActivitySteps.
     */
    data: ActivityStepCreateManyInput | ActivityStepCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActivityStep createManyAndReturn
   */
  export type ActivityStepCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityStep
     */
    select?: ActivityStepSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityStep
     */
    omit?: ActivityStepOmit<ExtArgs> | null
    /**
     * The data used to create many ActivitySteps.
     */
    data: ActivityStepCreateManyInput | ActivityStepCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityStepIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityStep update
   */
  export type ActivityStepUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityStep
     */
    select?: ActivityStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityStep
     */
    omit?: ActivityStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityStepInclude<ExtArgs> | null
    /**
     * The data needed to update a ActivityStep.
     */
    data: XOR<ActivityStepUpdateInput, ActivityStepUncheckedUpdateInput>
    /**
     * Choose, which ActivityStep to update.
     */
    where: ActivityStepWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityStep updateMany
   */
  export type ActivityStepUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActivitySteps.
     */
    data: XOR<ActivityStepUpdateManyMutationInput, ActivityStepUncheckedUpdateManyInput>
    /**
     * Filter which ActivitySteps to update
     */
    where?: ActivityStepWhereInput
    /**
     * Limit how many ActivitySteps to update.
     */
    limit?: number
  }

  /**
   * ActivityStep updateManyAndReturn
   */
  export type ActivityStepUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityStep
     */
    select?: ActivityStepSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityStep
     */
    omit?: ActivityStepOmit<ExtArgs> | null
    /**
     * The data used to update ActivitySteps.
     */
    data: XOR<ActivityStepUpdateManyMutationInput, ActivityStepUncheckedUpdateManyInput>
    /**
     * Filter which ActivitySteps to update
     */
    where?: ActivityStepWhereInput
    /**
     * Limit how many ActivitySteps to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityStepIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityStep upsert
   */
  export type ActivityStepUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityStep
     */
    select?: ActivityStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityStep
     */
    omit?: ActivityStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityStepInclude<ExtArgs> | null
    /**
     * The filter to search for the ActivityStep to update in case it exists.
     */
    where: ActivityStepWhereUniqueInput
    /**
     * In case the ActivityStep found by the `where` argument doesn't exist, create a new ActivityStep with this data.
     */
    create: XOR<ActivityStepCreateInput, ActivityStepUncheckedCreateInput>
    /**
     * In case the ActivityStep was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityStepUpdateInput, ActivityStepUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityStep delete
   */
  export type ActivityStepDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityStep
     */
    select?: ActivityStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityStep
     */
    omit?: ActivityStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityStepInclude<ExtArgs> | null
    /**
     * Filter which ActivityStep to delete.
     */
    where: ActivityStepWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityStep deleteMany
   */
  export type ActivityStepDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivitySteps to delete
     */
    where?: ActivityStepWhereInput
    /**
     * Limit how many ActivitySteps to delete.
     */
    limit?: number
  }

  /**
   * ActivityStep.assignedTo
   */
  export type ActivityStep$assignedToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityStepUserJoin
     */
    select?: ActivityStepUserJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityStepUserJoin
     */
    omit?: ActivityStepUserJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityStepUserJoinInclude<ExtArgs> | null
    where?: ActivityStepUserJoinWhereInput
    orderBy?: ActivityStepUserJoinOrderByWithRelationInput | ActivityStepUserJoinOrderByWithRelationInput[]
    cursor?: ActivityStepUserJoinWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityStepUserJoinScalarFieldEnum | ActivityStepUserJoinScalarFieldEnum[]
  }

  /**
   * ActivityStep without action
   */
  export type ActivityStepDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityStep
     */
    select?: ActivityStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityStep
     */
    omit?: ActivityStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityStepInclude<ExtArgs> | null
  }


  /**
   * Model ActivityStepUserJoin
   */

  export type AggregateActivityStepUserJoin = {
    _count: ActivityStepUserJoinCountAggregateOutputType | null
    _min: ActivityStepUserJoinMinAggregateOutputType | null
    _max: ActivityStepUserJoinMaxAggregateOutputType | null
  }

  export type ActivityStepUserJoinMinAggregateOutputType = {
    activityStepId: Uint8Array | null
    userId: Uint8Array | null
  }

  export type ActivityStepUserJoinMaxAggregateOutputType = {
    activityStepId: Uint8Array | null
    userId: Uint8Array | null
  }

  export type ActivityStepUserJoinCountAggregateOutputType = {
    activityStepId: number
    userId: number
    _all: number
  }


  export type ActivityStepUserJoinMinAggregateInputType = {
    activityStepId?: true
    userId?: true
  }

  export type ActivityStepUserJoinMaxAggregateInputType = {
    activityStepId?: true
    userId?: true
  }

  export type ActivityStepUserJoinCountAggregateInputType = {
    activityStepId?: true
    userId?: true
    _all?: true
  }

  export type ActivityStepUserJoinAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityStepUserJoin to aggregate.
     */
    where?: ActivityStepUserJoinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityStepUserJoins to fetch.
     */
    orderBy?: ActivityStepUserJoinOrderByWithRelationInput | ActivityStepUserJoinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityStepUserJoinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityStepUserJoins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityStepUserJoins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActivityStepUserJoins
    **/
    _count?: true | ActivityStepUserJoinCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityStepUserJoinMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityStepUserJoinMaxAggregateInputType
  }

  export type GetActivityStepUserJoinAggregateType<T extends ActivityStepUserJoinAggregateArgs> = {
        [P in keyof T & keyof AggregateActivityStepUserJoin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivityStepUserJoin[P]>
      : GetScalarType<T[P], AggregateActivityStepUserJoin[P]>
  }




  export type ActivityStepUserJoinGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityStepUserJoinWhereInput
    orderBy?: ActivityStepUserJoinOrderByWithAggregationInput | ActivityStepUserJoinOrderByWithAggregationInput[]
    by: ActivityStepUserJoinScalarFieldEnum[] | ActivityStepUserJoinScalarFieldEnum
    having?: ActivityStepUserJoinScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityStepUserJoinCountAggregateInputType | true
    _min?: ActivityStepUserJoinMinAggregateInputType
    _max?: ActivityStepUserJoinMaxAggregateInputType
  }

  export type ActivityStepUserJoinGroupByOutputType = {
    activityStepId: Uint8Array
    userId: Uint8Array
    _count: ActivityStepUserJoinCountAggregateOutputType | null
    _min: ActivityStepUserJoinMinAggregateOutputType | null
    _max: ActivityStepUserJoinMaxAggregateOutputType | null
  }

  type GetActivityStepUserJoinGroupByPayload<T extends ActivityStepUserJoinGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityStepUserJoinGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityStepUserJoinGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityStepUserJoinGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityStepUserJoinGroupByOutputType[P]>
        }
      >
    >


  export type ActivityStepUserJoinSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    activityStepId?: boolean
    userId?: boolean
    stepRelation?: boolean | ActivityStepDefaultArgs<ExtArgs>
    userRelation?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityStepUserJoin"]>

  export type ActivityStepUserJoinSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    activityStepId?: boolean
    userId?: boolean
    stepRelation?: boolean | ActivityStepDefaultArgs<ExtArgs>
    userRelation?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityStepUserJoin"]>

  export type ActivityStepUserJoinSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    activityStepId?: boolean
    userId?: boolean
    stepRelation?: boolean | ActivityStepDefaultArgs<ExtArgs>
    userRelation?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityStepUserJoin"]>

  export type ActivityStepUserJoinSelectScalar = {
    activityStepId?: boolean
    userId?: boolean
  }

  export type ActivityStepUserJoinOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"activityStepId" | "userId", ExtArgs["result"]["activityStepUserJoin"]>
  export type ActivityStepUserJoinInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stepRelation?: boolean | ActivityStepDefaultArgs<ExtArgs>
    userRelation?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ActivityStepUserJoinIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stepRelation?: boolean | ActivityStepDefaultArgs<ExtArgs>
    userRelation?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ActivityStepUserJoinIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stepRelation?: boolean | ActivityStepDefaultArgs<ExtArgs>
    userRelation?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ActivityStepUserJoinPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActivityStepUserJoin"
    objects: {
      stepRelation: Prisma.$ActivityStepPayload<ExtArgs>
      userRelation: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      /**
       * @@wrapper-ignore
       */
      activityStepId: Uint8Array
      userId: Uint8Array
    }, ExtArgs["result"]["activityStepUserJoin"]>
    composites: {}
  }

  type ActivityStepUserJoinGetPayload<S extends boolean | null | undefined | ActivityStepUserJoinDefaultArgs> = $Result.GetResult<Prisma.$ActivityStepUserJoinPayload, S>

  type ActivityStepUserJoinCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActivityStepUserJoinFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: ActivityStepUserJoinCountAggregateInputType | true
    }

  export interface ActivityStepUserJoinDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActivityStepUserJoin'], meta: { name: 'ActivityStepUserJoin' } }
    /**
     * Find zero or one ActivityStepUserJoin that matches the filter.
     * @param {ActivityStepUserJoinFindUniqueArgs} args - Arguments to find a ActivityStepUserJoin
     * @example
     * // Get one ActivityStepUserJoin
     * const activityStepUserJoin = await prisma.activityStepUserJoin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityStepUserJoinFindUniqueArgs>(args: SelectSubset<T, ActivityStepUserJoinFindUniqueArgs<ExtArgs>>): Prisma__ActivityStepUserJoinClient<$Result.GetResult<Prisma.$ActivityStepUserJoinPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ActivityStepUserJoin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActivityStepUserJoinFindUniqueOrThrowArgs} args - Arguments to find a ActivityStepUserJoin
     * @example
     * // Get one ActivityStepUserJoin
     * const activityStepUserJoin = await prisma.activityStepUserJoin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityStepUserJoinFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityStepUserJoinFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityStepUserJoinClient<$Result.GetResult<Prisma.$ActivityStepUserJoinPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ActivityStepUserJoin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityStepUserJoinFindFirstArgs} args - Arguments to find a ActivityStepUserJoin
     * @example
     * // Get one ActivityStepUserJoin
     * const activityStepUserJoin = await prisma.activityStepUserJoin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityStepUserJoinFindFirstArgs>(args?: SelectSubset<T, ActivityStepUserJoinFindFirstArgs<ExtArgs>>): Prisma__ActivityStepUserJoinClient<$Result.GetResult<Prisma.$ActivityStepUserJoinPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ActivityStepUserJoin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityStepUserJoinFindFirstOrThrowArgs} args - Arguments to find a ActivityStepUserJoin
     * @example
     * // Get one ActivityStepUserJoin
     * const activityStepUserJoin = await prisma.activityStepUserJoin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityStepUserJoinFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityStepUserJoinFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityStepUserJoinClient<$Result.GetResult<Prisma.$ActivityStepUserJoinPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ActivityStepUserJoins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityStepUserJoinFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActivityStepUserJoins
     * const activityStepUserJoins = await prisma.activityStepUserJoin.findMany()
     * 
     * // Get first 10 ActivityStepUserJoins
     * const activityStepUserJoins = await prisma.activityStepUserJoin.findMany({ take: 10 })
     * 
     * // Only select the `activityStepId`
     * const activityStepUserJoinWithActivityStepIdOnly = await prisma.activityStepUserJoin.findMany({ select: { activityStepId: true } })
     * 
     */
    findMany<T extends ActivityStepUserJoinFindManyArgs>(args?: SelectSubset<T, ActivityStepUserJoinFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityStepUserJoinPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ActivityStepUserJoin.
     * @param {ActivityStepUserJoinCreateArgs} args - Arguments to create a ActivityStepUserJoin.
     * @example
     * // Create one ActivityStepUserJoin
     * const ActivityStepUserJoin = await prisma.activityStepUserJoin.create({
     *   data: {
     *     // ... data to create a ActivityStepUserJoin
     *   }
     * })
     * 
     */
    create<T extends ActivityStepUserJoinCreateArgs>(args: SelectSubset<T, ActivityStepUserJoinCreateArgs<ExtArgs>>): Prisma__ActivityStepUserJoinClient<$Result.GetResult<Prisma.$ActivityStepUserJoinPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ActivityStepUserJoins.
     * @param {ActivityStepUserJoinCreateManyArgs} args - Arguments to create many ActivityStepUserJoins.
     * @example
     * // Create many ActivityStepUserJoins
     * const activityStepUserJoin = await prisma.activityStepUserJoin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityStepUserJoinCreateManyArgs>(args?: SelectSubset<T, ActivityStepUserJoinCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActivityStepUserJoins and returns the data saved in the database.
     * @param {ActivityStepUserJoinCreateManyAndReturnArgs} args - Arguments to create many ActivityStepUserJoins.
     * @example
     * // Create many ActivityStepUserJoins
     * const activityStepUserJoin = await prisma.activityStepUserJoin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActivityStepUserJoins and only return the `activityStepId`
     * const activityStepUserJoinWithActivityStepIdOnly = await prisma.activityStepUserJoin.createManyAndReturn({
     *   select: { activityStepId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityStepUserJoinCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityStepUserJoinCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityStepUserJoinPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a ActivityStepUserJoin.
     * @param {ActivityStepUserJoinDeleteArgs} args - Arguments to delete one ActivityStepUserJoin.
     * @example
     * // Delete one ActivityStepUserJoin
     * const ActivityStepUserJoin = await prisma.activityStepUserJoin.delete({
     *   where: {
     *     // ... filter to delete one ActivityStepUserJoin
     *   }
     * })
     * 
     */
    delete<T extends ActivityStepUserJoinDeleteArgs>(args: SelectSubset<T, ActivityStepUserJoinDeleteArgs<ExtArgs>>): Prisma__ActivityStepUserJoinClient<$Result.GetResult<Prisma.$ActivityStepUserJoinPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ActivityStepUserJoin.
     * @param {ActivityStepUserJoinUpdateArgs} args - Arguments to update one ActivityStepUserJoin.
     * @example
     * // Update one ActivityStepUserJoin
     * const activityStepUserJoin = await prisma.activityStepUserJoin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityStepUserJoinUpdateArgs>(args: SelectSubset<T, ActivityStepUserJoinUpdateArgs<ExtArgs>>): Prisma__ActivityStepUserJoinClient<$Result.GetResult<Prisma.$ActivityStepUserJoinPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ActivityStepUserJoins.
     * @param {ActivityStepUserJoinDeleteManyArgs} args - Arguments to filter ActivityStepUserJoins to delete.
     * @example
     * // Delete a few ActivityStepUserJoins
     * const { count } = await prisma.activityStepUserJoin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityStepUserJoinDeleteManyArgs>(args?: SelectSubset<T, ActivityStepUserJoinDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityStepUserJoins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityStepUserJoinUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActivityStepUserJoins
     * const activityStepUserJoin = await prisma.activityStepUserJoin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityStepUserJoinUpdateManyArgs>(args: SelectSubset<T, ActivityStepUserJoinUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityStepUserJoins and returns the data updated in the database.
     * @param {ActivityStepUserJoinUpdateManyAndReturnArgs} args - Arguments to update many ActivityStepUserJoins.
     * @example
     * // Update many ActivityStepUserJoins
     * const activityStepUserJoin = await prisma.activityStepUserJoin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ActivityStepUserJoins and only return the `activityStepId`
     * const activityStepUserJoinWithActivityStepIdOnly = await prisma.activityStepUserJoin.updateManyAndReturn({
     *   select: { activityStepId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActivityStepUserJoinUpdateManyAndReturnArgs>(args: SelectSubset<T, ActivityStepUserJoinUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityStepUserJoinPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one ActivityStepUserJoin.
     * @param {ActivityStepUserJoinUpsertArgs} args - Arguments to update or create a ActivityStepUserJoin.
     * @example
     * // Update or create a ActivityStepUserJoin
     * const activityStepUserJoin = await prisma.activityStepUserJoin.upsert({
     *   create: {
     *     // ... data to create a ActivityStepUserJoin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActivityStepUserJoin we want to update
     *   }
     * })
     */
    upsert<T extends ActivityStepUserJoinUpsertArgs>(args: SelectSubset<T, ActivityStepUserJoinUpsertArgs<ExtArgs>>): Prisma__ActivityStepUserJoinClient<$Result.GetResult<Prisma.$ActivityStepUserJoinPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ActivityStepUserJoins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityStepUserJoinCountArgs} args - Arguments to filter ActivityStepUserJoins to count.
     * @example
     * // Count the number of ActivityStepUserJoins
     * const count = await prisma.activityStepUserJoin.count({
     *   where: {
     *     // ... the filter for the ActivityStepUserJoins we want to count
     *   }
     * })
    **/
    count<T extends ActivityStepUserJoinCountArgs>(
      args?: Subset<T, ActivityStepUserJoinCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityStepUserJoinCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActivityStepUserJoin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityStepUserJoinAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityStepUserJoinAggregateArgs>(args: Subset<T, ActivityStepUserJoinAggregateArgs>): Prisma.PrismaPromise<GetActivityStepUserJoinAggregateType<T>>

    /**
     * Group by ActivityStepUserJoin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityStepUserJoinGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityStepUserJoinGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityStepUserJoinGroupByArgs['orderBy'] }
        : { orderBy?: ActivityStepUserJoinGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityStepUserJoinGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityStepUserJoinGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActivityStepUserJoin model
   */
  readonly fields: ActivityStepUserJoinFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActivityStepUserJoin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityStepUserJoinClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stepRelation<T extends ActivityStepDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ActivityStepDefaultArgs<ExtArgs>>): Prisma__ActivityStepClient<$Result.GetResult<Prisma.$ActivityStepPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    userRelation<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActivityStepUserJoin model
   */ 
  interface ActivityStepUserJoinFieldRefs {
    readonly activityStepId: FieldRef<"ActivityStepUserJoin", 'Bytes'>
    readonly userId: FieldRef<"ActivityStepUserJoin", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * ActivityStepUserJoin findUnique
   */
  export type ActivityStepUserJoinFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityStepUserJoin
     */
    select?: ActivityStepUserJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityStepUserJoin
     */
    omit?: ActivityStepUserJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityStepUserJoinInclude<ExtArgs> | null
    /**
     * Filter, which ActivityStepUserJoin to fetch.
     */
    where: ActivityStepUserJoinWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityStepUserJoin findUniqueOrThrow
   */
  export type ActivityStepUserJoinFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityStepUserJoin
     */
    select?: ActivityStepUserJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityStepUserJoin
     */
    omit?: ActivityStepUserJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityStepUserJoinInclude<ExtArgs> | null
    /**
     * Filter, which ActivityStepUserJoin to fetch.
     */
    where: ActivityStepUserJoinWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityStepUserJoin findFirst
   */
  export type ActivityStepUserJoinFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityStepUserJoin
     */
    select?: ActivityStepUserJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityStepUserJoin
     */
    omit?: ActivityStepUserJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityStepUserJoinInclude<ExtArgs> | null
    /**
     * Filter, which ActivityStepUserJoin to fetch.
     */
    where?: ActivityStepUserJoinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityStepUserJoins to fetch.
     */
    orderBy?: ActivityStepUserJoinOrderByWithRelationInput | ActivityStepUserJoinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityStepUserJoins.
     */
    cursor?: ActivityStepUserJoinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityStepUserJoins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityStepUserJoins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityStepUserJoins.
     */
    distinct?: ActivityStepUserJoinScalarFieldEnum | ActivityStepUserJoinScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityStepUserJoin findFirstOrThrow
   */
  export type ActivityStepUserJoinFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityStepUserJoin
     */
    select?: ActivityStepUserJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityStepUserJoin
     */
    omit?: ActivityStepUserJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityStepUserJoinInclude<ExtArgs> | null
    /**
     * Filter, which ActivityStepUserJoin to fetch.
     */
    where?: ActivityStepUserJoinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityStepUserJoins to fetch.
     */
    orderBy?: ActivityStepUserJoinOrderByWithRelationInput | ActivityStepUserJoinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityStepUserJoins.
     */
    cursor?: ActivityStepUserJoinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityStepUserJoins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityStepUserJoins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityStepUserJoins.
     */
    distinct?: ActivityStepUserJoinScalarFieldEnum | ActivityStepUserJoinScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityStepUserJoin findMany
   */
  export type ActivityStepUserJoinFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityStepUserJoin
     */
    select?: ActivityStepUserJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityStepUserJoin
     */
    omit?: ActivityStepUserJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityStepUserJoinInclude<ExtArgs> | null
    /**
     * Filter, which ActivityStepUserJoins to fetch.
     */
    where?: ActivityStepUserJoinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityStepUserJoins to fetch.
     */
    orderBy?: ActivityStepUserJoinOrderByWithRelationInput | ActivityStepUserJoinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActivityStepUserJoins.
     */
    cursor?: ActivityStepUserJoinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityStepUserJoins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityStepUserJoins.
     */
    skip?: number
    distinct?: ActivityStepUserJoinScalarFieldEnum | ActivityStepUserJoinScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityStepUserJoin create
   */
  export type ActivityStepUserJoinCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityStepUserJoin
     */
    select?: ActivityStepUserJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityStepUserJoin
     */
    omit?: ActivityStepUserJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityStepUserJoinInclude<ExtArgs> | null
    /**
     * The data needed to create a ActivityStepUserJoin.
     */
    data: XOR<ActivityStepUserJoinCreateInput, ActivityStepUserJoinUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityStepUserJoin createMany
   */
  export type ActivityStepUserJoinCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActivityStepUserJoins.
     */
    data: ActivityStepUserJoinCreateManyInput | ActivityStepUserJoinCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActivityStepUserJoin createManyAndReturn
   */
  export type ActivityStepUserJoinCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityStepUserJoin
     */
    select?: ActivityStepUserJoinSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityStepUserJoin
     */
    omit?: ActivityStepUserJoinOmit<ExtArgs> | null
    /**
     * The data used to create many ActivityStepUserJoins.
     */
    data: ActivityStepUserJoinCreateManyInput | ActivityStepUserJoinCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityStepUserJoinIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityStepUserJoin update
   */
  export type ActivityStepUserJoinUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityStepUserJoin
     */
    select?: ActivityStepUserJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityStepUserJoin
     */
    omit?: ActivityStepUserJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityStepUserJoinInclude<ExtArgs> | null
    /**
     * The data needed to update a ActivityStepUserJoin.
     */
    data: XOR<ActivityStepUserJoinUpdateInput, ActivityStepUserJoinUncheckedUpdateInput>
    /**
     * Choose, which ActivityStepUserJoin to update.
     */
    where: ActivityStepUserJoinWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityStepUserJoin updateMany
   */
  export type ActivityStepUserJoinUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActivityStepUserJoins.
     */
    data: XOR<ActivityStepUserJoinUpdateManyMutationInput, ActivityStepUserJoinUncheckedUpdateManyInput>
    /**
     * Filter which ActivityStepUserJoins to update
     */
    where?: ActivityStepUserJoinWhereInput
    /**
     * Limit how many ActivityStepUserJoins to update.
     */
    limit?: number
  }

  /**
   * ActivityStepUserJoin updateManyAndReturn
   */
  export type ActivityStepUserJoinUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityStepUserJoin
     */
    select?: ActivityStepUserJoinSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityStepUserJoin
     */
    omit?: ActivityStepUserJoinOmit<ExtArgs> | null
    /**
     * The data used to update ActivityStepUserJoins.
     */
    data: XOR<ActivityStepUserJoinUpdateManyMutationInput, ActivityStepUserJoinUncheckedUpdateManyInput>
    /**
     * Filter which ActivityStepUserJoins to update
     */
    where?: ActivityStepUserJoinWhereInput
    /**
     * Limit how many ActivityStepUserJoins to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityStepUserJoinIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityStepUserJoin upsert
   */
  export type ActivityStepUserJoinUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityStepUserJoin
     */
    select?: ActivityStepUserJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityStepUserJoin
     */
    omit?: ActivityStepUserJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityStepUserJoinInclude<ExtArgs> | null
    /**
     * The filter to search for the ActivityStepUserJoin to update in case it exists.
     */
    where: ActivityStepUserJoinWhereUniqueInput
    /**
     * In case the ActivityStepUserJoin found by the `where` argument doesn't exist, create a new ActivityStepUserJoin with this data.
     */
    create: XOR<ActivityStepUserJoinCreateInput, ActivityStepUserJoinUncheckedCreateInput>
    /**
     * In case the ActivityStepUserJoin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityStepUserJoinUpdateInput, ActivityStepUserJoinUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityStepUserJoin delete
   */
  export type ActivityStepUserJoinDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityStepUserJoin
     */
    select?: ActivityStepUserJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityStepUserJoin
     */
    omit?: ActivityStepUserJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityStepUserJoinInclude<ExtArgs> | null
    /**
     * Filter which ActivityStepUserJoin to delete.
     */
    where: ActivityStepUserJoinWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityStepUserJoin deleteMany
   */
  export type ActivityStepUserJoinDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityStepUserJoins to delete
     */
    where?: ActivityStepUserJoinWhereInput
    /**
     * Limit how many ActivityStepUserJoins to delete.
     */
    limit?: number
  }

  /**
   * ActivityStepUserJoin without action
   */
  export type ActivityStepUserJoinDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityStepUserJoin
     */
    select?: ActivityStepUserJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityStepUserJoin
     */
    omit?: ActivityStepUserJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityStepUserJoinInclude<ExtArgs> | null
  }


  /**
   * Model UserWaypointJoin
   */

  export type AggregateUserWaypointJoin = {
    _count: UserWaypointJoinCountAggregateOutputType | null
    _min: UserWaypointJoinMinAggregateOutputType | null
    _max: UserWaypointJoinMaxAggregateOutputType | null
  }

  export type UserWaypointJoinMinAggregateOutputType = {
    userId: Uint8Array | null
    waypointId: Uint8Array | null
  }

  export type UserWaypointJoinMaxAggregateOutputType = {
    userId: Uint8Array | null
    waypointId: Uint8Array | null
  }

  export type UserWaypointJoinCountAggregateOutputType = {
    userId: number
    waypointId: number
    _all: number
  }


  export type UserWaypointJoinMinAggregateInputType = {
    userId?: true
    waypointId?: true
  }

  export type UserWaypointJoinMaxAggregateInputType = {
    userId?: true
    waypointId?: true
  }

  export type UserWaypointJoinCountAggregateInputType = {
    userId?: true
    waypointId?: true
    _all?: true
  }

  export type UserWaypointJoinAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserWaypointJoin to aggregate.
     */
    where?: UserWaypointJoinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserWaypointJoins to fetch.
     */
    orderBy?: UserWaypointJoinOrderByWithRelationInput | UserWaypointJoinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWaypointJoinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserWaypointJoins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserWaypointJoins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserWaypointJoins
    **/
    _count?: true | UserWaypointJoinCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserWaypointJoinMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserWaypointJoinMaxAggregateInputType
  }

  export type GetUserWaypointJoinAggregateType<T extends UserWaypointJoinAggregateArgs> = {
        [P in keyof T & keyof AggregateUserWaypointJoin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserWaypointJoin[P]>
      : GetScalarType<T[P], AggregateUserWaypointJoin[P]>
  }




  export type UserWaypointJoinGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWaypointJoinWhereInput
    orderBy?: UserWaypointJoinOrderByWithAggregationInput | UserWaypointJoinOrderByWithAggregationInput[]
    by: UserWaypointJoinScalarFieldEnum[] | UserWaypointJoinScalarFieldEnum
    having?: UserWaypointJoinScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserWaypointJoinCountAggregateInputType | true
    _min?: UserWaypointJoinMinAggregateInputType
    _max?: UserWaypointJoinMaxAggregateInputType
  }

  export type UserWaypointJoinGroupByOutputType = {
    userId: Uint8Array
    waypointId: Uint8Array
    _count: UserWaypointJoinCountAggregateOutputType | null
    _min: UserWaypointJoinMinAggregateOutputType | null
    _max: UserWaypointJoinMaxAggregateOutputType | null
  }

  type GetUserWaypointJoinGroupByPayload<T extends UserWaypointJoinGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserWaypointJoinGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserWaypointJoinGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserWaypointJoinGroupByOutputType[P]>
            : GetScalarType<T[P], UserWaypointJoinGroupByOutputType[P]>
        }
      >
    >


  export type UserWaypointJoinSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    waypointId?: boolean
    userRelation?: boolean | UserDefaultArgs<ExtArgs>
    waypointRelation?: boolean | ActivityWaypointDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userWaypointJoin"]>

  export type UserWaypointJoinSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    waypointId?: boolean
    userRelation?: boolean | UserDefaultArgs<ExtArgs>
    waypointRelation?: boolean | ActivityWaypointDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userWaypointJoin"]>

  export type UserWaypointJoinSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    waypointId?: boolean
    userRelation?: boolean | UserDefaultArgs<ExtArgs>
    waypointRelation?: boolean | ActivityWaypointDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userWaypointJoin"]>

  export type UserWaypointJoinSelectScalar = {
    userId?: boolean
    waypointId?: boolean
  }

  export type UserWaypointJoinOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "waypointId", ExtArgs["result"]["userWaypointJoin"]>
  export type UserWaypointJoinInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userRelation?: boolean | UserDefaultArgs<ExtArgs>
    waypointRelation?: boolean | ActivityWaypointDefaultArgs<ExtArgs>
  }
  export type UserWaypointJoinIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userRelation?: boolean | UserDefaultArgs<ExtArgs>
    waypointRelation?: boolean | ActivityWaypointDefaultArgs<ExtArgs>
  }
  export type UserWaypointJoinIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userRelation?: boolean | UserDefaultArgs<ExtArgs>
    waypointRelation?: boolean | ActivityWaypointDefaultArgs<ExtArgs>
  }

  export type $UserWaypointJoinPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserWaypointJoin"
    objects: {
      userRelation: Prisma.$UserPayload<ExtArgs>
      waypointRelation: Prisma.$ActivityWaypointPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      /**
       * @@wrapper-ignore
       */
      userId: Uint8Array
      waypointId: Uint8Array
    }, ExtArgs["result"]["userWaypointJoin"]>
    composites: {}
  }

  type UserWaypointJoinGetPayload<S extends boolean | null | undefined | UserWaypointJoinDefaultArgs> = $Result.GetResult<Prisma.$UserWaypointJoinPayload, S>

  type UserWaypointJoinCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserWaypointJoinFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: UserWaypointJoinCountAggregateInputType | true
    }

  export interface UserWaypointJoinDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserWaypointJoin'], meta: { name: 'UserWaypointJoin' } }
    /**
     * Find zero or one UserWaypointJoin that matches the filter.
     * @param {UserWaypointJoinFindUniqueArgs} args - Arguments to find a UserWaypointJoin
     * @example
     * // Get one UserWaypointJoin
     * const userWaypointJoin = await prisma.userWaypointJoin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserWaypointJoinFindUniqueArgs>(args: SelectSubset<T, UserWaypointJoinFindUniqueArgs<ExtArgs>>): Prisma__UserWaypointJoinClient<$Result.GetResult<Prisma.$UserWaypointJoinPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one UserWaypointJoin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserWaypointJoinFindUniqueOrThrowArgs} args - Arguments to find a UserWaypointJoin
     * @example
     * // Get one UserWaypointJoin
     * const userWaypointJoin = await prisma.userWaypointJoin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserWaypointJoinFindUniqueOrThrowArgs>(args: SelectSubset<T, UserWaypointJoinFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserWaypointJoinClient<$Result.GetResult<Prisma.$UserWaypointJoinPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first UserWaypointJoin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserWaypointJoinFindFirstArgs} args - Arguments to find a UserWaypointJoin
     * @example
     * // Get one UserWaypointJoin
     * const userWaypointJoin = await prisma.userWaypointJoin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserWaypointJoinFindFirstArgs>(args?: SelectSubset<T, UserWaypointJoinFindFirstArgs<ExtArgs>>): Prisma__UserWaypointJoinClient<$Result.GetResult<Prisma.$UserWaypointJoinPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first UserWaypointJoin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserWaypointJoinFindFirstOrThrowArgs} args - Arguments to find a UserWaypointJoin
     * @example
     * // Get one UserWaypointJoin
     * const userWaypointJoin = await prisma.userWaypointJoin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserWaypointJoinFindFirstOrThrowArgs>(args?: SelectSubset<T, UserWaypointJoinFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserWaypointJoinClient<$Result.GetResult<Prisma.$UserWaypointJoinPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more UserWaypointJoins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserWaypointJoinFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserWaypointJoins
     * const userWaypointJoins = await prisma.userWaypointJoin.findMany()
     * 
     * // Get first 10 UserWaypointJoins
     * const userWaypointJoins = await prisma.userWaypointJoin.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userWaypointJoinWithUserIdOnly = await prisma.userWaypointJoin.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserWaypointJoinFindManyArgs>(args?: SelectSubset<T, UserWaypointJoinFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserWaypointJoinPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a UserWaypointJoin.
     * @param {UserWaypointJoinCreateArgs} args - Arguments to create a UserWaypointJoin.
     * @example
     * // Create one UserWaypointJoin
     * const UserWaypointJoin = await prisma.userWaypointJoin.create({
     *   data: {
     *     // ... data to create a UserWaypointJoin
     *   }
     * })
     * 
     */
    create<T extends UserWaypointJoinCreateArgs>(args: SelectSubset<T, UserWaypointJoinCreateArgs<ExtArgs>>): Prisma__UserWaypointJoinClient<$Result.GetResult<Prisma.$UserWaypointJoinPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many UserWaypointJoins.
     * @param {UserWaypointJoinCreateManyArgs} args - Arguments to create many UserWaypointJoins.
     * @example
     * // Create many UserWaypointJoins
     * const userWaypointJoin = await prisma.userWaypointJoin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserWaypointJoinCreateManyArgs>(args?: SelectSubset<T, UserWaypointJoinCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserWaypointJoins and returns the data saved in the database.
     * @param {UserWaypointJoinCreateManyAndReturnArgs} args - Arguments to create many UserWaypointJoins.
     * @example
     * // Create many UserWaypointJoins
     * const userWaypointJoin = await prisma.userWaypointJoin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserWaypointJoins and only return the `userId`
     * const userWaypointJoinWithUserIdOnly = await prisma.userWaypointJoin.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserWaypointJoinCreateManyAndReturnArgs>(args?: SelectSubset<T, UserWaypointJoinCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserWaypointJoinPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a UserWaypointJoin.
     * @param {UserWaypointJoinDeleteArgs} args - Arguments to delete one UserWaypointJoin.
     * @example
     * // Delete one UserWaypointJoin
     * const UserWaypointJoin = await prisma.userWaypointJoin.delete({
     *   where: {
     *     // ... filter to delete one UserWaypointJoin
     *   }
     * })
     * 
     */
    delete<T extends UserWaypointJoinDeleteArgs>(args: SelectSubset<T, UserWaypointJoinDeleteArgs<ExtArgs>>): Prisma__UserWaypointJoinClient<$Result.GetResult<Prisma.$UserWaypointJoinPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one UserWaypointJoin.
     * @param {UserWaypointJoinUpdateArgs} args - Arguments to update one UserWaypointJoin.
     * @example
     * // Update one UserWaypointJoin
     * const userWaypointJoin = await prisma.userWaypointJoin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserWaypointJoinUpdateArgs>(args: SelectSubset<T, UserWaypointJoinUpdateArgs<ExtArgs>>): Prisma__UserWaypointJoinClient<$Result.GetResult<Prisma.$UserWaypointJoinPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more UserWaypointJoins.
     * @param {UserWaypointJoinDeleteManyArgs} args - Arguments to filter UserWaypointJoins to delete.
     * @example
     * // Delete a few UserWaypointJoins
     * const { count } = await prisma.userWaypointJoin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserWaypointJoinDeleteManyArgs>(args?: SelectSubset<T, UserWaypointJoinDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserWaypointJoins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserWaypointJoinUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserWaypointJoins
     * const userWaypointJoin = await prisma.userWaypointJoin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserWaypointJoinUpdateManyArgs>(args: SelectSubset<T, UserWaypointJoinUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserWaypointJoins and returns the data updated in the database.
     * @param {UserWaypointJoinUpdateManyAndReturnArgs} args - Arguments to update many UserWaypointJoins.
     * @example
     * // Update many UserWaypointJoins
     * const userWaypointJoin = await prisma.userWaypointJoin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserWaypointJoins and only return the `userId`
     * const userWaypointJoinWithUserIdOnly = await prisma.userWaypointJoin.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserWaypointJoinUpdateManyAndReturnArgs>(args: SelectSubset<T, UserWaypointJoinUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserWaypointJoinPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one UserWaypointJoin.
     * @param {UserWaypointJoinUpsertArgs} args - Arguments to update or create a UserWaypointJoin.
     * @example
     * // Update or create a UserWaypointJoin
     * const userWaypointJoin = await prisma.userWaypointJoin.upsert({
     *   create: {
     *     // ... data to create a UserWaypointJoin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserWaypointJoin we want to update
     *   }
     * })
     */
    upsert<T extends UserWaypointJoinUpsertArgs>(args: SelectSubset<T, UserWaypointJoinUpsertArgs<ExtArgs>>): Prisma__UserWaypointJoinClient<$Result.GetResult<Prisma.$UserWaypointJoinPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of UserWaypointJoins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserWaypointJoinCountArgs} args - Arguments to filter UserWaypointJoins to count.
     * @example
     * // Count the number of UserWaypointJoins
     * const count = await prisma.userWaypointJoin.count({
     *   where: {
     *     // ... the filter for the UserWaypointJoins we want to count
     *   }
     * })
    **/
    count<T extends UserWaypointJoinCountArgs>(
      args?: Subset<T, UserWaypointJoinCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserWaypointJoinCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserWaypointJoin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserWaypointJoinAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserWaypointJoinAggregateArgs>(args: Subset<T, UserWaypointJoinAggregateArgs>): Prisma.PrismaPromise<GetUserWaypointJoinAggregateType<T>>

    /**
     * Group by UserWaypointJoin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserWaypointJoinGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserWaypointJoinGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserWaypointJoinGroupByArgs['orderBy'] }
        : { orderBy?: UserWaypointJoinGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserWaypointJoinGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserWaypointJoinGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserWaypointJoin model
   */
  readonly fields: UserWaypointJoinFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserWaypointJoin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserWaypointJoinClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userRelation<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    waypointRelation<T extends ActivityWaypointDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ActivityWaypointDefaultArgs<ExtArgs>>): Prisma__ActivityWaypointClient<$Result.GetResult<Prisma.$ActivityWaypointPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserWaypointJoin model
   */ 
  interface UserWaypointJoinFieldRefs {
    readonly userId: FieldRef<"UserWaypointJoin", 'Bytes'>
    readonly waypointId: FieldRef<"UserWaypointJoin", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * UserWaypointJoin findUnique
   */
  export type UserWaypointJoinFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWaypointJoin
     */
    select?: UserWaypointJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserWaypointJoin
     */
    omit?: UserWaypointJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWaypointJoinInclude<ExtArgs> | null
    /**
     * Filter, which UserWaypointJoin to fetch.
     */
    where: UserWaypointJoinWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserWaypointJoin findUniqueOrThrow
   */
  export type UserWaypointJoinFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWaypointJoin
     */
    select?: UserWaypointJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserWaypointJoin
     */
    omit?: UserWaypointJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWaypointJoinInclude<ExtArgs> | null
    /**
     * Filter, which UserWaypointJoin to fetch.
     */
    where: UserWaypointJoinWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserWaypointJoin findFirst
   */
  export type UserWaypointJoinFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWaypointJoin
     */
    select?: UserWaypointJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserWaypointJoin
     */
    omit?: UserWaypointJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWaypointJoinInclude<ExtArgs> | null
    /**
     * Filter, which UserWaypointJoin to fetch.
     */
    where?: UserWaypointJoinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserWaypointJoins to fetch.
     */
    orderBy?: UserWaypointJoinOrderByWithRelationInput | UserWaypointJoinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserWaypointJoins.
     */
    cursor?: UserWaypointJoinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserWaypointJoins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserWaypointJoins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserWaypointJoins.
     */
    distinct?: UserWaypointJoinScalarFieldEnum | UserWaypointJoinScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserWaypointJoin findFirstOrThrow
   */
  export type UserWaypointJoinFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWaypointJoin
     */
    select?: UserWaypointJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserWaypointJoin
     */
    omit?: UserWaypointJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWaypointJoinInclude<ExtArgs> | null
    /**
     * Filter, which UserWaypointJoin to fetch.
     */
    where?: UserWaypointJoinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserWaypointJoins to fetch.
     */
    orderBy?: UserWaypointJoinOrderByWithRelationInput | UserWaypointJoinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserWaypointJoins.
     */
    cursor?: UserWaypointJoinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserWaypointJoins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserWaypointJoins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserWaypointJoins.
     */
    distinct?: UserWaypointJoinScalarFieldEnum | UserWaypointJoinScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserWaypointJoin findMany
   */
  export type UserWaypointJoinFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWaypointJoin
     */
    select?: UserWaypointJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserWaypointJoin
     */
    omit?: UserWaypointJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWaypointJoinInclude<ExtArgs> | null
    /**
     * Filter, which UserWaypointJoins to fetch.
     */
    where?: UserWaypointJoinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserWaypointJoins to fetch.
     */
    orderBy?: UserWaypointJoinOrderByWithRelationInput | UserWaypointJoinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserWaypointJoins.
     */
    cursor?: UserWaypointJoinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserWaypointJoins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserWaypointJoins.
     */
    skip?: number
    distinct?: UserWaypointJoinScalarFieldEnum | UserWaypointJoinScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserWaypointJoin create
   */
  export type UserWaypointJoinCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWaypointJoin
     */
    select?: UserWaypointJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserWaypointJoin
     */
    omit?: UserWaypointJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWaypointJoinInclude<ExtArgs> | null
    /**
     * The data needed to create a UserWaypointJoin.
     */
    data: XOR<UserWaypointJoinCreateInput, UserWaypointJoinUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserWaypointJoin createMany
   */
  export type UserWaypointJoinCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserWaypointJoins.
     */
    data: UserWaypointJoinCreateManyInput | UserWaypointJoinCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserWaypointJoin createManyAndReturn
   */
  export type UserWaypointJoinCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWaypointJoin
     */
    select?: UserWaypointJoinSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserWaypointJoin
     */
    omit?: UserWaypointJoinOmit<ExtArgs> | null
    /**
     * The data used to create many UserWaypointJoins.
     */
    data: UserWaypointJoinCreateManyInput | UserWaypointJoinCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWaypointJoinIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserWaypointJoin update
   */
  export type UserWaypointJoinUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWaypointJoin
     */
    select?: UserWaypointJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserWaypointJoin
     */
    omit?: UserWaypointJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWaypointJoinInclude<ExtArgs> | null
    /**
     * The data needed to update a UserWaypointJoin.
     */
    data: XOR<UserWaypointJoinUpdateInput, UserWaypointJoinUncheckedUpdateInput>
    /**
     * Choose, which UserWaypointJoin to update.
     */
    where: UserWaypointJoinWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserWaypointJoin updateMany
   */
  export type UserWaypointJoinUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserWaypointJoins.
     */
    data: XOR<UserWaypointJoinUpdateManyMutationInput, UserWaypointJoinUncheckedUpdateManyInput>
    /**
     * Filter which UserWaypointJoins to update
     */
    where?: UserWaypointJoinWhereInput
    /**
     * Limit how many UserWaypointJoins to update.
     */
    limit?: number
  }

  /**
   * UserWaypointJoin updateManyAndReturn
   */
  export type UserWaypointJoinUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWaypointJoin
     */
    select?: UserWaypointJoinSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserWaypointJoin
     */
    omit?: UserWaypointJoinOmit<ExtArgs> | null
    /**
     * The data used to update UserWaypointJoins.
     */
    data: XOR<UserWaypointJoinUpdateManyMutationInput, UserWaypointJoinUncheckedUpdateManyInput>
    /**
     * Filter which UserWaypointJoins to update
     */
    where?: UserWaypointJoinWhereInput
    /**
     * Limit how many UserWaypointJoins to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWaypointJoinIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserWaypointJoin upsert
   */
  export type UserWaypointJoinUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWaypointJoin
     */
    select?: UserWaypointJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserWaypointJoin
     */
    omit?: UserWaypointJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWaypointJoinInclude<ExtArgs> | null
    /**
     * The filter to search for the UserWaypointJoin to update in case it exists.
     */
    where: UserWaypointJoinWhereUniqueInput
    /**
     * In case the UserWaypointJoin found by the `where` argument doesn't exist, create a new UserWaypointJoin with this data.
     */
    create: XOR<UserWaypointJoinCreateInput, UserWaypointJoinUncheckedCreateInput>
    /**
     * In case the UserWaypointJoin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserWaypointJoinUpdateInput, UserWaypointJoinUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserWaypointJoin delete
   */
  export type UserWaypointJoinDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWaypointJoin
     */
    select?: UserWaypointJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserWaypointJoin
     */
    omit?: UserWaypointJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWaypointJoinInclude<ExtArgs> | null
    /**
     * Filter which UserWaypointJoin to delete.
     */
    where: UserWaypointJoinWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserWaypointJoin deleteMany
   */
  export type UserWaypointJoinDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserWaypointJoins to delete
     */
    where?: UserWaypointJoinWhereInput
    /**
     * Limit how many UserWaypointJoins to delete.
     */
    limit?: number
  }

  /**
   * UserWaypointJoin without action
   */
  export type UserWaypointJoinDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWaypointJoin
     */
    select?: UserWaypointJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserWaypointJoin
     */
    omit?: UserWaypointJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWaypointJoinInclude<ExtArgs> | null
  }


  /**
   * Model ActivityWaypoint
   */

  export type AggregateActivityWaypoint = {
    _count: ActivityWaypointCountAggregateOutputType | null
    _avg: ActivityWaypointAvgAggregateOutputType | null
    _sum: ActivityWaypointSumAggregateOutputType | null
    _min: ActivityWaypointMinAggregateOutputType | null
    _max: ActivityWaypointMaxAggregateOutputType | null
  }

  export type ActivityWaypointAvgAggregateOutputType = {
    order: number | null
  }

  export type ActivityWaypointSumAggregateOutputType = {
    order: number | null
  }

  export type ActivityWaypointMinAggregateOutputType = {
    id: Uint8Array | null
    title: string | null
    description: string | null
    summary: string | null
    status: $Enums.ActivityStatus | null
    order: number | null
    actualStart: Date | null
    dueDate: Date | null
    actualEnd: Date | null
    activityId: Uint8Array | null
    templateId: Uint8Array | null
    createdAt: Date | null
    updatedAt: Date | null
    tenetId: Uint8Array | null
  }

  export type ActivityWaypointMaxAggregateOutputType = {
    id: Uint8Array | null
    title: string | null
    description: string | null
    summary: string | null
    status: $Enums.ActivityStatus | null
    order: number | null
    actualStart: Date | null
    dueDate: Date | null
    actualEnd: Date | null
    activityId: Uint8Array | null
    templateId: Uint8Array | null
    createdAt: Date | null
    updatedAt: Date | null
    tenetId: Uint8Array | null
  }

  export type ActivityWaypointCountAggregateOutputType = {
    id: number
    title: number
    description: number
    summary: number
    status: number
    order: number
    actualStart: number
    dueDate: number
    actualEnd: number
    activityId: number
    templateId: number
    createdAt: number
    updatedAt: number
    tenetId: number
    _all: number
  }


  export type ActivityWaypointAvgAggregateInputType = {
    order?: true
  }

  export type ActivityWaypointSumAggregateInputType = {
    order?: true
  }

  export type ActivityWaypointMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    summary?: true
    status?: true
    order?: true
    actualStart?: true
    dueDate?: true
    actualEnd?: true
    activityId?: true
    templateId?: true
    createdAt?: true
    updatedAt?: true
    tenetId?: true
  }

  export type ActivityWaypointMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    summary?: true
    status?: true
    order?: true
    actualStart?: true
    dueDate?: true
    actualEnd?: true
    activityId?: true
    templateId?: true
    createdAt?: true
    updatedAt?: true
    tenetId?: true
  }

  export type ActivityWaypointCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    summary?: true
    status?: true
    order?: true
    actualStart?: true
    dueDate?: true
    actualEnd?: true
    activityId?: true
    templateId?: true
    createdAt?: true
    updatedAt?: true
    tenetId?: true
    _all?: true
  }

  export type ActivityWaypointAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityWaypoint to aggregate.
     */
    where?: ActivityWaypointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityWaypoints to fetch.
     */
    orderBy?: ActivityWaypointOrderByWithRelationInput | ActivityWaypointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityWaypointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityWaypoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityWaypoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActivityWaypoints
    **/
    _count?: true | ActivityWaypointCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActivityWaypointAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActivityWaypointSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityWaypointMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityWaypointMaxAggregateInputType
  }

  export type GetActivityWaypointAggregateType<T extends ActivityWaypointAggregateArgs> = {
        [P in keyof T & keyof AggregateActivityWaypoint]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivityWaypoint[P]>
      : GetScalarType<T[P], AggregateActivityWaypoint[P]>
  }




  export type ActivityWaypointGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWaypointWhereInput
    orderBy?: ActivityWaypointOrderByWithAggregationInput | ActivityWaypointOrderByWithAggregationInput[]
    by: ActivityWaypointScalarFieldEnum[] | ActivityWaypointScalarFieldEnum
    having?: ActivityWaypointScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityWaypointCountAggregateInputType | true
    _avg?: ActivityWaypointAvgAggregateInputType
    _sum?: ActivityWaypointSumAggregateInputType
    _min?: ActivityWaypointMinAggregateInputType
    _max?: ActivityWaypointMaxAggregateInputType
  }

  export type ActivityWaypointGroupByOutputType = {
    id: Uint8Array
    title: string
    description: string | null
    summary: string | null
    status: $Enums.ActivityStatus
    order: number
    actualStart: Date
    dueDate: Date
    actualEnd: Date | null
    activityId: Uint8Array
    templateId: Uint8Array | null
    createdAt: Date
    updatedAt: Date
    tenetId: Uint8Array
    _count: ActivityWaypointCountAggregateOutputType | null
    _avg: ActivityWaypointAvgAggregateOutputType | null
    _sum: ActivityWaypointSumAggregateOutputType | null
    _min: ActivityWaypointMinAggregateOutputType | null
    _max: ActivityWaypointMaxAggregateOutputType | null
  }

  type GetActivityWaypointGroupByPayload<T extends ActivityWaypointGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityWaypointGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityWaypointGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityWaypointGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityWaypointGroupByOutputType[P]>
        }
      >
    >


  export type ActivityWaypointSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    summary?: boolean
    status?: boolean
    order?: boolean
    actualStart?: boolean
    dueDate?: boolean
    actualEnd?: boolean
    activityId?: boolean
    templateId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenetId?: boolean
    users?: boolean | ActivityWaypoint$usersArgs<ExtArgs>
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
    childActivities?: boolean | ActivityWaypoint$childActivitiesArgs<ExtArgs>
    template?: boolean | ActivityWaypoint$templateArgs<ExtArgs>
    events?: boolean | ActivityWaypoint$eventsArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
    Note?: boolean | ActivityWaypoint$NoteArgs<ExtArgs>
    _count?: boolean | ActivityWaypointCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityWaypoint"]>

  export type ActivityWaypointSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    summary?: boolean
    status?: boolean
    order?: boolean
    actualStart?: boolean
    dueDate?: boolean
    actualEnd?: boolean
    activityId?: boolean
    templateId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenetId?: boolean
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
    template?: boolean | ActivityWaypoint$templateArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityWaypoint"]>

  export type ActivityWaypointSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    summary?: boolean
    status?: boolean
    order?: boolean
    actualStart?: boolean
    dueDate?: boolean
    actualEnd?: boolean
    activityId?: boolean
    templateId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenetId?: boolean
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
    template?: boolean | ActivityWaypoint$templateArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityWaypoint"]>

  export type ActivityWaypointSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    summary?: boolean
    status?: boolean
    order?: boolean
    actualStart?: boolean
    dueDate?: boolean
    actualEnd?: boolean
    activityId?: boolean
    templateId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenetId?: boolean
  }

  export type ActivityWaypointOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "summary" | "status" | "order" | "actualStart" | "dueDate" | "actualEnd" | "activityId" | "templateId" | "createdAt" | "updatedAt" | "tenetId", ExtArgs["result"]["activityWaypoint"]>
  export type ActivityWaypointInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | ActivityWaypoint$usersArgs<ExtArgs>
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
    childActivities?: boolean | ActivityWaypoint$childActivitiesArgs<ExtArgs>
    template?: boolean | ActivityWaypoint$templateArgs<ExtArgs>
    events?: boolean | ActivityWaypoint$eventsArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
    Note?: boolean | ActivityWaypoint$NoteArgs<ExtArgs>
    _count?: boolean | ActivityWaypointCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ActivityWaypointIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
    template?: boolean | ActivityWaypoint$templateArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }
  export type ActivityWaypointIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activity?: boolean | ActivityDefaultArgs<ExtArgs>
    template?: boolean | ActivityWaypoint$templateArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }

  export type $ActivityWaypointPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActivityWaypoint"
    objects: {
      /**
       * @ai-field(Users who are involved in this waypoint)
       * @jointable(User, userRelation)
       */
      users: Prisma.$UserWaypointJoinPayload<ExtArgs>[]
      /**
       * @ai-field(Parent activity of this waypoint)
       */
      activity: Prisma.$ActivityPayload<ExtArgs>
      /**
       * @ai-field(Activities associated with this waypoint)
       */
      childActivities: Prisma.$ActivityPayload<ExtArgs>[]
      template: Prisma.$ActivityWaypointTemplatePayload<ExtArgs> | null
      events: Prisma.$ContactTimelineEventPayload<ExtArgs>[]
      tenet: Prisma.$TenetPayload<ExtArgs>
      Note: Prisma.$NotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      /**
       * @@ai-enabled
       */
      id: Uint8Array
      title: string
      description: string | null
      summary: string | null
      status: $Enums.ActivityStatus
      order: number
      actualStart: Date
      dueDate: Date
      actualEnd: Date | null
      /**
       * @ai-field
       */
      activityId: Uint8Array
      templateId: Uint8Array | null
      createdAt: Date
      updatedAt: Date
      tenetId: Uint8Array
    }, ExtArgs["result"]["activityWaypoint"]>
    composites: {}
  }

  type ActivityWaypointGetPayload<S extends boolean | null | undefined | ActivityWaypointDefaultArgs> = $Result.GetResult<Prisma.$ActivityWaypointPayload, S>

  type ActivityWaypointCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActivityWaypointFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: ActivityWaypointCountAggregateInputType | true
    }

  export interface ActivityWaypointDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActivityWaypoint'], meta: { name: 'ActivityWaypoint' } }
    /**
     * Find zero or one ActivityWaypoint that matches the filter.
     * @param {ActivityWaypointFindUniqueArgs} args - Arguments to find a ActivityWaypoint
     * @example
     * // Get one ActivityWaypoint
     * const activityWaypoint = await prisma.activityWaypoint.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityWaypointFindUniqueArgs>(args: SelectSubset<T, ActivityWaypointFindUniqueArgs<ExtArgs>>): Prisma__ActivityWaypointClient<$Result.GetResult<Prisma.$ActivityWaypointPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ActivityWaypoint that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActivityWaypointFindUniqueOrThrowArgs} args - Arguments to find a ActivityWaypoint
     * @example
     * // Get one ActivityWaypoint
     * const activityWaypoint = await prisma.activityWaypoint.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityWaypointFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityWaypointFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityWaypointClient<$Result.GetResult<Prisma.$ActivityWaypointPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ActivityWaypoint that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityWaypointFindFirstArgs} args - Arguments to find a ActivityWaypoint
     * @example
     * // Get one ActivityWaypoint
     * const activityWaypoint = await prisma.activityWaypoint.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityWaypointFindFirstArgs>(args?: SelectSubset<T, ActivityWaypointFindFirstArgs<ExtArgs>>): Prisma__ActivityWaypointClient<$Result.GetResult<Prisma.$ActivityWaypointPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ActivityWaypoint that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityWaypointFindFirstOrThrowArgs} args - Arguments to find a ActivityWaypoint
     * @example
     * // Get one ActivityWaypoint
     * const activityWaypoint = await prisma.activityWaypoint.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityWaypointFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityWaypointFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityWaypointClient<$Result.GetResult<Prisma.$ActivityWaypointPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ActivityWaypoints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityWaypointFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActivityWaypoints
     * const activityWaypoints = await prisma.activityWaypoint.findMany()
     * 
     * // Get first 10 ActivityWaypoints
     * const activityWaypoints = await prisma.activityWaypoint.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityWaypointWithIdOnly = await prisma.activityWaypoint.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityWaypointFindManyArgs>(args?: SelectSubset<T, ActivityWaypointFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityWaypointPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ActivityWaypoint.
     * @param {ActivityWaypointCreateArgs} args - Arguments to create a ActivityWaypoint.
     * @example
     * // Create one ActivityWaypoint
     * const ActivityWaypoint = await prisma.activityWaypoint.create({
     *   data: {
     *     // ... data to create a ActivityWaypoint
     *   }
     * })
     * 
     */
    create<T extends ActivityWaypointCreateArgs>(args: SelectSubset<T, ActivityWaypointCreateArgs<ExtArgs>>): Prisma__ActivityWaypointClient<$Result.GetResult<Prisma.$ActivityWaypointPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ActivityWaypoints.
     * @param {ActivityWaypointCreateManyArgs} args - Arguments to create many ActivityWaypoints.
     * @example
     * // Create many ActivityWaypoints
     * const activityWaypoint = await prisma.activityWaypoint.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityWaypointCreateManyArgs>(args?: SelectSubset<T, ActivityWaypointCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActivityWaypoints and returns the data saved in the database.
     * @param {ActivityWaypointCreateManyAndReturnArgs} args - Arguments to create many ActivityWaypoints.
     * @example
     * // Create many ActivityWaypoints
     * const activityWaypoint = await prisma.activityWaypoint.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActivityWaypoints and only return the `id`
     * const activityWaypointWithIdOnly = await prisma.activityWaypoint.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityWaypointCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityWaypointCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityWaypointPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a ActivityWaypoint.
     * @param {ActivityWaypointDeleteArgs} args - Arguments to delete one ActivityWaypoint.
     * @example
     * // Delete one ActivityWaypoint
     * const ActivityWaypoint = await prisma.activityWaypoint.delete({
     *   where: {
     *     // ... filter to delete one ActivityWaypoint
     *   }
     * })
     * 
     */
    delete<T extends ActivityWaypointDeleteArgs>(args: SelectSubset<T, ActivityWaypointDeleteArgs<ExtArgs>>): Prisma__ActivityWaypointClient<$Result.GetResult<Prisma.$ActivityWaypointPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ActivityWaypoint.
     * @param {ActivityWaypointUpdateArgs} args - Arguments to update one ActivityWaypoint.
     * @example
     * // Update one ActivityWaypoint
     * const activityWaypoint = await prisma.activityWaypoint.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityWaypointUpdateArgs>(args: SelectSubset<T, ActivityWaypointUpdateArgs<ExtArgs>>): Prisma__ActivityWaypointClient<$Result.GetResult<Prisma.$ActivityWaypointPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ActivityWaypoints.
     * @param {ActivityWaypointDeleteManyArgs} args - Arguments to filter ActivityWaypoints to delete.
     * @example
     * // Delete a few ActivityWaypoints
     * const { count } = await prisma.activityWaypoint.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityWaypointDeleteManyArgs>(args?: SelectSubset<T, ActivityWaypointDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityWaypoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityWaypointUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActivityWaypoints
     * const activityWaypoint = await prisma.activityWaypoint.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityWaypointUpdateManyArgs>(args: SelectSubset<T, ActivityWaypointUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityWaypoints and returns the data updated in the database.
     * @param {ActivityWaypointUpdateManyAndReturnArgs} args - Arguments to update many ActivityWaypoints.
     * @example
     * // Update many ActivityWaypoints
     * const activityWaypoint = await prisma.activityWaypoint.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ActivityWaypoints and only return the `id`
     * const activityWaypointWithIdOnly = await prisma.activityWaypoint.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActivityWaypointUpdateManyAndReturnArgs>(args: SelectSubset<T, ActivityWaypointUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityWaypointPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one ActivityWaypoint.
     * @param {ActivityWaypointUpsertArgs} args - Arguments to update or create a ActivityWaypoint.
     * @example
     * // Update or create a ActivityWaypoint
     * const activityWaypoint = await prisma.activityWaypoint.upsert({
     *   create: {
     *     // ... data to create a ActivityWaypoint
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActivityWaypoint we want to update
     *   }
     * })
     */
    upsert<T extends ActivityWaypointUpsertArgs>(args: SelectSubset<T, ActivityWaypointUpsertArgs<ExtArgs>>): Prisma__ActivityWaypointClient<$Result.GetResult<Prisma.$ActivityWaypointPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ActivityWaypoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityWaypointCountArgs} args - Arguments to filter ActivityWaypoints to count.
     * @example
     * // Count the number of ActivityWaypoints
     * const count = await prisma.activityWaypoint.count({
     *   where: {
     *     // ... the filter for the ActivityWaypoints we want to count
     *   }
     * })
    **/
    count<T extends ActivityWaypointCountArgs>(
      args?: Subset<T, ActivityWaypointCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityWaypointCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActivityWaypoint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityWaypointAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityWaypointAggregateArgs>(args: Subset<T, ActivityWaypointAggregateArgs>): Prisma.PrismaPromise<GetActivityWaypointAggregateType<T>>

    /**
     * Group by ActivityWaypoint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityWaypointGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityWaypointGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityWaypointGroupByArgs['orderBy'] }
        : { orderBy?: ActivityWaypointGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityWaypointGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityWaypointGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActivityWaypoint model
   */
  readonly fields: ActivityWaypointFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActivityWaypoint.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityWaypointClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends ActivityWaypoint$usersArgs<ExtArgs> = {}>(args?: Subset<T, ActivityWaypoint$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserWaypointJoinPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    activity<T extends ActivityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ActivityDefaultArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    childActivities<T extends ActivityWaypoint$childActivitiesArgs<ExtArgs> = {}>(args?: Subset<T, ActivityWaypoint$childActivitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    template<T extends ActivityWaypoint$templateArgs<ExtArgs> = {}>(args?: Subset<T, ActivityWaypoint$templateArgs<ExtArgs>>): Prisma__ActivityWaypointTemplateClient<$Result.GetResult<Prisma.$ActivityWaypointTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    events<T extends ActivityWaypoint$eventsArgs<ExtArgs> = {}>(args?: Subset<T, ActivityWaypoint$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactTimelineEventPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    tenet<T extends TenetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenetDefaultArgs<ExtArgs>>): Prisma__TenetClient<$Result.GetResult<Prisma.$TenetPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    Note<T extends ActivityWaypoint$NoteArgs<ExtArgs> = {}>(args?: Subset<T, ActivityWaypoint$NoteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActivityWaypoint model
   */ 
  interface ActivityWaypointFieldRefs {
    readonly id: FieldRef<"ActivityWaypoint", 'Bytes'>
    readonly title: FieldRef<"ActivityWaypoint", 'String'>
    readonly description: FieldRef<"ActivityWaypoint", 'String'>
    readonly summary: FieldRef<"ActivityWaypoint", 'String'>
    readonly status: FieldRef<"ActivityWaypoint", 'ActivityStatus'>
    readonly order: FieldRef<"ActivityWaypoint", 'Int'>
    readonly actualStart: FieldRef<"ActivityWaypoint", 'DateTime'>
    readonly dueDate: FieldRef<"ActivityWaypoint", 'DateTime'>
    readonly actualEnd: FieldRef<"ActivityWaypoint", 'DateTime'>
    readonly activityId: FieldRef<"ActivityWaypoint", 'Bytes'>
    readonly templateId: FieldRef<"ActivityWaypoint", 'Bytes'>
    readonly createdAt: FieldRef<"ActivityWaypoint", 'DateTime'>
    readonly updatedAt: FieldRef<"ActivityWaypoint", 'DateTime'>
    readonly tenetId: FieldRef<"ActivityWaypoint", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * ActivityWaypoint findUnique
   */
  export type ActivityWaypointFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityWaypoint
     */
    select?: ActivityWaypointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityWaypoint
     */
    omit?: ActivityWaypointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityWaypointInclude<ExtArgs> | null
    /**
     * Filter, which ActivityWaypoint to fetch.
     */
    where: ActivityWaypointWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityWaypoint findUniqueOrThrow
   */
  export type ActivityWaypointFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityWaypoint
     */
    select?: ActivityWaypointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityWaypoint
     */
    omit?: ActivityWaypointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityWaypointInclude<ExtArgs> | null
    /**
     * Filter, which ActivityWaypoint to fetch.
     */
    where: ActivityWaypointWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityWaypoint findFirst
   */
  export type ActivityWaypointFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityWaypoint
     */
    select?: ActivityWaypointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityWaypoint
     */
    omit?: ActivityWaypointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityWaypointInclude<ExtArgs> | null
    /**
     * Filter, which ActivityWaypoint to fetch.
     */
    where?: ActivityWaypointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityWaypoints to fetch.
     */
    orderBy?: ActivityWaypointOrderByWithRelationInput | ActivityWaypointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityWaypoints.
     */
    cursor?: ActivityWaypointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityWaypoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityWaypoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityWaypoints.
     */
    distinct?: ActivityWaypointScalarFieldEnum | ActivityWaypointScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityWaypoint findFirstOrThrow
   */
  export type ActivityWaypointFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityWaypoint
     */
    select?: ActivityWaypointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityWaypoint
     */
    omit?: ActivityWaypointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityWaypointInclude<ExtArgs> | null
    /**
     * Filter, which ActivityWaypoint to fetch.
     */
    where?: ActivityWaypointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityWaypoints to fetch.
     */
    orderBy?: ActivityWaypointOrderByWithRelationInput | ActivityWaypointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityWaypoints.
     */
    cursor?: ActivityWaypointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityWaypoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityWaypoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityWaypoints.
     */
    distinct?: ActivityWaypointScalarFieldEnum | ActivityWaypointScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityWaypoint findMany
   */
  export type ActivityWaypointFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityWaypoint
     */
    select?: ActivityWaypointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityWaypoint
     */
    omit?: ActivityWaypointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityWaypointInclude<ExtArgs> | null
    /**
     * Filter, which ActivityWaypoints to fetch.
     */
    where?: ActivityWaypointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityWaypoints to fetch.
     */
    orderBy?: ActivityWaypointOrderByWithRelationInput | ActivityWaypointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActivityWaypoints.
     */
    cursor?: ActivityWaypointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityWaypoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityWaypoints.
     */
    skip?: number
    distinct?: ActivityWaypointScalarFieldEnum | ActivityWaypointScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityWaypoint create
   */
  export type ActivityWaypointCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityWaypoint
     */
    select?: ActivityWaypointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityWaypoint
     */
    omit?: ActivityWaypointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityWaypointInclude<ExtArgs> | null
    /**
     * The data needed to create a ActivityWaypoint.
     */
    data: XOR<ActivityWaypointCreateInput, ActivityWaypointUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityWaypoint createMany
   */
  export type ActivityWaypointCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActivityWaypoints.
     */
    data: ActivityWaypointCreateManyInput | ActivityWaypointCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActivityWaypoint createManyAndReturn
   */
  export type ActivityWaypointCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityWaypoint
     */
    select?: ActivityWaypointSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityWaypoint
     */
    omit?: ActivityWaypointOmit<ExtArgs> | null
    /**
     * The data used to create many ActivityWaypoints.
     */
    data: ActivityWaypointCreateManyInput | ActivityWaypointCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityWaypointIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityWaypoint update
   */
  export type ActivityWaypointUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityWaypoint
     */
    select?: ActivityWaypointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityWaypoint
     */
    omit?: ActivityWaypointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityWaypointInclude<ExtArgs> | null
    /**
     * The data needed to update a ActivityWaypoint.
     */
    data: XOR<ActivityWaypointUpdateInput, ActivityWaypointUncheckedUpdateInput>
    /**
     * Choose, which ActivityWaypoint to update.
     */
    where: ActivityWaypointWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityWaypoint updateMany
   */
  export type ActivityWaypointUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActivityWaypoints.
     */
    data: XOR<ActivityWaypointUpdateManyMutationInput, ActivityWaypointUncheckedUpdateManyInput>
    /**
     * Filter which ActivityWaypoints to update
     */
    where?: ActivityWaypointWhereInput
    /**
     * Limit how many ActivityWaypoints to update.
     */
    limit?: number
  }

  /**
   * ActivityWaypoint updateManyAndReturn
   */
  export type ActivityWaypointUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityWaypoint
     */
    select?: ActivityWaypointSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityWaypoint
     */
    omit?: ActivityWaypointOmit<ExtArgs> | null
    /**
     * The data used to update ActivityWaypoints.
     */
    data: XOR<ActivityWaypointUpdateManyMutationInput, ActivityWaypointUncheckedUpdateManyInput>
    /**
     * Filter which ActivityWaypoints to update
     */
    where?: ActivityWaypointWhereInput
    /**
     * Limit how many ActivityWaypoints to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityWaypointIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityWaypoint upsert
   */
  export type ActivityWaypointUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityWaypoint
     */
    select?: ActivityWaypointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityWaypoint
     */
    omit?: ActivityWaypointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityWaypointInclude<ExtArgs> | null
    /**
     * The filter to search for the ActivityWaypoint to update in case it exists.
     */
    where: ActivityWaypointWhereUniqueInput
    /**
     * In case the ActivityWaypoint found by the `where` argument doesn't exist, create a new ActivityWaypoint with this data.
     */
    create: XOR<ActivityWaypointCreateInput, ActivityWaypointUncheckedCreateInput>
    /**
     * In case the ActivityWaypoint was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityWaypointUpdateInput, ActivityWaypointUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityWaypoint delete
   */
  export type ActivityWaypointDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityWaypoint
     */
    select?: ActivityWaypointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityWaypoint
     */
    omit?: ActivityWaypointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityWaypointInclude<ExtArgs> | null
    /**
     * Filter which ActivityWaypoint to delete.
     */
    where: ActivityWaypointWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityWaypoint deleteMany
   */
  export type ActivityWaypointDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityWaypoints to delete
     */
    where?: ActivityWaypointWhereInput
    /**
     * Limit how many ActivityWaypoints to delete.
     */
    limit?: number
  }

  /**
   * ActivityWaypoint.users
   */
  export type ActivityWaypoint$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserWaypointJoin
     */
    select?: UserWaypointJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserWaypointJoin
     */
    omit?: UserWaypointJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserWaypointJoinInclude<ExtArgs> | null
    where?: UserWaypointJoinWhereInput
    orderBy?: UserWaypointJoinOrderByWithRelationInput | UserWaypointJoinOrderByWithRelationInput[]
    cursor?: UserWaypointJoinWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserWaypointJoinScalarFieldEnum | UserWaypointJoinScalarFieldEnum[]
  }

  /**
   * ActivityWaypoint.childActivities
   */
  export type ActivityWaypoint$childActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    cursor?: ActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * ActivityWaypoint.template
   */
  export type ActivityWaypoint$templateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityWaypointTemplate
     */
    select?: ActivityWaypointTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityWaypointTemplate
     */
    omit?: ActivityWaypointTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityWaypointTemplateInclude<ExtArgs> | null
    where?: ActivityWaypointTemplateWhereInput
  }

  /**
   * ActivityWaypoint.events
   */
  export type ActivityWaypoint$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTimelineEvent
     */
    select?: ContactTimelineEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTimelineEvent
     */
    omit?: ContactTimelineEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTimelineEventInclude<ExtArgs> | null
    where?: ContactTimelineEventWhereInput
    orderBy?: ContactTimelineEventOrderByWithRelationInput | ContactTimelineEventOrderByWithRelationInput[]
    cursor?: ContactTimelineEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactTimelineEventScalarFieldEnum | ContactTimelineEventScalarFieldEnum[]
  }

  /**
   * ActivityWaypoint.Note
   */
  export type ActivityWaypoint$NoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    where?: NoteWhereInput
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    cursor?: NoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * ActivityWaypoint without action
   */
  export type ActivityWaypointDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityWaypoint
     */
    select?: ActivityWaypointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityWaypoint
     */
    omit?: ActivityWaypointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityWaypointInclude<ExtArgs> | null
  }


  /**
   * Model TemplateAssignment
   */

  export type AggregateTemplateAssignment = {
    _count: TemplateAssignmentCountAggregateOutputType | null
    _min: TemplateAssignmentMinAggregateOutputType | null
    _max: TemplateAssignmentMaxAggregateOutputType | null
  }

  export type TemplateAssignmentMinAggregateOutputType = {
    id: Uint8Array | null
    specificUserId: Uint8Array | null
    specificRole: $Enums.Role | null
    activityTemplateId: Uint8Array | null
    waypointTemplateId: Uint8Array | null
    createdAt: Date | null
    updatedAt: Date | null
    tenetId: Uint8Array | null
  }

  export type TemplateAssignmentMaxAggregateOutputType = {
    id: Uint8Array | null
    specificUserId: Uint8Array | null
    specificRole: $Enums.Role | null
    activityTemplateId: Uint8Array | null
    waypointTemplateId: Uint8Array | null
    createdAt: Date | null
    updatedAt: Date | null
    tenetId: Uint8Array | null
  }

  export type TemplateAssignmentCountAggregateOutputType = {
    id: number
    specificUserId: number
    specificRole: number
    activityTemplateId: number
    waypointTemplateId: number
    createdAt: number
    updatedAt: number
    tenetId: number
    _all: number
  }


  export type TemplateAssignmentMinAggregateInputType = {
    id?: true
    specificUserId?: true
    specificRole?: true
    activityTemplateId?: true
    waypointTemplateId?: true
    createdAt?: true
    updatedAt?: true
    tenetId?: true
  }

  export type TemplateAssignmentMaxAggregateInputType = {
    id?: true
    specificUserId?: true
    specificRole?: true
    activityTemplateId?: true
    waypointTemplateId?: true
    createdAt?: true
    updatedAt?: true
    tenetId?: true
  }

  export type TemplateAssignmentCountAggregateInputType = {
    id?: true
    specificUserId?: true
    specificRole?: true
    activityTemplateId?: true
    waypointTemplateId?: true
    createdAt?: true
    updatedAt?: true
    tenetId?: true
    _all?: true
  }

  export type TemplateAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TemplateAssignment to aggregate.
     */
    where?: TemplateAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateAssignments to fetch.
     */
    orderBy?: TemplateAssignmentOrderByWithRelationInput | TemplateAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TemplateAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TemplateAssignments
    **/
    _count?: true | TemplateAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TemplateAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TemplateAssignmentMaxAggregateInputType
  }

  export type GetTemplateAssignmentAggregateType<T extends TemplateAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateTemplateAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTemplateAssignment[P]>
      : GetScalarType<T[P], AggregateTemplateAssignment[P]>
  }




  export type TemplateAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TemplateAssignmentWhereInput
    orderBy?: TemplateAssignmentOrderByWithAggregationInput | TemplateAssignmentOrderByWithAggregationInput[]
    by: TemplateAssignmentScalarFieldEnum[] | TemplateAssignmentScalarFieldEnum
    having?: TemplateAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TemplateAssignmentCountAggregateInputType | true
    _min?: TemplateAssignmentMinAggregateInputType
    _max?: TemplateAssignmentMaxAggregateInputType
  }

  export type TemplateAssignmentGroupByOutputType = {
    id: Uint8Array
    specificUserId: Uint8Array | null
    specificRole: $Enums.Role | null
    activityTemplateId: Uint8Array | null
    waypointTemplateId: Uint8Array | null
    createdAt: Date
    updatedAt: Date
    tenetId: Uint8Array
    _count: TemplateAssignmentCountAggregateOutputType | null
    _min: TemplateAssignmentMinAggregateOutputType | null
    _max: TemplateAssignmentMaxAggregateOutputType | null
  }

  type GetTemplateAssignmentGroupByPayload<T extends TemplateAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TemplateAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TemplateAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TemplateAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], TemplateAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type TemplateAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    specificUserId?: boolean
    specificRole?: boolean
    activityTemplateId?: boolean
    waypointTemplateId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenetId?: boolean
    specificUser?: boolean | TemplateAssignment$specificUserArgs<ExtArgs>
    activityTemplate?: boolean | TemplateAssignment$activityTemplateArgs<ExtArgs>
    waypointTemplate?: boolean | TemplateAssignment$waypointTemplateArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["templateAssignment"]>

  export type TemplateAssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    specificUserId?: boolean
    specificRole?: boolean
    activityTemplateId?: boolean
    waypointTemplateId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenetId?: boolean
    specificUser?: boolean | TemplateAssignment$specificUserArgs<ExtArgs>
    activityTemplate?: boolean | TemplateAssignment$activityTemplateArgs<ExtArgs>
    waypointTemplate?: boolean | TemplateAssignment$waypointTemplateArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["templateAssignment"]>

  export type TemplateAssignmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    specificUserId?: boolean
    specificRole?: boolean
    activityTemplateId?: boolean
    waypointTemplateId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenetId?: boolean
    specificUser?: boolean | TemplateAssignment$specificUserArgs<ExtArgs>
    activityTemplate?: boolean | TemplateAssignment$activityTemplateArgs<ExtArgs>
    waypointTemplate?: boolean | TemplateAssignment$waypointTemplateArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["templateAssignment"]>

  export type TemplateAssignmentSelectScalar = {
    id?: boolean
    specificUserId?: boolean
    specificRole?: boolean
    activityTemplateId?: boolean
    waypointTemplateId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenetId?: boolean
  }

  export type TemplateAssignmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "specificUserId" | "specificRole" | "activityTemplateId" | "waypointTemplateId" | "createdAt" | "updatedAt" | "tenetId", ExtArgs["result"]["templateAssignment"]>
  export type TemplateAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    specificUser?: boolean | TemplateAssignment$specificUserArgs<ExtArgs>
    activityTemplate?: boolean | TemplateAssignment$activityTemplateArgs<ExtArgs>
    waypointTemplate?: boolean | TemplateAssignment$waypointTemplateArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }
  export type TemplateAssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    specificUser?: boolean | TemplateAssignment$specificUserArgs<ExtArgs>
    activityTemplate?: boolean | TemplateAssignment$activityTemplateArgs<ExtArgs>
    waypointTemplate?: boolean | TemplateAssignment$waypointTemplateArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }
  export type TemplateAssignmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    specificUser?: boolean | TemplateAssignment$specificUserArgs<ExtArgs>
    activityTemplate?: boolean | TemplateAssignment$activityTemplateArgs<ExtArgs>
    waypointTemplate?: boolean | TemplateAssignment$waypointTemplateArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }

  export type $TemplateAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TemplateAssignment"
    objects: {
      specificUser: Prisma.$UserPayload<ExtArgs> | null
      activityTemplate: Prisma.$ActivityTemplatePayload<ExtArgs> | null
      waypointTemplate: Prisma.$ActivityWaypointTemplatePayload<ExtArgs> | null
      tenet: Prisma.$TenetPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: Uint8Array
      specificUserId: Uint8Array | null
      specificRole: $Enums.Role | null
      activityTemplateId: Uint8Array | null
      waypointTemplateId: Uint8Array | null
      createdAt: Date
      updatedAt: Date
      tenetId: Uint8Array
    }, ExtArgs["result"]["templateAssignment"]>
    composites: {}
  }

  type TemplateAssignmentGetPayload<S extends boolean | null | undefined | TemplateAssignmentDefaultArgs> = $Result.GetResult<Prisma.$TemplateAssignmentPayload, S>

  type TemplateAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TemplateAssignmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: TemplateAssignmentCountAggregateInputType | true
    }

  export interface TemplateAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TemplateAssignment'], meta: { name: 'TemplateAssignment' } }
    /**
     * Find zero or one TemplateAssignment that matches the filter.
     * @param {TemplateAssignmentFindUniqueArgs} args - Arguments to find a TemplateAssignment
     * @example
     * // Get one TemplateAssignment
     * const templateAssignment = await prisma.templateAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TemplateAssignmentFindUniqueArgs>(args: SelectSubset<T, TemplateAssignmentFindUniqueArgs<ExtArgs>>): Prisma__TemplateAssignmentClient<$Result.GetResult<Prisma.$TemplateAssignmentPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one TemplateAssignment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TemplateAssignmentFindUniqueOrThrowArgs} args - Arguments to find a TemplateAssignment
     * @example
     * // Get one TemplateAssignment
     * const templateAssignment = await prisma.templateAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TemplateAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, TemplateAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TemplateAssignmentClient<$Result.GetResult<Prisma.$TemplateAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first TemplateAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateAssignmentFindFirstArgs} args - Arguments to find a TemplateAssignment
     * @example
     * // Get one TemplateAssignment
     * const templateAssignment = await prisma.templateAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TemplateAssignmentFindFirstArgs>(args?: SelectSubset<T, TemplateAssignmentFindFirstArgs<ExtArgs>>): Prisma__TemplateAssignmentClient<$Result.GetResult<Prisma.$TemplateAssignmentPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first TemplateAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateAssignmentFindFirstOrThrowArgs} args - Arguments to find a TemplateAssignment
     * @example
     * // Get one TemplateAssignment
     * const templateAssignment = await prisma.templateAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TemplateAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, TemplateAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__TemplateAssignmentClient<$Result.GetResult<Prisma.$TemplateAssignmentPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more TemplateAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TemplateAssignments
     * const templateAssignments = await prisma.templateAssignment.findMany()
     * 
     * // Get first 10 TemplateAssignments
     * const templateAssignments = await prisma.templateAssignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const templateAssignmentWithIdOnly = await prisma.templateAssignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TemplateAssignmentFindManyArgs>(args?: SelectSubset<T, TemplateAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplateAssignmentPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a TemplateAssignment.
     * @param {TemplateAssignmentCreateArgs} args - Arguments to create a TemplateAssignment.
     * @example
     * // Create one TemplateAssignment
     * const TemplateAssignment = await prisma.templateAssignment.create({
     *   data: {
     *     // ... data to create a TemplateAssignment
     *   }
     * })
     * 
     */
    create<T extends TemplateAssignmentCreateArgs>(args: SelectSubset<T, TemplateAssignmentCreateArgs<ExtArgs>>): Prisma__TemplateAssignmentClient<$Result.GetResult<Prisma.$TemplateAssignmentPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many TemplateAssignments.
     * @param {TemplateAssignmentCreateManyArgs} args - Arguments to create many TemplateAssignments.
     * @example
     * // Create many TemplateAssignments
     * const templateAssignment = await prisma.templateAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TemplateAssignmentCreateManyArgs>(args?: SelectSubset<T, TemplateAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TemplateAssignments and returns the data saved in the database.
     * @param {TemplateAssignmentCreateManyAndReturnArgs} args - Arguments to create many TemplateAssignments.
     * @example
     * // Create many TemplateAssignments
     * const templateAssignment = await prisma.templateAssignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TemplateAssignments and only return the `id`
     * const templateAssignmentWithIdOnly = await prisma.templateAssignment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TemplateAssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, TemplateAssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplateAssignmentPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a TemplateAssignment.
     * @param {TemplateAssignmentDeleteArgs} args - Arguments to delete one TemplateAssignment.
     * @example
     * // Delete one TemplateAssignment
     * const TemplateAssignment = await prisma.templateAssignment.delete({
     *   where: {
     *     // ... filter to delete one TemplateAssignment
     *   }
     * })
     * 
     */
    delete<T extends TemplateAssignmentDeleteArgs>(args: SelectSubset<T, TemplateAssignmentDeleteArgs<ExtArgs>>): Prisma__TemplateAssignmentClient<$Result.GetResult<Prisma.$TemplateAssignmentPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one TemplateAssignment.
     * @param {TemplateAssignmentUpdateArgs} args - Arguments to update one TemplateAssignment.
     * @example
     * // Update one TemplateAssignment
     * const templateAssignment = await prisma.templateAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TemplateAssignmentUpdateArgs>(args: SelectSubset<T, TemplateAssignmentUpdateArgs<ExtArgs>>): Prisma__TemplateAssignmentClient<$Result.GetResult<Prisma.$TemplateAssignmentPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more TemplateAssignments.
     * @param {TemplateAssignmentDeleteManyArgs} args - Arguments to filter TemplateAssignments to delete.
     * @example
     * // Delete a few TemplateAssignments
     * const { count } = await prisma.templateAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TemplateAssignmentDeleteManyArgs>(args?: SelectSubset<T, TemplateAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TemplateAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TemplateAssignments
     * const templateAssignment = await prisma.templateAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TemplateAssignmentUpdateManyArgs>(args: SelectSubset<T, TemplateAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TemplateAssignments and returns the data updated in the database.
     * @param {TemplateAssignmentUpdateManyAndReturnArgs} args - Arguments to update many TemplateAssignments.
     * @example
     * // Update many TemplateAssignments
     * const templateAssignment = await prisma.templateAssignment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TemplateAssignments and only return the `id`
     * const templateAssignmentWithIdOnly = await prisma.templateAssignment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TemplateAssignmentUpdateManyAndReturnArgs>(args: SelectSubset<T, TemplateAssignmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplateAssignmentPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one TemplateAssignment.
     * @param {TemplateAssignmentUpsertArgs} args - Arguments to update or create a TemplateAssignment.
     * @example
     * // Update or create a TemplateAssignment
     * const templateAssignment = await prisma.templateAssignment.upsert({
     *   create: {
     *     // ... data to create a TemplateAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TemplateAssignment we want to update
     *   }
     * })
     */
    upsert<T extends TemplateAssignmentUpsertArgs>(args: SelectSubset<T, TemplateAssignmentUpsertArgs<ExtArgs>>): Prisma__TemplateAssignmentClient<$Result.GetResult<Prisma.$TemplateAssignmentPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of TemplateAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateAssignmentCountArgs} args - Arguments to filter TemplateAssignments to count.
     * @example
     * // Count the number of TemplateAssignments
     * const count = await prisma.templateAssignment.count({
     *   where: {
     *     // ... the filter for the TemplateAssignments we want to count
     *   }
     * })
    **/
    count<T extends TemplateAssignmentCountArgs>(
      args?: Subset<T, TemplateAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TemplateAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TemplateAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TemplateAssignmentAggregateArgs>(args: Subset<T, TemplateAssignmentAggregateArgs>): Prisma.PrismaPromise<GetTemplateAssignmentAggregateType<T>>

    /**
     * Group by TemplateAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TemplateAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TemplateAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: TemplateAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TemplateAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTemplateAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TemplateAssignment model
   */
  readonly fields: TemplateAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TemplateAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TemplateAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    specificUser<T extends TemplateAssignment$specificUserArgs<ExtArgs> = {}>(args?: Subset<T, TemplateAssignment$specificUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    activityTemplate<T extends TemplateAssignment$activityTemplateArgs<ExtArgs> = {}>(args?: Subset<T, TemplateAssignment$activityTemplateArgs<ExtArgs>>): Prisma__ActivityTemplateClient<$Result.GetResult<Prisma.$ActivityTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    waypointTemplate<T extends TemplateAssignment$waypointTemplateArgs<ExtArgs> = {}>(args?: Subset<T, TemplateAssignment$waypointTemplateArgs<ExtArgs>>): Prisma__ActivityWaypointTemplateClient<$Result.GetResult<Prisma.$ActivityWaypointTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    tenet<T extends TenetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenetDefaultArgs<ExtArgs>>): Prisma__TenetClient<$Result.GetResult<Prisma.$TenetPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TemplateAssignment model
   */ 
  interface TemplateAssignmentFieldRefs {
    readonly id: FieldRef<"TemplateAssignment", 'Bytes'>
    readonly specificUserId: FieldRef<"TemplateAssignment", 'Bytes'>
    readonly specificRole: FieldRef<"TemplateAssignment", 'Role'>
    readonly activityTemplateId: FieldRef<"TemplateAssignment", 'Bytes'>
    readonly waypointTemplateId: FieldRef<"TemplateAssignment", 'Bytes'>
    readonly createdAt: FieldRef<"TemplateAssignment", 'DateTime'>
    readonly updatedAt: FieldRef<"TemplateAssignment", 'DateTime'>
    readonly tenetId: FieldRef<"TemplateAssignment", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * TemplateAssignment findUnique
   */
  export type TemplateAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateAssignment
     */
    select?: TemplateAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateAssignment
     */
    omit?: TemplateAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which TemplateAssignment to fetch.
     */
    where: TemplateAssignmentWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TemplateAssignment findUniqueOrThrow
   */
  export type TemplateAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateAssignment
     */
    select?: TemplateAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateAssignment
     */
    omit?: TemplateAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which TemplateAssignment to fetch.
     */
    where: TemplateAssignmentWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TemplateAssignment findFirst
   */
  export type TemplateAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateAssignment
     */
    select?: TemplateAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateAssignment
     */
    omit?: TemplateAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which TemplateAssignment to fetch.
     */
    where?: TemplateAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateAssignments to fetch.
     */
    orderBy?: TemplateAssignmentOrderByWithRelationInput | TemplateAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TemplateAssignments.
     */
    cursor?: TemplateAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TemplateAssignments.
     */
    distinct?: TemplateAssignmentScalarFieldEnum | TemplateAssignmentScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TemplateAssignment findFirstOrThrow
   */
  export type TemplateAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateAssignment
     */
    select?: TemplateAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateAssignment
     */
    omit?: TemplateAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which TemplateAssignment to fetch.
     */
    where?: TemplateAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateAssignments to fetch.
     */
    orderBy?: TemplateAssignmentOrderByWithRelationInput | TemplateAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TemplateAssignments.
     */
    cursor?: TemplateAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TemplateAssignments.
     */
    distinct?: TemplateAssignmentScalarFieldEnum | TemplateAssignmentScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TemplateAssignment findMany
   */
  export type TemplateAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateAssignment
     */
    select?: TemplateAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateAssignment
     */
    omit?: TemplateAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which TemplateAssignments to fetch.
     */
    where?: TemplateAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateAssignments to fetch.
     */
    orderBy?: TemplateAssignmentOrderByWithRelationInput | TemplateAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TemplateAssignments.
     */
    cursor?: TemplateAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateAssignments.
     */
    skip?: number
    distinct?: TemplateAssignmentScalarFieldEnum | TemplateAssignmentScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TemplateAssignment create
   */
  export type TemplateAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateAssignment
     */
    select?: TemplateAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateAssignment
     */
    omit?: TemplateAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a TemplateAssignment.
     */
    data: XOR<TemplateAssignmentCreateInput, TemplateAssignmentUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TemplateAssignment createMany
   */
  export type TemplateAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TemplateAssignments.
     */
    data: TemplateAssignmentCreateManyInput | TemplateAssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TemplateAssignment createManyAndReturn
   */
  export type TemplateAssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateAssignment
     */
    select?: TemplateAssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateAssignment
     */
    omit?: TemplateAssignmentOmit<ExtArgs> | null
    /**
     * The data used to create many TemplateAssignments.
     */
    data: TemplateAssignmentCreateManyInput | TemplateAssignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateAssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TemplateAssignment update
   */
  export type TemplateAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateAssignment
     */
    select?: TemplateAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateAssignment
     */
    omit?: TemplateAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a TemplateAssignment.
     */
    data: XOR<TemplateAssignmentUpdateInput, TemplateAssignmentUncheckedUpdateInput>
    /**
     * Choose, which TemplateAssignment to update.
     */
    where: TemplateAssignmentWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TemplateAssignment updateMany
   */
  export type TemplateAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TemplateAssignments.
     */
    data: XOR<TemplateAssignmentUpdateManyMutationInput, TemplateAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which TemplateAssignments to update
     */
    where?: TemplateAssignmentWhereInput
    /**
     * Limit how many TemplateAssignments to update.
     */
    limit?: number
  }

  /**
   * TemplateAssignment updateManyAndReturn
   */
  export type TemplateAssignmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateAssignment
     */
    select?: TemplateAssignmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateAssignment
     */
    omit?: TemplateAssignmentOmit<ExtArgs> | null
    /**
     * The data used to update TemplateAssignments.
     */
    data: XOR<TemplateAssignmentUpdateManyMutationInput, TemplateAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which TemplateAssignments to update
     */
    where?: TemplateAssignmentWhereInput
    /**
     * Limit how many TemplateAssignments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateAssignmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TemplateAssignment upsert
   */
  export type TemplateAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateAssignment
     */
    select?: TemplateAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateAssignment
     */
    omit?: TemplateAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the TemplateAssignment to update in case it exists.
     */
    where: TemplateAssignmentWhereUniqueInput
    /**
     * In case the TemplateAssignment found by the `where` argument doesn't exist, create a new TemplateAssignment with this data.
     */
    create: XOR<TemplateAssignmentCreateInput, TemplateAssignmentUncheckedCreateInput>
    /**
     * In case the TemplateAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TemplateAssignmentUpdateInput, TemplateAssignmentUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TemplateAssignment delete
   */
  export type TemplateAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateAssignment
     */
    select?: TemplateAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateAssignment
     */
    omit?: TemplateAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateAssignmentInclude<ExtArgs> | null
    /**
     * Filter which TemplateAssignment to delete.
     */
    where: TemplateAssignmentWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TemplateAssignment deleteMany
   */
  export type TemplateAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TemplateAssignments to delete
     */
    where?: TemplateAssignmentWhereInput
    /**
     * Limit how many TemplateAssignments to delete.
     */
    limit?: number
  }

  /**
   * TemplateAssignment.specificUser
   */
  export type TemplateAssignment$specificUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * TemplateAssignment.activityTemplate
   */
  export type TemplateAssignment$activityTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityTemplate
     */
    select?: ActivityTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityTemplate
     */
    omit?: ActivityTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityTemplateInclude<ExtArgs> | null
    where?: ActivityTemplateWhereInput
  }

  /**
   * TemplateAssignment.waypointTemplate
   */
  export type TemplateAssignment$waypointTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityWaypointTemplate
     */
    select?: ActivityWaypointTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityWaypointTemplate
     */
    omit?: ActivityWaypointTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityWaypointTemplateInclude<ExtArgs> | null
    where?: ActivityWaypointTemplateWhereInput
  }

  /**
   * TemplateAssignment without action
   */
  export type TemplateAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateAssignment
     */
    select?: TemplateAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateAssignment
     */
    omit?: TemplateAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateAssignmentInclude<ExtArgs> | null
  }


  /**
   * Model ActivityWaypointTemplate
   */

  export type AggregateActivityWaypointTemplate = {
    _count: ActivityWaypointTemplateCountAggregateOutputType | null
    _avg: ActivityWaypointTemplateAvgAggregateOutputType | null
    _sum: ActivityWaypointTemplateSumAggregateOutputType | null
    _min: ActivityWaypointTemplateMinAggregateOutputType | null
    _max: ActivityWaypointTemplateMaxAggregateOutputType | null
  }

  export type ActivityWaypointTemplateAvgAggregateOutputType = {
    order: number | null
    dueDate: number | null
  }

  export type ActivityWaypointTemplateSumAggregateOutputType = {
    order: number | null
    dueDate: number | null
  }

  export type ActivityWaypointTemplateMinAggregateOutputType = {
    id: Uint8Array | null
    title: string | null
    description: string | null
    defaultStatus: $Enums.ActivityStatus | null
    order: number | null
    dateOffsetType: $Enums.DateOffsetType | null
    dueDate: number | null
    parentActivityId: Uint8Array | null
    createdAt: Date | null
    updatedAt: Date | null
    tenetId: Uint8Array | null
  }

  export type ActivityWaypointTemplateMaxAggregateOutputType = {
    id: Uint8Array | null
    title: string | null
    description: string | null
    defaultStatus: $Enums.ActivityStatus | null
    order: number | null
    dateOffsetType: $Enums.DateOffsetType | null
    dueDate: number | null
    parentActivityId: Uint8Array | null
    createdAt: Date | null
    updatedAt: Date | null
    tenetId: Uint8Array | null
  }

  export type ActivityWaypointTemplateCountAggregateOutputType = {
    id: number
    title: number
    description: number
    defaultStatus: number
    order: number
    dateOffsetType: number
    dueDate: number
    parentActivityId: number
    createdAt: number
    updatedAt: number
    tenetId: number
    _all: number
  }


  export type ActivityWaypointTemplateAvgAggregateInputType = {
    order?: true
    dueDate?: true
  }

  export type ActivityWaypointTemplateSumAggregateInputType = {
    order?: true
    dueDate?: true
  }

  export type ActivityWaypointTemplateMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    defaultStatus?: true
    order?: true
    dateOffsetType?: true
    dueDate?: true
    parentActivityId?: true
    createdAt?: true
    updatedAt?: true
    tenetId?: true
  }

  export type ActivityWaypointTemplateMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    defaultStatus?: true
    order?: true
    dateOffsetType?: true
    dueDate?: true
    parentActivityId?: true
    createdAt?: true
    updatedAt?: true
    tenetId?: true
  }

  export type ActivityWaypointTemplateCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    defaultStatus?: true
    order?: true
    dateOffsetType?: true
    dueDate?: true
    parentActivityId?: true
    createdAt?: true
    updatedAt?: true
    tenetId?: true
    _all?: true
  }

  export type ActivityWaypointTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityWaypointTemplate to aggregate.
     */
    where?: ActivityWaypointTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityWaypointTemplates to fetch.
     */
    orderBy?: ActivityWaypointTemplateOrderByWithRelationInput | ActivityWaypointTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityWaypointTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityWaypointTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityWaypointTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActivityWaypointTemplates
    **/
    _count?: true | ActivityWaypointTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActivityWaypointTemplateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActivityWaypointTemplateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityWaypointTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityWaypointTemplateMaxAggregateInputType
  }

  export type GetActivityWaypointTemplateAggregateType<T extends ActivityWaypointTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateActivityWaypointTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivityWaypointTemplate[P]>
      : GetScalarType<T[P], AggregateActivityWaypointTemplate[P]>
  }




  export type ActivityWaypointTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWaypointTemplateWhereInput
    orderBy?: ActivityWaypointTemplateOrderByWithAggregationInput | ActivityWaypointTemplateOrderByWithAggregationInput[]
    by: ActivityWaypointTemplateScalarFieldEnum[] | ActivityWaypointTemplateScalarFieldEnum
    having?: ActivityWaypointTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityWaypointTemplateCountAggregateInputType | true
    _avg?: ActivityWaypointTemplateAvgAggregateInputType
    _sum?: ActivityWaypointTemplateSumAggregateInputType
    _min?: ActivityWaypointTemplateMinAggregateInputType
    _max?: ActivityWaypointTemplateMaxAggregateInputType
  }

  export type ActivityWaypointTemplateGroupByOutputType = {
    id: Uint8Array
    title: string
    description: string | null
    defaultStatus: $Enums.ActivityStatus
    order: number
    dateOffsetType: $Enums.DateOffsetType
    dueDate: number
    parentActivityId: Uint8Array
    createdAt: Date
    updatedAt: Date
    tenetId: Uint8Array
    _count: ActivityWaypointTemplateCountAggregateOutputType | null
    _avg: ActivityWaypointTemplateAvgAggregateOutputType | null
    _sum: ActivityWaypointTemplateSumAggregateOutputType | null
    _min: ActivityWaypointTemplateMinAggregateOutputType | null
    _max: ActivityWaypointTemplateMaxAggregateOutputType | null
  }

  type GetActivityWaypointTemplateGroupByPayload<T extends ActivityWaypointTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityWaypointTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityWaypointTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityWaypointTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityWaypointTemplateGroupByOutputType[P]>
        }
      >
    >


  export type ActivityWaypointTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    defaultStatus?: boolean
    order?: boolean
    dateOffsetType?: boolean
    dueDate?: boolean
    parentActivityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenetId?: boolean
    parentActivity?: boolean | ActivityTemplateDefaultArgs<ExtArgs>
    activities?: boolean | ActivityWaypointTemplate$activitiesArgs<ExtArgs>
    waypoints?: boolean | ActivityWaypointTemplate$waypointsArgs<ExtArgs>
    assignments?: boolean | ActivityWaypointTemplate$assignmentsArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
    _count?: boolean | ActivityWaypointTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityWaypointTemplate"]>

  export type ActivityWaypointTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    defaultStatus?: boolean
    order?: boolean
    dateOffsetType?: boolean
    dueDate?: boolean
    parentActivityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenetId?: boolean
    parentActivity?: boolean | ActivityTemplateDefaultArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityWaypointTemplate"]>

  export type ActivityWaypointTemplateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    defaultStatus?: boolean
    order?: boolean
    dateOffsetType?: boolean
    dueDate?: boolean
    parentActivityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenetId?: boolean
    parentActivity?: boolean | ActivityTemplateDefaultArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityWaypointTemplate"]>

  export type ActivityWaypointTemplateSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    defaultStatus?: boolean
    order?: boolean
    dateOffsetType?: boolean
    dueDate?: boolean
    parentActivityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenetId?: boolean
  }

  export type ActivityWaypointTemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "defaultStatus" | "order" | "dateOffsetType" | "dueDate" | "parentActivityId" | "createdAt" | "updatedAt" | "tenetId", ExtArgs["result"]["activityWaypointTemplate"]>
  export type ActivityWaypointTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parentActivity?: boolean | ActivityTemplateDefaultArgs<ExtArgs>
    activities?: boolean | ActivityWaypointTemplate$activitiesArgs<ExtArgs>
    waypoints?: boolean | ActivityWaypointTemplate$waypointsArgs<ExtArgs>
    assignments?: boolean | ActivityWaypointTemplate$assignmentsArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
    _count?: boolean | ActivityWaypointTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ActivityWaypointTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parentActivity?: boolean | ActivityTemplateDefaultArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }
  export type ActivityWaypointTemplateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parentActivity?: boolean | ActivityTemplateDefaultArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }

  export type $ActivityWaypointTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActivityWaypointTemplate"
    objects: {
      parentActivity: Prisma.$ActivityTemplatePayload<ExtArgs>
      activities: Prisma.$ActivityTemplatePayload<ExtArgs>[]
      waypoints: Prisma.$ActivityWaypointPayload<ExtArgs>[]
      assignments: Prisma.$TemplateAssignmentPayload<ExtArgs>[]
      tenet: Prisma.$TenetPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: Uint8Array
      title: string
      description: string | null
      defaultStatus: $Enums.ActivityStatus
      order: number
      dateOffsetType: $Enums.DateOffsetType
      dueDate: number
      parentActivityId: Uint8Array
      createdAt: Date
      updatedAt: Date
      tenetId: Uint8Array
    }, ExtArgs["result"]["activityWaypointTemplate"]>
    composites: {}
  }

  type ActivityWaypointTemplateGetPayload<S extends boolean | null | undefined | ActivityWaypointTemplateDefaultArgs> = $Result.GetResult<Prisma.$ActivityWaypointTemplatePayload, S>

  type ActivityWaypointTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActivityWaypointTemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: ActivityWaypointTemplateCountAggregateInputType | true
    }

  export interface ActivityWaypointTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActivityWaypointTemplate'], meta: { name: 'ActivityWaypointTemplate' } }
    /**
     * Find zero or one ActivityWaypointTemplate that matches the filter.
     * @param {ActivityWaypointTemplateFindUniqueArgs} args - Arguments to find a ActivityWaypointTemplate
     * @example
     * // Get one ActivityWaypointTemplate
     * const activityWaypointTemplate = await prisma.activityWaypointTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityWaypointTemplateFindUniqueArgs>(args: SelectSubset<T, ActivityWaypointTemplateFindUniqueArgs<ExtArgs>>): Prisma__ActivityWaypointTemplateClient<$Result.GetResult<Prisma.$ActivityWaypointTemplatePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ActivityWaypointTemplate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActivityWaypointTemplateFindUniqueOrThrowArgs} args - Arguments to find a ActivityWaypointTemplate
     * @example
     * // Get one ActivityWaypointTemplate
     * const activityWaypointTemplate = await prisma.activityWaypointTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityWaypointTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityWaypointTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityWaypointTemplateClient<$Result.GetResult<Prisma.$ActivityWaypointTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ActivityWaypointTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityWaypointTemplateFindFirstArgs} args - Arguments to find a ActivityWaypointTemplate
     * @example
     * // Get one ActivityWaypointTemplate
     * const activityWaypointTemplate = await prisma.activityWaypointTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityWaypointTemplateFindFirstArgs>(args?: SelectSubset<T, ActivityWaypointTemplateFindFirstArgs<ExtArgs>>): Prisma__ActivityWaypointTemplateClient<$Result.GetResult<Prisma.$ActivityWaypointTemplatePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ActivityWaypointTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityWaypointTemplateFindFirstOrThrowArgs} args - Arguments to find a ActivityWaypointTemplate
     * @example
     * // Get one ActivityWaypointTemplate
     * const activityWaypointTemplate = await prisma.activityWaypointTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityWaypointTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityWaypointTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityWaypointTemplateClient<$Result.GetResult<Prisma.$ActivityWaypointTemplatePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ActivityWaypointTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityWaypointTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActivityWaypointTemplates
     * const activityWaypointTemplates = await prisma.activityWaypointTemplate.findMany()
     * 
     * // Get first 10 ActivityWaypointTemplates
     * const activityWaypointTemplates = await prisma.activityWaypointTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityWaypointTemplateWithIdOnly = await prisma.activityWaypointTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityWaypointTemplateFindManyArgs>(args?: SelectSubset<T, ActivityWaypointTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityWaypointTemplatePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ActivityWaypointTemplate.
     * @param {ActivityWaypointTemplateCreateArgs} args - Arguments to create a ActivityWaypointTemplate.
     * @example
     * // Create one ActivityWaypointTemplate
     * const ActivityWaypointTemplate = await prisma.activityWaypointTemplate.create({
     *   data: {
     *     // ... data to create a ActivityWaypointTemplate
     *   }
     * })
     * 
     */
    create<T extends ActivityWaypointTemplateCreateArgs>(args: SelectSubset<T, ActivityWaypointTemplateCreateArgs<ExtArgs>>): Prisma__ActivityWaypointTemplateClient<$Result.GetResult<Prisma.$ActivityWaypointTemplatePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ActivityWaypointTemplates.
     * @param {ActivityWaypointTemplateCreateManyArgs} args - Arguments to create many ActivityWaypointTemplates.
     * @example
     * // Create many ActivityWaypointTemplates
     * const activityWaypointTemplate = await prisma.activityWaypointTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityWaypointTemplateCreateManyArgs>(args?: SelectSubset<T, ActivityWaypointTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActivityWaypointTemplates and returns the data saved in the database.
     * @param {ActivityWaypointTemplateCreateManyAndReturnArgs} args - Arguments to create many ActivityWaypointTemplates.
     * @example
     * // Create many ActivityWaypointTemplates
     * const activityWaypointTemplate = await prisma.activityWaypointTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActivityWaypointTemplates and only return the `id`
     * const activityWaypointTemplateWithIdOnly = await prisma.activityWaypointTemplate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityWaypointTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityWaypointTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityWaypointTemplatePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a ActivityWaypointTemplate.
     * @param {ActivityWaypointTemplateDeleteArgs} args - Arguments to delete one ActivityWaypointTemplate.
     * @example
     * // Delete one ActivityWaypointTemplate
     * const ActivityWaypointTemplate = await prisma.activityWaypointTemplate.delete({
     *   where: {
     *     // ... filter to delete one ActivityWaypointTemplate
     *   }
     * })
     * 
     */
    delete<T extends ActivityWaypointTemplateDeleteArgs>(args: SelectSubset<T, ActivityWaypointTemplateDeleteArgs<ExtArgs>>): Prisma__ActivityWaypointTemplateClient<$Result.GetResult<Prisma.$ActivityWaypointTemplatePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ActivityWaypointTemplate.
     * @param {ActivityWaypointTemplateUpdateArgs} args - Arguments to update one ActivityWaypointTemplate.
     * @example
     * // Update one ActivityWaypointTemplate
     * const activityWaypointTemplate = await prisma.activityWaypointTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityWaypointTemplateUpdateArgs>(args: SelectSubset<T, ActivityWaypointTemplateUpdateArgs<ExtArgs>>): Prisma__ActivityWaypointTemplateClient<$Result.GetResult<Prisma.$ActivityWaypointTemplatePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ActivityWaypointTemplates.
     * @param {ActivityWaypointTemplateDeleteManyArgs} args - Arguments to filter ActivityWaypointTemplates to delete.
     * @example
     * // Delete a few ActivityWaypointTemplates
     * const { count } = await prisma.activityWaypointTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityWaypointTemplateDeleteManyArgs>(args?: SelectSubset<T, ActivityWaypointTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityWaypointTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityWaypointTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActivityWaypointTemplates
     * const activityWaypointTemplate = await prisma.activityWaypointTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityWaypointTemplateUpdateManyArgs>(args: SelectSubset<T, ActivityWaypointTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityWaypointTemplates and returns the data updated in the database.
     * @param {ActivityWaypointTemplateUpdateManyAndReturnArgs} args - Arguments to update many ActivityWaypointTemplates.
     * @example
     * // Update many ActivityWaypointTemplates
     * const activityWaypointTemplate = await prisma.activityWaypointTemplate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ActivityWaypointTemplates and only return the `id`
     * const activityWaypointTemplateWithIdOnly = await prisma.activityWaypointTemplate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActivityWaypointTemplateUpdateManyAndReturnArgs>(args: SelectSubset<T, ActivityWaypointTemplateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityWaypointTemplatePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one ActivityWaypointTemplate.
     * @param {ActivityWaypointTemplateUpsertArgs} args - Arguments to update or create a ActivityWaypointTemplate.
     * @example
     * // Update or create a ActivityWaypointTemplate
     * const activityWaypointTemplate = await prisma.activityWaypointTemplate.upsert({
     *   create: {
     *     // ... data to create a ActivityWaypointTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActivityWaypointTemplate we want to update
     *   }
     * })
     */
    upsert<T extends ActivityWaypointTemplateUpsertArgs>(args: SelectSubset<T, ActivityWaypointTemplateUpsertArgs<ExtArgs>>): Prisma__ActivityWaypointTemplateClient<$Result.GetResult<Prisma.$ActivityWaypointTemplatePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ActivityWaypointTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityWaypointTemplateCountArgs} args - Arguments to filter ActivityWaypointTemplates to count.
     * @example
     * // Count the number of ActivityWaypointTemplates
     * const count = await prisma.activityWaypointTemplate.count({
     *   where: {
     *     // ... the filter for the ActivityWaypointTemplates we want to count
     *   }
     * })
    **/
    count<T extends ActivityWaypointTemplateCountArgs>(
      args?: Subset<T, ActivityWaypointTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityWaypointTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActivityWaypointTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityWaypointTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityWaypointTemplateAggregateArgs>(args: Subset<T, ActivityWaypointTemplateAggregateArgs>): Prisma.PrismaPromise<GetActivityWaypointTemplateAggregateType<T>>

    /**
     * Group by ActivityWaypointTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityWaypointTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityWaypointTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityWaypointTemplateGroupByArgs['orderBy'] }
        : { orderBy?: ActivityWaypointTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityWaypointTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityWaypointTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActivityWaypointTemplate model
   */
  readonly fields: ActivityWaypointTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActivityWaypointTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityWaypointTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parentActivity<T extends ActivityTemplateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ActivityTemplateDefaultArgs<ExtArgs>>): Prisma__ActivityTemplateClient<$Result.GetResult<Prisma.$ActivityTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    activities<T extends ActivityWaypointTemplate$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, ActivityWaypointTemplate$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityTemplatePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    waypoints<T extends ActivityWaypointTemplate$waypointsArgs<ExtArgs> = {}>(args?: Subset<T, ActivityWaypointTemplate$waypointsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityWaypointPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    assignments<T extends ActivityWaypointTemplate$assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, ActivityWaypointTemplate$assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplateAssignmentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    tenet<T extends TenetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenetDefaultArgs<ExtArgs>>): Prisma__TenetClient<$Result.GetResult<Prisma.$TenetPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActivityWaypointTemplate model
   */ 
  interface ActivityWaypointTemplateFieldRefs {
    readonly id: FieldRef<"ActivityWaypointTemplate", 'Bytes'>
    readonly title: FieldRef<"ActivityWaypointTemplate", 'String'>
    readonly description: FieldRef<"ActivityWaypointTemplate", 'String'>
    readonly defaultStatus: FieldRef<"ActivityWaypointTemplate", 'ActivityStatus'>
    readonly order: FieldRef<"ActivityWaypointTemplate", 'Int'>
    readonly dateOffsetType: FieldRef<"ActivityWaypointTemplate", 'DateOffsetType'>
    readonly dueDate: FieldRef<"ActivityWaypointTemplate", 'Int'>
    readonly parentActivityId: FieldRef<"ActivityWaypointTemplate", 'Bytes'>
    readonly createdAt: FieldRef<"ActivityWaypointTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"ActivityWaypointTemplate", 'DateTime'>
    readonly tenetId: FieldRef<"ActivityWaypointTemplate", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * ActivityWaypointTemplate findUnique
   */
  export type ActivityWaypointTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityWaypointTemplate
     */
    select?: ActivityWaypointTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityWaypointTemplate
     */
    omit?: ActivityWaypointTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityWaypointTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ActivityWaypointTemplate to fetch.
     */
    where: ActivityWaypointTemplateWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityWaypointTemplate findUniqueOrThrow
   */
  export type ActivityWaypointTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityWaypointTemplate
     */
    select?: ActivityWaypointTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityWaypointTemplate
     */
    omit?: ActivityWaypointTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityWaypointTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ActivityWaypointTemplate to fetch.
     */
    where: ActivityWaypointTemplateWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityWaypointTemplate findFirst
   */
  export type ActivityWaypointTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityWaypointTemplate
     */
    select?: ActivityWaypointTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityWaypointTemplate
     */
    omit?: ActivityWaypointTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityWaypointTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ActivityWaypointTemplate to fetch.
     */
    where?: ActivityWaypointTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityWaypointTemplates to fetch.
     */
    orderBy?: ActivityWaypointTemplateOrderByWithRelationInput | ActivityWaypointTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityWaypointTemplates.
     */
    cursor?: ActivityWaypointTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityWaypointTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityWaypointTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityWaypointTemplates.
     */
    distinct?: ActivityWaypointTemplateScalarFieldEnum | ActivityWaypointTemplateScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityWaypointTemplate findFirstOrThrow
   */
  export type ActivityWaypointTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityWaypointTemplate
     */
    select?: ActivityWaypointTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityWaypointTemplate
     */
    omit?: ActivityWaypointTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityWaypointTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ActivityWaypointTemplate to fetch.
     */
    where?: ActivityWaypointTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityWaypointTemplates to fetch.
     */
    orderBy?: ActivityWaypointTemplateOrderByWithRelationInput | ActivityWaypointTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityWaypointTemplates.
     */
    cursor?: ActivityWaypointTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityWaypointTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityWaypointTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityWaypointTemplates.
     */
    distinct?: ActivityWaypointTemplateScalarFieldEnum | ActivityWaypointTemplateScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityWaypointTemplate findMany
   */
  export type ActivityWaypointTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityWaypointTemplate
     */
    select?: ActivityWaypointTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityWaypointTemplate
     */
    omit?: ActivityWaypointTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityWaypointTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ActivityWaypointTemplates to fetch.
     */
    where?: ActivityWaypointTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityWaypointTemplates to fetch.
     */
    orderBy?: ActivityWaypointTemplateOrderByWithRelationInput | ActivityWaypointTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActivityWaypointTemplates.
     */
    cursor?: ActivityWaypointTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityWaypointTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityWaypointTemplates.
     */
    skip?: number
    distinct?: ActivityWaypointTemplateScalarFieldEnum | ActivityWaypointTemplateScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityWaypointTemplate create
   */
  export type ActivityWaypointTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityWaypointTemplate
     */
    select?: ActivityWaypointTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityWaypointTemplate
     */
    omit?: ActivityWaypointTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityWaypointTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a ActivityWaypointTemplate.
     */
    data: XOR<ActivityWaypointTemplateCreateInput, ActivityWaypointTemplateUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityWaypointTemplate createMany
   */
  export type ActivityWaypointTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActivityWaypointTemplates.
     */
    data: ActivityWaypointTemplateCreateManyInput | ActivityWaypointTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActivityWaypointTemplate createManyAndReturn
   */
  export type ActivityWaypointTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityWaypointTemplate
     */
    select?: ActivityWaypointTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityWaypointTemplate
     */
    omit?: ActivityWaypointTemplateOmit<ExtArgs> | null
    /**
     * The data used to create many ActivityWaypointTemplates.
     */
    data: ActivityWaypointTemplateCreateManyInput | ActivityWaypointTemplateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityWaypointTemplateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityWaypointTemplate update
   */
  export type ActivityWaypointTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityWaypointTemplate
     */
    select?: ActivityWaypointTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityWaypointTemplate
     */
    omit?: ActivityWaypointTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityWaypointTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a ActivityWaypointTemplate.
     */
    data: XOR<ActivityWaypointTemplateUpdateInput, ActivityWaypointTemplateUncheckedUpdateInput>
    /**
     * Choose, which ActivityWaypointTemplate to update.
     */
    where: ActivityWaypointTemplateWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityWaypointTemplate updateMany
   */
  export type ActivityWaypointTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActivityWaypointTemplates.
     */
    data: XOR<ActivityWaypointTemplateUpdateManyMutationInput, ActivityWaypointTemplateUncheckedUpdateManyInput>
    /**
     * Filter which ActivityWaypointTemplates to update
     */
    where?: ActivityWaypointTemplateWhereInput
    /**
     * Limit how many ActivityWaypointTemplates to update.
     */
    limit?: number
  }

  /**
   * ActivityWaypointTemplate updateManyAndReturn
   */
  export type ActivityWaypointTemplateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityWaypointTemplate
     */
    select?: ActivityWaypointTemplateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityWaypointTemplate
     */
    omit?: ActivityWaypointTemplateOmit<ExtArgs> | null
    /**
     * The data used to update ActivityWaypointTemplates.
     */
    data: XOR<ActivityWaypointTemplateUpdateManyMutationInput, ActivityWaypointTemplateUncheckedUpdateManyInput>
    /**
     * Filter which ActivityWaypointTemplates to update
     */
    where?: ActivityWaypointTemplateWhereInput
    /**
     * Limit how many ActivityWaypointTemplates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityWaypointTemplateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityWaypointTemplate upsert
   */
  export type ActivityWaypointTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityWaypointTemplate
     */
    select?: ActivityWaypointTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityWaypointTemplate
     */
    omit?: ActivityWaypointTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityWaypointTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the ActivityWaypointTemplate to update in case it exists.
     */
    where: ActivityWaypointTemplateWhereUniqueInput
    /**
     * In case the ActivityWaypointTemplate found by the `where` argument doesn't exist, create a new ActivityWaypointTemplate with this data.
     */
    create: XOR<ActivityWaypointTemplateCreateInput, ActivityWaypointTemplateUncheckedCreateInput>
    /**
     * In case the ActivityWaypointTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityWaypointTemplateUpdateInput, ActivityWaypointTemplateUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityWaypointTemplate delete
   */
  export type ActivityWaypointTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityWaypointTemplate
     */
    select?: ActivityWaypointTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityWaypointTemplate
     */
    omit?: ActivityWaypointTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityWaypointTemplateInclude<ExtArgs> | null
    /**
     * Filter which ActivityWaypointTemplate to delete.
     */
    where: ActivityWaypointTemplateWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityWaypointTemplate deleteMany
   */
  export type ActivityWaypointTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityWaypointTemplates to delete
     */
    where?: ActivityWaypointTemplateWhereInput
    /**
     * Limit how many ActivityWaypointTemplates to delete.
     */
    limit?: number
  }

  /**
   * ActivityWaypointTemplate.activities
   */
  export type ActivityWaypointTemplate$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityTemplate
     */
    select?: ActivityTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityTemplate
     */
    omit?: ActivityTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityTemplateInclude<ExtArgs> | null
    where?: ActivityTemplateWhereInput
    orderBy?: ActivityTemplateOrderByWithRelationInput | ActivityTemplateOrderByWithRelationInput[]
    cursor?: ActivityTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityTemplateScalarFieldEnum | ActivityTemplateScalarFieldEnum[]
  }

  /**
   * ActivityWaypointTemplate.waypoints
   */
  export type ActivityWaypointTemplate$waypointsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityWaypoint
     */
    select?: ActivityWaypointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityWaypoint
     */
    omit?: ActivityWaypointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityWaypointInclude<ExtArgs> | null
    where?: ActivityWaypointWhereInput
    orderBy?: ActivityWaypointOrderByWithRelationInput | ActivityWaypointOrderByWithRelationInput[]
    cursor?: ActivityWaypointWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityWaypointScalarFieldEnum | ActivityWaypointScalarFieldEnum[]
  }

  /**
   * ActivityWaypointTemplate.assignments
   */
  export type ActivityWaypointTemplate$assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateAssignment
     */
    select?: TemplateAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateAssignment
     */
    omit?: TemplateAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateAssignmentInclude<ExtArgs> | null
    where?: TemplateAssignmentWhereInput
    orderBy?: TemplateAssignmentOrderByWithRelationInput | TemplateAssignmentOrderByWithRelationInput[]
    cursor?: TemplateAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TemplateAssignmentScalarFieldEnum | TemplateAssignmentScalarFieldEnum[]
  }

  /**
   * ActivityWaypointTemplate without action
   */
  export type ActivityWaypointTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityWaypointTemplate
     */
    select?: ActivityWaypointTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityWaypointTemplate
     */
    omit?: ActivityWaypointTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityWaypointTemplateInclude<ExtArgs> | null
  }


  /**
   * Model ActivityTemplateStep
   */

  export type AggregateActivityTemplateStep = {
    _count: ActivityTemplateStepCountAggregateOutputType | null
    _avg: ActivityTemplateStepAvgAggregateOutputType | null
    _sum: ActivityTemplateStepSumAggregateOutputType | null
    _min: ActivityTemplateStepMinAggregateOutputType | null
    _max: ActivityTemplateStepMaxAggregateOutputType | null
  }

  export type ActivityTemplateStepAvgAggregateOutputType = {
    order: number | null
  }

  export type ActivityTemplateStepSumAggregateOutputType = {
    order: number | null
  }

  export type ActivityTemplateStepMinAggregateOutputType = {
    id: Uint8Array | null
    order: number | null
    title: string | null
    type: $Enums.ActivityStepType | null
    activityTemplateId: Uint8Array | null
    tenetId: Uint8Array | null
  }

  export type ActivityTemplateStepMaxAggregateOutputType = {
    id: Uint8Array | null
    order: number | null
    title: string | null
    type: $Enums.ActivityStepType | null
    activityTemplateId: Uint8Array | null
    tenetId: Uint8Array | null
  }

  export type ActivityTemplateStepCountAggregateOutputType = {
    id: number
    order: number
    title: number
    type: number
    activityTemplateId: number
    tenetId: number
    _all: number
  }


  export type ActivityTemplateStepAvgAggregateInputType = {
    order?: true
  }

  export type ActivityTemplateStepSumAggregateInputType = {
    order?: true
  }

  export type ActivityTemplateStepMinAggregateInputType = {
    id?: true
    order?: true
    title?: true
    type?: true
    activityTemplateId?: true
    tenetId?: true
  }

  export type ActivityTemplateStepMaxAggregateInputType = {
    id?: true
    order?: true
    title?: true
    type?: true
    activityTemplateId?: true
    tenetId?: true
  }

  export type ActivityTemplateStepCountAggregateInputType = {
    id?: true
    order?: true
    title?: true
    type?: true
    activityTemplateId?: true
    tenetId?: true
    _all?: true
  }

  export type ActivityTemplateStepAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityTemplateStep to aggregate.
     */
    where?: ActivityTemplateStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityTemplateSteps to fetch.
     */
    orderBy?: ActivityTemplateStepOrderByWithRelationInput | ActivityTemplateStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityTemplateStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityTemplateSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityTemplateSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActivityTemplateSteps
    **/
    _count?: true | ActivityTemplateStepCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActivityTemplateStepAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActivityTemplateStepSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityTemplateStepMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityTemplateStepMaxAggregateInputType
  }

  export type GetActivityTemplateStepAggregateType<T extends ActivityTemplateStepAggregateArgs> = {
        [P in keyof T & keyof AggregateActivityTemplateStep]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivityTemplateStep[P]>
      : GetScalarType<T[P], AggregateActivityTemplateStep[P]>
  }




  export type ActivityTemplateStepGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityTemplateStepWhereInput
    orderBy?: ActivityTemplateStepOrderByWithAggregationInput | ActivityTemplateStepOrderByWithAggregationInput[]
    by: ActivityTemplateStepScalarFieldEnum[] | ActivityTemplateStepScalarFieldEnum
    having?: ActivityTemplateStepScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityTemplateStepCountAggregateInputType | true
    _avg?: ActivityTemplateStepAvgAggregateInputType
    _sum?: ActivityTemplateStepSumAggregateInputType
    _min?: ActivityTemplateStepMinAggregateInputType
    _max?: ActivityTemplateStepMaxAggregateInputType
  }

  export type ActivityTemplateStepGroupByOutputType = {
    id: Uint8Array
    order: number
    title: string
    type: $Enums.ActivityStepType
    activityTemplateId: Uint8Array
    tenetId: Uint8Array
    _count: ActivityTemplateStepCountAggregateOutputType | null
    _avg: ActivityTemplateStepAvgAggregateOutputType | null
    _sum: ActivityTemplateStepSumAggregateOutputType | null
    _min: ActivityTemplateStepMinAggregateOutputType | null
    _max: ActivityTemplateStepMaxAggregateOutputType | null
  }

  type GetActivityTemplateStepGroupByPayload<T extends ActivityTemplateStepGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityTemplateStepGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityTemplateStepGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityTemplateStepGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityTemplateStepGroupByOutputType[P]>
        }
      >
    >


  export type ActivityTemplateStepSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    order?: boolean
    title?: boolean
    type?: boolean
    activityTemplateId?: boolean
    tenetId?: boolean
    activityTemplate?: boolean | ActivityTemplateDefaultArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
    assignedTo?: boolean | ActivityTemplateStep$assignedToArgs<ExtArgs>
    _count?: boolean | ActivityTemplateStepCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityTemplateStep"]>

  export type ActivityTemplateStepSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    order?: boolean
    title?: boolean
    type?: boolean
    activityTemplateId?: boolean
    tenetId?: boolean
    activityTemplate?: boolean | ActivityTemplateDefaultArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityTemplateStep"]>

  export type ActivityTemplateStepSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    order?: boolean
    title?: boolean
    type?: boolean
    activityTemplateId?: boolean
    tenetId?: boolean
    activityTemplate?: boolean | ActivityTemplateDefaultArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityTemplateStep"]>

  export type ActivityTemplateStepSelectScalar = {
    id?: boolean
    order?: boolean
    title?: boolean
    type?: boolean
    activityTemplateId?: boolean
    tenetId?: boolean
  }

  export type ActivityTemplateStepOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "order" | "title" | "type" | "activityTemplateId" | "tenetId", ExtArgs["result"]["activityTemplateStep"]>
  export type ActivityTemplateStepInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activityTemplate?: boolean | ActivityTemplateDefaultArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
    assignedTo?: boolean | ActivityTemplateStep$assignedToArgs<ExtArgs>
    _count?: boolean | ActivityTemplateStepCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ActivityTemplateStepIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activityTemplate?: boolean | ActivityTemplateDefaultArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }
  export type ActivityTemplateStepIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activityTemplate?: boolean | ActivityTemplateDefaultArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }

  export type $ActivityTemplateStepPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActivityTemplateStep"
    objects: {
      activityTemplate: Prisma.$ActivityTemplatePayload<ExtArgs>
      tenet: Prisma.$TenetPayload<ExtArgs>
      assignedTo: Prisma.$ActivityTemplateStepAssignmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: Uint8Array
      order: number
      title: string
      type: $Enums.ActivityStepType
      activityTemplateId: Uint8Array
      tenetId: Uint8Array
    }, ExtArgs["result"]["activityTemplateStep"]>
    composites: {}
  }

  type ActivityTemplateStepGetPayload<S extends boolean | null | undefined | ActivityTemplateStepDefaultArgs> = $Result.GetResult<Prisma.$ActivityTemplateStepPayload, S>

  type ActivityTemplateStepCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActivityTemplateStepFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: ActivityTemplateStepCountAggregateInputType | true
    }

  export interface ActivityTemplateStepDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActivityTemplateStep'], meta: { name: 'ActivityTemplateStep' } }
    /**
     * Find zero or one ActivityTemplateStep that matches the filter.
     * @param {ActivityTemplateStepFindUniqueArgs} args - Arguments to find a ActivityTemplateStep
     * @example
     * // Get one ActivityTemplateStep
     * const activityTemplateStep = await prisma.activityTemplateStep.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityTemplateStepFindUniqueArgs>(args: SelectSubset<T, ActivityTemplateStepFindUniqueArgs<ExtArgs>>): Prisma__ActivityTemplateStepClient<$Result.GetResult<Prisma.$ActivityTemplateStepPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ActivityTemplateStep that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActivityTemplateStepFindUniqueOrThrowArgs} args - Arguments to find a ActivityTemplateStep
     * @example
     * // Get one ActivityTemplateStep
     * const activityTemplateStep = await prisma.activityTemplateStep.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityTemplateStepFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityTemplateStepFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityTemplateStepClient<$Result.GetResult<Prisma.$ActivityTemplateStepPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ActivityTemplateStep that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityTemplateStepFindFirstArgs} args - Arguments to find a ActivityTemplateStep
     * @example
     * // Get one ActivityTemplateStep
     * const activityTemplateStep = await prisma.activityTemplateStep.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityTemplateStepFindFirstArgs>(args?: SelectSubset<T, ActivityTemplateStepFindFirstArgs<ExtArgs>>): Prisma__ActivityTemplateStepClient<$Result.GetResult<Prisma.$ActivityTemplateStepPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ActivityTemplateStep that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityTemplateStepFindFirstOrThrowArgs} args - Arguments to find a ActivityTemplateStep
     * @example
     * // Get one ActivityTemplateStep
     * const activityTemplateStep = await prisma.activityTemplateStep.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityTemplateStepFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityTemplateStepFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityTemplateStepClient<$Result.GetResult<Prisma.$ActivityTemplateStepPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ActivityTemplateSteps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityTemplateStepFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActivityTemplateSteps
     * const activityTemplateSteps = await prisma.activityTemplateStep.findMany()
     * 
     * // Get first 10 ActivityTemplateSteps
     * const activityTemplateSteps = await prisma.activityTemplateStep.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityTemplateStepWithIdOnly = await prisma.activityTemplateStep.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityTemplateStepFindManyArgs>(args?: SelectSubset<T, ActivityTemplateStepFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityTemplateStepPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ActivityTemplateStep.
     * @param {ActivityTemplateStepCreateArgs} args - Arguments to create a ActivityTemplateStep.
     * @example
     * // Create one ActivityTemplateStep
     * const ActivityTemplateStep = await prisma.activityTemplateStep.create({
     *   data: {
     *     // ... data to create a ActivityTemplateStep
     *   }
     * })
     * 
     */
    create<T extends ActivityTemplateStepCreateArgs>(args: SelectSubset<T, ActivityTemplateStepCreateArgs<ExtArgs>>): Prisma__ActivityTemplateStepClient<$Result.GetResult<Prisma.$ActivityTemplateStepPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ActivityTemplateSteps.
     * @param {ActivityTemplateStepCreateManyArgs} args - Arguments to create many ActivityTemplateSteps.
     * @example
     * // Create many ActivityTemplateSteps
     * const activityTemplateStep = await prisma.activityTemplateStep.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityTemplateStepCreateManyArgs>(args?: SelectSubset<T, ActivityTemplateStepCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActivityTemplateSteps and returns the data saved in the database.
     * @param {ActivityTemplateStepCreateManyAndReturnArgs} args - Arguments to create many ActivityTemplateSteps.
     * @example
     * // Create many ActivityTemplateSteps
     * const activityTemplateStep = await prisma.activityTemplateStep.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActivityTemplateSteps and only return the `id`
     * const activityTemplateStepWithIdOnly = await prisma.activityTemplateStep.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityTemplateStepCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityTemplateStepCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityTemplateStepPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a ActivityTemplateStep.
     * @param {ActivityTemplateStepDeleteArgs} args - Arguments to delete one ActivityTemplateStep.
     * @example
     * // Delete one ActivityTemplateStep
     * const ActivityTemplateStep = await prisma.activityTemplateStep.delete({
     *   where: {
     *     // ... filter to delete one ActivityTemplateStep
     *   }
     * })
     * 
     */
    delete<T extends ActivityTemplateStepDeleteArgs>(args: SelectSubset<T, ActivityTemplateStepDeleteArgs<ExtArgs>>): Prisma__ActivityTemplateStepClient<$Result.GetResult<Prisma.$ActivityTemplateStepPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ActivityTemplateStep.
     * @param {ActivityTemplateStepUpdateArgs} args - Arguments to update one ActivityTemplateStep.
     * @example
     * // Update one ActivityTemplateStep
     * const activityTemplateStep = await prisma.activityTemplateStep.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityTemplateStepUpdateArgs>(args: SelectSubset<T, ActivityTemplateStepUpdateArgs<ExtArgs>>): Prisma__ActivityTemplateStepClient<$Result.GetResult<Prisma.$ActivityTemplateStepPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ActivityTemplateSteps.
     * @param {ActivityTemplateStepDeleteManyArgs} args - Arguments to filter ActivityTemplateSteps to delete.
     * @example
     * // Delete a few ActivityTemplateSteps
     * const { count } = await prisma.activityTemplateStep.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityTemplateStepDeleteManyArgs>(args?: SelectSubset<T, ActivityTemplateStepDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityTemplateSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityTemplateStepUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActivityTemplateSteps
     * const activityTemplateStep = await prisma.activityTemplateStep.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityTemplateStepUpdateManyArgs>(args: SelectSubset<T, ActivityTemplateStepUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityTemplateSteps and returns the data updated in the database.
     * @param {ActivityTemplateStepUpdateManyAndReturnArgs} args - Arguments to update many ActivityTemplateSteps.
     * @example
     * // Update many ActivityTemplateSteps
     * const activityTemplateStep = await prisma.activityTemplateStep.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ActivityTemplateSteps and only return the `id`
     * const activityTemplateStepWithIdOnly = await prisma.activityTemplateStep.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActivityTemplateStepUpdateManyAndReturnArgs>(args: SelectSubset<T, ActivityTemplateStepUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityTemplateStepPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one ActivityTemplateStep.
     * @param {ActivityTemplateStepUpsertArgs} args - Arguments to update or create a ActivityTemplateStep.
     * @example
     * // Update or create a ActivityTemplateStep
     * const activityTemplateStep = await prisma.activityTemplateStep.upsert({
     *   create: {
     *     // ... data to create a ActivityTemplateStep
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActivityTemplateStep we want to update
     *   }
     * })
     */
    upsert<T extends ActivityTemplateStepUpsertArgs>(args: SelectSubset<T, ActivityTemplateStepUpsertArgs<ExtArgs>>): Prisma__ActivityTemplateStepClient<$Result.GetResult<Prisma.$ActivityTemplateStepPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ActivityTemplateSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityTemplateStepCountArgs} args - Arguments to filter ActivityTemplateSteps to count.
     * @example
     * // Count the number of ActivityTemplateSteps
     * const count = await prisma.activityTemplateStep.count({
     *   where: {
     *     // ... the filter for the ActivityTemplateSteps we want to count
     *   }
     * })
    **/
    count<T extends ActivityTemplateStepCountArgs>(
      args?: Subset<T, ActivityTemplateStepCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityTemplateStepCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActivityTemplateStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityTemplateStepAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityTemplateStepAggregateArgs>(args: Subset<T, ActivityTemplateStepAggregateArgs>): Prisma.PrismaPromise<GetActivityTemplateStepAggregateType<T>>

    /**
     * Group by ActivityTemplateStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityTemplateStepGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityTemplateStepGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityTemplateStepGroupByArgs['orderBy'] }
        : { orderBy?: ActivityTemplateStepGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityTemplateStepGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityTemplateStepGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActivityTemplateStep model
   */
  readonly fields: ActivityTemplateStepFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActivityTemplateStep.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityTemplateStepClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    activityTemplate<T extends ActivityTemplateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ActivityTemplateDefaultArgs<ExtArgs>>): Prisma__ActivityTemplateClient<$Result.GetResult<Prisma.$ActivityTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    tenet<T extends TenetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenetDefaultArgs<ExtArgs>>): Prisma__TenetClient<$Result.GetResult<Prisma.$TenetPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    assignedTo<T extends ActivityTemplateStep$assignedToArgs<ExtArgs> = {}>(args?: Subset<T, ActivityTemplateStep$assignedToArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityTemplateStepAssignmentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActivityTemplateStep model
   */ 
  interface ActivityTemplateStepFieldRefs {
    readonly id: FieldRef<"ActivityTemplateStep", 'Bytes'>
    readonly order: FieldRef<"ActivityTemplateStep", 'Int'>
    readonly title: FieldRef<"ActivityTemplateStep", 'String'>
    readonly type: FieldRef<"ActivityTemplateStep", 'ActivityStepType'>
    readonly activityTemplateId: FieldRef<"ActivityTemplateStep", 'Bytes'>
    readonly tenetId: FieldRef<"ActivityTemplateStep", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * ActivityTemplateStep findUnique
   */
  export type ActivityTemplateStepFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityTemplateStep
     */
    select?: ActivityTemplateStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityTemplateStep
     */
    omit?: ActivityTemplateStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityTemplateStepInclude<ExtArgs> | null
    /**
     * Filter, which ActivityTemplateStep to fetch.
     */
    where: ActivityTemplateStepWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityTemplateStep findUniqueOrThrow
   */
  export type ActivityTemplateStepFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityTemplateStep
     */
    select?: ActivityTemplateStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityTemplateStep
     */
    omit?: ActivityTemplateStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityTemplateStepInclude<ExtArgs> | null
    /**
     * Filter, which ActivityTemplateStep to fetch.
     */
    where: ActivityTemplateStepWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityTemplateStep findFirst
   */
  export type ActivityTemplateStepFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityTemplateStep
     */
    select?: ActivityTemplateStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityTemplateStep
     */
    omit?: ActivityTemplateStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityTemplateStepInclude<ExtArgs> | null
    /**
     * Filter, which ActivityTemplateStep to fetch.
     */
    where?: ActivityTemplateStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityTemplateSteps to fetch.
     */
    orderBy?: ActivityTemplateStepOrderByWithRelationInput | ActivityTemplateStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityTemplateSteps.
     */
    cursor?: ActivityTemplateStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityTemplateSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityTemplateSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityTemplateSteps.
     */
    distinct?: ActivityTemplateStepScalarFieldEnum | ActivityTemplateStepScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityTemplateStep findFirstOrThrow
   */
  export type ActivityTemplateStepFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityTemplateStep
     */
    select?: ActivityTemplateStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityTemplateStep
     */
    omit?: ActivityTemplateStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityTemplateStepInclude<ExtArgs> | null
    /**
     * Filter, which ActivityTemplateStep to fetch.
     */
    where?: ActivityTemplateStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityTemplateSteps to fetch.
     */
    orderBy?: ActivityTemplateStepOrderByWithRelationInput | ActivityTemplateStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityTemplateSteps.
     */
    cursor?: ActivityTemplateStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityTemplateSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityTemplateSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityTemplateSteps.
     */
    distinct?: ActivityTemplateStepScalarFieldEnum | ActivityTemplateStepScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityTemplateStep findMany
   */
  export type ActivityTemplateStepFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityTemplateStep
     */
    select?: ActivityTemplateStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityTemplateStep
     */
    omit?: ActivityTemplateStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityTemplateStepInclude<ExtArgs> | null
    /**
     * Filter, which ActivityTemplateSteps to fetch.
     */
    where?: ActivityTemplateStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityTemplateSteps to fetch.
     */
    orderBy?: ActivityTemplateStepOrderByWithRelationInput | ActivityTemplateStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActivityTemplateSteps.
     */
    cursor?: ActivityTemplateStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityTemplateSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityTemplateSteps.
     */
    skip?: number
    distinct?: ActivityTemplateStepScalarFieldEnum | ActivityTemplateStepScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityTemplateStep create
   */
  export type ActivityTemplateStepCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityTemplateStep
     */
    select?: ActivityTemplateStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityTemplateStep
     */
    omit?: ActivityTemplateStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityTemplateStepInclude<ExtArgs> | null
    /**
     * The data needed to create a ActivityTemplateStep.
     */
    data: XOR<ActivityTemplateStepCreateInput, ActivityTemplateStepUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityTemplateStep createMany
   */
  export type ActivityTemplateStepCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActivityTemplateSteps.
     */
    data: ActivityTemplateStepCreateManyInput | ActivityTemplateStepCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActivityTemplateStep createManyAndReturn
   */
  export type ActivityTemplateStepCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityTemplateStep
     */
    select?: ActivityTemplateStepSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityTemplateStep
     */
    omit?: ActivityTemplateStepOmit<ExtArgs> | null
    /**
     * The data used to create many ActivityTemplateSteps.
     */
    data: ActivityTemplateStepCreateManyInput | ActivityTemplateStepCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityTemplateStepIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityTemplateStep update
   */
  export type ActivityTemplateStepUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityTemplateStep
     */
    select?: ActivityTemplateStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityTemplateStep
     */
    omit?: ActivityTemplateStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityTemplateStepInclude<ExtArgs> | null
    /**
     * The data needed to update a ActivityTemplateStep.
     */
    data: XOR<ActivityTemplateStepUpdateInput, ActivityTemplateStepUncheckedUpdateInput>
    /**
     * Choose, which ActivityTemplateStep to update.
     */
    where: ActivityTemplateStepWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityTemplateStep updateMany
   */
  export type ActivityTemplateStepUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActivityTemplateSteps.
     */
    data: XOR<ActivityTemplateStepUpdateManyMutationInput, ActivityTemplateStepUncheckedUpdateManyInput>
    /**
     * Filter which ActivityTemplateSteps to update
     */
    where?: ActivityTemplateStepWhereInput
    /**
     * Limit how many ActivityTemplateSteps to update.
     */
    limit?: number
  }

  /**
   * ActivityTemplateStep updateManyAndReturn
   */
  export type ActivityTemplateStepUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityTemplateStep
     */
    select?: ActivityTemplateStepSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityTemplateStep
     */
    omit?: ActivityTemplateStepOmit<ExtArgs> | null
    /**
     * The data used to update ActivityTemplateSteps.
     */
    data: XOR<ActivityTemplateStepUpdateManyMutationInput, ActivityTemplateStepUncheckedUpdateManyInput>
    /**
     * Filter which ActivityTemplateSteps to update
     */
    where?: ActivityTemplateStepWhereInput
    /**
     * Limit how many ActivityTemplateSteps to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityTemplateStepIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityTemplateStep upsert
   */
  export type ActivityTemplateStepUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityTemplateStep
     */
    select?: ActivityTemplateStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityTemplateStep
     */
    omit?: ActivityTemplateStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityTemplateStepInclude<ExtArgs> | null
    /**
     * The filter to search for the ActivityTemplateStep to update in case it exists.
     */
    where: ActivityTemplateStepWhereUniqueInput
    /**
     * In case the ActivityTemplateStep found by the `where` argument doesn't exist, create a new ActivityTemplateStep with this data.
     */
    create: XOR<ActivityTemplateStepCreateInput, ActivityTemplateStepUncheckedCreateInput>
    /**
     * In case the ActivityTemplateStep was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityTemplateStepUpdateInput, ActivityTemplateStepUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityTemplateStep delete
   */
  export type ActivityTemplateStepDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityTemplateStep
     */
    select?: ActivityTemplateStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityTemplateStep
     */
    omit?: ActivityTemplateStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityTemplateStepInclude<ExtArgs> | null
    /**
     * Filter which ActivityTemplateStep to delete.
     */
    where: ActivityTemplateStepWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityTemplateStep deleteMany
   */
  export type ActivityTemplateStepDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityTemplateSteps to delete
     */
    where?: ActivityTemplateStepWhereInput
    /**
     * Limit how many ActivityTemplateSteps to delete.
     */
    limit?: number
  }

  /**
   * ActivityTemplateStep.assignedTo
   */
  export type ActivityTemplateStep$assignedToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityTemplateStepAssignment
     */
    select?: ActivityTemplateStepAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityTemplateStepAssignment
     */
    omit?: ActivityTemplateStepAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityTemplateStepAssignmentInclude<ExtArgs> | null
    where?: ActivityTemplateStepAssignmentWhereInput
    orderBy?: ActivityTemplateStepAssignmentOrderByWithRelationInput | ActivityTemplateStepAssignmentOrderByWithRelationInput[]
    cursor?: ActivityTemplateStepAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityTemplateStepAssignmentScalarFieldEnum | ActivityTemplateStepAssignmentScalarFieldEnum[]
  }

  /**
   * ActivityTemplateStep without action
   */
  export type ActivityTemplateStepDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityTemplateStep
     */
    select?: ActivityTemplateStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityTemplateStep
     */
    omit?: ActivityTemplateStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityTemplateStepInclude<ExtArgs> | null
  }


  /**
   * Model ActivityTemplateStepAssignment
   */

  export type AggregateActivityTemplateStepAssignment = {
    _count: ActivityTemplateStepAssignmentCountAggregateOutputType | null
    _min: ActivityTemplateStepAssignmentMinAggregateOutputType | null
    _max: ActivityTemplateStepAssignmentMaxAggregateOutputType | null
  }

  export type ActivityTemplateStepAssignmentMinAggregateOutputType = {
    id: Uint8Array | null
    specificUserId: Uint8Array | null
    specificRole: $Enums.Role | null
    activityTemplateStepId: Uint8Array | null
    tenetId: Uint8Array | null
  }

  export type ActivityTemplateStepAssignmentMaxAggregateOutputType = {
    id: Uint8Array | null
    specificUserId: Uint8Array | null
    specificRole: $Enums.Role | null
    activityTemplateStepId: Uint8Array | null
    tenetId: Uint8Array | null
  }

  export type ActivityTemplateStepAssignmentCountAggregateOutputType = {
    id: number
    specificUserId: number
    specificRole: number
    activityTemplateStepId: number
    tenetId: number
    _all: number
  }


  export type ActivityTemplateStepAssignmentMinAggregateInputType = {
    id?: true
    specificUserId?: true
    specificRole?: true
    activityTemplateStepId?: true
    tenetId?: true
  }

  export type ActivityTemplateStepAssignmentMaxAggregateInputType = {
    id?: true
    specificUserId?: true
    specificRole?: true
    activityTemplateStepId?: true
    tenetId?: true
  }

  export type ActivityTemplateStepAssignmentCountAggregateInputType = {
    id?: true
    specificUserId?: true
    specificRole?: true
    activityTemplateStepId?: true
    tenetId?: true
    _all?: true
  }

  export type ActivityTemplateStepAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityTemplateStepAssignment to aggregate.
     */
    where?: ActivityTemplateStepAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityTemplateStepAssignments to fetch.
     */
    orderBy?: ActivityTemplateStepAssignmentOrderByWithRelationInput | ActivityTemplateStepAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityTemplateStepAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityTemplateStepAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityTemplateStepAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActivityTemplateStepAssignments
    **/
    _count?: true | ActivityTemplateStepAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityTemplateStepAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityTemplateStepAssignmentMaxAggregateInputType
  }

  export type GetActivityTemplateStepAssignmentAggregateType<T extends ActivityTemplateStepAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateActivityTemplateStepAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivityTemplateStepAssignment[P]>
      : GetScalarType<T[P], AggregateActivityTemplateStepAssignment[P]>
  }




  export type ActivityTemplateStepAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityTemplateStepAssignmentWhereInput
    orderBy?: ActivityTemplateStepAssignmentOrderByWithAggregationInput | ActivityTemplateStepAssignmentOrderByWithAggregationInput[]
    by: ActivityTemplateStepAssignmentScalarFieldEnum[] | ActivityTemplateStepAssignmentScalarFieldEnum
    having?: ActivityTemplateStepAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityTemplateStepAssignmentCountAggregateInputType | true
    _min?: ActivityTemplateStepAssignmentMinAggregateInputType
    _max?: ActivityTemplateStepAssignmentMaxAggregateInputType
  }

  export type ActivityTemplateStepAssignmentGroupByOutputType = {
    id: Uint8Array
    specificUserId: Uint8Array | null
    specificRole: $Enums.Role | null
    activityTemplateStepId: Uint8Array
    tenetId: Uint8Array
    _count: ActivityTemplateStepAssignmentCountAggregateOutputType | null
    _min: ActivityTemplateStepAssignmentMinAggregateOutputType | null
    _max: ActivityTemplateStepAssignmentMaxAggregateOutputType | null
  }

  type GetActivityTemplateStepAssignmentGroupByPayload<T extends ActivityTemplateStepAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityTemplateStepAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityTemplateStepAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityTemplateStepAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityTemplateStepAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type ActivityTemplateStepAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    specificUserId?: boolean
    specificRole?: boolean
    activityTemplateStepId?: boolean
    tenetId?: boolean
    specificUser?: boolean | ActivityTemplateStepAssignment$specificUserArgs<ExtArgs>
    activityTemplateStep?: boolean | ActivityTemplateStepDefaultArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityTemplateStepAssignment"]>

  export type ActivityTemplateStepAssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    specificUserId?: boolean
    specificRole?: boolean
    activityTemplateStepId?: boolean
    tenetId?: boolean
    specificUser?: boolean | ActivityTemplateStepAssignment$specificUserArgs<ExtArgs>
    activityTemplateStep?: boolean | ActivityTemplateStepDefaultArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityTemplateStepAssignment"]>

  export type ActivityTemplateStepAssignmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    specificUserId?: boolean
    specificRole?: boolean
    activityTemplateStepId?: boolean
    tenetId?: boolean
    specificUser?: boolean | ActivityTemplateStepAssignment$specificUserArgs<ExtArgs>
    activityTemplateStep?: boolean | ActivityTemplateStepDefaultArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityTemplateStepAssignment"]>

  export type ActivityTemplateStepAssignmentSelectScalar = {
    id?: boolean
    specificUserId?: boolean
    specificRole?: boolean
    activityTemplateStepId?: boolean
    tenetId?: boolean
  }

  export type ActivityTemplateStepAssignmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "specificUserId" | "specificRole" | "activityTemplateStepId" | "tenetId", ExtArgs["result"]["activityTemplateStepAssignment"]>
  export type ActivityTemplateStepAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    specificUser?: boolean | ActivityTemplateStepAssignment$specificUserArgs<ExtArgs>
    activityTemplateStep?: boolean | ActivityTemplateStepDefaultArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }
  export type ActivityTemplateStepAssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    specificUser?: boolean | ActivityTemplateStepAssignment$specificUserArgs<ExtArgs>
    activityTemplateStep?: boolean | ActivityTemplateStepDefaultArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }
  export type ActivityTemplateStepAssignmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    specificUser?: boolean | ActivityTemplateStepAssignment$specificUserArgs<ExtArgs>
    activityTemplateStep?: boolean | ActivityTemplateStepDefaultArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }

  export type $ActivityTemplateStepAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActivityTemplateStepAssignment"
    objects: {
      specificUser: Prisma.$UserPayload<ExtArgs> | null
      activityTemplateStep: Prisma.$ActivityTemplateStepPayload<ExtArgs>
      tenet: Prisma.$TenetPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: Uint8Array
      specificUserId: Uint8Array | null
      specificRole: $Enums.Role | null
      activityTemplateStepId: Uint8Array
      tenetId: Uint8Array
    }, ExtArgs["result"]["activityTemplateStepAssignment"]>
    composites: {}
  }

  type ActivityTemplateStepAssignmentGetPayload<S extends boolean | null | undefined | ActivityTemplateStepAssignmentDefaultArgs> = $Result.GetResult<Prisma.$ActivityTemplateStepAssignmentPayload, S>

  type ActivityTemplateStepAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActivityTemplateStepAssignmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: ActivityTemplateStepAssignmentCountAggregateInputType | true
    }

  export interface ActivityTemplateStepAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActivityTemplateStepAssignment'], meta: { name: 'ActivityTemplateStepAssignment' } }
    /**
     * Find zero or one ActivityTemplateStepAssignment that matches the filter.
     * @param {ActivityTemplateStepAssignmentFindUniqueArgs} args - Arguments to find a ActivityTemplateStepAssignment
     * @example
     * // Get one ActivityTemplateStepAssignment
     * const activityTemplateStepAssignment = await prisma.activityTemplateStepAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityTemplateStepAssignmentFindUniqueArgs>(args: SelectSubset<T, ActivityTemplateStepAssignmentFindUniqueArgs<ExtArgs>>): Prisma__ActivityTemplateStepAssignmentClient<$Result.GetResult<Prisma.$ActivityTemplateStepAssignmentPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ActivityTemplateStepAssignment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActivityTemplateStepAssignmentFindUniqueOrThrowArgs} args - Arguments to find a ActivityTemplateStepAssignment
     * @example
     * // Get one ActivityTemplateStepAssignment
     * const activityTemplateStepAssignment = await prisma.activityTemplateStepAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityTemplateStepAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityTemplateStepAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityTemplateStepAssignmentClient<$Result.GetResult<Prisma.$ActivityTemplateStepAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ActivityTemplateStepAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityTemplateStepAssignmentFindFirstArgs} args - Arguments to find a ActivityTemplateStepAssignment
     * @example
     * // Get one ActivityTemplateStepAssignment
     * const activityTemplateStepAssignment = await prisma.activityTemplateStepAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityTemplateStepAssignmentFindFirstArgs>(args?: SelectSubset<T, ActivityTemplateStepAssignmentFindFirstArgs<ExtArgs>>): Prisma__ActivityTemplateStepAssignmentClient<$Result.GetResult<Prisma.$ActivityTemplateStepAssignmentPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ActivityTemplateStepAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityTemplateStepAssignmentFindFirstOrThrowArgs} args - Arguments to find a ActivityTemplateStepAssignment
     * @example
     * // Get one ActivityTemplateStepAssignment
     * const activityTemplateStepAssignment = await prisma.activityTemplateStepAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityTemplateStepAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityTemplateStepAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityTemplateStepAssignmentClient<$Result.GetResult<Prisma.$ActivityTemplateStepAssignmentPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ActivityTemplateStepAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityTemplateStepAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActivityTemplateStepAssignments
     * const activityTemplateStepAssignments = await prisma.activityTemplateStepAssignment.findMany()
     * 
     * // Get first 10 ActivityTemplateStepAssignments
     * const activityTemplateStepAssignments = await prisma.activityTemplateStepAssignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityTemplateStepAssignmentWithIdOnly = await prisma.activityTemplateStepAssignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityTemplateStepAssignmentFindManyArgs>(args?: SelectSubset<T, ActivityTemplateStepAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityTemplateStepAssignmentPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ActivityTemplateStepAssignment.
     * @param {ActivityTemplateStepAssignmentCreateArgs} args - Arguments to create a ActivityTemplateStepAssignment.
     * @example
     * // Create one ActivityTemplateStepAssignment
     * const ActivityTemplateStepAssignment = await prisma.activityTemplateStepAssignment.create({
     *   data: {
     *     // ... data to create a ActivityTemplateStepAssignment
     *   }
     * })
     * 
     */
    create<T extends ActivityTemplateStepAssignmentCreateArgs>(args: SelectSubset<T, ActivityTemplateStepAssignmentCreateArgs<ExtArgs>>): Prisma__ActivityTemplateStepAssignmentClient<$Result.GetResult<Prisma.$ActivityTemplateStepAssignmentPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ActivityTemplateStepAssignments.
     * @param {ActivityTemplateStepAssignmentCreateManyArgs} args - Arguments to create many ActivityTemplateStepAssignments.
     * @example
     * // Create many ActivityTemplateStepAssignments
     * const activityTemplateStepAssignment = await prisma.activityTemplateStepAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityTemplateStepAssignmentCreateManyArgs>(args?: SelectSubset<T, ActivityTemplateStepAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActivityTemplateStepAssignments and returns the data saved in the database.
     * @param {ActivityTemplateStepAssignmentCreateManyAndReturnArgs} args - Arguments to create many ActivityTemplateStepAssignments.
     * @example
     * // Create many ActivityTemplateStepAssignments
     * const activityTemplateStepAssignment = await prisma.activityTemplateStepAssignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActivityTemplateStepAssignments and only return the `id`
     * const activityTemplateStepAssignmentWithIdOnly = await prisma.activityTemplateStepAssignment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityTemplateStepAssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityTemplateStepAssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityTemplateStepAssignmentPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a ActivityTemplateStepAssignment.
     * @param {ActivityTemplateStepAssignmentDeleteArgs} args - Arguments to delete one ActivityTemplateStepAssignment.
     * @example
     * // Delete one ActivityTemplateStepAssignment
     * const ActivityTemplateStepAssignment = await prisma.activityTemplateStepAssignment.delete({
     *   where: {
     *     // ... filter to delete one ActivityTemplateStepAssignment
     *   }
     * })
     * 
     */
    delete<T extends ActivityTemplateStepAssignmentDeleteArgs>(args: SelectSubset<T, ActivityTemplateStepAssignmentDeleteArgs<ExtArgs>>): Prisma__ActivityTemplateStepAssignmentClient<$Result.GetResult<Prisma.$ActivityTemplateStepAssignmentPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ActivityTemplateStepAssignment.
     * @param {ActivityTemplateStepAssignmentUpdateArgs} args - Arguments to update one ActivityTemplateStepAssignment.
     * @example
     * // Update one ActivityTemplateStepAssignment
     * const activityTemplateStepAssignment = await prisma.activityTemplateStepAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityTemplateStepAssignmentUpdateArgs>(args: SelectSubset<T, ActivityTemplateStepAssignmentUpdateArgs<ExtArgs>>): Prisma__ActivityTemplateStepAssignmentClient<$Result.GetResult<Prisma.$ActivityTemplateStepAssignmentPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ActivityTemplateStepAssignments.
     * @param {ActivityTemplateStepAssignmentDeleteManyArgs} args - Arguments to filter ActivityTemplateStepAssignments to delete.
     * @example
     * // Delete a few ActivityTemplateStepAssignments
     * const { count } = await prisma.activityTemplateStepAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityTemplateStepAssignmentDeleteManyArgs>(args?: SelectSubset<T, ActivityTemplateStepAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityTemplateStepAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityTemplateStepAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActivityTemplateStepAssignments
     * const activityTemplateStepAssignment = await prisma.activityTemplateStepAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityTemplateStepAssignmentUpdateManyArgs>(args: SelectSubset<T, ActivityTemplateStepAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityTemplateStepAssignments and returns the data updated in the database.
     * @param {ActivityTemplateStepAssignmentUpdateManyAndReturnArgs} args - Arguments to update many ActivityTemplateStepAssignments.
     * @example
     * // Update many ActivityTemplateStepAssignments
     * const activityTemplateStepAssignment = await prisma.activityTemplateStepAssignment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ActivityTemplateStepAssignments and only return the `id`
     * const activityTemplateStepAssignmentWithIdOnly = await prisma.activityTemplateStepAssignment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActivityTemplateStepAssignmentUpdateManyAndReturnArgs>(args: SelectSubset<T, ActivityTemplateStepAssignmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityTemplateStepAssignmentPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one ActivityTemplateStepAssignment.
     * @param {ActivityTemplateStepAssignmentUpsertArgs} args - Arguments to update or create a ActivityTemplateStepAssignment.
     * @example
     * // Update or create a ActivityTemplateStepAssignment
     * const activityTemplateStepAssignment = await prisma.activityTemplateStepAssignment.upsert({
     *   create: {
     *     // ... data to create a ActivityTemplateStepAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActivityTemplateStepAssignment we want to update
     *   }
     * })
     */
    upsert<T extends ActivityTemplateStepAssignmentUpsertArgs>(args: SelectSubset<T, ActivityTemplateStepAssignmentUpsertArgs<ExtArgs>>): Prisma__ActivityTemplateStepAssignmentClient<$Result.GetResult<Prisma.$ActivityTemplateStepAssignmentPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ActivityTemplateStepAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityTemplateStepAssignmentCountArgs} args - Arguments to filter ActivityTemplateStepAssignments to count.
     * @example
     * // Count the number of ActivityTemplateStepAssignments
     * const count = await prisma.activityTemplateStepAssignment.count({
     *   where: {
     *     // ... the filter for the ActivityTemplateStepAssignments we want to count
     *   }
     * })
    **/
    count<T extends ActivityTemplateStepAssignmentCountArgs>(
      args?: Subset<T, ActivityTemplateStepAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityTemplateStepAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActivityTemplateStepAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityTemplateStepAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityTemplateStepAssignmentAggregateArgs>(args: Subset<T, ActivityTemplateStepAssignmentAggregateArgs>): Prisma.PrismaPromise<GetActivityTemplateStepAssignmentAggregateType<T>>

    /**
     * Group by ActivityTemplateStepAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityTemplateStepAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityTemplateStepAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityTemplateStepAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: ActivityTemplateStepAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityTemplateStepAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityTemplateStepAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActivityTemplateStepAssignment model
   */
  readonly fields: ActivityTemplateStepAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActivityTemplateStepAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityTemplateStepAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    specificUser<T extends ActivityTemplateStepAssignment$specificUserArgs<ExtArgs> = {}>(args?: Subset<T, ActivityTemplateStepAssignment$specificUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    activityTemplateStep<T extends ActivityTemplateStepDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ActivityTemplateStepDefaultArgs<ExtArgs>>): Prisma__ActivityTemplateStepClient<$Result.GetResult<Prisma.$ActivityTemplateStepPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    tenet<T extends TenetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenetDefaultArgs<ExtArgs>>): Prisma__TenetClient<$Result.GetResult<Prisma.$TenetPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActivityTemplateStepAssignment model
   */ 
  interface ActivityTemplateStepAssignmentFieldRefs {
    readonly id: FieldRef<"ActivityTemplateStepAssignment", 'Bytes'>
    readonly specificUserId: FieldRef<"ActivityTemplateStepAssignment", 'Bytes'>
    readonly specificRole: FieldRef<"ActivityTemplateStepAssignment", 'Role'>
    readonly activityTemplateStepId: FieldRef<"ActivityTemplateStepAssignment", 'Bytes'>
    readonly tenetId: FieldRef<"ActivityTemplateStepAssignment", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * ActivityTemplateStepAssignment findUnique
   */
  export type ActivityTemplateStepAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityTemplateStepAssignment
     */
    select?: ActivityTemplateStepAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityTemplateStepAssignment
     */
    omit?: ActivityTemplateStepAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityTemplateStepAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ActivityTemplateStepAssignment to fetch.
     */
    where: ActivityTemplateStepAssignmentWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityTemplateStepAssignment findUniqueOrThrow
   */
  export type ActivityTemplateStepAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityTemplateStepAssignment
     */
    select?: ActivityTemplateStepAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityTemplateStepAssignment
     */
    omit?: ActivityTemplateStepAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityTemplateStepAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ActivityTemplateStepAssignment to fetch.
     */
    where: ActivityTemplateStepAssignmentWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityTemplateStepAssignment findFirst
   */
  export type ActivityTemplateStepAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityTemplateStepAssignment
     */
    select?: ActivityTemplateStepAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityTemplateStepAssignment
     */
    omit?: ActivityTemplateStepAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityTemplateStepAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ActivityTemplateStepAssignment to fetch.
     */
    where?: ActivityTemplateStepAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityTemplateStepAssignments to fetch.
     */
    orderBy?: ActivityTemplateStepAssignmentOrderByWithRelationInput | ActivityTemplateStepAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityTemplateStepAssignments.
     */
    cursor?: ActivityTemplateStepAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityTemplateStepAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityTemplateStepAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityTemplateStepAssignments.
     */
    distinct?: ActivityTemplateStepAssignmentScalarFieldEnum | ActivityTemplateStepAssignmentScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityTemplateStepAssignment findFirstOrThrow
   */
  export type ActivityTemplateStepAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityTemplateStepAssignment
     */
    select?: ActivityTemplateStepAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityTemplateStepAssignment
     */
    omit?: ActivityTemplateStepAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityTemplateStepAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ActivityTemplateStepAssignment to fetch.
     */
    where?: ActivityTemplateStepAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityTemplateStepAssignments to fetch.
     */
    orderBy?: ActivityTemplateStepAssignmentOrderByWithRelationInput | ActivityTemplateStepAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityTemplateStepAssignments.
     */
    cursor?: ActivityTemplateStepAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityTemplateStepAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityTemplateStepAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityTemplateStepAssignments.
     */
    distinct?: ActivityTemplateStepAssignmentScalarFieldEnum | ActivityTemplateStepAssignmentScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityTemplateStepAssignment findMany
   */
  export type ActivityTemplateStepAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityTemplateStepAssignment
     */
    select?: ActivityTemplateStepAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityTemplateStepAssignment
     */
    omit?: ActivityTemplateStepAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityTemplateStepAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ActivityTemplateStepAssignments to fetch.
     */
    where?: ActivityTemplateStepAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityTemplateStepAssignments to fetch.
     */
    orderBy?: ActivityTemplateStepAssignmentOrderByWithRelationInput | ActivityTemplateStepAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActivityTemplateStepAssignments.
     */
    cursor?: ActivityTemplateStepAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityTemplateStepAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityTemplateStepAssignments.
     */
    skip?: number
    distinct?: ActivityTemplateStepAssignmentScalarFieldEnum | ActivityTemplateStepAssignmentScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityTemplateStepAssignment create
   */
  export type ActivityTemplateStepAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityTemplateStepAssignment
     */
    select?: ActivityTemplateStepAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityTemplateStepAssignment
     */
    omit?: ActivityTemplateStepAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityTemplateStepAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a ActivityTemplateStepAssignment.
     */
    data: XOR<ActivityTemplateStepAssignmentCreateInput, ActivityTemplateStepAssignmentUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityTemplateStepAssignment createMany
   */
  export type ActivityTemplateStepAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActivityTemplateStepAssignments.
     */
    data: ActivityTemplateStepAssignmentCreateManyInput | ActivityTemplateStepAssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActivityTemplateStepAssignment createManyAndReturn
   */
  export type ActivityTemplateStepAssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityTemplateStepAssignment
     */
    select?: ActivityTemplateStepAssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityTemplateStepAssignment
     */
    omit?: ActivityTemplateStepAssignmentOmit<ExtArgs> | null
    /**
     * The data used to create many ActivityTemplateStepAssignments.
     */
    data: ActivityTemplateStepAssignmentCreateManyInput | ActivityTemplateStepAssignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityTemplateStepAssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityTemplateStepAssignment update
   */
  export type ActivityTemplateStepAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityTemplateStepAssignment
     */
    select?: ActivityTemplateStepAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityTemplateStepAssignment
     */
    omit?: ActivityTemplateStepAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityTemplateStepAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a ActivityTemplateStepAssignment.
     */
    data: XOR<ActivityTemplateStepAssignmentUpdateInput, ActivityTemplateStepAssignmentUncheckedUpdateInput>
    /**
     * Choose, which ActivityTemplateStepAssignment to update.
     */
    where: ActivityTemplateStepAssignmentWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityTemplateStepAssignment updateMany
   */
  export type ActivityTemplateStepAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActivityTemplateStepAssignments.
     */
    data: XOR<ActivityTemplateStepAssignmentUpdateManyMutationInput, ActivityTemplateStepAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which ActivityTemplateStepAssignments to update
     */
    where?: ActivityTemplateStepAssignmentWhereInput
    /**
     * Limit how many ActivityTemplateStepAssignments to update.
     */
    limit?: number
  }

  /**
   * ActivityTemplateStepAssignment updateManyAndReturn
   */
  export type ActivityTemplateStepAssignmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityTemplateStepAssignment
     */
    select?: ActivityTemplateStepAssignmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityTemplateStepAssignment
     */
    omit?: ActivityTemplateStepAssignmentOmit<ExtArgs> | null
    /**
     * The data used to update ActivityTemplateStepAssignments.
     */
    data: XOR<ActivityTemplateStepAssignmentUpdateManyMutationInput, ActivityTemplateStepAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which ActivityTemplateStepAssignments to update
     */
    where?: ActivityTemplateStepAssignmentWhereInput
    /**
     * Limit how many ActivityTemplateStepAssignments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityTemplateStepAssignmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityTemplateStepAssignment upsert
   */
  export type ActivityTemplateStepAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityTemplateStepAssignment
     */
    select?: ActivityTemplateStepAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityTemplateStepAssignment
     */
    omit?: ActivityTemplateStepAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityTemplateStepAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the ActivityTemplateStepAssignment to update in case it exists.
     */
    where: ActivityTemplateStepAssignmentWhereUniqueInput
    /**
     * In case the ActivityTemplateStepAssignment found by the `where` argument doesn't exist, create a new ActivityTemplateStepAssignment with this data.
     */
    create: XOR<ActivityTemplateStepAssignmentCreateInput, ActivityTemplateStepAssignmentUncheckedCreateInput>
    /**
     * In case the ActivityTemplateStepAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityTemplateStepAssignmentUpdateInput, ActivityTemplateStepAssignmentUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityTemplateStepAssignment delete
   */
  export type ActivityTemplateStepAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityTemplateStepAssignment
     */
    select?: ActivityTemplateStepAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityTemplateStepAssignment
     */
    omit?: ActivityTemplateStepAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityTemplateStepAssignmentInclude<ExtArgs> | null
    /**
     * Filter which ActivityTemplateStepAssignment to delete.
     */
    where: ActivityTemplateStepAssignmentWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityTemplateStepAssignment deleteMany
   */
  export type ActivityTemplateStepAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityTemplateStepAssignments to delete
     */
    where?: ActivityTemplateStepAssignmentWhereInput
    /**
     * Limit how many ActivityTemplateStepAssignments to delete.
     */
    limit?: number
  }

  /**
   * ActivityTemplateStepAssignment.specificUser
   */
  export type ActivityTemplateStepAssignment$specificUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ActivityTemplateStepAssignment without action
   */
  export type ActivityTemplateStepAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityTemplateStepAssignment
     */
    select?: ActivityTemplateStepAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityTemplateStepAssignment
     */
    omit?: ActivityTemplateStepAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityTemplateStepAssignmentInclude<ExtArgs> | null
  }


  /**
   * Model ActivityTemplate
   */

  export type AggregateActivityTemplate = {
    _count: ActivityTemplateCountAggregateOutputType | null
    _avg: ActivityTemplateAvgAggregateOutputType | null
    _sum: ActivityTemplateSumAggregateOutputType | null
    _min: ActivityTemplateMinAggregateOutputType | null
    _max: ActivityTemplateMaxAggregateOutputType | null
  }

  export type ActivityTemplateAvgAggregateOutputType = {
    startDate: number | null
    endDate: number | null
    order: number | null
  }

  export type ActivityTemplateSumAggregateOutputType = {
    startDate: number | null
    endDate: number | null
    order: number | null
  }

  export type ActivityTemplateMinAggregateOutputType = {
    id: Uint8Array | null
    title: string | null
    description: string | null
    type: $Enums.ActivityType | null
    defaultPriority: $Enums.ActivityPriority | null
    defaultStatus: $Enums.ActivityStatus | null
    taskScheduleType: $Enums.TaskScheduleType | null
    dateOffsetType: $Enums.DateOffsetType | null
    startDate: number | null
    endDate: number | null
    startRelativeToId: Uint8Array | null
    parentWaypointId: Uint8Array | null
    parentActivityId: Uint8Array | null
    createdAt: Date | null
    updatedAt: Date | null
    tenetId: Uint8Array | null
    order: number | null
  }

  export type ActivityTemplateMaxAggregateOutputType = {
    id: Uint8Array | null
    title: string | null
    description: string | null
    type: $Enums.ActivityType | null
    defaultPriority: $Enums.ActivityPriority | null
    defaultStatus: $Enums.ActivityStatus | null
    taskScheduleType: $Enums.TaskScheduleType | null
    dateOffsetType: $Enums.DateOffsetType | null
    startDate: number | null
    endDate: number | null
    startRelativeToId: Uint8Array | null
    parentWaypointId: Uint8Array | null
    parentActivityId: Uint8Array | null
    createdAt: Date | null
    updatedAt: Date | null
    tenetId: Uint8Array | null
    order: number | null
  }

  export type ActivityTemplateCountAggregateOutputType = {
    id: number
    title: number
    description: number
    type: number
    defaultPriority: number
    defaultStatus: number
    taskScheduleType: number
    dateOffsetType: number
    startDate: number
    endDate: number
    startRelativeToId: number
    parentWaypointId: number
    parentActivityId: number
    createdAt: number
    updatedAt: number
    tenetId: number
    order: number
    _all: number
  }


  export type ActivityTemplateAvgAggregateInputType = {
    startDate?: true
    endDate?: true
    order?: true
  }

  export type ActivityTemplateSumAggregateInputType = {
    startDate?: true
    endDate?: true
    order?: true
  }

  export type ActivityTemplateMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    defaultPriority?: true
    defaultStatus?: true
    taskScheduleType?: true
    dateOffsetType?: true
    startDate?: true
    endDate?: true
    startRelativeToId?: true
    parentWaypointId?: true
    parentActivityId?: true
    createdAt?: true
    updatedAt?: true
    tenetId?: true
    order?: true
  }

  export type ActivityTemplateMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    defaultPriority?: true
    defaultStatus?: true
    taskScheduleType?: true
    dateOffsetType?: true
    startDate?: true
    endDate?: true
    startRelativeToId?: true
    parentWaypointId?: true
    parentActivityId?: true
    createdAt?: true
    updatedAt?: true
    tenetId?: true
    order?: true
  }

  export type ActivityTemplateCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    defaultPriority?: true
    defaultStatus?: true
    taskScheduleType?: true
    dateOffsetType?: true
    startDate?: true
    endDate?: true
    startRelativeToId?: true
    parentWaypointId?: true
    parentActivityId?: true
    createdAt?: true
    updatedAt?: true
    tenetId?: true
    order?: true
    _all?: true
  }

  export type ActivityTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityTemplate to aggregate.
     */
    where?: ActivityTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityTemplates to fetch.
     */
    orderBy?: ActivityTemplateOrderByWithRelationInput | ActivityTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActivityTemplates
    **/
    _count?: true | ActivityTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActivityTemplateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActivityTemplateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityTemplateMaxAggregateInputType
  }

  export type GetActivityTemplateAggregateType<T extends ActivityTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateActivityTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivityTemplate[P]>
      : GetScalarType<T[P], AggregateActivityTemplate[P]>
  }




  export type ActivityTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityTemplateWhereInput
    orderBy?: ActivityTemplateOrderByWithAggregationInput | ActivityTemplateOrderByWithAggregationInput[]
    by: ActivityTemplateScalarFieldEnum[] | ActivityTemplateScalarFieldEnum
    having?: ActivityTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityTemplateCountAggregateInputType | true
    _avg?: ActivityTemplateAvgAggregateInputType
    _sum?: ActivityTemplateSumAggregateInputType
    _min?: ActivityTemplateMinAggregateInputType
    _max?: ActivityTemplateMaxAggregateInputType
  }

  export type ActivityTemplateGroupByOutputType = {
    id: Uint8Array
    title: string
    description: string | null
    type: $Enums.ActivityType
    defaultPriority: $Enums.ActivityPriority
    defaultStatus: $Enums.ActivityStatus
    taskScheduleType: $Enums.TaskScheduleType | null
    dateOffsetType: $Enums.DateOffsetType
    startDate: number
    endDate: number
    startRelativeToId: Uint8Array | null
    parentWaypointId: Uint8Array | null
    parentActivityId: Uint8Array | null
    createdAt: Date
    updatedAt: Date
    tenetId: Uint8Array
    order: number | null
    _count: ActivityTemplateCountAggregateOutputType | null
    _avg: ActivityTemplateAvgAggregateOutputType | null
    _sum: ActivityTemplateSumAggregateOutputType | null
    _min: ActivityTemplateMinAggregateOutputType | null
    _max: ActivityTemplateMaxAggregateOutputType | null
  }

  type GetActivityTemplateGroupByPayload<T extends ActivityTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityTemplateGroupByOutputType[P]>
        }
      >
    >


  export type ActivityTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    defaultPriority?: boolean
    defaultStatus?: boolean
    taskScheduleType?: boolean
    dateOffsetType?: boolean
    startDate?: boolean
    endDate?: boolean
    startRelativeToId?: boolean
    parentWaypointId?: boolean
    parentActivityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenetId?: boolean
    order?: boolean
    steps?: boolean | ActivityTemplate$stepsArgs<ExtArgs>
    startRelativeTo?: boolean | ActivityTemplate$startRelativeToArgs<ExtArgs>
    dependents?: boolean | ActivityTemplate$dependentsArgs<ExtArgs>
    parentWaypoint?: boolean | ActivityTemplate$parentWaypointArgs<ExtArgs>
    parentActivity?: boolean | ActivityTemplate$parentActivityArgs<ExtArgs>
    waypoints?: boolean | ActivityTemplate$waypointsArgs<ExtArgs>
    childActivities?: boolean | ActivityTemplate$childActivitiesArgs<ExtArgs>
    activities?: boolean | ActivityTemplate$activitiesArgs<ExtArgs>
    assignments?: boolean | ActivityTemplate$assignmentsArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
    _count?: boolean | ActivityTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityTemplate"]>

  export type ActivityTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    defaultPriority?: boolean
    defaultStatus?: boolean
    taskScheduleType?: boolean
    dateOffsetType?: boolean
    startDate?: boolean
    endDate?: boolean
    startRelativeToId?: boolean
    parentWaypointId?: boolean
    parentActivityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenetId?: boolean
    order?: boolean
    startRelativeTo?: boolean | ActivityTemplate$startRelativeToArgs<ExtArgs>
    parentWaypoint?: boolean | ActivityTemplate$parentWaypointArgs<ExtArgs>
    parentActivity?: boolean | ActivityTemplate$parentActivityArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityTemplate"]>

  export type ActivityTemplateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    defaultPriority?: boolean
    defaultStatus?: boolean
    taskScheduleType?: boolean
    dateOffsetType?: boolean
    startDate?: boolean
    endDate?: boolean
    startRelativeToId?: boolean
    parentWaypointId?: boolean
    parentActivityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenetId?: boolean
    order?: boolean
    startRelativeTo?: boolean | ActivityTemplate$startRelativeToArgs<ExtArgs>
    parentWaypoint?: boolean | ActivityTemplate$parentWaypointArgs<ExtArgs>
    parentActivity?: boolean | ActivityTemplate$parentActivityArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityTemplate"]>

  export type ActivityTemplateSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    defaultPriority?: boolean
    defaultStatus?: boolean
    taskScheduleType?: boolean
    dateOffsetType?: boolean
    startDate?: boolean
    endDate?: boolean
    startRelativeToId?: boolean
    parentWaypointId?: boolean
    parentActivityId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenetId?: boolean
    order?: boolean
  }

  export type ActivityTemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "type" | "defaultPriority" | "defaultStatus" | "taskScheduleType" | "dateOffsetType" | "startDate" | "endDate" | "startRelativeToId" | "parentWaypointId" | "parentActivityId" | "createdAt" | "updatedAt" | "tenetId" | "order", ExtArgs["result"]["activityTemplate"]>
  export type ActivityTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    steps?: boolean | ActivityTemplate$stepsArgs<ExtArgs>
    startRelativeTo?: boolean | ActivityTemplate$startRelativeToArgs<ExtArgs>
    dependents?: boolean | ActivityTemplate$dependentsArgs<ExtArgs>
    parentWaypoint?: boolean | ActivityTemplate$parentWaypointArgs<ExtArgs>
    parentActivity?: boolean | ActivityTemplate$parentActivityArgs<ExtArgs>
    waypoints?: boolean | ActivityTemplate$waypointsArgs<ExtArgs>
    childActivities?: boolean | ActivityTemplate$childActivitiesArgs<ExtArgs>
    activities?: boolean | ActivityTemplate$activitiesArgs<ExtArgs>
    assignments?: boolean | ActivityTemplate$assignmentsArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
    _count?: boolean | ActivityTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ActivityTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    startRelativeTo?: boolean | ActivityTemplate$startRelativeToArgs<ExtArgs>
    parentWaypoint?: boolean | ActivityTemplate$parentWaypointArgs<ExtArgs>
    parentActivity?: boolean | ActivityTemplate$parentActivityArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }
  export type ActivityTemplateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    startRelativeTo?: boolean | ActivityTemplate$startRelativeToArgs<ExtArgs>
    parentWaypoint?: boolean | ActivityTemplate$parentWaypointArgs<ExtArgs>
    parentActivity?: boolean | ActivityTemplate$parentActivityArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }

  export type $ActivityTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActivityTemplate"
    objects: {
      steps: Prisma.$ActivityTemplateStepPayload<ExtArgs>[]
      startRelativeTo: Prisma.$ActivityTemplatePayload<ExtArgs> | null
      dependents: Prisma.$ActivityTemplatePayload<ExtArgs>[]
      parentWaypoint: Prisma.$ActivityWaypointTemplatePayload<ExtArgs> | null
      parentActivity: Prisma.$ActivityTemplatePayload<ExtArgs> | null
      waypoints: Prisma.$ActivityWaypointTemplatePayload<ExtArgs>[]
      childActivities: Prisma.$ActivityTemplatePayload<ExtArgs>[]
      activities: Prisma.$ActivityPayload<ExtArgs>[]
      assignments: Prisma.$TemplateAssignmentPayload<ExtArgs>[]
      tenet: Prisma.$TenetPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: Uint8Array
      title: string
      description: string | null
      type: $Enums.ActivityType
      defaultPriority: $Enums.ActivityPriority
      defaultStatus: $Enums.ActivityStatus
      taskScheduleType: $Enums.TaskScheduleType | null
      dateOffsetType: $Enums.DateOffsetType
      startDate: number
      endDate: number
      startRelativeToId: Uint8Array | null
      parentWaypointId: Uint8Array | null
      parentActivityId: Uint8Array | null
      createdAt: Date
      updatedAt: Date
      tenetId: Uint8Array
      order: number | null
    }, ExtArgs["result"]["activityTemplate"]>
    composites: {}
  }

  type ActivityTemplateGetPayload<S extends boolean | null | undefined | ActivityTemplateDefaultArgs> = $Result.GetResult<Prisma.$ActivityTemplatePayload, S>

  type ActivityTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActivityTemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: ActivityTemplateCountAggregateInputType | true
    }

  export interface ActivityTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActivityTemplate'], meta: { name: 'ActivityTemplate' } }
    /**
     * Find zero or one ActivityTemplate that matches the filter.
     * @param {ActivityTemplateFindUniqueArgs} args - Arguments to find a ActivityTemplate
     * @example
     * // Get one ActivityTemplate
     * const activityTemplate = await prisma.activityTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityTemplateFindUniqueArgs>(args: SelectSubset<T, ActivityTemplateFindUniqueArgs<ExtArgs>>): Prisma__ActivityTemplateClient<$Result.GetResult<Prisma.$ActivityTemplatePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ActivityTemplate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActivityTemplateFindUniqueOrThrowArgs} args - Arguments to find a ActivityTemplate
     * @example
     * // Get one ActivityTemplate
     * const activityTemplate = await prisma.activityTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityTemplateClient<$Result.GetResult<Prisma.$ActivityTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ActivityTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityTemplateFindFirstArgs} args - Arguments to find a ActivityTemplate
     * @example
     * // Get one ActivityTemplate
     * const activityTemplate = await prisma.activityTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityTemplateFindFirstArgs>(args?: SelectSubset<T, ActivityTemplateFindFirstArgs<ExtArgs>>): Prisma__ActivityTemplateClient<$Result.GetResult<Prisma.$ActivityTemplatePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ActivityTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityTemplateFindFirstOrThrowArgs} args - Arguments to find a ActivityTemplate
     * @example
     * // Get one ActivityTemplate
     * const activityTemplate = await prisma.activityTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityTemplateClient<$Result.GetResult<Prisma.$ActivityTemplatePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ActivityTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActivityTemplates
     * const activityTemplates = await prisma.activityTemplate.findMany()
     * 
     * // Get first 10 ActivityTemplates
     * const activityTemplates = await prisma.activityTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityTemplateWithIdOnly = await prisma.activityTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityTemplateFindManyArgs>(args?: SelectSubset<T, ActivityTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityTemplatePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ActivityTemplate.
     * @param {ActivityTemplateCreateArgs} args - Arguments to create a ActivityTemplate.
     * @example
     * // Create one ActivityTemplate
     * const ActivityTemplate = await prisma.activityTemplate.create({
     *   data: {
     *     // ... data to create a ActivityTemplate
     *   }
     * })
     * 
     */
    create<T extends ActivityTemplateCreateArgs>(args: SelectSubset<T, ActivityTemplateCreateArgs<ExtArgs>>): Prisma__ActivityTemplateClient<$Result.GetResult<Prisma.$ActivityTemplatePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ActivityTemplates.
     * @param {ActivityTemplateCreateManyArgs} args - Arguments to create many ActivityTemplates.
     * @example
     * // Create many ActivityTemplates
     * const activityTemplate = await prisma.activityTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityTemplateCreateManyArgs>(args?: SelectSubset<T, ActivityTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActivityTemplates and returns the data saved in the database.
     * @param {ActivityTemplateCreateManyAndReturnArgs} args - Arguments to create many ActivityTemplates.
     * @example
     * // Create many ActivityTemplates
     * const activityTemplate = await prisma.activityTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActivityTemplates and only return the `id`
     * const activityTemplateWithIdOnly = await prisma.activityTemplate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityTemplatePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a ActivityTemplate.
     * @param {ActivityTemplateDeleteArgs} args - Arguments to delete one ActivityTemplate.
     * @example
     * // Delete one ActivityTemplate
     * const ActivityTemplate = await prisma.activityTemplate.delete({
     *   where: {
     *     // ... filter to delete one ActivityTemplate
     *   }
     * })
     * 
     */
    delete<T extends ActivityTemplateDeleteArgs>(args: SelectSubset<T, ActivityTemplateDeleteArgs<ExtArgs>>): Prisma__ActivityTemplateClient<$Result.GetResult<Prisma.$ActivityTemplatePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ActivityTemplate.
     * @param {ActivityTemplateUpdateArgs} args - Arguments to update one ActivityTemplate.
     * @example
     * // Update one ActivityTemplate
     * const activityTemplate = await prisma.activityTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityTemplateUpdateArgs>(args: SelectSubset<T, ActivityTemplateUpdateArgs<ExtArgs>>): Prisma__ActivityTemplateClient<$Result.GetResult<Prisma.$ActivityTemplatePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ActivityTemplates.
     * @param {ActivityTemplateDeleteManyArgs} args - Arguments to filter ActivityTemplates to delete.
     * @example
     * // Delete a few ActivityTemplates
     * const { count } = await prisma.activityTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityTemplateDeleteManyArgs>(args?: SelectSubset<T, ActivityTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActivityTemplates
     * const activityTemplate = await prisma.activityTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityTemplateUpdateManyArgs>(args: SelectSubset<T, ActivityTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityTemplates and returns the data updated in the database.
     * @param {ActivityTemplateUpdateManyAndReturnArgs} args - Arguments to update many ActivityTemplates.
     * @example
     * // Update many ActivityTemplates
     * const activityTemplate = await prisma.activityTemplate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ActivityTemplates and only return the `id`
     * const activityTemplateWithIdOnly = await prisma.activityTemplate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActivityTemplateUpdateManyAndReturnArgs>(args: SelectSubset<T, ActivityTemplateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityTemplatePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one ActivityTemplate.
     * @param {ActivityTemplateUpsertArgs} args - Arguments to update or create a ActivityTemplate.
     * @example
     * // Update or create a ActivityTemplate
     * const activityTemplate = await prisma.activityTemplate.upsert({
     *   create: {
     *     // ... data to create a ActivityTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActivityTemplate we want to update
     *   }
     * })
     */
    upsert<T extends ActivityTemplateUpsertArgs>(args: SelectSubset<T, ActivityTemplateUpsertArgs<ExtArgs>>): Prisma__ActivityTemplateClient<$Result.GetResult<Prisma.$ActivityTemplatePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ActivityTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityTemplateCountArgs} args - Arguments to filter ActivityTemplates to count.
     * @example
     * // Count the number of ActivityTemplates
     * const count = await prisma.activityTemplate.count({
     *   where: {
     *     // ... the filter for the ActivityTemplates we want to count
     *   }
     * })
    **/
    count<T extends ActivityTemplateCountArgs>(
      args?: Subset<T, ActivityTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActivityTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityTemplateAggregateArgs>(args: Subset<T, ActivityTemplateAggregateArgs>): Prisma.PrismaPromise<GetActivityTemplateAggregateType<T>>

    /**
     * Group by ActivityTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityTemplateGroupByArgs['orderBy'] }
        : { orderBy?: ActivityTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActivityTemplate model
   */
  readonly fields: ActivityTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActivityTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    steps<T extends ActivityTemplate$stepsArgs<ExtArgs> = {}>(args?: Subset<T, ActivityTemplate$stepsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityTemplateStepPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    startRelativeTo<T extends ActivityTemplate$startRelativeToArgs<ExtArgs> = {}>(args?: Subset<T, ActivityTemplate$startRelativeToArgs<ExtArgs>>): Prisma__ActivityTemplateClient<$Result.GetResult<Prisma.$ActivityTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    dependents<T extends ActivityTemplate$dependentsArgs<ExtArgs> = {}>(args?: Subset<T, ActivityTemplate$dependentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityTemplatePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    parentWaypoint<T extends ActivityTemplate$parentWaypointArgs<ExtArgs> = {}>(args?: Subset<T, ActivityTemplate$parentWaypointArgs<ExtArgs>>): Prisma__ActivityWaypointTemplateClient<$Result.GetResult<Prisma.$ActivityWaypointTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    parentActivity<T extends ActivityTemplate$parentActivityArgs<ExtArgs> = {}>(args?: Subset<T, ActivityTemplate$parentActivityArgs<ExtArgs>>): Prisma__ActivityTemplateClient<$Result.GetResult<Prisma.$ActivityTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    waypoints<T extends ActivityTemplate$waypointsArgs<ExtArgs> = {}>(args?: Subset<T, ActivityTemplate$waypointsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityWaypointTemplatePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    childActivities<T extends ActivityTemplate$childActivitiesArgs<ExtArgs> = {}>(args?: Subset<T, ActivityTemplate$childActivitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityTemplatePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    activities<T extends ActivityTemplate$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, ActivityTemplate$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    assignments<T extends ActivityTemplate$assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, ActivityTemplate$assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplateAssignmentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    tenet<T extends TenetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenetDefaultArgs<ExtArgs>>): Prisma__TenetClient<$Result.GetResult<Prisma.$TenetPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActivityTemplate model
   */ 
  interface ActivityTemplateFieldRefs {
    readonly id: FieldRef<"ActivityTemplate", 'Bytes'>
    readonly title: FieldRef<"ActivityTemplate", 'String'>
    readonly description: FieldRef<"ActivityTemplate", 'String'>
    readonly type: FieldRef<"ActivityTemplate", 'ActivityType'>
    readonly defaultPriority: FieldRef<"ActivityTemplate", 'ActivityPriority'>
    readonly defaultStatus: FieldRef<"ActivityTemplate", 'ActivityStatus'>
    readonly taskScheduleType: FieldRef<"ActivityTemplate", 'TaskScheduleType'>
    readonly dateOffsetType: FieldRef<"ActivityTemplate", 'DateOffsetType'>
    readonly startDate: FieldRef<"ActivityTemplate", 'Int'>
    readonly endDate: FieldRef<"ActivityTemplate", 'Int'>
    readonly startRelativeToId: FieldRef<"ActivityTemplate", 'Bytes'>
    readonly parentWaypointId: FieldRef<"ActivityTemplate", 'Bytes'>
    readonly parentActivityId: FieldRef<"ActivityTemplate", 'Bytes'>
    readonly createdAt: FieldRef<"ActivityTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"ActivityTemplate", 'DateTime'>
    readonly tenetId: FieldRef<"ActivityTemplate", 'Bytes'>
    readonly order: FieldRef<"ActivityTemplate", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ActivityTemplate findUnique
   */
  export type ActivityTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityTemplate
     */
    select?: ActivityTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityTemplate
     */
    omit?: ActivityTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ActivityTemplate to fetch.
     */
    where: ActivityTemplateWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityTemplate findUniqueOrThrow
   */
  export type ActivityTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityTemplate
     */
    select?: ActivityTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityTemplate
     */
    omit?: ActivityTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ActivityTemplate to fetch.
     */
    where: ActivityTemplateWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityTemplate findFirst
   */
  export type ActivityTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityTemplate
     */
    select?: ActivityTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityTemplate
     */
    omit?: ActivityTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ActivityTemplate to fetch.
     */
    where?: ActivityTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityTemplates to fetch.
     */
    orderBy?: ActivityTemplateOrderByWithRelationInput | ActivityTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityTemplates.
     */
    cursor?: ActivityTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityTemplates.
     */
    distinct?: ActivityTemplateScalarFieldEnum | ActivityTemplateScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityTemplate findFirstOrThrow
   */
  export type ActivityTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityTemplate
     */
    select?: ActivityTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityTemplate
     */
    omit?: ActivityTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ActivityTemplate to fetch.
     */
    where?: ActivityTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityTemplates to fetch.
     */
    orderBy?: ActivityTemplateOrderByWithRelationInput | ActivityTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityTemplates.
     */
    cursor?: ActivityTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityTemplates.
     */
    distinct?: ActivityTemplateScalarFieldEnum | ActivityTemplateScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityTemplate findMany
   */
  export type ActivityTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityTemplate
     */
    select?: ActivityTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityTemplate
     */
    omit?: ActivityTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ActivityTemplates to fetch.
     */
    where?: ActivityTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityTemplates to fetch.
     */
    orderBy?: ActivityTemplateOrderByWithRelationInput | ActivityTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActivityTemplates.
     */
    cursor?: ActivityTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityTemplates.
     */
    skip?: number
    distinct?: ActivityTemplateScalarFieldEnum | ActivityTemplateScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityTemplate create
   */
  export type ActivityTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityTemplate
     */
    select?: ActivityTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityTemplate
     */
    omit?: ActivityTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a ActivityTemplate.
     */
    data: XOR<ActivityTemplateCreateInput, ActivityTemplateUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityTemplate createMany
   */
  export type ActivityTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActivityTemplates.
     */
    data: ActivityTemplateCreateManyInput | ActivityTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActivityTemplate createManyAndReturn
   */
  export type ActivityTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityTemplate
     */
    select?: ActivityTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityTemplate
     */
    omit?: ActivityTemplateOmit<ExtArgs> | null
    /**
     * The data used to create many ActivityTemplates.
     */
    data: ActivityTemplateCreateManyInput | ActivityTemplateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityTemplateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityTemplate update
   */
  export type ActivityTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityTemplate
     */
    select?: ActivityTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityTemplate
     */
    omit?: ActivityTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a ActivityTemplate.
     */
    data: XOR<ActivityTemplateUpdateInput, ActivityTemplateUncheckedUpdateInput>
    /**
     * Choose, which ActivityTemplate to update.
     */
    where: ActivityTemplateWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityTemplate updateMany
   */
  export type ActivityTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActivityTemplates.
     */
    data: XOR<ActivityTemplateUpdateManyMutationInput, ActivityTemplateUncheckedUpdateManyInput>
    /**
     * Filter which ActivityTemplates to update
     */
    where?: ActivityTemplateWhereInput
    /**
     * Limit how many ActivityTemplates to update.
     */
    limit?: number
  }

  /**
   * ActivityTemplate updateManyAndReturn
   */
  export type ActivityTemplateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityTemplate
     */
    select?: ActivityTemplateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityTemplate
     */
    omit?: ActivityTemplateOmit<ExtArgs> | null
    /**
     * The data used to update ActivityTemplates.
     */
    data: XOR<ActivityTemplateUpdateManyMutationInput, ActivityTemplateUncheckedUpdateManyInput>
    /**
     * Filter which ActivityTemplates to update
     */
    where?: ActivityTemplateWhereInput
    /**
     * Limit how many ActivityTemplates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityTemplateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityTemplate upsert
   */
  export type ActivityTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityTemplate
     */
    select?: ActivityTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityTemplate
     */
    omit?: ActivityTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the ActivityTemplate to update in case it exists.
     */
    where: ActivityTemplateWhereUniqueInput
    /**
     * In case the ActivityTemplate found by the `where` argument doesn't exist, create a new ActivityTemplate with this data.
     */
    create: XOR<ActivityTemplateCreateInput, ActivityTemplateUncheckedCreateInput>
    /**
     * In case the ActivityTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityTemplateUpdateInput, ActivityTemplateUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityTemplate delete
   */
  export type ActivityTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityTemplate
     */
    select?: ActivityTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityTemplate
     */
    omit?: ActivityTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityTemplateInclude<ExtArgs> | null
    /**
     * Filter which ActivityTemplate to delete.
     */
    where: ActivityTemplateWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityTemplate deleteMany
   */
  export type ActivityTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityTemplates to delete
     */
    where?: ActivityTemplateWhereInput
    /**
     * Limit how many ActivityTemplates to delete.
     */
    limit?: number
  }

  /**
   * ActivityTemplate.steps
   */
  export type ActivityTemplate$stepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityTemplateStep
     */
    select?: ActivityTemplateStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityTemplateStep
     */
    omit?: ActivityTemplateStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityTemplateStepInclude<ExtArgs> | null
    where?: ActivityTemplateStepWhereInput
    orderBy?: ActivityTemplateStepOrderByWithRelationInput | ActivityTemplateStepOrderByWithRelationInput[]
    cursor?: ActivityTemplateStepWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityTemplateStepScalarFieldEnum | ActivityTemplateStepScalarFieldEnum[]
  }

  /**
   * ActivityTemplate.startRelativeTo
   */
  export type ActivityTemplate$startRelativeToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityTemplate
     */
    select?: ActivityTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityTemplate
     */
    omit?: ActivityTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityTemplateInclude<ExtArgs> | null
    where?: ActivityTemplateWhereInput
  }

  /**
   * ActivityTemplate.dependents
   */
  export type ActivityTemplate$dependentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityTemplate
     */
    select?: ActivityTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityTemplate
     */
    omit?: ActivityTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityTemplateInclude<ExtArgs> | null
    where?: ActivityTemplateWhereInput
    orderBy?: ActivityTemplateOrderByWithRelationInput | ActivityTemplateOrderByWithRelationInput[]
    cursor?: ActivityTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityTemplateScalarFieldEnum | ActivityTemplateScalarFieldEnum[]
  }

  /**
   * ActivityTemplate.parentWaypoint
   */
  export type ActivityTemplate$parentWaypointArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityWaypointTemplate
     */
    select?: ActivityWaypointTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityWaypointTemplate
     */
    omit?: ActivityWaypointTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityWaypointTemplateInclude<ExtArgs> | null
    where?: ActivityWaypointTemplateWhereInput
  }

  /**
   * ActivityTemplate.parentActivity
   */
  export type ActivityTemplate$parentActivityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityTemplate
     */
    select?: ActivityTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityTemplate
     */
    omit?: ActivityTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityTemplateInclude<ExtArgs> | null
    where?: ActivityTemplateWhereInput
  }

  /**
   * ActivityTemplate.waypoints
   */
  export type ActivityTemplate$waypointsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityWaypointTemplate
     */
    select?: ActivityWaypointTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityWaypointTemplate
     */
    omit?: ActivityWaypointTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityWaypointTemplateInclude<ExtArgs> | null
    where?: ActivityWaypointTemplateWhereInput
    orderBy?: ActivityWaypointTemplateOrderByWithRelationInput | ActivityWaypointTemplateOrderByWithRelationInput[]
    cursor?: ActivityWaypointTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityWaypointTemplateScalarFieldEnum | ActivityWaypointTemplateScalarFieldEnum[]
  }

  /**
   * ActivityTemplate.childActivities
   */
  export type ActivityTemplate$childActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityTemplate
     */
    select?: ActivityTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityTemplate
     */
    omit?: ActivityTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityTemplateInclude<ExtArgs> | null
    where?: ActivityTemplateWhereInput
    orderBy?: ActivityTemplateOrderByWithRelationInput | ActivityTemplateOrderByWithRelationInput[]
    cursor?: ActivityTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityTemplateScalarFieldEnum | ActivityTemplateScalarFieldEnum[]
  }

  /**
   * ActivityTemplate.activities
   */
  export type ActivityTemplate$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    cursor?: ActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * ActivityTemplate.assignments
   */
  export type ActivityTemplate$assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateAssignment
     */
    select?: TemplateAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateAssignment
     */
    omit?: TemplateAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateAssignmentInclude<ExtArgs> | null
    where?: TemplateAssignmentWhereInput
    orderBy?: TemplateAssignmentOrderByWithRelationInput | TemplateAssignmentOrderByWithRelationInput[]
    cursor?: TemplateAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TemplateAssignmentScalarFieldEnum | TemplateAssignmentScalarFieldEnum[]
  }

  /**
   * ActivityTemplate without action
   */
  export type ActivityTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityTemplate
     */
    select?: ActivityTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityTemplate
     */
    omit?: ActivityTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityTemplateInclude<ExtArgs> | null
  }


  /**
   * Model Activity
   */

  export type AggregateActivity = {
    _count: ActivityCountAggregateOutputType | null
    _avg: ActivityAvgAggregateOutputType | null
    _sum: ActivitySumAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  export type ActivityAvgAggregateOutputType = {
    order: number | null
  }

  export type ActivitySumAggregateOutputType = {
    order: number | null
  }

  export type ActivityMinAggregateOutputType = {
    id: Uint8Array | null
    title: string | null
    type: $Enums.ActivityType | null
    parentActivityId: Uint8Array | null
    parentWaypointId: Uint8Array | null
    templateId: Uint8Array | null
    taskScheduleType: $Enums.TaskScheduleType | null
    startDate: Date | null
    endDate: Date | null
    completedAt: Date | null
    description: string | null
    priority: $Enums.ActivityPriority | null
    status: $Enums.ActivityStatus | null
    assignedById: Uint8Array | null
    phoneNumber: string | null
    location: string | null
    holdReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
    tenetId: Uint8Array | null
    deleted: boolean | null
    deletedAt: Date | null
    order: number | null
    opportunityId: Uint8Array | null
  }

  export type ActivityMaxAggregateOutputType = {
    id: Uint8Array | null
    title: string | null
    type: $Enums.ActivityType | null
    parentActivityId: Uint8Array | null
    parentWaypointId: Uint8Array | null
    templateId: Uint8Array | null
    taskScheduleType: $Enums.TaskScheduleType | null
    startDate: Date | null
    endDate: Date | null
    completedAt: Date | null
    description: string | null
    priority: $Enums.ActivityPriority | null
    status: $Enums.ActivityStatus | null
    assignedById: Uint8Array | null
    phoneNumber: string | null
    location: string | null
    holdReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
    tenetId: Uint8Array | null
    deleted: boolean | null
    deletedAt: Date | null
    order: number | null
    opportunityId: Uint8Array | null
  }

  export type ActivityCountAggregateOutputType = {
    id: number
    title: number
    type: number
    parentActivityId: number
    parentWaypointId: number
    templateId: number
    taskScheduleType: number
    startDate: number
    endDate: number
    completedAt: number
    description: number
    priority: number
    status: number
    assignedById: number
    phoneNumber: number
    location: number
    holdReason: number
    createdAt: number
    updatedAt: number
    tenetId: number
    deleted: number
    deletedAt: number
    order: number
    opportunityId: number
    _all: number
  }


  export type ActivityAvgAggregateInputType = {
    order?: true
  }

  export type ActivitySumAggregateInputType = {
    order?: true
  }

  export type ActivityMinAggregateInputType = {
    id?: true
    title?: true
    type?: true
    parentActivityId?: true
    parentWaypointId?: true
    templateId?: true
    taskScheduleType?: true
    startDate?: true
    endDate?: true
    completedAt?: true
    description?: true
    priority?: true
    status?: true
    assignedById?: true
    phoneNumber?: true
    location?: true
    holdReason?: true
    createdAt?: true
    updatedAt?: true
    tenetId?: true
    deleted?: true
    deletedAt?: true
    order?: true
    opportunityId?: true
  }

  export type ActivityMaxAggregateInputType = {
    id?: true
    title?: true
    type?: true
    parentActivityId?: true
    parentWaypointId?: true
    templateId?: true
    taskScheduleType?: true
    startDate?: true
    endDate?: true
    completedAt?: true
    description?: true
    priority?: true
    status?: true
    assignedById?: true
    phoneNumber?: true
    location?: true
    holdReason?: true
    createdAt?: true
    updatedAt?: true
    tenetId?: true
    deleted?: true
    deletedAt?: true
    order?: true
    opportunityId?: true
  }

  export type ActivityCountAggregateInputType = {
    id?: true
    title?: true
    type?: true
    parentActivityId?: true
    parentWaypointId?: true
    templateId?: true
    taskScheduleType?: true
    startDate?: true
    endDate?: true
    completedAt?: true
    description?: true
    priority?: true
    status?: true
    assignedById?: true
    phoneNumber?: true
    location?: true
    holdReason?: true
    createdAt?: true
    updatedAt?: true
    tenetId?: true
    deleted?: true
    deletedAt?: true
    order?: true
    opportunityId?: true
    _all?: true
  }

  export type ActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activity to aggregate.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Activities
    **/
    _count?: true | ActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActivityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActivitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityMaxAggregateInputType
  }

  export type GetActivityAggregateType<T extends ActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivity[P]>
      : GetScalarType<T[P], AggregateActivity[P]>
  }




  export type ActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithAggregationInput | ActivityOrderByWithAggregationInput[]
    by: ActivityScalarFieldEnum[] | ActivityScalarFieldEnum
    having?: ActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityCountAggregateInputType | true
    _avg?: ActivityAvgAggregateInputType
    _sum?: ActivitySumAggregateInputType
    _min?: ActivityMinAggregateInputType
    _max?: ActivityMaxAggregateInputType
  }

  export type ActivityGroupByOutputType = {
    id: Uint8Array
    title: string
    type: $Enums.ActivityType
    parentActivityId: Uint8Array | null
    parentWaypointId: Uint8Array | null
    templateId: Uint8Array | null
    taskScheduleType: $Enums.TaskScheduleType | null
    startDate: Date
    endDate: Date
    completedAt: Date | null
    description: string | null
    priority: $Enums.ActivityPriority
    status: $Enums.ActivityStatus
    assignedById: Uint8Array
    phoneNumber: string | null
    location: string | null
    holdReason: string | null
    createdAt: Date
    updatedAt: Date
    tenetId: Uint8Array
    deleted: boolean
    deletedAt: Date | null
    order: number | null
    opportunityId: Uint8Array | null
    _count: ActivityCountAggregateOutputType | null
    _avg: ActivityAvgAggregateOutputType | null
    _sum: ActivitySumAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  type GetActivityGroupByPayload<T extends ActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityGroupByOutputType[P]>
        }
      >
    >


  export type ActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    type?: boolean
    parentActivityId?: boolean
    parentWaypointId?: boolean
    templateId?: boolean
    taskScheduleType?: boolean
    startDate?: boolean
    endDate?: boolean
    completedAt?: boolean
    description?: boolean
    priority?: boolean
    status?: boolean
    assignedById?: boolean
    phoneNumber?: boolean
    location?: boolean
    holdReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenetId?: boolean
    deleted?: boolean
    deletedAt?: boolean
    order?: boolean
    opportunityId?: boolean
    steps?: boolean | Activity$stepsArgs<ExtArgs>
    waypoints?: boolean | Activity$waypointsArgs<ExtArgs>
    activities?: boolean | Activity$activitiesArgs<ExtArgs>
    parentActivity?: boolean | Activity$parentActivityArgs<ExtArgs>
    parentWaypoint?: boolean | Activity$parentWaypointArgs<ExtArgs>
    template?: boolean | Activity$templateArgs<ExtArgs>
    assignedBy?: boolean | UserDefaultArgs<ExtArgs>
    contacts?: boolean | Activity$contactsArgs<ExtArgs>
    users?: boolean | Activity$usersArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
    attachments?: boolean | Activity$attachmentsArgs<ExtArgs>
    notes?: boolean | Activity$notesArgs<ExtArgs>
    events?: boolean | Activity$eventsArgs<ExtArgs>
    opportunity?: boolean | Activity$opportunityArgs<ExtArgs>
    _count?: boolean | ActivityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    type?: boolean
    parentActivityId?: boolean
    parentWaypointId?: boolean
    templateId?: boolean
    taskScheduleType?: boolean
    startDate?: boolean
    endDate?: boolean
    completedAt?: boolean
    description?: boolean
    priority?: boolean
    status?: boolean
    assignedById?: boolean
    phoneNumber?: boolean
    location?: boolean
    holdReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenetId?: boolean
    deleted?: boolean
    deletedAt?: boolean
    order?: boolean
    opportunityId?: boolean
    parentActivity?: boolean | Activity$parentActivityArgs<ExtArgs>
    parentWaypoint?: boolean | Activity$parentWaypointArgs<ExtArgs>
    template?: boolean | Activity$templateArgs<ExtArgs>
    assignedBy?: boolean | UserDefaultArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
    opportunity?: boolean | Activity$opportunityArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    type?: boolean
    parentActivityId?: boolean
    parentWaypointId?: boolean
    templateId?: boolean
    taskScheduleType?: boolean
    startDate?: boolean
    endDate?: boolean
    completedAt?: boolean
    description?: boolean
    priority?: boolean
    status?: boolean
    assignedById?: boolean
    phoneNumber?: boolean
    location?: boolean
    holdReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenetId?: boolean
    deleted?: boolean
    deletedAt?: boolean
    order?: boolean
    opportunityId?: boolean
    parentActivity?: boolean | Activity$parentActivityArgs<ExtArgs>
    parentWaypoint?: boolean | Activity$parentWaypointArgs<ExtArgs>
    template?: boolean | Activity$templateArgs<ExtArgs>
    assignedBy?: boolean | UserDefaultArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
    opportunity?: boolean | Activity$opportunityArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectScalar = {
    id?: boolean
    title?: boolean
    type?: boolean
    parentActivityId?: boolean
    parentWaypointId?: boolean
    templateId?: boolean
    taskScheduleType?: boolean
    startDate?: boolean
    endDate?: boolean
    completedAt?: boolean
    description?: boolean
    priority?: boolean
    status?: boolean
    assignedById?: boolean
    phoneNumber?: boolean
    location?: boolean
    holdReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenetId?: boolean
    deleted?: boolean
    deletedAt?: boolean
    order?: boolean
    opportunityId?: boolean
  }

  export type ActivityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "type" | "parentActivityId" | "parentWaypointId" | "templateId" | "taskScheduleType" | "startDate" | "endDate" | "completedAt" | "description" | "priority" | "status" | "assignedById" | "phoneNumber" | "location" | "holdReason" | "createdAt" | "updatedAt" | "tenetId" | "deleted" | "deletedAt" | "order" | "opportunityId", ExtArgs["result"]["activity"]>
  export type ActivityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    steps?: boolean | Activity$stepsArgs<ExtArgs>
    waypoints?: boolean | Activity$waypointsArgs<ExtArgs>
    activities?: boolean | Activity$activitiesArgs<ExtArgs>
    parentActivity?: boolean | Activity$parentActivityArgs<ExtArgs>
    parentWaypoint?: boolean | Activity$parentWaypointArgs<ExtArgs>
    template?: boolean | Activity$templateArgs<ExtArgs>
    assignedBy?: boolean | UserDefaultArgs<ExtArgs>
    contacts?: boolean | Activity$contactsArgs<ExtArgs>
    users?: boolean | Activity$usersArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
    attachments?: boolean | Activity$attachmentsArgs<ExtArgs>
    notes?: boolean | Activity$notesArgs<ExtArgs>
    events?: boolean | Activity$eventsArgs<ExtArgs>
    opportunity?: boolean | Activity$opportunityArgs<ExtArgs>
    _count?: boolean | ActivityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ActivityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parentActivity?: boolean | Activity$parentActivityArgs<ExtArgs>
    parentWaypoint?: boolean | Activity$parentWaypointArgs<ExtArgs>
    template?: boolean | Activity$templateArgs<ExtArgs>
    assignedBy?: boolean | UserDefaultArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
    opportunity?: boolean | Activity$opportunityArgs<ExtArgs>
  }
  export type ActivityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parentActivity?: boolean | Activity$parentActivityArgs<ExtArgs>
    parentWaypoint?: boolean | Activity$parentWaypointArgs<ExtArgs>
    template?: boolean | Activity$templateArgs<ExtArgs>
    assignedBy?: boolean | UserDefaultArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
    opportunity?: boolean | Activity$opportunityArgs<ExtArgs>
  }

  export type $ActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Activity"
    objects: {
      /**
       * @ai-field(Steps required to complete this activity)
       */
      steps: Prisma.$ActivityStepPayload<ExtArgs>[]
      /**
       * @ai-field(Waypoints required to complete this activity if it's a path)
       */
      waypoints: Prisma.$ActivityWaypointPayload<ExtArgs>[]
      /**
       * @ai-field(Child activities of this activity, if it's a waypoints or path)
       */
      activities: Prisma.$ActivityPayload<ExtArgs>[]
      /**
       * @ai-field(Parent activity of this activity)
       */
      parentActivity: Prisma.$ActivityPayload<ExtArgs> | null
      /**
       * @ai-field(Parent waypoint of this activity)
       */
      parentWaypoint: Prisma.$ActivityWaypointPayload<ExtArgs> | null
      template: Prisma.$ActivityTemplatePayload<ExtArgs> | null
      assignedBy: Prisma.$UserPayload<ExtArgs>
      /**
       * @jointable(Contact, contactRelation)
       * @ai-field
       */
      contacts: Prisma.$ActivityContactJoinPayload<ExtArgs>[]
      /**
       * @jointable(User, userRelation)
       * @ai-field
       */
      users: Prisma.$ActivityUserJoinPayload<ExtArgs>[]
      tenet: Prisma.$TenetPayload<ExtArgs>
      attachments: Prisma.$AttachmentPayload<ExtArgs>[]
      /**
       * @ai-field
       */
      notes: Prisma.$NotePayload<ExtArgs>[]
      /**
       * @ai-field(Timeline of interactions with this activity)
       */
      events: Prisma.$ContactTimelineEventPayload<ExtArgs>[]
      /**
       * @ai-field(Associated opportunity)
       */
      opportunity: Prisma.$OpportunityPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      /**
       * @@ai-enabled
       */
      id: Uint8Array
      /**
       * @ai-field
       */
      title: string
      /**
       * @ai-field(Activity type, either task or schedule item)
       */
      type: $Enums.ActivityType
      /**
       * @ai-field
       */
      parentActivityId: Uint8Array | null
      /**
       * @ai-field
       */
      parentWaypointId: Uint8Array | null
      templateId: Uint8Array | null
      /**
       * @ai-field(Task/Schedule item subtype. Not applicable to notes)
       */
      taskScheduleType: $Enums.TaskScheduleType | null
      /**
       * @ai-field
       */
      startDate: Date
      /**
       * @ai-field(The due date for this activity, for task/schedule items only)
       */
      endDate: Date
      /**
       * @ai-field
       */
      completedAt: Date | null
      /**
       * @ai-field
       */
      description: string | null
      /**
       * @ai-field
       */
      priority: $Enums.ActivityPriority
      /**
       * @ai-field
       */
      status: $Enums.ActivityStatus
      assignedById: Uint8Array
      /**
       * @ai-field
       */
      phoneNumber: string | null
      /**
       * @ai-field
       */
      location: string | null
      /**
       * @ai-field(For schedule items only of type/subtype hold)
       */
      holdReason: string | null
      createdAt: Date
      updatedAt: Date
      tenetId: Uint8Array
      /**
       * @@soft-delete
       */
      deleted: boolean
      deletedAt: Date | null
      /**
       * @ai-field(Order within the waypoint-type activitiy or individual path waypoint)
       */
      order: number | null
      /**
       * @ai-field
       */
      opportunityId: Uint8Array | null
    }, ExtArgs["result"]["activity"]>
    composites: {}
  }

  type ActivityGetPayload<S extends boolean | null | undefined | ActivityDefaultArgs> = $Result.GetResult<Prisma.$ActivityPayload, S>

  type ActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActivityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: ActivityCountAggregateInputType | true
    }

  export interface ActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Activity'], meta: { name: 'Activity' } }
    /**
     * Find zero or one Activity that matches the filter.
     * @param {ActivityFindUniqueArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityFindUniqueArgs>(args: SelectSubset<T, ActivityFindUniqueArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Activity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActivityFindUniqueOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Activity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityFindFirstArgs>(args?: SelectSubset<T, ActivityFindFirstArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Activity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Activities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Activities
     * const activities = await prisma.activity.findMany()
     * 
     * // Get first 10 Activities
     * const activities = await prisma.activity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityWithIdOnly = await prisma.activity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityFindManyArgs>(args?: SelectSubset<T, ActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Activity.
     * @param {ActivityCreateArgs} args - Arguments to create a Activity.
     * @example
     * // Create one Activity
     * const Activity = await prisma.activity.create({
     *   data: {
     *     // ... data to create a Activity
     *   }
     * })
     * 
     */
    create<T extends ActivityCreateArgs>(args: SelectSubset<T, ActivityCreateArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Activities.
     * @param {ActivityCreateManyArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activity = await prisma.activity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityCreateManyArgs>(args?: SelectSubset<T, ActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Activities and returns the data saved in the database.
     * @param {ActivityCreateManyAndReturnArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activity = await prisma.activity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Activities and only return the `id`
     * const activityWithIdOnly = await prisma.activity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Activity.
     * @param {ActivityDeleteArgs} args - Arguments to delete one Activity.
     * @example
     * // Delete one Activity
     * const Activity = await prisma.activity.delete({
     *   where: {
     *     // ... filter to delete one Activity
     *   }
     * })
     * 
     */
    delete<T extends ActivityDeleteArgs>(args: SelectSubset<T, ActivityDeleteArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Activity.
     * @param {ActivityUpdateArgs} args - Arguments to update one Activity.
     * @example
     * // Update one Activity
     * const activity = await prisma.activity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityUpdateArgs>(args: SelectSubset<T, ActivityUpdateArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Activities.
     * @param {ActivityDeleteManyArgs} args - Arguments to filter Activities to delete.
     * @example
     * // Delete a few Activities
     * const { count } = await prisma.activity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityDeleteManyArgs>(args?: SelectSubset<T, ActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Activities
     * const activity = await prisma.activity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityUpdateManyArgs>(args: SelectSubset<T, ActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activities and returns the data updated in the database.
     * @param {ActivityUpdateManyAndReturnArgs} args - Arguments to update many Activities.
     * @example
     * // Update many Activities
     * const activity = await prisma.activity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Activities and only return the `id`
     * const activityWithIdOnly = await prisma.activity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActivityUpdateManyAndReturnArgs>(args: SelectSubset<T, ActivityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Activity.
     * @param {ActivityUpsertArgs} args - Arguments to update or create a Activity.
     * @example
     * // Update or create a Activity
     * const activity = await prisma.activity.upsert({
     *   create: {
     *     // ... data to create a Activity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Activity we want to update
     *   }
     * })
     */
    upsert<T extends ActivityUpsertArgs>(args: SelectSubset<T, ActivityUpsertArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityCountArgs} args - Arguments to filter Activities to count.
     * @example
     * // Count the number of Activities
     * const count = await prisma.activity.count({
     *   where: {
     *     // ... the filter for the Activities we want to count
     *   }
     * })
    **/
    count<T extends ActivityCountArgs>(
      args?: Subset<T, ActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityAggregateArgs>(args: Subset<T, ActivityAggregateArgs>): Prisma.PrismaPromise<GetActivityAggregateType<T>>

    /**
     * Group by Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityGroupByArgs['orderBy'] }
        : { orderBy?: ActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Activity model
   */
  readonly fields: ActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Activity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    steps<T extends Activity$stepsArgs<ExtArgs> = {}>(args?: Subset<T, Activity$stepsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityStepPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    waypoints<T extends Activity$waypointsArgs<ExtArgs> = {}>(args?: Subset<T, Activity$waypointsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityWaypointPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    activities<T extends Activity$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, Activity$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    parentActivity<T extends Activity$parentActivityArgs<ExtArgs> = {}>(args?: Subset<T, Activity$parentActivityArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    parentWaypoint<T extends Activity$parentWaypointArgs<ExtArgs> = {}>(args?: Subset<T, Activity$parentWaypointArgs<ExtArgs>>): Prisma__ActivityWaypointClient<$Result.GetResult<Prisma.$ActivityWaypointPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    template<T extends Activity$templateArgs<ExtArgs> = {}>(args?: Subset<T, Activity$templateArgs<ExtArgs>>): Prisma__ActivityTemplateClient<$Result.GetResult<Prisma.$ActivityTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    assignedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    contacts<T extends Activity$contactsArgs<ExtArgs> = {}>(args?: Subset<T, Activity$contactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityContactJoinPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    users<T extends Activity$usersArgs<ExtArgs> = {}>(args?: Subset<T, Activity$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityUserJoinPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    tenet<T extends TenetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenetDefaultArgs<ExtArgs>>): Prisma__TenetClient<$Result.GetResult<Prisma.$TenetPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    attachments<T extends Activity$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Activity$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    notes<T extends Activity$notesArgs<ExtArgs> = {}>(args?: Subset<T, Activity$notesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    events<T extends Activity$eventsArgs<ExtArgs> = {}>(args?: Subset<T, Activity$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactTimelineEventPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    opportunity<T extends Activity$opportunityArgs<ExtArgs> = {}>(args?: Subset<T, Activity$opportunityArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Activity model
   */ 
  interface ActivityFieldRefs {
    readonly id: FieldRef<"Activity", 'Bytes'>
    readonly title: FieldRef<"Activity", 'String'>
    readonly type: FieldRef<"Activity", 'ActivityType'>
    readonly parentActivityId: FieldRef<"Activity", 'Bytes'>
    readonly parentWaypointId: FieldRef<"Activity", 'Bytes'>
    readonly templateId: FieldRef<"Activity", 'Bytes'>
    readonly taskScheduleType: FieldRef<"Activity", 'TaskScheduleType'>
    readonly startDate: FieldRef<"Activity", 'DateTime'>
    readonly endDate: FieldRef<"Activity", 'DateTime'>
    readonly completedAt: FieldRef<"Activity", 'DateTime'>
    readonly description: FieldRef<"Activity", 'String'>
    readonly priority: FieldRef<"Activity", 'ActivityPriority'>
    readonly status: FieldRef<"Activity", 'ActivityStatus'>
    readonly assignedById: FieldRef<"Activity", 'Bytes'>
    readonly phoneNumber: FieldRef<"Activity", 'String'>
    readonly location: FieldRef<"Activity", 'String'>
    readonly holdReason: FieldRef<"Activity", 'String'>
    readonly createdAt: FieldRef<"Activity", 'DateTime'>
    readonly updatedAt: FieldRef<"Activity", 'DateTime'>
    readonly tenetId: FieldRef<"Activity", 'Bytes'>
    readonly deleted: FieldRef<"Activity", 'Boolean'>
    readonly deletedAt: FieldRef<"Activity", 'DateTime'>
    readonly order: FieldRef<"Activity", 'Int'>
    readonly opportunityId: FieldRef<"Activity", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * Activity findUnique
   */
  export type ActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Activity findUniqueOrThrow
   */
  export type ActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Activity findFirst
   */
  export type ActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Activity findFirstOrThrow
   */
  export type ActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Activity findMany
   */
  export type ActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activities to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Activity create
   */
  export type ActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The data needed to create a Activity.
     */
    data: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Activity createMany
   */
  export type ActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Activities.
     */
    data: ActivityCreateManyInput | ActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Activity createManyAndReturn
   */
  export type ActivityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * The data used to create many Activities.
     */
    data: ActivityCreateManyInput | ActivityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Activity update
   */
  export type ActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The data needed to update a Activity.
     */
    data: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
    /**
     * Choose, which Activity to update.
     */
    where: ActivityWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Activity updateMany
   */
  export type ActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Activities.
     */
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyInput>
    /**
     * Filter which Activities to update
     */
    where?: ActivityWhereInput
    /**
     * Limit how many Activities to update.
     */
    limit?: number
  }

  /**
   * Activity updateManyAndReturn
   */
  export type ActivityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * The data used to update Activities.
     */
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyInput>
    /**
     * Filter which Activities to update
     */
    where?: ActivityWhereInput
    /**
     * Limit how many Activities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Activity upsert
   */
  export type ActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The filter to search for the Activity to update in case it exists.
     */
    where: ActivityWhereUniqueInput
    /**
     * In case the Activity found by the `where` argument doesn't exist, create a new Activity with this data.
     */
    create: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
    /**
     * In case the Activity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Activity delete
   */
  export type ActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter which Activity to delete.
     */
    where: ActivityWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Activity deleteMany
   */
  export type ActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activities to delete
     */
    where?: ActivityWhereInput
    /**
     * Limit how many Activities to delete.
     */
    limit?: number
  }

  /**
   * Activity.steps
   */
  export type Activity$stepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityStep
     */
    select?: ActivityStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityStep
     */
    omit?: ActivityStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityStepInclude<ExtArgs> | null
    where?: ActivityStepWhereInput
    orderBy?: ActivityStepOrderByWithRelationInput | ActivityStepOrderByWithRelationInput[]
    cursor?: ActivityStepWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityStepScalarFieldEnum | ActivityStepScalarFieldEnum[]
  }

  /**
   * Activity.waypoints
   */
  export type Activity$waypointsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityWaypoint
     */
    select?: ActivityWaypointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityWaypoint
     */
    omit?: ActivityWaypointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityWaypointInclude<ExtArgs> | null
    where?: ActivityWaypointWhereInput
    orderBy?: ActivityWaypointOrderByWithRelationInput | ActivityWaypointOrderByWithRelationInput[]
    cursor?: ActivityWaypointWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityWaypointScalarFieldEnum | ActivityWaypointScalarFieldEnum[]
  }

  /**
   * Activity.activities
   */
  export type Activity$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    cursor?: ActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity.parentActivity
   */
  export type Activity$parentActivityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
  }

  /**
   * Activity.parentWaypoint
   */
  export type Activity$parentWaypointArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityWaypoint
     */
    select?: ActivityWaypointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityWaypoint
     */
    omit?: ActivityWaypointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityWaypointInclude<ExtArgs> | null
    where?: ActivityWaypointWhereInput
  }

  /**
   * Activity.template
   */
  export type Activity$templateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityTemplate
     */
    select?: ActivityTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityTemplate
     */
    omit?: ActivityTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityTemplateInclude<ExtArgs> | null
    where?: ActivityTemplateWhereInput
  }

  /**
   * Activity.contacts
   */
  export type Activity$contactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityContactJoin
     */
    select?: ActivityContactJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityContactJoin
     */
    omit?: ActivityContactJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityContactJoinInclude<ExtArgs> | null
    where?: ActivityContactJoinWhereInput
    orderBy?: ActivityContactJoinOrderByWithRelationInput | ActivityContactJoinOrderByWithRelationInput[]
    cursor?: ActivityContactJoinWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityContactJoinScalarFieldEnum | ActivityContactJoinScalarFieldEnum[]
  }

  /**
   * Activity.users
   */
  export type Activity$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityUserJoin
     */
    select?: ActivityUserJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityUserJoin
     */
    omit?: ActivityUserJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityUserJoinInclude<ExtArgs> | null
    where?: ActivityUserJoinWhereInput
    orderBy?: ActivityUserJoinOrderByWithRelationInput | ActivityUserJoinOrderByWithRelationInput[]
    cursor?: ActivityUserJoinWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityUserJoinScalarFieldEnum | ActivityUserJoinScalarFieldEnum[]
  }

  /**
   * Activity.attachments
   */
  export type Activity$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    where?: AttachmentWhereInput
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    cursor?: AttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Activity.notes
   */
  export type Activity$notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    where?: NoteWhereInput
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    cursor?: NoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * Activity.events
   */
  export type Activity$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTimelineEvent
     */
    select?: ContactTimelineEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTimelineEvent
     */
    omit?: ContactTimelineEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTimelineEventInclude<ExtArgs> | null
    where?: ContactTimelineEventWhereInput
    orderBy?: ContactTimelineEventOrderByWithRelationInput | ContactTimelineEventOrderByWithRelationInput[]
    cursor?: ContactTimelineEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactTimelineEventScalarFieldEnum | ContactTimelineEventScalarFieldEnum[]
  }

  /**
   * Activity.opportunity
   */
  export type Activity$opportunityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    where?: OpportunityWhereInput
  }

  /**
   * Activity without action
   */
  export type ActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
  }


  /**
   * Model ContactTimelineEvent
   */

  export type AggregateContactTimelineEvent = {
    _count: ContactTimelineEventCountAggregateOutputType | null
    _min: ContactTimelineEventMinAggregateOutputType | null
    _max: ContactTimelineEventMaxAggregateOutputType | null
  }

  export type ContactTimelineEventMinAggregateOutputType = {
    id: Uint8Array | null
    activityId: Uint8Array | null
    waypointId: Uint8Array | null
    opportunityId: Uint8Array | null
    noteId: Uint8Array | null
    extraInfo: string | null
    userId: Uint8Array | null
    tenetId: Uint8Array | null
    eventType: $Enums.ContactTimelineEventType | null
    relationshipType: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactTimelineEventMaxAggregateOutputType = {
    id: Uint8Array | null
    activityId: Uint8Array | null
    waypointId: Uint8Array | null
    opportunityId: Uint8Array | null
    noteId: Uint8Array | null
    extraInfo: string | null
    userId: Uint8Array | null
    tenetId: Uint8Array | null
    eventType: $Enums.ContactTimelineEventType | null
    relationshipType: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactTimelineEventCountAggregateOutputType = {
    id: number
    activityId: number
    waypointId: number
    opportunityId: number
    noteId: number
    extraInfo: number
    userId: number
    tenetId: number
    eventType: number
    relationshipType: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContactTimelineEventMinAggregateInputType = {
    id?: true
    activityId?: true
    waypointId?: true
    opportunityId?: true
    noteId?: true
    extraInfo?: true
    userId?: true
    tenetId?: true
    eventType?: true
    relationshipType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactTimelineEventMaxAggregateInputType = {
    id?: true
    activityId?: true
    waypointId?: true
    opportunityId?: true
    noteId?: true
    extraInfo?: true
    userId?: true
    tenetId?: true
    eventType?: true
    relationshipType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactTimelineEventCountAggregateInputType = {
    id?: true
    activityId?: true
    waypointId?: true
    opportunityId?: true
    noteId?: true
    extraInfo?: true
    userId?: true
    tenetId?: true
    eventType?: true
    relationshipType?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContactTimelineEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactTimelineEvent to aggregate.
     */
    where?: ContactTimelineEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactTimelineEvents to fetch.
     */
    orderBy?: ContactTimelineEventOrderByWithRelationInput | ContactTimelineEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactTimelineEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactTimelineEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactTimelineEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContactTimelineEvents
    **/
    _count?: true | ContactTimelineEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactTimelineEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactTimelineEventMaxAggregateInputType
  }

  export type GetContactTimelineEventAggregateType<T extends ContactTimelineEventAggregateArgs> = {
        [P in keyof T & keyof AggregateContactTimelineEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContactTimelineEvent[P]>
      : GetScalarType<T[P], AggregateContactTimelineEvent[P]>
  }




  export type ContactTimelineEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactTimelineEventWhereInput
    orderBy?: ContactTimelineEventOrderByWithAggregationInput | ContactTimelineEventOrderByWithAggregationInput[]
    by: ContactTimelineEventScalarFieldEnum[] | ContactTimelineEventScalarFieldEnum
    having?: ContactTimelineEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactTimelineEventCountAggregateInputType | true
    _min?: ContactTimelineEventMinAggregateInputType
    _max?: ContactTimelineEventMaxAggregateInputType
  }

  export type ContactTimelineEventGroupByOutputType = {
    id: Uint8Array
    activityId: Uint8Array | null
    waypointId: Uint8Array | null
    opportunityId: Uint8Array | null
    noteId: Uint8Array | null
    extraInfo: string | null
    userId: Uint8Array
    tenetId: Uint8Array
    eventType: $Enums.ContactTimelineEventType
    relationshipType: string | null
    createdAt: Date
    updatedAt: Date
    _count: ContactTimelineEventCountAggregateOutputType | null
    _min: ContactTimelineEventMinAggregateOutputType | null
    _max: ContactTimelineEventMaxAggregateOutputType | null
  }

  type GetContactTimelineEventGroupByPayload<T extends ContactTimelineEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactTimelineEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactTimelineEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactTimelineEventGroupByOutputType[P]>
            : GetScalarType<T[P], ContactTimelineEventGroupByOutputType[P]>
        }
      >
    >


  export type ContactTimelineEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    activityId?: boolean
    waypointId?: boolean
    opportunityId?: boolean
    noteId?: boolean
    extraInfo?: boolean
    userId?: boolean
    tenetId?: boolean
    eventType?: boolean
    relationshipType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    activity?: boolean | ContactTimelineEvent$activityArgs<ExtArgs>
    waypoint?: boolean | ContactTimelineEvent$waypointArgs<ExtArgs>
    opportunity?: boolean | ContactTimelineEvent$opportunityArgs<ExtArgs>
    note?: boolean | ContactTimelineEvent$noteArgs<ExtArgs>
    contacts?: boolean | ContactTimelineEvent$contactsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
    _count?: boolean | ContactTimelineEventCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactTimelineEvent"]>

  export type ContactTimelineEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    activityId?: boolean
    waypointId?: boolean
    opportunityId?: boolean
    noteId?: boolean
    extraInfo?: boolean
    userId?: boolean
    tenetId?: boolean
    eventType?: boolean
    relationshipType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    activity?: boolean | ContactTimelineEvent$activityArgs<ExtArgs>
    waypoint?: boolean | ContactTimelineEvent$waypointArgs<ExtArgs>
    opportunity?: boolean | ContactTimelineEvent$opportunityArgs<ExtArgs>
    note?: boolean | ContactTimelineEvent$noteArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactTimelineEvent"]>

  export type ContactTimelineEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    activityId?: boolean
    waypointId?: boolean
    opportunityId?: boolean
    noteId?: boolean
    extraInfo?: boolean
    userId?: boolean
    tenetId?: boolean
    eventType?: boolean
    relationshipType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    activity?: boolean | ContactTimelineEvent$activityArgs<ExtArgs>
    waypoint?: boolean | ContactTimelineEvent$waypointArgs<ExtArgs>
    opportunity?: boolean | ContactTimelineEvent$opportunityArgs<ExtArgs>
    note?: boolean | ContactTimelineEvent$noteArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactTimelineEvent"]>

  export type ContactTimelineEventSelectScalar = {
    id?: boolean
    activityId?: boolean
    waypointId?: boolean
    opportunityId?: boolean
    noteId?: boolean
    extraInfo?: boolean
    userId?: boolean
    tenetId?: boolean
    eventType?: boolean
    relationshipType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContactTimelineEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "activityId" | "waypointId" | "opportunityId" | "noteId" | "extraInfo" | "userId" | "tenetId" | "eventType" | "relationshipType" | "createdAt" | "updatedAt", ExtArgs["result"]["contactTimelineEvent"]>
  export type ContactTimelineEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activity?: boolean | ContactTimelineEvent$activityArgs<ExtArgs>
    waypoint?: boolean | ContactTimelineEvent$waypointArgs<ExtArgs>
    opportunity?: boolean | ContactTimelineEvent$opportunityArgs<ExtArgs>
    note?: boolean | ContactTimelineEvent$noteArgs<ExtArgs>
    contacts?: boolean | ContactTimelineEvent$contactsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
    _count?: boolean | ContactTimelineEventCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ContactTimelineEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activity?: boolean | ContactTimelineEvent$activityArgs<ExtArgs>
    waypoint?: boolean | ContactTimelineEvent$waypointArgs<ExtArgs>
    opportunity?: boolean | ContactTimelineEvent$opportunityArgs<ExtArgs>
    note?: boolean | ContactTimelineEvent$noteArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }
  export type ContactTimelineEventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activity?: boolean | ContactTimelineEvent$activityArgs<ExtArgs>
    waypoint?: boolean | ContactTimelineEvent$waypointArgs<ExtArgs>
    opportunity?: boolean | ContactTimelineEvent$opportunityArgs<ExtArgs>
    note?: boolean | ContactTimelineEvent$noteArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }

  export type $ContactTimelineEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContactTimelineEvent"
    objects: {
      /**
       * @ai-field(If associated with an activity, the activity this event is associated with)
       */
      activity: Prisma.$ActivityPayload<ExtArgs> | null
      /**
       * @ai-field(If the activity is associated with an waypoint, the waypoint this event is associated with)
       */
      waypoint: Prisma.$ActivityWaypointPayload<ExtArgs> | null
      /**
       * @ai-field(If associated with an opportunity, the opportunity this event is associated with)
       */
      opportunity: Prisma.$OpportunityPayload<ExtArgs> | null
      /**
       * @ai-field(If associated with a note, the note this event is associated with)
       */
      note: Prisma.$NotePayload<ExtArgs> | null
      /**
       * @ai-field(The associated contacts)
       * @jointable(Contact, contactRelation)
       * @join(type, contactTimelineRelationshipType)
       */
      contacts: Prisma.$ContactTimelineEventContactJoinPayload<ExtArgs>[]
      /**
       * @ai-field(The user who caused this event)
       */
      user: Prisma.$UserPayload<ExtArgs>
      tenet: Prisma.$TenetPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      /**
       * @@ai-enabled
       */
      id: Uint8Array
      /**
       * @ai-field
       */
      activityId: Uint8Array | null
      /**
       * @ai-field
       */
      waypointId: Uint8Array | null
      /**
       * @ai-field
       */
      opportunityId: Uint8Array | null
      /**
       * @ai-field(If associated with a note, the note this event is associated with)
       */
      noteId: Uint8Array | null
      /**
       * @ai-field(Info about the event, like what was updated)
       */
      extraInfo: string | null
      /**
       * @ai-field
       */
      userId: Uint8Array
      tenetId: Uint8Array
      /**
       * @ai-field
       */
      eventType: $Enums.ContactTimelineEventType
      /**
       * @ai-field(If the event is a relationship, the name of the relationship)
       */
      relationshipType: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contactTimelineEvent"]>
    composites: {}
  }

  type ContactTimelineEventGetPayload<S extends boolean | null | undefined | ContactTimelineEventDefaultArgs> = $Result.GetResult<Prisma.$ContactTimelineEventPayload, S>

  type ContactTimelineEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactTimelineEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: ContactTimelineEventCountAggregateInputType | true
    }

  export interface ContactTimelineEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContactTimelineEvent'], meta: { name: 'ContactTimelineEvent' } }
    /**
     * Find zero or one ContactTimelineEvent that matches the filter.
     * @param {ContactTimelineEventFindUniqueArgs} args - Arguments to find a ContactTimelineEvent
     * @example
     * // Get one ContactTimelineEvent
     * const contactTimelineEvent = await prisma.contactTimelineEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactTimelineEventFindUniqueArgs>(args: SelectSubset<T, ContactTimelineEventFindUniqueArgs<ExtArgs>>): Prisma__ContactTimelineEventClient<$Result.GetResult<Prisma.$ContactTimelineEventPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ContactTimelineEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactTimelineEventFindUniqueOrThrowArgs} args - Arguments to find a ContactTimelineEvent
     * @example
     * // Get one ContactTimelineEvent
     * const contactTimelineEvent = await prisma.contactTimelineEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactTimelineEventFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactTimelineEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactTimelineEventClient<$Result.GetResult<Prisma.$ContactTimelineEventPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ContactTimelineEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactTimelineEventFindFirstArgs} args - Arguments to find a ContactTimelineEvent
     * @example
     * // Get one ContactTimelineEvent
     * const contactTimelineEvent = await prisma.contactTimelineEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactTimelineEventFindFirstArgs>(args?: SelectSubset<T, ContactTimelineEventFindFirstArgs<ExtArgs>>): Prisma__ContactTimelineEventClient<$Result.GetResult<Prisma.$ContactTimelineEventPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ContactTimelineEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactTimelineEventFindFirstOrThrowArgs} args - Arguments to find a ContactTimelineEvent
     * @example
     * // Get one ContactTimelineEvent
     * const contactTimelineEvent = await prisma.contactTimelineEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactTimelineEventFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactTimelineEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactTimelineEventClient<$Result.GetResult<Prisma.$ContactTimelineEventPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ContactTimelineEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactTimelineEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContactTimelineEvents
     * const contactTimelineEvents = await prisma.contactTimelineEvent.findMany()
     * 
     * // Get first 10 ContactTimelineEvents
     * const contactTimelineEvents = await prisma.contactTimelineEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactTimelineEventWithIdOnly = await prisma.contactTimelineEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactTimelineEventFindManyArgs>(args?: SelectSubset<T, ContactTimelineEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactTimelineEventPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ContactTimelineEvent.
     * @param {ContactTimelineEventCreateArgs} args - Arguments to create a ContactTimelineEvent.
     * @example
     * // Create one ContactTimelineEvent
     * const ContactTimelineEvent = await prisma.contactTimelineEvent.create({
     *   data: {
     *     // ... data to create a ContactTimelineEvent
     *   }
     * })
     * 
     */
    create<T extends ContactTimelineEventCreateArgs>(args: SelectSubset<T, ContactTimelineEventCreateArgs<ExtArgs>>): Prisma__ContactTimelineEventClient<$Result.GetResult<Prisma.$ContactTimelineEventPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ContactTimelineEvents.
     * @param {ContactTimelineEventCreateManyArgs} args - Arguments to create many ContactTimelineEvents.
     * @example
     * // Create many ContactTimelineEvents
     * const contactTimelineEvent = await prisma.contactTimelineEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactTimelineEventCreateManyArgs>(args?: SelectSubset<T, ContactTimelineEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContactTimelineEvents and returns the data saved in the database.
     * @param {ContactTimelineEventCreateManyAndReturnArgs} args - Arguments to create many ContactTimelineEvents.
     * @example
     * // Create many ContactTimelineEvents
     * const contactTimelineEvent = await prisma.contactTimelineEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContactTimelineEvents and only return the `id`
     * const contactTimelineEventWithIdOnly = await prisma.contactTimelineEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactTimelineEventCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactTimelineEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactTimelineEventPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a ContactTimelineEvent.
     * @param {ContactTimelineEventDeleteArgs} args - Arguments to delete one ContactTimelineEvent.
     * @example
     * // Delete one ContactTimelineEvent
     * const ContactTimelineEvent = await prisma.contactTimelineEvent.delete({
     *   where: {
     *     // ... filter to delete one ContactTimelineEvent
     *   }
     * })
     * 
     */
    delete<T extends ContactTimelineEventDeleteArgs>(args: SelectSubset<T, ContactTimelineEventDeleteArgs<ExtArgs>>): Prisma__ContactTimelineEventClient<$Result.GetResult<Prisma.$ContactTimelineEventPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ContactTimelineEvent.
     * @param {ContactTimelineEventUpdateArgs} args - Arguments to update one ContactTimelineEvent.
     * @example
     * // Update one ContactTimelineEvent
     * const contactTimelineEvent = await prisma.contactTimelineEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactTimelineEventUpdateArgs>(args: SelectSubset<T, ContactTimelineEventUpdateArgs<ExtArgs>>): Prisma__ContactTimelineEventClient<$Result.GetResult<Prisma.$ContactTimelineEventPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ContactTimelineEvents.
     * @param {ContactTimelineEventDeleteManyArgs} args - Arguments to filter ContactTimelineEvents to delete.
     * @example
     * // Delete a few ContactTimelineEvents
     * const { count } = await prisma.contactTimelineEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactTimelineEventDeleteManyArgs>(args?: SelectSubset<T, ContactTimelineEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactTimelineEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactTimelineEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContactTimelineEvents
     * const contactTimelineEvent = await prisma.contactTimelineEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactTimelineEventUpdateManyArgs>(args: SelectSubset<T, ContactTimelineEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactTimelineEvents and returns the data updated in the database.
     * @param {ContactTimelineEventUpdateManyAndReturnArgs} args - Arguments to update many ContactTimelineEvents.
     * @example
     * // Update many ContactTimelineEvents
     * const contactTimelineEvent = await prisma.contactTimelineEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContactTimelineEvents and only return the `id`
     * const contactTimelineEventWithIdOnly = await prisma.contactTimelineEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContactTimelineEventUpdateManyAndReturnArgs>(args: SelectSubset<T, ContactTimelineEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactTimelineEventPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one ContactTimelineEvent.
     * @param {ContactTimelineEventUpsertArgs} args - Arguments to update or create a ContactTimelineEvent.
     * @example
     * // Update or create a ContactTimelineEvent
     * const contactTimelineEvent = await prisma.contactTimelineEvent.upsert({
     *   create: {
     *     // ... data to create a ContactTimelineEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContactTimelineEvent we want to update
     *   }
     * })
     */
    upsert<T extends ContactTimelineEventUpsertArgs>(args: SelectSubset<T, ContactTimelineEventUpsertArgs<ExtArgs>>): Prisma__ContactTimelineEventClient<$Result.GetResult<Prisma.$ContactTimelineEventPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ContactTimelineEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactTimelineEventCountArgs} args - Arguments to filter ContactTimelineEvents to count.
     * @example
     * // Count the number of ContactTimelineEvents
     * const count = await prisma.contactTimelineEvent.count({
     *   where: {
     *     // ... the filter for the ContactTimelineEvents we want to count
     *   }
     * })
    **/
    count<T extends ContactTimelineEventCountArgs>(
      args?: Subset<T, ContactTimelineEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactTimelineEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContactTimelineEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactTimelineEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactTimelineEventAggregateArgs>(args: Subset<T, ContactTimelineEventAggregateArgs>): Prisma.PrismaPromise<GetContactTimelineEventAggregateType<T>>

    /**
     * Group by ContactTimelineEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactTimelineEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactTimelineEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactTimelineEventGroupByArgs['orderBy'] }
        : { orderBy?: ContactTimelineEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactTimelineEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactTimelineEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContactTimelineEvent model
   */
  readonly fields: ContactTimelineEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContactTimelineEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactTimelineEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    activity<T extends ContactTimelineEvent$activityArgs<ExtArgs> = {}>(args?: Subset<T, ContactTimelineEvent$activityArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    waypoint<T extends ContactTimelineEvent$waypointArgs<ExtArgs> = {}>(args?: Subset<T, ContactTimelineEvent$waypointArgs<ExtArgs>>): Prisma__ActivityWaypointClient<$Result.GetResult<Prisma.$ActivityWaypointPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    opportunity<T extends ContactTimelineEvent$opportunityArgs<ExtArgs> = {}>(args?: Subset<T, ContactTimelineEvent$opportunityArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    note<T extends ContactTimelineEvent$noteArgs<ExtArgs> = {}>(args?: Subset<T, ContactTimelineEvent$noteArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    contacts<T extends ContactTimelineEvent$contactsArgs<ExtArgs> = {}>(args?: Subset<T, ContactTimelineEvent$contactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactTimelineEventContactJoinPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    tenet<T extends TenetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenetDefaultArgs<ExtArgs>>): Prisma__TenetClient<$Result.GetResult<Prisma.$TenetPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContactTimelineEvent model
   */ 
  interface ContactTimelineEventFieldRefs {
    readonly id: FieldRef<"ContactTimelineEvent", 'Bytes'>
    readonly activityId: FieldRef<"ContactTimelineEvent", 'Bytes'>
    readonly waypointId: FieldRef<"ContactTimelineEvent", 'Bytes'>
    readonly opportunityId: FieldRef<"ContactTimelineEvent", 'Bytes'>
    readonly noteId: FieldRef<"ContactTimelineEvent", 'Bytes'>
    readonly extraInfo: FieldRef<"ContactTimelineEvent", 'String'>
    readonly userId: FieldRef<"ContactTimelineEvent", 'Bytes'>
    readonly tenetId: FieldRef<"ContactTimelineEvent", 'Bytes'>
    readonly eventType: FieldRef<"ContactTimelineEvent", 'ContactTimelineEventType'>
    readonly relationshipType: FieldRef<"ContactTimelineEvent", 'String'>
    readonly createdAt: FieldRef<"ContactTimelineEvent", 'DateTime'>
    readonly updatedAt: FieldRef<"ContactTimelineEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContactTimelineEvent findUnique
   */
  export type ContactTimelineEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTimelineEvent
     */
    select?: ContactTimelineEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTimelineEvent
     */
    omit?: ContactTimelineEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTimelineEventInclude<ExtArgs> | null
    /**
     * Filter, which ContactTimelineEvent to fetch.
     */
    where: ContactTimelineEventWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactTimelineEvent findUniqueOrThrow
   */
  export type ContactTimelineEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTimelineEvent
     */
    select?: ContactTimelineEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTimelineEvent
     */
    omit?: ContactTimelineEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTimelineEventInclude<ExtArgs> | null
    /**
     * Filter, which ContactTimelineEvent to fetch.
     */
    where: ContactTimelineEventWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactTimelineEvent findFirst
   */
  export type ContactTimelineEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTimelineEvent
     */
    select?: ContactTimelineEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTimelineEvent
     */
    omit?: ContactTimelineEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTimelineEventInclude<ExtArgs> | null
    /**
     * Filter, which ContactTimelineEvent to fetch.
     */
    where?: ContactTimelineEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactTimelineEvents to fetch.
     */
    orderBy?: ContactTimelineEventOrderByWithRelationInput | ContactTimelineEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactTimelineEvents.
     */
    cursor?: ContactTimelineEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactTimelineEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactTimelineEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactTimelineEvents.
     */
    distinct?: ContactTimelineEventScalarFieldEnum | ContactTimelineEventScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactTimelineEvent findFirstOrThrow
   */
  export type ContactTimelineEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTimelineEvent
     */
    select?: ContactTimelineEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTimelineEvent
     */
    omit?: ContactTimelineEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTimelineEventInclude<ExtArgs> | null
    /**
     * Filter, which ContactTimelineEvent to fetch.
     */
    where?: ContactTimelineEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactTimelineEvents to fetch.
     */
    orderBy?: ContactTimelineEventOrderByWithRelationInput | ContactTimelineEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactTimelineEvents.
     */
    cursor?: ContactTimelineEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactTimelineEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactTimelineEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactTimelineEvents.
     */
    distinct?: ContactTimelineEventScalarFieldEnum | ContactTimelineEventScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactTimelineEvent findMany
   */
  export type ContactTimelineEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTimelineEvent
     */
    select?: ContactTimelineEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTimelineEvent
     */
    omit?: ContactTimelineEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTimelineEventInclude<ExtArgs> | null
    /**
     * Filter, which ContactTimelineEvents to fetch.
     */
    where?: ContactTimelineEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactTimelineEvents to fetch.
     */
    orderBy?: ContactTimelineEventOrderByWithRelationInput | ContactTimelineEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContactTimelineEvents.
     */
    cursor?: ContactTimelineEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactTimelineEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactTimelineEvents.
     */
    skip?: number
    distinct?: ContactTimelineEventScalarFieldEnum | ContactTimelineEventScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactTimelineEvent create
   */
  export type ContactTimelineEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTimelineEvent
     */
    select?: ContactTimelineEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTimelineEvent
     */
    omit?: ContactTimelineEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTimelineEventInclude<ExtArgs> | null
    /**
     * The data needed to create a ContactTimelineEvent.
     */
    data: XOR<ContactTimelineEventCreateInput, ContactTimelineEventUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactTimelineEvent createMany
   */
  export type ContactTimelineEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContactTimelineEvents.
     */
    data: ContactTimelineEventCreateManyInput | ContactTimelineEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactTimelineEvent createManyAndReturn
   */
  export type ContactTimelineEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTimelineEvent
     */
    select?: ContactTimelineEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTimelineEvent
     */
    omit?: ContactTimelineEventOmit<ExtArgs> | null
    /**
     * The data used to create many ContactTimelineEvents.
     */
    data: ContactTimelineEventCreateManyInput | ContactTimelineEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTimelineEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContactTimelineEvent update
   */
  export type ContactTimelineEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTimelineEvent
     */
    select?: ContactTimelineEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTimelineEvent
     */
    omit?: ContactTimelineEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTimelineEventInclude<ExtArgs> | null
    /**
     * The data needed to update a ContactTimelineEvent.
     */
    data: XOR<ContactTimelineEventUpdateInput, ContactTimelineEventUncheckedUpdateInput>
    /**
     * Choose, which ContactTimelineEvent to update.
     */
    where: ContactTimelineEventWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactTimelineEvent updateMany
   */
  export type ContactTimelineEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContactTimelineEvents.
     */
    data: XOR<ContactTimelineEventUpdateManyMutationInput, ContactTimelineEventUncheckedUpdateManyInput>
    /**
     * Filter which ContactTimelineEvents to update
     */
    where?: ContactTimelineEventWhereInput
    /**
     * Limit how many ContactTimelineEvents to update.
     */
    limit?: number
  }

  /**
   * ContactTimelineEvent updateManyAndReturn
   */
  export type ContactTimelineEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTimelineEvent
     */
    select?: ContactTimelineEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTimelineEvent
     */
    omit?: ContactTimelineEventOmit<ExtArgs> | null
    /**
     * The data used to update ContactTimelineEvents.
     */
    data: XOR<ContactTimelineEventUpdateManyMutationInput, ContactTimelineEventUncheckedUpdateManyInput>
    /**
     * Filter which ContactTimelineEvents to update
     */
    where?: ContactTimelineEventWhereInput
    /**
     * Limit how many ContactTimelineEvents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTimelineEventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContactTimelineEvent upsert
   */
  export type ContactTimelineEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTimelineEvent
     */
    select?: ContactTimelineEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTimelineEvent
     */
    omit?: ContactTimelineEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTimelineEventInclude<ExtArgs> | null
    /**
     * The filter to search for the ContactTimelineEvent to update in case it exists.
     */
    where: ContactTimelineEventWhereUniqueInput
    /**
     * In case the ContactTimelineEvent found by the `where` argument doesn't exist, create a new ContactTimelineEvent with this data.
     */
    create: XOR<ContactTimelineEventCreateInput, ContactTimelineEventUncheckedCreateInput>
    /**
     * In case the ContactTimelineEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactTimelineEventUpdateInput, ContactTimelineEventUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactTimelineEvent delete
   */
  export type ContactTimelineEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTimelineEvent
     */
    select?: ContactTimelineEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTimelineEvent
     */
    omit?: ContactTimelineEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTimelineEventInclude<ExtArgs> | null
    /**
     * Filter which ContactTimelineEvent to delete.
     */
    where: ContactTimelineEventWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactTimelineEvent deleteMany
   */
  export type ContactTimelineEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactTimelineEvents to delete
     */
    where?: ContactTimelineEventWhereInput
    /**
     * Limit how many ContactTimelineEvents to delete.
     */
    limit?: number
  }

  /**
   * ContactTimelineEvent.activity
   */
  export type ContactTimelineEvent$activityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
  }

  /**
   * ContactTimelineEvent.waypoint
   */
  export type ContactTimelineEvent$waypointArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityWaypoint
     */
    select?: ActivityWaypointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityWaypoint
     */
    omit?: ActivityWaypointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityWaypointInclude<ExtArgs> | null
    where?: ActivityWaypointWhereInput
  }

  /**
   * ContactTimelineEvent.opportunity
   */
  export type ContactTimelineEvent$opportunityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    where?: OpportunityWhereInput
  }

  /**
   * ContactTimelineEvent.note
   */
  export type ContactTimelineEvent$noteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    where?: NoteWhereInput
  }

  /**
   * ContactTimelineEvent.contacts
   */
  export type ContactTimelineEvent$contactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTimelineEventContactJoin
     */
    select?: ContactTimelineEventContactJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTimelineEventContactJoin
     */
    omit?: ContactTimelineEventContactJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTimelineEventContactJoinInclude<ExtArgs> | null
    where?: ContactTimelineEventContactJoinWhereInput
    orderBy?: ContactTimelineEventContactJoinOrderByWithRelationInput | ContactTimelineEventContactJoinOrderByWithRelationInput[]
    cursor?: ContactTimelineEventContactJoinWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactTimelineEventContactJoinScalarFieldEnum | ContactTimelineEventContactJoinScalarFieldEnum[]
  }

  /**
   * ContactTimelineEvent without action
   */
  export type ContactTimelineEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTimelineEvent
     */
    select?: ContactTimelineEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTimelineEvent
     */
    omit?: ContactTimelineEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTimelineEventInclude<ExtArgs> | null
  }


  /**
   * Model AuditEvent
   */

  export type AggregateAuditEvent = {
    _count: AuditEventCountAggregateOutputType | null
    _min: AuditEventMinAggregateOutputType | null
    _max: AuditEventMaxAggregateOutputType | null
  }

  export type AuditEventMinAggregateOutputType = {
    id: Uint8Array | null
    userId: Uint8Array | null
    tenetId: Uint8Array | null
    type: $Enums.AuditEventType | null
    details: string | null
    referenceId: Uint8Array | null
    reference: $Enums.Auditable | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuditEventMaxAggregateOutputType = {
    id: Uint8Array | null
    userId: Uint8Array | null
    tenetId: Uint8Array | null
    type: $Enums.AuditEventType | null
    details: string | null
    referenceId: Uint8Array | null
    reference: $Enums.Auditable | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuditEventCountAggregateOutputType = {
    id: number
    userId: number
    tenetId: number
    type: number
    details: number
    referenceId: number
    reference: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AuditEventMinAggregateInputType = {
    id?: true
    userId?: true
    tenetId?: true
    type?: true
    details?: true
    referenceId?: true
    reference?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuditEventMaxAggregateInputType = {
    id?: true
    userId?: true
    tenetId?: true
    type?: true
    details?: true
    referenceId?: true
    reference?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuditEventCountAggregateInputType = {
    id?: true
    userId?: true
    tenetId?: true
    type?: true
    details?: true
    referenceId?: true
    reference?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AuditEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditEvent to aggregate.
     */
    where?: AuditEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditEvents to fetch.
     */
    orderBy?: AuditEventOrderByWithRelationInput | AuditEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditEvents
    **/
    _count?: true | AuditEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditEventMaxAggregateInputType
  }

  export type GetAuditEventAggregateType<T extends AuditEventAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditEvent[P]>
      : GetScalarType<T[P], AggregateAuditEvent[P]>
  }




  export type AuditEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditEventWhereInput
    orderBy?: AuditEventOrderByWithAggregationInput | AuditEventOrderByWithAggregationInput[]
    by: AuditEventScalarFieldEnum[] | AuditEventScalarFieldEnum
    having?: AuditEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditEventCountAggregateInputType | true
    _min?: AuditEventMinAggregateInputType
    _max?: AuditEventMaxAggregateInputType
  }

  export type AuditEventGroupByOutputType = {
    id: Uint8Array
    userId: Uint8Array
    tenetId: Uint8Array
    type: $Enums.AuditEventType
    details: string | null
    referenceId: Uint8Array
    reference: $Enums.Auditable
    createdAt: Date
    updatedAt: Date
    _count: AuditEventCountAggregateOutputType | null
    _min: AuditEventMinAggregateOutputType | null
    _max: AuditEventMaxAggregateOutputType | null
  }

  type GetAuditEventGroupByPayload<T extends AuditEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditEventGroupByOutputType[P]>
            : GetScalarType<T[P], AuditEventGroupByOutputType[P]>
        }
      >
    >


  export type AuditEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tenetId?: boolean
    type?: boolean
    details?: boolean
    referenceId?: boolean
    reference?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditEvent"]>

  export type AuditEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tenetId?: boolean
    type?: boolean
    details?: boolean
    referenceId?: boolean
    reference?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditEvent"]>

  export type AuditEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tenetId?: boolean
    type?: boolean
    details?: boolean
    referenceId?: boolean
    reference?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditEvent"]>

  export type AuditEventSelectScalar = {
    id?: boolean
    userId?: boolean
    tenetId?: boolean
    type?: boolean
    details?: boolean
    referenceId?: boolean
    reference?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AuditEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "tenetId" | "type" | "details" | "referenceId" | "reference" | "createdAt" | "updatedAt", ExtArgs["result"]["auditEvent"]>
  export type AuditEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }
  export type AuditEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }
  export type AuditEventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }

  export type $AuditEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditEvent"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      tenet: Prisma.$TenetPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: Uint8Array
      userId: Uint8Array
      tenetId: Uint8Array
      type: $Enums.AuditEventType
      details: string | null
      referenceId: Uint8Array
      reference: $Enums.Auditable
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["auditEvent"]>
    composites: {}
  }

  type AuditEventGetPayload<S extends boolean | null | undefined | AuditEventDefaultArgs> = $Result.GetResult<Prisma.$AuditEventPayload, S>

  type AuditEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: AuditEventCountAggregateInputType | true
    }

  export interface AuditEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditEvent'], meta: { name: 'AuditEvent' } }
    /**
     * Find zero or one AuditEvent that matches the filter.
     * @param {AuditEventFindUniqueArgs} args - Arguments to find a AuditEvent
     * @example
     * // Get one AuditEvent
     * const auditEvent = await prisma.auditEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditEventFindUniqueArgs>(args: SelectSubset<T, AuditEventFindUniqueArgs<ExtArgs>>): Prisma__AuditEventClient<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one AuditEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditEventFindUniqueOrThrowArgs} args - Arguments to find a AuditEvent
     * @example
     * // Get one AuditEvent
     * const auditEvent = await prisma.auditEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditEventFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditEventClient<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first AuditEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditEventFindFirstArgs} args - Arguments to find a AuditEvent
     * @example
     * // Get one AuditEvent
     * const auditEvent = await prisma.auditEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditEventFindFirstArgs>(args?: SelectSubset<T, AuditEventFindFirstArgs<ExtArgs>>): Prisma__AuditEventClient<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first AuditEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditEventFindFirstOrThrowArgs} args - Arguments to find a AuditEvent
     * @example
     * // Get one AuditEvent
     * const auditEvent = await prisma.auditEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditEventFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditEventClient<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more AuditEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditEvents
     * const auditEvents = await prisma.auditEvent.findMany()
     * 
     * // Get first 10 AuditEvents
     * const auditEvents = await prisma.auditEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditEventWithIdOnly = await prisma.auditEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditEventFindManyArgs>(args?: SelectSubset<T, AuditEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a AuditEvent.
     * @param {AuditEventCreateArgs} args - Arguments to create a AuditEvent.
     * @example
     * // Create one AuditEvent
     * const AuditEvent = await prisma.auditEvent.create({
     *   data: {
     *     // ... data to create a AuditEvent
     *   }
     * })
     * 
     */
    create<T extends AuditEventCreateArgs>(args: SelectSubset<T, AuditEventCreateArgs<ExtArgs>>): Prisma__AuditEventClient<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many AuditEvents.
     * @param {AuditEventCreateManyArgs} args - Arguments to create many AuditEvents.
     * @example
     * // Create many AuditEvents
     * const auditEvent = await prisma.auditEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditEventCreateManyArgs>(args?: SelectSubset<T, AuditEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditEvents and returns the data saved in the database.
     * @param {AuditEventCreateManyAndReturnArgs} args - Arguments to create many AuditEvents.
     * @example
     * // Create many AuditEvents
     * const auditEvent = await prisma.auditEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditEvents and only return the `id`
     * const auditEventWithIdOnly = await prisma.auditEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditEventCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a AuditEvent.
     * @param {AuditEventDeleteArgs} args - Arguments to delete one AuditEvent.
     * @example
     * // Delete one AuditEvent
     * const AuditEvent = await prisma.auditEvent.delete({
     *   where: {
     *     // ... filter to delete one AuditEvent
     *   }
     * })
     * 
     */
    delete<T extends AuditEventDeleteArgs>(args: SelectSubset<T, AuditEventDeleteArgs<ExtArgs>>): Prisma__AuditEventClient<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one AuditEvent.
     * @param {AuditEventUpdateArgs} args - Arguments to update one AuditEvent.
     * @example
     * // Update one AuditEvent
     * const auditEvent = await prisma.auditEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditEventUpdateArgs>(args: SelectSubset<T, AuditEventUpdateArgs<ExtArgs>>): Prisma__AuditEventClient<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more AuditEvents.
     * @param {AuditEventDeleteManyArgs} args - Arguments to filter AuditEvents to delete.
     * @example
     * // Delete a few AuditEvents
     * const { count } = await prisma.auditEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditEventDeleteManyArgs>(args?: SelectSubset<T, AuditEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditEvents
     * const auditEvent = await prisma.auditEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditEventUpdateManyArgs>(args: SelectSubset<T, AuditEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditEvents and returns the data updated in the database.
     * @param {AuditEventUpdateManyAndReturnArgs} args - Arguments to update many AuditEvents.
     * @example
     * // Update many AuditEvents
     * const auditEvent = await prisma.auditEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditEvents and only return the `id`
     * const auditEventWithIdOnly = await prisma.auditEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditEventUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one AuditEvent.
     * @param {AuditEventUpsertArgs} args - Arguments to update or create a AuditEvent.
     * @example
     * // Update or create a AuditEvent
     * const auditEvent = await prisma.auditEvent.upsert({
     *   create: {
     *     // ... data to create a AuditEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditEvent we want to update
     *   }
     * })
     */
    upsert<T extends AuditEventUpsertArgs>(args: SelectSubset<T, AuditEventUpsertArgs<ExtArgs>>): Prisma__AuditEventClient<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of AuditEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditEventCountArgs} args - Arguments to filter AuditEvents to count.
     * @example
     * // Count the number of AuditEvents
     * const count = await prisma.auditEvent.count({
     *   where: {
     *     // ... the filter for the AuditEvents we want to count
     *   }
     * })
    **/
    count<T extends AuditEventCountArgs>(
      args?: Subset<T, AuditEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditEventAggregateArgs>(args: Subset<T, AuditEventAggregateArgs>): Prisma.PrismaPromise<GetAuditEventAggregateType<T>>

    /**
     * Group by AuditEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditEventGroupByArgs['orderBy'] }
        : { orderBy?: AuditEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditEvent model
   */
  readonly fields: AuditEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    tenet<T extends TenetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenetDefaultArgs<ExtArgs>>): Prisma__TenetClient<$Result.GetResult<Prisma.$TenetPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditEvent model
   */ 
  interface AuditEventFieldRefs {
    readonly id: FieldRef<"AuditEvent", 'Bytes'>
    readonly userId: FieldRef<"AuditEvent", 'Bytes'>
    readonly tenetId: FieldRef<"AuditEvent", 'Bytes'>
    readonly type: FieldRef<"AuditEvent", 'AuditEventType'>
    readonly details: FieldRef<"AuditEvent", 'String'>
    readonly referenceId: FieldRef<"AuditEvent", 'Bytes'>
    readonly reference: FieldRef<"AuditEvent", 'Auditable'>
    readonly createdAt: FieldRef<"AuditEvent", 'DateTime'>
    readonly updatedAt: FieldRef<"AuditEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditEvent findUnique
   */
  export type AuditEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditEvent
     */
    omit?: AuditEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventInclude<ExtArgs> | null
    /**
     * Filter, which AuditEvent to fetch.
     */
    where: AuditEventWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AuditEvent findUniqueOrThrow
   */
  export type AuditEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditEvent
     */
    omit?: AuditEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventInclude<ExtArgs> | null
    /**
     * Filter, which AuditEvent to fetch.
     */
    where: AuditEventWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AuditEvent findFirst
   */
  export type AuditEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditEvent
     */
    omit?: AuditEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventInclude<ExtArgs> | null
    /**
     * Filter, which AuditEvent to fetch.
     */
    where?: AuditEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditEvents to fetch.
     */
    orderBy?: AuditEventOrderByWithRelationInput | AuditEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditEvents.
     */
    cursor?: AuditEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditEvents.
     */
    distinct?: AuditEventScalarFieldEnum | AuditEventScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AuditEvent findFirstOrThrow
   */
  export type AuditEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditEvent
     */
    omit?: AuditEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventInclude<ExtArgs> | null
    /**
     * Filter, which AuditEvent to fetch.
     */
    where?: AuditEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditEvents to fetch.
     */
    orderBy?: AuditEventOrderByWithRelationInput | AuditEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditEvents.
     */
    cursor?: AuditEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditEvents.
     */
    distinct?: AuditEventScalarFieldEnum | AuditEventScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AuditEvent findMany
   */
  export type AuditEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditEvent
     */
    omit?: AuditEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventInclude<ExtArgs> | null
    /**
     * Filter, which AuditEvents to fetch.
     */
    where?: AuditEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditEvents to fetch.
     */
    orderBy?: AuditEventOrderByWithRelationInput | AuditEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditEvents.
     */
    cursor?: AuditEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditEvents.
     */
    skip?: number
    distinct?: AuditEventScalarFieldEnum | AuditEventScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AuditEvent create
   */
  export type AuditEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditEvent
     */
    omit?: AuditEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditEvent.
     */
    data: XOR<AuditEventCreateInput, AuditEventUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AuditEvent createMany
   */
  export type AuditEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditEvents.
     */
    data: AuditEventCreateManyInput | AuditEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditEvent createManyAndReturn
   */
  export type AuditEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditEvent
     */
    omit?: AuditEventOmit<ExtArgs> | null
    /**
     * The data used to create many AuditEvents.
     */
    data: AuditEventCreateManyInput | AuditEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditEvent update
   */
  export type AuditEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditEvent
     */
    omit?: AuditEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditEvent.
     */
    data: XOR<AuditEventUpdateInput, AuditEventUncheckedUpdateInput>
    /**
     * Choose, which AuditEvent to update.
     */
    where: AuditEventWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AuditEvent updateMany
   */
  export type AuditEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditEvents.
     */
    data: XOR<AuditEventUpdateManyMutationInput, AuditEventUncheckedUpdateManyInput>
    /**
     * Filter which AuditEvents to update
     */
    where?: AuditEventWhereInput
    /**
     * Limit how many AuditEvents to update.
     */
    limit?: number
  }

  /**
   * AuditEvent updateManyAndReturn
   */
  export type AuditEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditEvent
     */
    omit?: AuditEventOmit<ExtArgs> | null
    /**
     * The data used to update AuditEvents.
     */
    data: XOR<AuditEventUpdateManyMutationInput, AuditEventUncheckedUpdateManyInput>
    /**
     * Filter which AuditEvents to update
     */
    where?: AuditEventWhereInput
    /**
     * Limit how many AuditEvents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditEvent upsert
   */
  export type AuditEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditEvent
     */
    omit?: AuditEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditEvent to update in case it exists.
     */
    where: AuditEventWhereUniqueInput
    /**
     * In case the AuditEvent found by the `where` argument doesn't exist, create a new AuditEvent with this data.
     */
    create: XOR<AuditEventCreateInput, AuditEventUncheckedCreateInput>
    /**
     * In case the AuditEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditEventUpdateInput, AuditEventUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AuditEvent delete
   */
  export type AuditEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditEvent
     */
    omit?: AuditEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventInclude<ExtArgs> | null
    /**
     * Filter which AuditEvent to delete.
     */
    where: AuditEventWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * AuditEvent deleteMany
   */
  export type AuditEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditEvents to delete
     */
    where?: AuditEventWhereInput
    /**
     * Limit how many AuditEvents to delete.
     */
    limit?: number
  }

  /**
   * AuditEvent without action
   */
  export type AuditEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditEvent
     */
    omit?: AuditEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventInclude<ExtArgs> | null
  }


  /**
   * Model ContactTimelineEventContactJoin
   */

  export type AggregateContactTimelineEventContactJoin = {
    _count: ContactTimelineEventContactJoinCountAggregateOutputType | null
    _min: ContactTimelineEventContactJoinMinAggregateOutputType | null
    _max: ContactTimelineEventContactJoinMaxAggregateOutputType | null
  }

  export type ContactTimelineEventContactJoinMinAggregateOutputType = {
    contactEventId: Uint8Array | null
    contactId: Uint8Array | null
    type: $Enums.ContactTimelineEventJoinType | null
  }

  export type ContactTimelineEventContactJoinMaxAggregateOutputType = {
    contactEventId: Uint8Array | null
    contactId: Uint8Array | null
    type: $Enums.ContactTimelineEventJoinType | null
  }

  export type ContactTimelineEventContactJoinCountAggregateOutputType = {
    contactEventId: number
    contactId: number
    type: number
    _all: number
  }


  export type ContactTimelineEventContactJoinMinAggregateInputType = {
    contactEventId?: true
    contactId?: true
    type?: true
  }

  export type ContactTimelineEventContactJoinMaxAggregateInputType = {
    contactEventId?: true
    contactId?: true
    type?: true
  }

  export type ContactTimelineEventContactJoinCountAggregateInputType = {
    contactEventId?: true
    contactId?: true
    type?: true
    _all?: true
  }

  export type ContactTimelineEventContactJoinAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactTimelineEventContactJoin to aggregate.
     */
    where?: ContactTimelineEventContactJoinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactTimelineEventContactJoins to fetch.
     */
    orderBy?: ContactTimelineEventContactJoinOrderByWithRelationInput | ContactTimelineEventContactJoinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactTimelineEventContactJoinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactTimelineEventContactJoins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactTimelineEventContactJoins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContactTimelineEventContactJoins
    **/
    _count?: true | ContactTimelineEventContactJoinCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactTimelineEventContactJoinMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactTimelineEventContactJoinMaxAggregateInputType
  }

  export type GetContactTimelineEventContactJoinAggregateType<T extends ContactTimelineEventContactJoinAggregateArgs> = {
        [P in keyof T & keyof AggregateContactTimelineEventContactJoin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContactTimelineEventContactJoin[P]>
      : GetScalarType<T[P], AggregateContactTimelineEventContactJoin[P]>
  }




  export type ContactTimelineEventContactJoinGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactTimelineEventContactJoinWhereInput
    orderBy?: ContactTimelineEventContactJoinOrderByWithAggregationInput | ContactTimelineEventContactJoinOrderByWithAggregationInput[]
    by: ContactTimelineEventContactJoinScalarFieldEnum[] | ContactTimelineEventContactJoinScalarFieldEnum
    having?: ContactTimelineEventContactJoinScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactTimelineEventContactJoinCountAggregateInputType | true
    _min?: ContactTimelineEventContactJoinMinAggregateInputType
    _max?: ContactTimelineEventContactJoinMaxAggregateInputType
  }

  export type ContactTimelineEventContactJoinGroupByOutputType = {
    contactEventId: Uint8Array
    contactId: Uint8Array
    type: $Enums.ContactTimelineEventJoinType
    _count: ContactTimelineEventContactJoinCountAggregateOutputType | null
    _min: ContactTimelineEventContactJoinMinAggregateOutputType | null
    _max: ContactTimelineEventContactJoinMaxAggregateOutputType | null
  }

  type GetContactTimelineEventContactJoinGroupByPayload<T extends ContactTimelineEventContactJoinGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactTimelineEventContactJoinGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactTimelineEventContactJoinGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactTimelineEventContactJoinGroupByOutputType[P]>
            : GetScalarType<T[P], ContactTimelineEventContactJoinGroupByOutputType[P]>
        }
      >
    >


  export type ContactTimelineEventContactJoinSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    contactEventId?: boolean
    contactId?: boolean
    type?: boolean
    contactEventRelation?: boolean | ContactTimelineEventDefaultArgs<ExtArgs>
    contactRelation?: boolean | ContactDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactTimelineEventContactJoin"]>

  export type ContactTimelineEventContactJoinSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    contactEventId?: boolean
    contactId?: boolean
    type?: boolean
    contactEventRelation?: boolean | ContactTimelineEventDefaultArgs<ExtArgs>
    contactRelation?: boolean | ContactDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactTimelineEventContactJoin"]>

  export type ContactTimelineEventContactJoinSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    contactEventId?: boolean
    contactId?: boolean
    type?: boolean
    contactEventRelation?: boolean | ContactTimelineEventDefaultArgs<ExtArgs>
    contactRelation?: boolean | ContactDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactTimelineEventContactJoin"]>

  export type ContactTimelineEventContactJoinSelectScalar = {
    contactEventId?: boolean
    contactId?: boolean
    type?: boolean
  }

  export type ContactTimelineEventContactJoinOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"contactEventId" | "contactId" | "type", ExtArgs["result"]["contactTimelineEventContactJoin"]>
  export type ContactTimelineEventContactJoinInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contactEventRelation?: boolean | ContactTimelineEventDefaultArgs<ExtArgs>
    contactRelation?: boolean | ContactDefaultArgs<ExtArgs>
  }
  export type ContactTimelineEventContactJoinIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contactEventRelation?: boolean | ContactTimelineEventDefaultArgs<ExtArgs>
    contactRelation?: boolean | ContactDefaultArgs<ExtArgs>
  }
  export type ContactTimelineEventContactJoinIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contactEventRelation?: boolean | ContactTimelineEventDefaultArgs<ExtArgs>
    contactRelation?: boolean | ContactDefaultArgs<ExtArgs>
  }

  export type $ContactTimelineEventContactJoinPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContactTimelineEventContactJoin"
    objects: {
      contactEventRelation: Prisma.$ContactTimelineEventPayload<ExtArgs>
      contactRelation: Prisma.$ContactPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      /**
       * @@wrapper-ignore
       */
      contactEventId: Uint8Array
      contactId: Uint8Array
      /**
       * @ai-field(Describes how this contact relates to a contact event.)
       */
      type: $Enums.ContactTimelineEventJoinType
    }, ExtArgs["result"]["contactTimelineEventContactJoin"]>
    composites: {}
  }

  type ContactTimelineEventContactJoinGetPayload<S extends boolean | null | undefined | ContactTimelineEventContactJoinDefaultArgs> = $Result.GetResult<Prisma.$ContactTimelineEventContactJoinPayload, S>

  type ContactTimelineEventContactJoinCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactTimelineEventContactJoinFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: ContactTimelineEventContactJoinCountAggregateInputType | true
    }

  export interface ContactTimelineEventContactJoinDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContactTimelineEventContactJoin'], meta: { name: 'ContactTimelineEventContactJoin' } }
    /**
     * Find zero or one ContactTimelineEventContactJoin that matches the filter.
     * @param {ContactTimelineEventContactJoinFindUniqueArgs} args - Arguments to find a ContactTimelineEventContactJoin
     * @example
     * // Get one ContactTimelineEventContactJoin
     * const contactTimelineEventContactJoin = await prisma.contactTimelineEventContactJoin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactTimelineEventContactJoinFindUniqueArgs>(args: SelectSubset<T, ContactTimelineEventContactJoinFindUniqueArgs<ExtArgs>>): Prisma__ContactTimelineEventContactJoinClient<$Result.GetResult<Prisma.$ContactTimelineEventContactJoinPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ContactTimelineEventContactJoin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactTimelineEventContactJoinFindUniqueOrThrowArgs} args - Arguments to find a ContactTimelineEventContactJoin
     * @example
     * // Get one ContactTimelineEventContactJoin
     * const contactTimelineEventContactJoin = await prisma.contactTimelineEventContactJoin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactTimelineEventContactJoinFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactTimelineEventContactJoinFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactTimelineEventContactJoinClient<$Result.GetResult<Prisma.$ContactTimelineEventContactJoinPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ContactTimelineEventContactJoin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactTimelineEventContactJoinFindFirstArgs} args - Arguments to find a ContactTimelineEventContactJoin
     * @example
     * // Get one ContactTimelineEventContactJoin
     * const contactTimelineEventContactJoin = await prisma.contactTimelineEventContactJoin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactTimelineEventContactJoinFindFirstArgs>(args?: SelectSubset<T, ContactTimelineEventContactJoinFindFirstArgs<ExtArgs>>): Prisma__ContactTimelineEventContactJoinClient<$Result.GetResult<Prisma.$ContactTimelineEventContactJoinPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ContactTimelineEventContactJoin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactTimelineEventContactJoinFindFirstOrThrowArgs} args - Arguments to find a ContactTimelineEventContactJoin
     * @example
     * // Get one ContactTimelineEventContactJoin
     * const contactTimelineEventContactJoin = await prisma.contactTimelineEventContactJoin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactTimelineEventContactJoinFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactTimelineEventContactJoinFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactTimelineEventContactJoinClient<$Result.GetResult<Prisma.$ContactTimelineEventContactJoinPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ContactTimelineEventContactJoins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactTimelineEventContactJoinFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContactTimelineEventContactJoins
     * const contactTimelineEventContactJoins = await prisma.contactTimelineEventContactJoin.findMany()
     * 
     * // Get first 10 ContactTimelineEventContactJoins
     * const contactTimelineEventContactJoins = await prisma.contactTimelineEventContactJoin.findMany({ take: 10 })
     * 
     * // Only select the `contactEventId`
     * const contactTimelineEventContactJoinWithContactEventIdOnly = await prisma.contactTimelineEventContactJoin.findMany({ select: { contactEventId: true } })
     * 
     */
    findMany<T extends ContactTimelineEventContactJoinFindManyArgs>(args?: SelectSubset<T, ContactTimelineEventContactJoinFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactTimelineEventContactJoinPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ContactTimelineEventContactJoin.
     * @param {ContactTimelineEventContactJoinCreateArgs} args - Arguments to create a ContactTimelineEventContactJoin.
     * @example
     * // Create one ContactTimelineEventContactJoin
     * const ContactTimelineEventContactJoin = await prisma.contactTimelineEventContactJoin.create({
     *   data: {
     *     // ... data to create a ContactTimelineEventContactJoin
     *   }
     * })
     * 
     */
    create<T extends ContactTimelineEventContactJoinCreateArgs>(args: SelectSubset<T, ContactTimelineEventContactJoinCreateArgs<ExtArgs>>): Prisma__ContactTimelineEventContactJoinClient<$Result.GetResult<Prisma.$ContactTimelineEventContactJoinPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ContactTimelineEventContactJoins.
     * @param {ContactTimelineEventContactJoinCreateManyArgs} args - Arguments to create many ContactTimelineEventContactJoins.
     * @example
     * // Create many ContactTimelineEventContactJoins
     * const contactTimelineEventContactJoin = await prisma.contactTimelineEventContactJoin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactTimelineEventContactJoinCreateManyArgs>(args?: SelectSubset<T, ContactTimelineEventContactJoinCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContactTimelineEventContactJoins and returns the data saved in the database.
     * @param {ContactTimelineEventContactJoinCreateManyAndReturnArgs} args - Arguments to create many ContactTimelineEventContactJoins.
     * @example
     * // Create many ContactTimelineEventContactJoins
     * const contactTimelineEventContactJoin = await prisma.contactTimelineEventContactJoin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContactTimelineEventContactJoins and only return the `contactEventId`
     * const contactTimelineEventContactJoinWithContactEventIdOnly = await prisma.contactTimelineEventContactJoin.createManyAndReturn({
     *   select: { contactEventId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactTimelineEventContactJoinCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactTimelineEventContactJoinCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactTimelineEventContactJoinPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a ContactTimelineEventContactJoin.
     * @param {ContactTimelineEventContactJoinDeleteArgs} args - Arguments to delete one ContactTimelineEventContactJoin.
     * @example
     * // Delete one ContactTimelineEventContactJoin
     * const ContactTimelineEventContactJoin = await prisma.contactTimelineEventContactJoin.delete({
     *   where: {
     *     // ... filter to delete one ContactTimelineEventContactJoin
     *   }
     * })
     * 
     */
    delete<T extends ContactTimelineEventContactJoinDeleteArgs>(args: SelectSubset<T, ContactTimelineEventContactJoinDeleteArgs<ExtArgs>>): Prisma__ContactTimelineEventContactJoinClient<$Result.GetResult<Prisma.$ContactTimelineEventContactJoinPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ContactTimelineEventContactJoin.
     * @param {ContactTimelineEventContactJoinUpdateArgs} args - Arguments to update one ContactTimelineEventContactJoin.
     * @example
     * // Update one ContactTimelineEventContactJoin
     * const contactTimelineEventContactJoin = await prisma.contactTimelineEventContactJoin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactTimelineEventContactJoinUpdateArgs>(args: SelectSubset<T, ContactTimelineEventContactJoinUpdateArgs<ExtArgs>>): Prisma__ContactTimelineEventContactJoinClient<$Result.GetResult<Prisma.$ContactTimelineEventContactJoinPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ContactTimelineEventContactJoins.
     * @param {ContactTimelineEventContactJoinDeleteManyArgs} args - Arguments to filter ContactTimelineEventContactJoins to delete.
     * @example
     * // Delete a few ContactTimelineEventContactJoins
     * const { count } = await prisma.contactTimelineEventContactJoin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactTimelineEventContactJoinDeleteManyArgs>(args?: SelectSubset<T, ContactTimelineEventContactJoinDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactTimelineEventContactJoins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactTimelineEventContactJoinUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContactTimelineEventContactJoins
     * const contactTimelineEventContactJoin = await prisma.contactTimelineEventContactJoin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactTimelineEventContactJoinUpdateManyArgs>(args: SelectSubset<T, ContactTimelineEventContactJoinUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactTimelineEventContactJoins and returns the data updated in the database.
     * @param {ContactTimelineEventContactJoinUpdateManyAndReturnArgs} args - Arguments to update many ContactTimelineEventContactJoins.
     * @example
     * // Update many ContactTimelineEventContactJoins
     * const contactTimelineEventContactJoin = await prisma.contactTimelineEventContactJoin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContactTimelineEventContactJoins and only return the `contactEventId`
     * const contactTimelineEventContactJoinWithContactEventIdOnly = await prisma.contactTimelineEventContactJoin.updateManyAndReturn({
     *   select: { contactEventId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContactTimelineEventContactJoinUpdateManyAndReturnArgs>(args: SelectSubset<T, ContactTimelineEventContactJoinUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactTimelineEventContactJoinPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one ContactTimelineEventContactJoin.
     * @param {ContactTimelineEventContactJoinUpsertArgs} args - Arguments to update or create a ContactTimelineEventContactJoin.
     * @example
     * // Update or create a ContactTimelineEventContactJoin
     * const contactTimelineEventContactJoin = await prisma.contactTimelineEventContactJoin.upsert({
     *   create: {
     *     // ... data to create a ContactTimelineEventContactJoin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContactTimelineEventContactJoin we want to update
     *   }
     * })
     */
    upsert<T extends ContactTimelineEventContactJoinUpsertArgs>(args: SelectSubset<T, ContactTimelineEventContactJoinUpsertArgs<ExtArgs>>): Prisma__ContactTimelineEventContactJoinClient<$Result.GetResult<Prisma.$ContactTimelineEventContactJoinPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ContactTimelineEventContactJoins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactTimelineEventContactJoinCountArgs} args - Arguments to filter ContactTimelineEventContactJoins to count.
     * @example
     * // Count the number of ContactTimelineEventContactJoins
     * const count = await prisma.contactTimelineEventContactJoin.count({
     *   where: {
     *     // ... the filter for the ContactTimelineEventContactJoins we want to count
     *   }
     * })
    **/
    count<T extends ContactTimelineEventContactJoinCountArgs>(
      args?: Subset<T, ContactTimelineEventContactJoinCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactTimelineEventContactJoinCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContactTimelineEventContactJoin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactTimelineEventContactJoinAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactTimelineEventContactJoinAggregateArgs>(args: Subset<T, ContactTimelineEventContactJoinAggregateArgs>): Prisma.PrismaPromise<GetContactTimelineEventContactJoinAggregateType<T>>

    /**
     * Group by ContactTimelineEventContactJoin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactTimelineEventContactJoinGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactTimelineEventContactJoinGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactTimelineEventContactJoinGroupByArgs['orderBy'] }
        : { orderBy?: ContactTimelineEventContactJoinGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactTimelineEventContactJoinGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactTimelineEventContactJoinGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContactTimelineEventContactJoin model
   */
  readonly fields: ContactTimelineEventContactJoinFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContactTimelineEventContactJoin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactTimelineEventContactJoinClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contactEventRelation<T extends ContactTimelineEventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContactTimelineEventDefaultArgs<ExtArgs>>): Prisma__ContactTimelineEventClient<$Result.GetResult<Prisma.$ContactTimelineEventPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    contactRelation<T extends ContactDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContactDefaultArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContactTimelineEventContactJoin model
   */ 
  interface ContactTimelineEventContactJoinFieldRefs {
    readonly contactEventId: FieldRef<"ContactTimelineEventContactJoin", 'Bytes'>
    readonly contactId: FieldRef<"ContactTimelineEventContactJoin", 'Bytes'>
    readonly type: FieldRef<"ContactTimelineEventContactJoin", 'ContactTimelineEventJoinType'>
  }
    

  // Custom InputTypes
  /**
   * ContactTimelineEventContactJoin findUnique
   */
  export type ContactTimelineEventContactJoinFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTimelineEventContactJoin
     */
    select?: ContactTimelineEventContactJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTimelineEventContactJoin
     */
    omit?: ContactTimelineEventContactJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTimelineEventContactJoinInclude<ExtArgs> | null
    /**
     * Filter, which ContactTimelineEventContactJoin to fetch.
     */
    where: ContactTimelineEventContactJoinWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactTimelineEventContactJoin findUniqueOrThrow
   */
  export type ContactTimelineEventContactJoinFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTimelineEventContactJoin
     */
    select?: ContactTimelineEventContactJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTimelineEventContactJoin
     */
    omit?: ContactTimelineEventContactJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTimelineEventContactJoinInclude<ExtArgs> | null
    /**
     * Filter, which ContactTimelineEventContactJoin to fetch.
     */
    where: ContactTimelineEventContactJoinWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactTimelineEventContactJoin findFirst
   */
  export type ContactTimelineEventContactJoinFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTimelineEventContactJoin
     */
    select?: ContactTimelineEventContactJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTimelineEventContactJoin
     */
    omit?: ContactTimelineEventContactJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTimelineEventContactJoinInclude<ExtArgs> | null
    /**
     * Filter, which ContactTimelineEventContactJoin to fetch.
     */
    where?: ContactTimelineEventContactJoinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactTimelineEventContactJoins to fetch.
     */
    orderBy?: ContactTimelineEventContactJoinOrderByWithRelationInput | ContactTimelineEventContactJoinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactTimelineEventContactJoins.
     */
    cursor?: ContactTimelineEventContactJoinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactTimelineEventContactJoins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactTimelineEventContactJoins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactTimelineEventContactJoins.
     */
    distinct?: ContactTimelineEventContactJoinScalarFieldEnum | ContactTimelineEventContactJoinScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactTimelineEventContactJoin findFirstOrThrow
   */
  export type ContactTimelineEventContactJoinFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTimelineEventContactJoin
     */
    select?: ContactTimelineEventContactJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTimelineEventContactJoin
     */
    omit?: ContactTimelineEventContactJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTimelineEventContactJoinInclude<ExtArgs> | null
    /**
     * Filter, which ContactTimelineEventContactJoin to fetch.
     */
    where?: ContactTimelineEventContactJoinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactTimelineEventContactJoins to fetch.
     */
    orderBy?: ContactTimelineEventContactJoinOrderByWithRelationInput | ContactTimelineEventContactJoinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactTimelineEventContactJoins.
     */
    cursor?: ContactTimelineEventContactJoinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactTimelineEventContactJoins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactTimelineEventContactJoins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactTimelineEventContactJoins.
     */
    distinct?: ContactTimelineEventContactJoinScalarFieldEnum | ContactTimelineEventContactJoinScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactTimelineEventContactJoin findMany
   */
  export type ContactTimelineEventContactJoinFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTimelineEventContactJoin
     */
    select?: ContactTimelineEventContactJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTimelineEventContactJoin
     */
    omit?: ContactTimelineEventContactJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTimelineEventContactJoinInclude<ExtArgs> | null
    /**
     * Filter, which ContactTimelineEventContactJoins to fetch.
     */
    where?: ContactTimelineEventContactJoinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactTimelineEventContactJoins to fetch.
     */
    orderBy?: ContactTimelineEventContactJoinOrderByWithRelationInput | ContactTimelineEventContactJoinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContactTimelineEventContactJoins.
     */
    cursor?: ContactTimelineEventContactJoinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactTimelineEventContactJoins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactTimelineEventContactJoins.
     */
    skip?: number
    distinct?: ContactTimelineEventContactJoinScalarFieldEnum | ContactTimelineEventContactJoinScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactTimelineEventContactJoin create
   */
  export type ContactTimelineEventContactJoinCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTimelineEventContactJoin
     */
    select?: ContactTimelineEventContactJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTimelineEventContactJoin
     */
    omit?: ContactTimelineEventContactJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTimelineEventContactJoinInclude<ExtArgs> | null
    /**
     * The data needed to create a ContactTimelineEventContactJoin.
     */
    data: XOR<ContactTimelineEventContactJoinCreateInput, ContactTimelineEventContactJoinUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactTimelineEventContactJoin createMany
   */
  export type ContactTimelineEventContactJoinCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContactTimelineEventContactJoins.
     */
    data: ContactTimelineEventContactJoinCreateManyInput | ContactTimelineEventContactJoinCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactTimelineEventContactJoin createManyAndReturn
   */
  export type ContactTimelineEventContactJoinCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTimelineEventContactJoin
     */
    select?: ContactTimelineEventContactJoinSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTimelineEventContactJoin
     */
    omit?: ContactTimelineEventContactJoinOmit<ExtArgs> | null
    /**
     * The data used to create many ContactTimelineEventContactJoins.
     */
    data: ContactTimelineEventContactJoinCreateManyInput | ContactTimelineEventContactJoinCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTimelineEventContactJoinIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContactTimelineEventContactJoin update
   */
  export type ContactTimelineEventContactJoinUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTimelineEventContactJoin
     */
    select?: ContactTimelineEventContactJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTimelineEventContactJoin
     */
    omit?: ContactTimelineEventContactJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTimelineEventContactJoinInclude<ExtArgs> | null
    /**
     * The data needed to update a ContactTimelineEventContactJoin.
     */
    data: XOR<ContactTimelineEventContactJoinUpdateInput, ContactTimelineEventContactJoinUncheckedUpdateInput>
    /**
     * Choose, which ContactTimelineEventContactJoin to update.
     */
    where: ContactTimelineEventContactJoinWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactTimelineEventContactJoin updateMany
   */
  export type ContactTimelineEventContactJoinUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContactTimelineEventContactJoins.
     */
    data: XOR<ContactTimelineEventContactJoinUpdateManyMutationInput, ContactTimelineEventContactJoinUncheckedUpdateManyInput>
    /**
     * Filter which ContactTimelineEventContactJoins to update
     */
    where?: ContactTimelineEventContactJoinWhereInput
    /**
     * Limit how many ContactTimelineEventContactJoins to update.
     */
    limit?: number
  }

  /**
   * ContactTimelineEventContactJoin updateManyAndReturn
   */
  export type ContactTimelineEventContactJoinUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTimelineEventContactJoin
     */
    select?: ContactTimelineEventContactJoinSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTimelineEventContactJoin
     */
    omit?: ContactTimelineEventContactJoinOmit<ExtArgs> | null
    /**
     * The data used to update ContactTimelineEventContactJoins.
     */
    data: XOR<ContactTimelineEventContactJoinUpdateManyMutationInput, ContactTimelineEventContactJoinUncheckedUpdateManyInput>
    /**
     * Filter which ContactTimelineEventContactJoins to update
     */
    where?: ContactTimelineEventContactJoinWhereInput
    /**
     * Limit how many ContactTimelineEventContactJoins to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTimelineEventContactJoinIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContactTimelineEventContactJoin upsert
   */
  export type ContactTimelineEventContactJoinUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTimelineEventContactJoin
     */
    select?: ContactTimelineEventContactJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTimelineEventContactJoin
     */
    omit?: ContactTimelineEventContactJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTimelineEventContactJoinInclude<ExtArgs> | null
    /**
     * The filter to search for the ContactTimelineEventContactJoin to update in case it exists.
     */
    where: ContactTimelineEventContactJoinWhereUniqueInput
    /**
     * In case the ContactTimelineEventContactJoin found by the `where` argument doesn't exist, create a new ContactTimelineEventContactJoin with this data.
     */
    create: XOR<ContactTimelineEventContactJoinCreateInput, ContactTimelineEventContactJoinUncheckedCreateInput>
    /**
     * In case the ContactTimelineEventContactJoin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactTimelineEventContactJoinUpdateInput, ContactTimelineEventContactJoinUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactTimelineEventContactJoin delete
   */
  export type ContactTimelineEventContactJoinDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTimelineEventContactJoin
     */
    select?: ContactTimelineEventContactJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTimelineEventContactJoin
     */
    omit?: ContactTimelineEventContactJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTimelineEventContactJoinInclude<ExtArgs> | null
    /**
     * Filter which ContactTimelineEventContactJoin to delete.
     */
    where: ContactTimelineEventContactJoinWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactTimelineEventContactJoin deleteMany
   */
  export type ContactTimelineEventContactJoinDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactTimelineEventContactJoins to delete
     */
    where?: ContactTimelineEventContactJoinWhereInput
    /**
     * Limit how many ContactTimelineEventContactJoins to delete.
     */
    limit?: number
  }

  /**
   * ContactTimelineEventContactJoin without action
   */
  export type ContactTimelineEventContactJoinDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTimelineEventContactJoin
     */
    select?: ContactTimelineEventContactJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTimelineEventContactJoin
     */
    omit?: ContactTimelineEventContactJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTimelineEventContactJoinInclude<ExtArgs> | null
  }


  /**
   * Model Note
   */

  export type AggregateNote = {
    _count: NoteCountAggregateOutputType | null
    _min: NoteMinAggregateOutputType | null
    _max: NoteMaxAggregateOutputType | null
  }

  export type NoteMinAggregateOutputType = {
    id: Uint8Array | null
    content: string | null
    waypointId: Uint8Array | null
    activityId: Uint8Array | null
    contactId: Uint8Array | null
    opportunityId: Uint8Array | null
    tenetId: Uint8Array | null
    authorId: Uint8Array | null
    createdAt: Date | null
    updatedAt: Date | null
    deleted: boolean | null
    deletedAt: Date | null
    noteType: $Enums.NoteType | null
  }

  export type NoteMaxAggregateOutputType = {
    id: Uint8Array | null
    content: string | null
    waypointId: Uint8Array | null
    activityId: Uint8Array | null
    contactId: Uint8Array | null
    opportunityId: Uint8Array | null
    tenetId: Uint8Array | null
    authorId: Uint8Array | null
    createdAt: Date | null
    updatedAt: Date | null
    deleted: boolean | null
    deletedAt: Date | null
    noteType: $Enums.NoteType | null
  }

  export type NoteCountAggregateOutputType = {
    id: number
    content: number
    waypointId: number
    activityId: number
    contactId: number
    opportunityId: number
    tenetId: number
    authorId: number
    createdAt: number
    updatedAt: number
    deleted: number
    deletedAt: number
    noteType: number
    _all: number
  }


  export type NoteMinAggregateInputType = {
    id?: true
    content?: true
    waypointId?: true
    activityId?: true
    contactId?: true
    opportunityId?: true
    tenetId?: true
    authorId?: true
    createdAt?: true
    updatedAt?: true
    deleted?: true
    deletedAt?: true
    noteType?: true
  }

  export type NoteMaxAggregateInputType = {
    id?: true
    content?: true
    waypointId?: true
    activityId?: true
    contactId?: true
    opportunityId?: true
    tenetId?: true
    authorId?: true
    createdAt?: true
    updatedAt?: true
    deleted?: true
    deletedAt?: true
    noteType?: true
  }

  export type NoteCountAggregateInputType = {
    id?: true
    content?: true
    waypointId?: true
    activityId?: true
    contactId?: true
    opportunityId?: true
    tenetId?: true
    authorId?: true
    createdAt?: true
    updatedAt?: true
    deleted?: true
    deletedAt?: true
    noteType?: true
    _all?: true
  }

  export type NoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Note to aggregate.
     */
    where?: NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notes
    **/
    _count?: true | NoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NoteMaxAggregateInputType
  }

  export type GetNoteAggregateType<T extends NoteAggregateArgs> = {
        [P in keyof T & keyof AggregateNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNote[P]>
      : GetScalarType<T[P], AggregateNote[P]>
  }




  export type NoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoteWhereInput
    orderBy?: NoteOrderByWithAggregationInput | NoteOrderByWithAggregationInput[]
    by: NoteScalarFieldEnum[] | NoteScalarFieldEnum
    having?: NoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NoteCountAggregateInputType | true
    _min?: NoteMinAggregateInputType
    _max?: NoteMaxAggregateInputType
  }

  export type NoteGroupByOutputType = {
    id: Uint8Array
    content: string
    waypointId: Uint8Array | null
    activityId: Uint8Array | null
    contactId: Uint8Array | null
    opportunityId: Uint8Array | null
    tenetId: Uint8Array
    authorId: Uint8Array
    createdAt: Date
    updatedAt: Date
    deleted: boolean
    deletedAt: Date | null
    noteType: $Enums.NoteType
    _count: NoteCountAggregateOutputType | null
    _min: NoteMinAggregateOutputType | null
    _max: NoteMaxAggregateOutputType | null
  }

  type GetNoteGroupByPayload<T extends NoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NoteGroupByOutputType[P]>
            : GetScalarType<T[P], NoteGroupByOutputType[P]>
        }
      >
    >


  export type NoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    waypointId?: boolean
    activityId?: boolean
    contactId?: boolean
    opportunityId?: boolean
    tenetId?: boolean
    authorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deleted?: boolean
    deletedAt?: boolean
    noteType?: boolean
    waypoint?: boolean | Note$waypointArgs<ExtArgs>
    activity?: boolean | Note$activityArgs<ExtArgs>
    contact?: boolean | Note$contactArgs<ExtArgs>
    opportunity?: boolean | Note$opportunityArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    events?: boolean | Note$eventsArgs<ExtArgs>
    _count?: boolean | NoteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["note"]>

  export type NoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    waypointId?: boolean
    activityId?: boolean
    contactId?: boolean
    opportunityId?: boolean
    tenetId?: boolean
    authorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deleted?: boolean
    deletedAt?: boolean
    noteType?: boolean
    waypoint?: boolean | Note$waypointArgs<ExtArgs>
    activity?: boolean | Note$activityArgs<ExtArgs>
    contact?: boolean | Note$contactArgs<ExtArgs>
    opportunity?: boolean | Note$opportunityArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["note"]>

  export type NoteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    waypointId?: boolean
    activityId?: boolean
    contactId?: boolean
    opportunityId?: boolean
    tenetId?: boolean
    authorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deleted?: boolean
    deletedAt?: boolean
    noteType?: boolean
    waypoint?: boolean | Note$waypointArgs<ExtArgs>
    activity?: boolean | Note$activityArgs<ExtArgs>
    contact?: boolean | Note$contactArgs<ExtArgs>
    opportunity?: boolean | Note$opportunityArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["note"]>

  export type NoteSelectScalar = {
    id?: boolean
    content?: boolean
    waypointId?: boolean
    activityId?: boolean
    contactId?: boolean
    opportunityId?: boolean
    tenetId?: boolean
    authorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deleted?: boolean
    deletedAt?: boolean
    noteType?: boolean
  }

  export type NoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "waypointId" | "activityId" | "contactId" | "opportunityId" | "tenetId" | "authorId" | "createdAt" | "updatedAt" | "deleted" | "deletedAt" | "noteType", ExtArgs["result"]["note"]>
  export type NoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    waypoint?: boolean | Note$waypointArgs<ExtArgs>
    activity?: boolean | Note$activityArgs<ExtArgs>
    contact?: boolean | Note$contactArgs<ExtArgs>
    opportunity?: boolean | Note$opportunityArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    events?: boolean | Note$eventsArgs<ExtArgs>
    _count?: boolean | NoteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    waypoint?: boolean | Note$waypointArgs<ExtArgs>
    activity?: boolean | Note$activityArgs<ExtArgs>
    contact?: boolean | Note$contactArgs<ExtArgs>
    opportunity?: boolean | Note$opportunityArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NoteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    waypoint?: boolean | Note$waypointArgs<ExtArgs>
    activity?: boolean | Note$activityArgs<ExtArgs>
    contact?: boolean | Note$contactArgs<ExtArgs>
    opportunity?: boolean | Note$opportunityArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Note"
    objects: {
      /**
       * @ai-field
       */
      waypoint: Prisma.$ActivityWaypointPayload<ExtArgs> | null
      /**
       * @ai-field
       */
      activity: Prisma.$ActivityPayload<ExtArgs> | null
      /**
       * @ai-field
       */
      contact: Prisma.$ContactPayload<ExtArgs> | null
      /**
       * @ai-field
       */
      opportunity: Prisma.$OpportunityPayload<ExtArgs> | null
      tenet: Prisma.$TenetPayload<ExtArgs>
      /**
       * @ai-field
       */
      author: Prisma.$UserPayload<ExtArgs>
      events: Prisma.$ContactTimelineEventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      /**
       * @@ai-enabled
       */
      id: Uint8Array
      /**
       * @ai-field
       */
      content: string
      /**
       * @ai-field
       */
      waypointId: Uint8Array | null
      /**
       * @ai-field
       */
      activityId: Uint8Array | null
      /**
       * @ai-field
       */
      contactId: Uint8Array | null
      /**
       * @ai-field
       */
      opportunityId: Uint8Array | null
      tenetId: Uint8Array
      /**
       * @ai-field
       */
      authorId: Uint8Array
      createdAt: Date
      updatedAt: Date
      /**
       * @@soft-delete
       */
      deleted: boolean
      deletedAt: Date | null
      noteType: $Enums.NoteType
    }, ExtArgs["result"]["note"]>
    composites: {}
  }

  type NoteGetPayload<S extends boolean | null | undefined | NoteDefaultArgs> = $Result.GetResult<Prisma.$NotePayload, S>

  type NoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: NoteCountAggregateInputType | true
    }

  export interface NoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Note'], meta: { name: 'Note' } }
    /**
     * Find zero or one Note that matches the filter.
     * @param {NoteFindUniqueArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NoteFindUniqueArgs>(args: SelectSubset<T, NoteFindUniqueArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Note that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NoteFindUniqueOrThrowArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NoteFindUniqueOrThrowArgs>(args: SelectSubset<T, NoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Note that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteFindFirstArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NoteFindFirstArgs>(args?: SelectSubset<T, NoteFindFirstArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Note that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteFindFirstOrThrowArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NoteFindFirstOrThrowArgs>(args?: SelectSubset<T, NoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Notes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notes
     * const notes = await prisma.note.findMany()
     * 
     * // Get first 10 Notes
     * const notes = await prisma.note.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const noteWithIdOnly = await prisma.note.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NoteFindManyArgs>(args?: SelectSubset<T, NoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Note.
     * @param {NoteCreateArgs} args - Arguments to create a Note.
     * @example
     * // Create one Note
     * const Note = await prisma.note.create({
     *   data: {
     *     // ... data to create a Note
     *   }
     * })
     * 
     */
    create<T extends NoteCreateArgs>(args: SelectSubset<T, NoteCreateArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Notes.
     * @param {NoteCreateManyArgs} args - Arguments to create many Notes.
     * @example
     * // Create many Notes
     * const note = await prisma.note.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NoteCreateManyArgs>(args?: SelectSubset<T, NoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notes and returns the data saved in the database.
     * @param {NoteCreateManyAndReturnArgs} args - Arguments to create many Notes.
     * @example
     * // Create many Notes
     * const note = await prisma.note.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notes and only return the `id`
     * const noteWithIdOnly = await prisma.note.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NoteCreateManyAndReturnArgs>(args?: SelectSubset<T, NoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Note.
     * @param {NoteDeleteArgs} args - Arguments to delete one Note.
     * @example
     * // Delete one Note
     * const Note = await prisma.note.delete({
     *   where: {
     *     // ... filter to delete one Note
     *   }
     * })
     * 
     */
    delete<T extends NoteDeleteArgs>(args: SelectSubset<T, NoteDeleteArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Note.
     * @param {NoteUpdateArgs} args - Arguments to update one Note.
     * @example
     * // Update one Note
     * const note = await prisma.note.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NoteUpdateArgs>(args: SelectSubset<T, NoteUpdateArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Notes.
     * @param {NoteDeleteManyArgs} args - Arguments to filter Notes to delete.
     * @example
     * // Delete a few Notes
     * const { count } = await prisma.note.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NoteDeleteManyArgs>(args?: SelectSubset<T, NoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notes
     * const note = await prisma.note.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NoteUpdateManyArgs>(args: SelectSubset<T, NoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notes and returns the data updated in the database.
     * @param {NoteUpdateManyAndReturnArgs} args - Arguments to update many Notes.
     * @example
     * // Update many Notes
     * const note = await prisma.note.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notes and only return the `id`
     * const noteWithIdOnly = await prisma.note.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NoteUpdateManyAndReturnArgs>(args: SelectSubset<T, NoteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Note.
     * @param {NoteUpsertArgs} args - Arguments to update or create a Note.
     * @example
     * // Update or create a Note
     * const note = await prisma.note.upsert({
     *   create: {
     *     // ... data to create a Note
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Note we want to update
     *   }
     * })
     */
    upsert<T extends NoteUpsertArgs>(args: SelectSubset<T, NoteUpsertArgs<ExtArgs>>): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteCountArgs} args - Arguments to filter Notes to count.
     * @example
     * // Count the number of Notes
     * const count = await prisma.note.count({
     *   where: {
     *     // ... the filter for the Notes we want to count
     *   }
     * })
    **/
    count<T extends NoteCountArgs>(
      args?: Subset<T, NoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Note.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NoteAggregateArgs>(args: Subset<T, NoteAggregateArgs>): Prisma.PrismaPromise<GetNoteAggregateType<T>>

    /**
     * Group by Note.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NoteGroupByArgs['orderBy'] }
        : { orderBy?: NoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Note model
   */
  readonly fields: NoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Note.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    waypoint<T extends Note$waypointArgs<ExtArgs> = {}>(args?: Subset<T, Note$waypointArgs<ExtArgs>>): Prisma__ActivityWaypointClient<$Result.GetResult<Prisma.$ActivityWaypointPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    activity<T extends Note$activityArgs<ExtArgs> = {}>(args?: Subset<T, Note$activityArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    contact<T extends Note$contactArgs<ExtArgs> = {}>(args?: Subset<T, Note$contactArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    opportunity<T extends Note$opportunityArgs<ExtArgs> = {}>(args?: Subset<T, Note$opportunityArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    tenet<T extends TenetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenetDefaultArgs<ExtArgs>>): Prisma__TenetClient<$Result.GetResult<Prisma.$TenetPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    events<T extends Note$eventsArgs<ExtArgs> = {}>(args?: Subset<T, Note$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactTimelineEventPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Note model
   */ 
  interface NoteFieldRefs {
    readonly id: FieldRef<"Note", 'Bytes'>
    readonly content: FieldRef<"Note", 'String'>
    readonly waypointId: FieldRef<"Note", 'Bytes'>
    readonly activityId: FieldRef<"Note", 'Bytes'>
    readonly contactId: FieldRef<"Note", 'Bytes'>
    readonly opportunityId: FieldRef<"Note", 'Bytes'>
    readonly tenetId: FieldRef<"Note", 'Bytes'>
    readonly authorId: FieldRef<"Note", 'Bytes'>
    readonly createdAt: FieldRef<"Note", 'DateTime'>
    readonly updatedAt: FieldRef<"Note", 'DateTime'>
    readonly deleted: FieldRef<"Note", 'Boolean'>
    readonly deletedAt: FieldRef<"Note", 'DateTime'>
    readonly noteType: FieldRef<"Note", 'NoteType'>
  }
    

  // Custom InputTypes
  /**
   * Note findUnique
   */
  export type NoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Note to fetch.
     */
    where: NoteWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Note findUniqueOrThrow
   */
  export type NoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Note to fetch.
     */
    where: NoteWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Note findFirst
   */
  export type NoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Note to fetch.
     */
    where?: NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notes.
     */
    cursor?: NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notes.
     */
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Note findFirstOrThrow
   */
  export type NoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Note to fetch.
     */
    where?: NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notes.
     */
    cursor?: NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notes.
     */
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Note findMany
   */
  export type NoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Notes to fetch.
     */
    where?: NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notes.
     */
    cursor?: NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Note create
   */
  export type NoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * The data needed to create a Note.
     */
    data: XOR<NoteCreateInput, NoteUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Note createMany
   */
  export type NoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notes.
     */
    data: NoteCreateManyInput | NoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Note createManyAndReturn
   */
  export type NoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * The data used to create many Notes.
     */
    data: NoteCreateManyInput | NoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Note update
   */
  export type NoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * The data needed to update a Note.
     */
    data: XOR<NoteUpdateInput, NoteUncheckedUpdateInput>
    /**
     * Choose, which Note to update.
     */
    where: NoteWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Note updateMany
   */
  export type NoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notes.
     */
    data: XOR<NoteUpdateManyMutationInput, NoteUncheckedUpdateManyInput>
    /**
     * Filter which Notes to update
     */
    where?: NoteWhereInput
    /**
     * Limit how many Notes to update.
     */
    limit?: number
  }

  /**
   * Note updateManyAndReturn
   */
  export type NoteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * The data used to update Notes.
     */
    data: XOR<NoteUpdateManyMutationInput, NoteUncheckedUpdateManyInput>
    /**
     * Filter which Notes to update
     */
    where?: NoteWhereInput
    /**
     * Limit how many Notes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Note upsert
   */
  export type NoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * The filter to search for the Note to update in case it exists.
     */
    where: NoteWhereUniqueInput
    /**
     * In case the Note found by the `where` argument doesn't exist, create a new Note with this data.
     */
    create: XOR<NoteCreateInput, NoteUncheckedCreateInput>
    /**
     * In case the Note was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NoteUpdateInput, NoteUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Note delete
   */
  export type NoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter which Note to delete.
     */
    where: NoteWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Note deleteMany
   */
  export type NoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notes to delete
     */
    where?: NoteWhereInput
    /**
     * Limit how many Notes to delete.
     */
    limit?: number
  }

  /**
   * Note.waypoint
   */
  export type Note$waypointArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityWaypoint
     */
    select?: ActivityWaypointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityWaypoint
     */
    omit?: ActivityWaypointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityWaypointInclude<ExtArgs> | null
    where?: ActivityWaypointWhereInput
  }

  /**
   * Note.activity
   */
  export type Note$activityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
  }

  /**
   * Note.contact
   */
  export type Note$contactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
  }

  /**
   * Note.opportunity
   */
  export type Note$opportunityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    where?: OpportunityWhereInput
  }

  /**
   * Note.events
   */
  export type Note$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTimelineEvent
     */
    select?: ContactTimelineEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTimelineEvent
     */
    omit?: ContactTimelineEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTimelineEventInclude<ExtArgs> | null
    where?: ContactTimelineEventWhereInput
    orderBy?: ContactTimelineEventOrderByWithRelationInput | ContactTimelineEventOrderByWithRelationInput[]
    cursor?: ContactTimelineEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactTimelineEventScalarFieldEnum | ContactTimelineEventScalarFieldEnum[]
  }

  /**
   * Note without action
   */
  export type NoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
  }


  /**
   * Model Attachment
   */

  export type AggregateAttachment = {
    _count: AttachmentCountAggregateOutputType | null
    _min: AttachmentMinAggregateOutputType | null
    _max: AttachmentMaxAggregateOutputType | null
  }

  export type AttachmentMinAggregateOutputType = {
    id: Uint8Array | null
    name: string | null
    location: string | null
    activityId: Uint8Array | null
    tenetId: Uint8Array | null
  }

  export type AttachmentMaxAggregateOutputType = {
    id: Uint8Array | null
    name: string | null
    location: string | null
    activityId: Uint8Array | null
    tenetId: Uint8Array | null
  }

  export type AttachmentCountAggregateOutputType = {
    id: number
    name: number
    location: number
    activityId: number
    tenetId: number
    _all: number
  }


  export type AttachmentMinAggregateInputType = {
    id?: true
    name?: true
    location?: true
    activityId?: true
    tenetId?: true
  }

  export type AttachmentMaxAggregateInputType = {
    id?: true
    name?: true
    location?: true
    activityId?: true
    tenetId?: true
  }

  export type AttachmentCountAggregateInputType = {
    id?: true
    name?: true
    location?: true
    activityId?: true
    tenetId?: true
    _all?: true
  }

  export type AttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attachment to aggregate.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Attachments
    **/
    _count?: true | AttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttachmentMaxAggregateInputType
  }

  export type GetAttachmentAggregateType<T extends AttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttachment[P]>
      : GetScalarType<T[P], AggregateAttachment[P]>
  }




  export type AttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttachmentWhereInput
    orderBy?: AttachmentOrderByWithAggregationInput | AttachmentOrderByWithAggregationInput[]
    by: AttachmentScalarFieldEnum[] | AttachmentScalarFieldEnum
    having?: AttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttachmentCountAggregateInputType | true
    _min?: AttachmentMinAggregateInputType
    _max?: AttachmentMaxAggregateInputType
  }

  export type AttachmentGroupByOutputType = {
    id: Uint8Array
    name: string
    location: string
    activityId: Uint8Array | null
    tenetId: Uint8Array
    _count: AttachmentCountAggregateOutputType | null
    _min: AttachmentMinAggregateOutputType | null
    _max: AttachmentMaxAggregateOutputType | null
  }

  type GetAttachmentGroupByPayload<T extends AttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], AttachmentGroupByOutputType[P]>
        }
      >
    >


  export type AttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    location?: boolean
    activityId?: boolean
    tenetId?: boolean
    activity?: boolean | Attachment$activityArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attachment"]>

  export type AttachmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    location?: boolean
    activityId?: boolean
    tenetId?: boolean
    activity?: boolean | Attachment$activityArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attachment"]>

  export type AttachmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    location?: boolean
    activityId?: boolean
    tenetId?: boolean
    activity?: boolean | Attachment$activityArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attachment"]>

  export type AttachmentSelectScalar = {
    id?: boolean
    name?: boolean
    location?: boolean
    activityId?: boolean
    tenetId?: boolean
  }

  export type AttachmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "location" | "activityId" | "tenetId", ExtArgs["result"]["attachment"]>
  export type AttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activity?: boolean | Attachment$activityArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }
  export type AttachmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activity?: boolean | Attachment$activityArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }
  export type AttachmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activity?: boolean | Attachment$activityArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }

  export type $AttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Attachment"
    objects: {
      activity: Prisma.$ActivityPayload<ExtArgs> | null
      tenet: Prisma.$TenetPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: Uint8Array
      name: string
      location: string
      activityId: Uint8Array | null
      tenetId: Uint8Array
    }, ExtArgs["result"]["attachment"]>
    composites: {}
  }

  type AttachmentGetPayload<S extends boolean | null | undefined | AttachmentDefaultArgs> = $Result.GetResult<Prisma.$AttachmentPayload, S>

  type AttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttachmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: AttachmentCountAggregateInputType | true
    }

  export interface AttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Attachment'], meta: { name: 'Attachment' } }
    /**
     * Find zero or one Attachment that matches the filter.
     * @param {AttachmentFindUniqueArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttachmentFindUniqueArgs>(args: SelectSubset<T, AttachmentFindUniqueArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Attachment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttachmentFindUniqueOrThrowArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Attachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentFindFirstArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttachmentFindFirstArgs>(args?: SelectSubset<T, AttachmentFindFirstArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Attachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentFindFirstOrThrowArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Attachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attachments
     * const attachments = await prisma.attachment.findMany()
     * 
     * // Get first 10 Attachments
     * const attachments = await prisma.attachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attachmentWithIdOnly = await prisma.attachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttachmentFindManyArgs>(args?: SelectSubset<T, AttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Attachment.
     * @param {AttachmentCreateArgs} args - Arguments to create a Attachment.
     * @example
     * // Create one Attachment
     * const Attachment = await prisma.attachment.create({
     *   data: {
     *     // ... data to create a Attachment
     *   }
     * })
     * 
     */
    create<T extends AttachmentCreateArgs>(args: SelectSubset<T, AttachmentCreateArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Attachments.
     * @param {AttachmentCreateManyArgs} args - Arguments to create many Attachments.
     * @example
     * // Create many Attachments
     * const attachment = await prisma.attachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttachmentCreateManyArgs>(args?: SelectSubset<T, AttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Attachments and returns the data saved in the database.
     * @param {AttachmentCreateManyAndReturnArgs} args - Arguments to create many Attachments.
     * @example
     * // Create many Attachments
     * const attachment = await prisma.attachment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Attachments and only return the `id`
     * const attachmentWithIdOnly = await prisma.attachment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttachmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AttachmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Attachment.
     * @param {AttachmentDeleteArgs} args - Arguments to delete one Attachment.
     * @example
     * // Delete one Attachment
     * const Attachment = await prisma.attachment.delete({
     *   where: {
     *     // ... filter to delete one Attachment
     *   }
     * })
     * 
     */
    delete<T extends AttachmentDeleteArgs>(args: SelectSubset<T, AttachmentDeleteArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Attachment.
     * @param {AttachmentUpdateArgs} args - Arguments to update one Attachment.
     * @example
     * // Update one Attachment
     * const attachment = await prisma.attachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttachmentUpdateArgs>(args: SelectSubset<T, AttachmentUpdateArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Attachments.
     * @param {AttachmentDeleteManyArgs} args - Arguments to filter Attachments to delete.
     * @example
     * // Delete a few Attachments
     * const { count } = await prisma.attachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttachmentDeleteManyArgs>(args?: SelectSubset<T, AttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attachments
     * const attachment = await prisma.attachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttachmentUpdateManyArgs>(args: SelectSubset<T, AttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attachments and returns the data updated in the database.
     * @param {AttachmentUpdateManyAndReturnArgs} args - Arguments to update many Attachments.
     * @example
     * // Update many Attachments
     * const attachment = await prisma.attachment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Attachments and only return the `id`
     * const attachmentWithIdOnly = await prisma.attachment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AttachmentUpdateManyAndReturnArgs>(args: SelectSubset<T, AttachmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Attachment.
     * @param {AttachmentUpsertArgs} args - Arguments to update or create a Attachment.
     * @example
     * // Update or create a Attachment
     * const attachment = await prisma.attachment.upsert({
     *   create: {
     *     // ... data to create a Attachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attachment we want to update
     *   }
     * })
     */
    upsert<T extends AttachmentUpsertArgs>(args: SelectSubset<T, AttachmentUpsertArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Attachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentCountArgs} args - Arguments to filter Attachments to count.
     * @example
     * // Count the number of Attachments
     * const count = await prisma.attachment.count({
     *   where: {
     *     // ... the filter for the Attachments we want to count
     *   }
     * })
    **/
    count<T extends AttachmentCountArgs>(
      args?: Subset<T, AttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttachmentAggregateArgs>(args: Subset<T, AttachmentAggregateArgs>): Prisma.PrismaPromise<GetAttachmentAggregateType<T>>

    /**
     * Group by Attachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttachmentGroupByArgs['orderBy'] }
        : { orderBy?: AttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Attachment model
   */
  readonly fields: AttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Attachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    activity<T extends Attachment$activityArgs<ExtArgs> = {}>(args?: Subset<T, Attachment$activityArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    tenet<T extends TenetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenetDefaultArgs<ExtArgs>>): Prisma__TenetClient<$Result.GetResult<Prisma.$TenetPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Attachment model
   */ 
  interface AttachmentFieldRefs {
    readonly id: FieldRef<"Attachment", 'Bytes'>
    readonly name: FieldRef<"Attachment", 'String'>
    readonly location: FieldRef<"Attachment", 'String'>
    readonly activityId: FieldRef<"Attachment", 'Bytes'>
    readonly tenetId: FieldRef<"Attachment", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * Attachment findUnique
   */
  export type AttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where: AttachmentWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Attachment findUniqueOrThrow
   */
  export type AttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where: AttachmentWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Attachment findFirst
   */
  export type AttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attachments.
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attachments.
     */
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Attachment findFirstOrThrow
   */
  export type AttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attachments.
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attachments.
     */
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Attachment findMany
   */
  export type AttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachments to fetch.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Attachments.
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Attachment create
   */
  export type AttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Attachment.
     */
    data: XOR<AttachmentCreateInput, AttachmentUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Attachment createMany
   */
  export type AttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Attachments.
     */
    data: AttachmentCreateManyInput | AttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Attachment createManyAndReturn
   */
  export type AttachmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * The data used to create many Attachments.
     */
    data: AttachmentCreateManyInput | AttachmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attachment update
   */
  export type AttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Attachment.
     */
    data: XOR<AttachmentUpdateInput, AttachmentUncheckedUpdateInput>
    /**
     * Choose, which Attachment to update.
     */
    where: AttachmentWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Attachment updateMany
   */
  export type AttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Attachments.
     */
    data: XOR<AttachmentUpdateManyMutationInput, AttachmentUncheckedUpdateManyInput>
    /**
     * Filter which Attachments to update
     */
    where?: AttachmentWhereInput
    /**
     * Limit how many Attachments to update.
     */
    limit?: number
  }

  /**
   * Attachment updateManyAndReturn
   */
  export type AttachmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * The data used to update Attachments.
     */
    data: XOR<AttachmentUpdateManyMutationInput, AttachmentUncheckedUpdateManyInput>
    /**
     * Filter which Attachments to update
     */
    where?: AttachmentWhereInput
    /**
     * Limit how many Attachments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attachment upsert
   */
  export type AttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Attachment to update in case it exists.
     */
    where: AttachmentWhereUniqueInput
    /**
     * In case the Attachment found by the `where` argument doesn't exist, create a new Attachment with this data.
     */
    create: XOR<AttachmentCreateInput, AttachmentUncheckedCreateInput>
    /**
     * In case the Attachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttachmentUpdateInput, AttachmentUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Attachment delete
   */
  export type AttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter which Attachment to delete.
     */
    where: AttachmentWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Attachment deleteMany
   */
  export type AttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attachments to delete
     */
    where?: AttachmentWhereInput
    /**
     * Limit how many Attachments to delete.
     */
    limit?: number
  }

  /**
   * Attachment.activity
   */
  export type Attachment$activityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
  }

  /**
   * Attachment without action
   */
  export type AttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attachment
     */
    omit?: AttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
  }


  /**
   * Model ActivityContactJoin
   */

  export type AggregateActivityContactJoin = {
    _count: ActivityContactJoinCountAggregateOutputType | null
    _min: ActivityContactJoinMinAggregateOutputType | null
    _max: ActivityContactJoinMaxAggregateOutputType | null
  }

  export type ActivityContactJoinMinAggregateOutputType = {
    activityId: Uint8Array | null
    contactId: Uint8Array | null
  }

  export type ActivityContactJoinMaxAggregateOutputType = {
    activityId: Uint8Array | null
    contactId: Uint8Array | null
  }

  export type ActivityContactJoinCountAggregateOutputType = {
    activityId: number
    contactId: number
    _all: number
  }


  export type ActivityContactJoinMinAggregateInputType = {
    activityId?: true
    contactId?: true
  }

  export type ActivityContactJoinMaxAggregateInputType = {
    activityId?: true
    contactId?: true
  }

  export type ActivityContactJoinCountAggregateInputType = {
    activityId?: true
    contactId?: true
    _all?: true
  }

  export type ActivityContactJoinAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityContactJoin to aggregate.
     */
    where?: ActivityContactJoinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityContactJoins to fetch.
     */
    orderBy?: ActivityContactJoinOrderByWithRelationInput | ActivityContactJoinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityContactJoinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityContactJoins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityContactJoins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActivityContactJoins
    **/
    _count?: true | ActivityContactJoinCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityContactJoinMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityContactJoinMaxAggregateInputType
  }

  export type GetActivityContactJoinAggregateType<T extends ActivityContactJoinAggregateArgs> = {
        [P in keyof T & keyof AggregateActivityContactJoin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivityContactJoin[P]>
      : GetScalarType<T[P], AggregateActivityContactJoin[P]>
  }




  export type ActivityContactJoinGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityContactJoinWhereInput
    orderBy?: ActivityContactJoinOrderByWithAggregationInput | ActivityContactJoinOrderByWithAggregationInput[]
    by: ActivityContactJoinScalarFieldEnum[] | ActivityContactJoinScalarFieldEnum
    having?: ActivityContactJoinScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityContactJoinCountAggregateInputType | true
    _min?: ActivityContactJoinMinAggregateInputType
    _max?: ActivityContactJoinMaxAggregateInputType
  }

  export type ActivityContactJoinGroupByOutputType = {
    activityId: Uint8Array
    contactId: Uint8Array
    _count: ActivityContactJoinCountAggregateOutputType | null
    _min: ActivityContactJoinMinAggregateOutputType | null
    _max: ActivityContactJoinMaxAggregateOutputType | null
  }

  type GetActivityContactJoinGroupByPayload<T extends ActivityContactJoinGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityContactJoinGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityContactJoinGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityContactJoinGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityContactJoinGroupByOutputType[P]>
        }
      >
    >


  export type ActivityContactJoinSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    activityId?: boolean
    contactId?: boolean
    activityRelation?: boolean | ActivityDefaultArgs<ExtArgs>
    contactRelation?: boolean | ContactDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityContactJoin"]>

  export type ActivityContactJoinSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    activityId?: boolean
    contactId?: boolean
    activityRelation?: boolean | ActivityDefaultArgs<ExtArgs>
    contactRelation?: boolean | ContactDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityContactJoin"]>

  export type ActivityContactJoinSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    activityId?: boolean
    contactId?: boolean
    activityRelation?: boolean | ActivityDefaultArgs<ExtArgs>
    contactRelation?: boolean | ContactDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityContactJoin"]>

  export type ActivityContactJoinSelectScalar = {
    activityId?: boolean
    contactId?: boolean
  }

  export type ActivityContactJoinOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"activityId" | "contactId", ExtArgs["result"]["activityContactJoin"]>
  export type ActivityContactJoinInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activityRelation?: boolean | ActivityDefaultArgs<ExtArgs>
    contactRelation?: boolean | ContactDefaultArgs<ExtArgs>
  }
  export type ActivityContactJoinIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activityRelation?: boolean | ActivityDefaultArgs<ExtArgs>
    contactRelation?: boolean | ContactDefaultArgs<ExtArgs>
  }
  export type ActivityContactJoinIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activityRelation?: boolean | ActivityDefaultArgs<ExtArgs>
    contactRelation?: boolean | ContactDefaultArgs<ExtArgs>
  }

  export type $ActivityContactJoinPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActivityContactJoin"
    objects: {
      activityRelation: Prisma.$ActivityPayload<ExtArgs>
      contactRelation: Prisma.$ContactPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      /**
       * @@wrapper-ignore
       */
      activityId: Uint8Array
      contactId: Uint8Array
    }, ExtArgs["result"]["activityContactJoin"]>
    composites: {}
  }

  type ActivityContactJoinGetPayload<S extends boolean | null | undefined | ActivityContactJoinDefaultArgs> = $Result.GetResult<Prisma.$ActivityContactJoinPayload, S>

  type ActivityContactJoinCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActivityContactJoinFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: ActivityContactJoinCountAggregateInputType | true
    }

  export interface ActivityContactJoinDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActivityContactJoin'], meta: { name: 'ActivityContactJoin' } }
    /**
     * Find zero or one ActivityContactJoin that matches the filter.
     * @param {ActivityContactJoinFindUniqueArgs} args - Arguments to find a ActivityContactJoin
     * @example
     * // Get one ActivityContactJoin
     * const activityContactJoin = await prisma.activityContactJoin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityContactJoinFindUniqueArgs>(args: SelectSubset<T, ActivityContactJoinFindUniqueArgs<ExtArgs>>): Prisma__ActivityContactJoinClient<$Result.GetResult<Prisma.$ActivityContactJoinPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ActivityContactJoin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActivityContactJoinFindUniqueOrThrowArgs} args - Arguments to find a ActivityContactJoin
     * @example
     * // Get one ActivityContactJoin
     * const activityContactJoin = await prisma.activityContactJoin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityContactJoinFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityContactJoinFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityContactJoinClient<$Result.GetResult<Prisma.$ActivityContactJoinPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ActivityContactJoin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityContactJoinFindFirstArgs} args - Arguments to find a ActivityContactJoin
     * @example
     * // Get one ActivityContactJoin
     * const activityContactJoin = await prisma.activityContactJoin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityContactJoinFindFirstArgs>(args?: SelectSubset<T, ActivityContactJoinFindFirstArgs<ExtArgs>>): Prisma__ActivityContactJoinClient<$Result.GetResult<Prisma.$ActivityContactJoinPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ActivityContactJoin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityContactJoinFindFirstOrThrowArgs} args - Arguments to find a ActivityContactJoin
     * @example
     * // Get one ActivityContactJoin
     * const activityContactJoin = await prisma.activityContactJoin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityContactJoinFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityContactJoinFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityContactJoinClient<$Result.GetResult<Prisma.$ActivityContactJoinPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ActivityContactJoins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityContactJoinFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActivityContactJoins
     * const activityContactJoins = await prisma.activityContactJoin.findMany()
     * 
     * // Get first 10 ActivityContactJoins
     * const activityContactJoins = await prisma.activityContactJoin.findMany({ take: 10 })
     * 
     * // Only select the `activityId`
     * const activityContactJoinWithActivityIdOnly = await prisma.activityContactJoin.findMany({ select: { activityId: true } })
     * 
     */
    findMany<T extends ActivityContactJoinFindManyArgs>(args?: SelectSubset<T, ActivityContactJoinFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityContactJoinPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ActivityContactJoin.
     * @param {ActivityContactJoinCreateArgs} args - Arguments to create a ActivityContactJoin.
     * @example
     * // Create one ActivityContactJoin
     * const ActivityContactJoin = await prisma.activityContactJoin.create({
     *   data: {
     *     // ... data to create a ActivityContactJoin
     *   }
     * })
     * 
     */
    create<T extends ActivityContactJoinCreateArgs>(args: SelectSubset<T, ActivityContactJoinCreateArgs<ExtArgs>>): Prisma__ActivityContactJoinClient<$Result.GetResult<Prisma.$ActivityContactJoinPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ActivityContactJoins.
     * @param {ActivityContactJoinCreateManyArgs} args - Arguments to create many ActivityContactJoins.
     * @example
     * // Create many ActivityContactJoins
     * const activityContactJoin = await prisma.activityContactJoin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityContactJoinCreateManyArgs>(args?: SelectSubset<T, ActivityContactJoinCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActivityContactJoins and returns the data saved in the database.
     * @param {ActivityContactJoinCreateManyAndReturnArgs} args - Arguments to create many ActivityContactJoins.
     * @example
     * // Create many ActivityContactJoins
     * const activityContactJoin = await prisma.activityContactJoin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActivityContactJoins and only return the `activityId`
     * const activityContactJoinWithActivityIdOnly = await prisma.activityContactJoin.createManyAndReturn({
     *   select: { activityId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityContactJoinCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityContactJoinCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityContactJoinPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a ActivityContactJoin.
     * @param {ActivityContactJoinDeleteArgs} args - Arguments to delete one ActivityContactJoin.
     * @example
     * // Delete one ActivityContactJoin
     * const ActivityContactJoin = await prisma.activityContactJoin.delete({
     *   where: {
     *     // ... filter to delete one ActivityContactJoin
     *   }
     * })
     * 
     */
    delete<T extends ActivityContactJoinDeleteArgs>(args: SelectSubset<T, ActivityContactJoinDeleteArgs<ExtArgs>>): Prisma__ActivityContactJoinClient<$Result.GetResult<Prisma.$ActivityContactJoinPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ActivityContactJoin.
     * @param {ActivityContactJoinUpdateArgs} args - Arguments to update one ActivityContactJoin.
     * @example
     * // Update one ActivityContactJoin
     * const activityContactJoin = await prisma.activityContactJoin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityContactJoinUpdateArgs>(args: SelectSubset<T, ActivityContactJoinUpdateArgs<ExtArgs>>): Prisma__ActivityContactJoinClient<$Result.GetResult<Prisma.$ActivityContactJoinPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ActivityContactJoins.
     * @param {ActivityContactJoinDeleteManyArgs} args - Arguments to filter ActivityContactJoins to delete.
     * @example
     * // Delete a few ActivityContactJoins
     * const { count } = await prisma.activityContactJoin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityContactJoinDeleteManyArgs>(args?: SelectSubset<T, ActivityContactJoinDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityContactJoins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityContactJoinUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActivityContactJoins
     * const activityContactJoin = await prisma.activityContactJoin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityContactJoinUpdateManyArgs>(args: SelectSubset<T, ActivityContactJoinUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityContactJoins and returns the data updated in the database.
     * @param {ActivityContactJoinUpdateManyAndReturnArgs} args - Arguments to update many ActivityContactJoins.
     * @example
     * // Update many ActivityContactJoins
     * const activityContactJoin = await prisma.activityContactJoin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ActivityContactJoins and only return the `activityId`
     * const activityContactJoinWithActivityIdOnly = await prisma.activityContactJoin.updateManyAndReturn({
     *   select: { activityId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActivityContactJoinUpdateManyAndReturnArgs>(args: SelectSubset<T, ActivityContactJoinUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityContactJoinPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one ActivityContactJoin.
     * @param {ActivityContactJoinUpsertArgs} args - Arguments to update or create a ActivityContactJoin.
     * @example
     * // Update or create a ActivityContactJoin
     * const activityContactJoin = await prisma.activityContactJoin.upsert({
     *   create: {
     *     // ... data to create a ActivityContactJoin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActivityContactJoin we want to update
     *   }
     * })
     */
    upsert<T extends ActivityContactJoinUpsertArgs>(args: SelectSubset<T, ActivityContactJoinUpsertArgs<ExtArgs>>): Prisma__ActivityContactJoinClient<$Result.GetResult<Prisma.$ActivityContactJoinPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ActivityContactJoins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityContactJoinCountArgs} args - Arguments to filter ActivityContactJoins to count.
     * @example
     * // Count the number of ActivityContactJoins
     * const count = await prisma.activityContactJoin.count({
     *   where: {
     *     // ... the filter for the ActivityContactJoins we want to count
     *   }
     * })
    **/
    count<T extends ActivityContactJoinCountArgs>(
      args?: Subset<T, ActivityContactJoinCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityContactJoinCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActivityContactJoin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityContactJoinAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityContactJoinAggregateArgs>(args: Subset<T, ActivityContactJoinAggregateArgs>): Prisma.PrismaPromise<GetActivityContactJoinAggregateType<T>>

    /**
     * Group by ActivityContactJoin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityContactJoinGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityContactJoinGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityContactJoinGroupByArgs['orderBy'] }
        : { orderBy?: ActivityContactJoinGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityContactJoinGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityContactJoinGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActivityContactJoin model
   */
  readonly fields: ActivityContactJoinFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActivityContactJoin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityContactJoinClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    activityRelation<T extends ActivityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ActivityDefaultArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    contactRelation<T extends ContactDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContactDefaultArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActivityContactJoin model
   */ 
  interface ActivityContactJoinFieldRefs {
    readonly activityId: FieldRef<"ActivityContactJoin", 'Bytes'>
    readonly contactId: FieldRef<"ActivityContactJoin", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * ActivityContactJoin findUnique
   */
  export type ActivityContactJoinFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityContactJoin
     */
    select?: ActivityContactJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityContactJoin
     */
    omit?: ActivityContactJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityContactJoinInclude<ExtArgs> | null
    /**
     * Filter, which ActivityContactJoin to fetch.
     */
    where: ActivityContactJoinWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityContactJoin findUniqueOrThrow
   */
  export type ActivityContactJoinFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityContactJoin
     */
    select?: ActivityContactJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityContactJoin
     */
    omit?: ActivityContactJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityContactJoinInclude<ExtArgs> | null
    /**
     * Filter, which ActivityContactJoin to fetch.
     */
    where: ActivityContactJoinWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityContactJoin findFirst
   */
  export type ActivityContactJoinFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityContactJoin
     */
    select?: ActivityContactJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityContactJoin
     */
    omit?: ActivityContactJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityContactJoinInclude<ExtArgs> | null
    /**
     * Filter, which ActivityContactJoin to fetch.
     */
    where?: ActivityContactJoinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityContactJoins to fetch.
     */
    orderBy?: ActivityContactJoinOrderByWithRelationInput | ActivityContactJoinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityContactJoins.
     */
    cursor?: ActivityContactJoinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityContactJoins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityContactJoins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityContactJoins.
     */
    distinct?: ActivityContactJoinScalarFieldEnum | ActivityContactJoinScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityContactJoin findFirstOrThrow
   */
  export type ActivityContactJoinFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityContactJoin
     */
    select?: ActivityContactJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityContactJoin
     */
    omit?: ActivityContactJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityContactJoinInclude<ExtArgs> | null
    /**
     * Filter, which ActivityContactJoin to fetch.
     */
    where?: ActivityContactJoinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityContactJoins to fetch.
     */
    orderBy?: ActivityContactJoinOrderByWithRelationInput | ActivityContactJoinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityContactJoins.
     */
    cursor?: ActivityContactJoinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityContactJoins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityContactJoins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityContactJoins.
     */
    distinct?: ActivityContactJoinScalarFieldEnum | ActivityContactJoinScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityContactJoin findMany
   */
  export type ActivityContactJoinFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityContactJoin
     */
    select?: ActivityContactJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityContactJoin
     */
    omit?: ActivityContactJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityContactJoinInclude<ExtArgs> | null
    /**
     * Filter, which ActivityContactJoins to fetch.
     */
    where?: ActivityContactJoinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityContactJoins to fetch.
     */
    orderBy?: ActivityContactJoinOrderByWithRelationInput | ActivityContactJoinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActivityContactJoins.
     */
    cursor?: ActivityContactJoinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityContactJoins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityContactJoins.
     */
    skip?: number
    distinct?: ActivityContactJoinScalarFieldEnum | ActivityContactJoinScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityContactJoin create
   */
  export type ActivityContactJoinCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityContactJoin
     */
    select?: ActivityContactJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityContactJoin
     */
    omit?: ActivityContactJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityContactJoinInclude<ExtArgs> | null
    /**
     * The data needed to create a ActivityContactJoin.
     */
    data: XOR<ActivityContactJoinCreateInput, ActivityContactJoinUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityContactJoin createMany
   */
  export type ActivityContactJoinCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActivityContactJoins.
     */
    data: ActivityContactJoinCreateManyInput | ActivityContactJoinCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActivityContactJoin createManyAndReturn
   */
  export type ActivityContactJoinCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityContactJoin
     */
    select?: ActivityContactJoinSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityContactJoin
     */
    omit?: ActivityContactJoinOmit<ExtArgs> | null
    /**
     * The data used to create many ActivityContactJoins.
     */
    data: ActivityContactJoinCreateManyInput | ActivityContactJoinCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityContactJoinIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityContactJoin update
   */
  export type ActivityContactJoinUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityContactJoin
     */
    select?: ActivityContactJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityContactJoin
     */
    omit?: ActivityContactJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityContactJoinInclude<ExtArgs> | null
    /**
     * The data needed to update a ActivityContactJoin.
     */
    data: XOR<ActivityContactJoinUpdateInput, ActivityContactJoinUncheckedUpdateInput>
    /**
     * Choose, which ActivityContactJoin to update.
     */
    where: ActivityContactJoinWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityContactJoin updateMany
   */
  export type ActivityContactJoinUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActivityContactJoins.
     */
    data: XOR<ActivityContactJoinUpdateManyMutationInput, ActivityContactJoinUncheckedUpdateManyInput>
    /**
     * Filter which ActivityContactJoins to update
     */
    where?: ActivityContactJoinWhereInput
    /**
     * Limit how many ActivityContactJoins to update.
     */
    limit?: number
  }

  /**
   * ActivityContactJoin updateManyAndReturn
   */
  export type ActivityContactJoinUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityContactJoin
     */
    select?: ActivityContactJoinSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityContactJoin
     */
    omit?: ActivityContactJoinOmit<ExtArgs> | null
    /**
     * The data used to update ActivityContactJoins.
     */
    data: XOR<ActivityContactJoinUpdateManyMutationInput, ActivityContactJoinUncheckedUpdateManyInput>
    /**
     * Filter which ActivityContactJoins to update
     */
    where?: ActivityContactJoinWhereInput
    /**
     * Limit how many ActivityContactJoins to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityContactJoinIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityContactJoin upsert
   */
  export type ActivityContactJoinUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityContactJoin
     */
    select?: ActivityContactJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityContactJoin
     */
    omit?: ActivityContactJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityContactJoinInclude<ExtArgs> | null
    /**
     * The filter to search for the ActivityContactJoin to update in case it exists.
     */
    where: ActivityContactJoinWhereUniqueInput
    /**
     * In case the ActivityContactJoin found by the `where` argument doesn't exist, create a new ActivityContactJoin with this data.
     */
    create: XOR<ActivityContactJoinCreateInput, ActivityContactJoinUncheckedCreateInput>
    /**
     * In case the ActivityContactJoin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityContactJoinUpdateInput, ActivityContactJoinUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityContactJoin delete
   */
  export type ActivityContactJoinDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityContactJoin
     */
    select?: ActivityContactJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityContactJoin
     */
    omit?: ActivityContactJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityContactJoinInclude<ExtArgs> | null
    /**
     * Filter which ActivityContactJoin to delete.
     */
    where: ActivityContactJoinWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityContactJoin deleteMany
   */
  export type ActivityContactJoinDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityContactJoins to delete
     */
    where?: ActivityContactJoinWhereInput
    /**
     * Limit how many ActivityContactJoins to delete.
     */
    limit?: number
  }

  /**
   * ActivityContactJoin without action
   */
  export type ActivityContactJoinDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityContactJoin
     */
    select?: ActivityContactJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityContactJoin
     */
    omit?: ActivityContactJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityContactJoinInclude<ExtArgs> | null
  }


  /**
   * Model ActivityUserJoin
   */

  export type AggregateActivityUserJoin = {
    _count: ActivityUserJoinCountAggregateOutputType | null
    _min: ActivityUserJoinMinAggregateOutputType | null
    _max: ActivityUserJoinMaxAggregateOutputType | null
  }

  export type ActivityUserJoinMinAggregateOutputType = {
    activityId: Uint8Array | null
    userId: Uint8Array | null
  }

  export type ActivityUserJoinMaxAggregateOutputType = {
    activityId: Uint8Array | null
    userId: Uint8Array | null
  }

  export type ActivityUserJoinCountAggregateOutputType = {
    activityId: number
    userId: number
    _all: number
  }


  export type ActivityUserJoinMinAggregateInputType = {
    activityId?: true
    userId?: true
  }

  export type ActivityUserJoinMaxAggregateInputType = {
    activityId?: true
    userId?: true
  }

  export type ActivityUserJoinCountAggregateInputType = {
    activityId?: true
    userId?: true
    _all?: true
  }

  export type ActivityUserJoinAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityUserJoin to aggregate.
     */
    where?: ActivityUserJoinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityUserJoins to fetch.
     */
    orderBy?: ActivityUserJoinOrderByWithRelationInput | ActivityUserJoinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityUserJoinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityUserJoins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityUserJoins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActivityUserJoins
    **/
    _count?: true | ActivityUserJoinCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityUserJoinMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityUserJoinMaxAggregateInputType
  }

  export type GetActivityUserJoinAggregateType<T extends ActivityUserJoinAggregateArgs> = {
        [P in keyof T & keyof AggregateActivityUserJoin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivityUserJoin[P]>
      : GetScalarType<T[P], AggregateActivityUserJoin[P]>
  }




  export type ActivityUserJoinGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityUserJoinWhereInput
    orderBy?: ActivityUserJoinOrderByWithAggregationInput | ActivityUserJoinOrderByWithAggregationInput[]
    by: ActivityUserJoinScalarFieldEnum[] | ActivityUserJoinScalarFieldEnum
    having?: ActivityUserJoinScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityUserJoinCountAggregateInputType | true
    _min?: ActivityUserJoinMinAggregateInputType
    _max?: ActivityUserJoinMaxAggregateInputType
  }

  export type ActivityUserJoinGroupByOutputType = {
    activityId: Uint8Array
    userId: Uint8Array
    _count: ActivityUserJoinCountAggregateOutputType | null
    _min: ActivityUserJoinMinAggregateOutputType | null
    _max: ActivityUserJoinMaxAggregateOutputType | null
  }

  type GetActivityUserJoinGroupByPayload<T extends ActivityUserJoinGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityUserJoinGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityUserJoinGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityUserJoinGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityUserJoinGroupByOutputType[P]>
        }
      >
    >


  export type ActivityUserJoinSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    activityId?: boolean
    userId?: boolean
    activityRelation?: boolean | ActivityDefaultArgs<ExtArgs>
    userRelation?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityUserJoin"]>

  export type ActivityUserJoinSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    activityId?: boolean
    userId?: boolean
    activityRelation?: boolean | ActivityDefaultArgs<ExtArgs>
    userRelation?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityUserJoin"]>

  export type ActivityUserJoinSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    activityId?: boolean
    userId?: boolean
    activityRelation?: boolean | ActivityDefaultArgs<ExtArgs>
    userRelation?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityUserJoin"]>

  export type ActivityUserJoinSelectScalar = {
    activityId?: boolean
    userId?: boolean
  }

  export type ActivityUserJoinOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"activityId" | "userId", ExtArgs["result"]["activityUserJoin"]>
  export type ActivityUserJoinInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activityRelation?: boolean | ActivityDefaultArgs<ExtArgs>
    userRelation?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ActivityUserJoinIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activityRelation?: boolean | ActivityDefaultArgs<ExtArgs>
    userRelation?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ActivityUserJoinIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activityRelation?: boolean | ActivityDefaultArgs<ExtArgs>
    userRelation?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ActivityUserJoinPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActivityUserJoin"
    objects: {
      activityRelation: Prisma.$ActivityPayload<ExtArgs>
      userRelation: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      /**
       * @@wrapper-ignore
       */
      activityId: Uint8Array
      userId: Uint8Array
    }, ExtArgs["result"]["activityUserJoin"]>
    composites: {}
  }

  type ActivityUserJoinGetPayload<S extends boolean | null | undefined | ActivityUserJoinDefaultArgs> = $Result.GetResult<Prisma.$ActivityUserJoinPayload, S>

  type ActivityUserJoinCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActivityUserJoinFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: ActivityUserJoinCountAggregateInputType | true
    }

  export interface ActivityUserJoinDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActivityUserJoin'], meta: { name: 'ActivityUserJoin' } }
    /**
     * Find zero or one ActivityUserJoin that matches the filter.
     * @param {ActivityUserJoinFindUniqueArgs} args - Arguments to find a ActivityUserJoin
     * @example
     * // Get one ActivityUserJoin
     * const activityUserJoin = await prisma.activityUserJoin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityUserJoinFindUniqueArgs>(args: SelectSubset<T, ActivityUserJoinFindUniqueArgs<ExtArgs>>): Prisma__ActivityUserJoinClient<$Result.GetResult<Prisma.$ActivityUserJoinPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ActivityUserJoin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActivityUserJoinFindUniqueOrThrowArgs} args - Arguments to find a ActivityUserJoin
     * @example
     * // Get one ActivityUserJoin
     * const activityUserJoin = await prisma.activityUserJoin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityUserJoinFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityUserJoinFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityUserJoinClient<$Result.GetResult<Prisma.$ActivityUserJoinPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ActivityUserJoin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityUserJoinFindFirstArgs} args - Arguments to find a ActivityUserJoin
     * @example
     * // Get one ActivityUserJoin
     * const activityUserJoin = await prisma.activityUserJoin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityUserJoinFindFirstArgs>(args?: SelectSubset<T, ActivityUserJoinFindFirstArgs<ExtArgs>>): Prisma__ActivityUserJoinClient<$Result.GetResult<Prisma.$ActivityUserJoinPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ActivityUserJoin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityUserJoinFindFirstOrThrowArgs} args - Arguments to find a ActivityUserJoin
     * @example
     * // Get one ActivityUserJoin
     * const activityUserJoin = await prisma.activityUserJoin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityUserJoinFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityUserJoinFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityUserJoinClient<$Result.GetResult<Prisma.$ActivityUserJoinPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ActivityUserJoins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityUserJoinFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActivityUserJoins
     * const activityUserJoins = await prisma.activityUserJoin.findMany()
     * 
     * // Get first 10 ActivityUserJoins
     * const activityUserJoins = await prisma.activityUserJoin.findMany({ take: 10 })
     * 
     * // Only select the `activityId`
     * const activityUserJoinWithActivityIdOnly = await prisma.activityUserJoin.findMany({ select: { activityId: true } })
     * 
     */
    findMany<T extends ActivityUserJoinFindManyArgs>(args?: SelectSubset<T, ActivityUserJoinFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityUserJoinPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ActivityUserJoin.
     * @param {ActivityUserJoinCreateArgs} args - Arguments to create a ActivityUserJoin.
     * @example
     * // Create one ActivityUserJoin
     * const ActivityUserJoin = await prisma.activityUserJoin.create({
     *   data: {
     *     // ... data to create a ActivityUserJoin
     *   }
     * })
     * 
     */
    create<T extends ActivityUserJoinCreateArgs>(args: SelectSubset<T, ActivityUserJoinCreateArgs<ExtArgs>>): Prisma__ActivityUserJoinClient<$Result.GetResult<Prisma.$ActivityUserJoinPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ActivityUserJoins.
     * @param {ActivityUserJoinCreateManyArgs} args - Arguments to create many ActivityUserJoins.
     * @example
     * // Create many ActivityUserJoins
     * const activityUserJoin = await prisma.activityUserJoin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityUserJoinCreateManyArgs>(args?: SelectSubset<T, ActivityUserJoinCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActivityUserJoins and returns the data saved in the database.
     * @param {ActivityUserJoinCreateManyAndReturnArgs} args - Arguments to create many ActivityUserJoins.
     * @example
     * // Create many ActivityUserJoins
     * const activityUserJoin = await prisma.activityUserJoin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActivityUserJoins and only return the `activityId`
     * const activityUserJoinWithActivityIdOnly = await prisma.activityUserJoin.createManyAndReturn({
     *   select: { activityId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityUserJoinCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityUserJoinCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityUserJoinPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a ActivityUserJoin.
     * @param {ActivityUserJoinDeleteArgs} args - Arguments to delete one ActivityUserJoin.
     * @example
     * // Delete one ActivityUserJoin
     * const ActivityUserJoin = await prisma.activityUserJoin.delete({
     *   where: {
     *     // ... filter to delete one ActivityUserJoin
     *   }
     * })
     * 
     */
    delete<T extends ActivityUserJoinDeleteArgs>(args: SelectSubset<T, ActivityUserJoinDeleteArgs<ExtArgs>>): Prisma__ActivityUserJoinClient<$Result.GetResult<Prisma.$ActivityUserJoinPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ActivityUserJoin.
     * @param {ActivityUserJoinUpdateArgs} args - Arguments to update one ActivityUserJoin.
     * @example
     * // Update one ActivityUserJoin
     * const activityUserJoin = await prisma.activityUserJoin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityUserJoinUpdateArgs>(args: SelectSubset<T, ActivityUserJoinUpdateArgs<ExtArgs>>): Prisma__ActivityUserJoinClient<$Result.GetResult<Prisma.$ActivityUserJoinPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ActivityUserJoins.
     * @param {ActivityUserJoinDeleteManyArgs} args - Arguments to filter ActivityUserJoins to delete.
     * @example
     * // Delete a few ActivityUserJoins
     * const { count } = await prisma.activityUserJoin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityUserJoinDeleteManyArgs>(args?: SelectSubset<T, ActivityUserJoinDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityUserJoins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityUserJoinUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActivityUserJoins
     * const activityUserJoin = await prisma.activityUserJoin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityUserJoinUpdateManyArgs>(args: SelectSubset<T, ActivityUserJoinUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityUserJoins and returns the data updated in the database.
     * @param {ActivityUserJoinUpdateManyAndReturnArgs} args - Arguments to update many ActivityUserJoins.
     * @example
     * // Update many ActivityUserJoins
     * const activityUserJoin = await prisma.activityUserJoin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ActivityUserJoins and only return the `activityId`
     * const activityUserJoinWithActivityIdOnly = await prisma.activityUserJoin.updateManyAndReturn({
     *   select: { activityId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActivityUserJoinUpdateManyAndReturnArgs>(args: SelectSubset<T, ActivityUserJoinUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityUserJoinPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one ActivityUserJoin.
     * @param {ActivityUserJoinUpsertArgs} args - Arguments to update or create a ActivityUserJoin.
     * @example
     * // Update or create a ActivityUserJoin
     * const activityUserJoin = await prisma.activityUserJoin.upsert({
     *   create: {
     *     // ... data to create a ActivityUserJoin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActivityUserJoin we want to update
     *   }
     * })
     */
    upsert<T extends ActivityUserJoinUpsertArgs>(args: SelectSubset<T, ActivityUserJoinUpsertArgs<ExtArgs>>): Prisma__ActivityUserJoinClient<$Result.GetResult<Prisma.$ActivityUserJoinPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ActivityUserJoins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityUserJoinCountArgs} args - Arguments to filter ActivityUserJoins to count.
     * @example
     * // Count the number of ActivityUserJoins
     * const count = await prisma.activityUserJoin.count({
     *   where: {
     *     // ... the filter for the ActivityUserJoins we want to count
     *   }
     * })
    **/
    count<T extends ActivityUserJoinCountArgs>(
      args?: Subset<T, ActivityUserJoinCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityUserJoinCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActivityUserJoin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityUserJoinAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityUserJoinAggregateArgs>(args: Subset<T, ActivityUserJoinAggregateArgs>): Prisma.PrismaPromise<GetActivityUserJoinAggregateType<T>>

    /**
     * Group by ActivityUserJoin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityUserJoinGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityUserJoinGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityUserJoinGroupByArgs['orderBy'] }
        : { orderBy?: ActivityUserJoinGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityUserJoinGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityUserJoinGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActivityUserJoin model
   */
  readonly fields: ActivityUserJoinFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActivityUserJoin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityUserJoinClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    activityRelation<T extends ActivityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ActivityDefaultArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    userRelation<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActivityUserJoin model
   */ 
  interface ActivityUserJoinFieldRefs {
    readonly activityId: FieldRef<"ActivityUserJoin", 'Bytes'>
    readonly userId: FieldRef<"ActivityUserJoin", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * ActivityUserJoin findUnique
   */
  export type ActivityUserJoinFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityUserJoin
     */
    select?: ActivityUserJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityUserJoin
     */
    omit?: ActivityUserJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityUserJoinInclude<ExtArgs> | null
    /**
     * Filter, which ActivityUserJoin to fetch.
     */
    where: ActivityUserJoinWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityUserJoin findUniqueOrThrow
   */
  export type ActivityUserJoinFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityUserJoin
     */
    select?: ActivityUserJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityUserJoin
     */
    omit?: ActivityUserJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityUserJoinInclude<ExtArgs> | null
    /**
     * Filter, which ActivityUserJoin to fetch.
     */
    where: ActivityUserJoinWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityUserJoin findFirst
   */
  export type ActivityUserJoinFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityUserJoin
     */
    select?: ActivityUserJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityUserJoin
     */
    omit?: ActivityUserJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityUserJoinInclude<ExtArgs> | null
    /**
     * Filter, which ActivityUserJoin to fetch.
     */
    where?: ActivityUserJoinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityUserJoins to fetch.
     */
    orderBy?: ActivityUserJoinOrderByWithRelationInput | ActivityUserJoinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityUserJoins.
     */
    cursor?: ActivityUserJoinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityUserJoins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityUserJoins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityUserJoins.
     */
    distinct?: ActivityUserJoinScalarFieldEnum | ActivityUserJoinScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityUserJoin findFirstOrThrow
   */
  export type ActivityUserJoinFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityUserJoin
     */
    select?: ActivityUserJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityUserJoin
     */
    omit?: ActivityUserJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityUserJoinInclude<ExtArgs> | null
    /**
     * Filter, which ActivityUserJoin to fetch.
     */
    where?: ActivityUserJoinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityUserJoins to fetch.
     */
    orderBy?: ActivityUserJoinOrderByWithRelationInput | ActivityUserJoinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityUserJoins.
     */
    cursor?: ActivityUserJoinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityUserJoins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityUserJoins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityUserJoins.
     */
    distinct?: ActivityUserJoinScalarFieldEnum | ActivityUserJoinScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityUserJoin findMany
   */
  export type ActivityUserJoinFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityUserJoin
     */
    select?: ActivityUserJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityUserJoin
     */
    omit?: ActivityUserJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityUserJoinInclude<ExtArgs> | null
    /**
     * Filter, which ActivityUserJoins to fetch.
     */
    where?: ActivityUserJoinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityUserJoins to fetch.
     */
    orderBy?: ActivityUserJoinOrderByWithRelationInput | ActivityUserJoinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActivityUserJoins.
     */
    cursor?: ActivityUserJoinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityUserJoins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityUserJoins.
     */
    skip?: number
    distinct?: ActivityUserJoinScalarFieldEnum | ActivityUserJoinScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityUserJoin create
   */
  export type ActivityUserJoinCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityUserJoin
     */
    select?: ActivityUserJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityUserJoin
     */
    omit?: ActivityUserJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityUserJoinInclude<ExtArgs> | null
    /**
     * The data needed to create a ActivityUserJoin.
     */
    data: XOR<ActivityUserJoinCreateInput, ActivityUserJoinUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityUserJoin createMany
   */
  export type ActivityUserJoinCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActivityUserJoins.
     */
    data: ActivityUserJoinCreateManyInput | ActivityUserJoinCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActivityUserJoin createManyAndReturn
   */
  export type ActivityUserJoinCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityUserJoin
     */
    select?: ActivityUserJoinSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityUserJoin
     */
    omit?: ActivityUserJoinOmit<ExtArgs> | null
    /**
     * The data used to create many ActivityUserJoins.
     */
    data: ActivityUserJoinCreateManyInput | ActivityUserJoinCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityUserJoinIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityUserJoin update
   */
  export type ActivityUserJoinUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityUserJoin
     */
    select?: ActivityUserJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityUserJoin
     */
    omit?: ActivityUserJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityUserJoinInclude<ExtArgs> | null
    /**
     * The data needed to update a ActivityUserJoin.
     */
    data: XOR<ActivityUserJoinUpdateInput, ActivityUserJoinUncheckedUpdateInput>
    /**
     * Choose, which ActivityUserJoin to update.
     */
    where: ActivityUserJoinWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityUserJoin updateMany
   */
  export type ActivityUserJoinUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActivityUserJoins.
     */
    data: XOR<ActivityUserJoinUpdateManyMutationInput, ActivityUserJoinUncheckedUpdateManyInput>
    /**
     * Filter which ActivityUserJoins to update
     */
    where?: ActivityUserJoinWhereInput
    /**
     * Limit how many ActivityUserJoins to update.
     */
    limit?: number
  }

  /**
   * ActivityUserJoin updateManyAndReturn
   */
  export type ActivityUserJoinUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityUserJoin
     */
    select?: ActivityUserJoinSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityUserJoin
     */
    omit?: ActivityUserJoinOmit<ExtArgs> | null
    /**
     * The data used to update ActivityUserJoins.
     */
    data: XOR<ActivityUserJoinUpdateManyMutationInput, ActivityUserJoinUncheckedUpdateManyInput>
    /**
     * Filter which ActivityUserJoins to update
     */
    where?: ActivityUserJoinWhereInput
    /**
     * Limit how many ActivityUserJoins to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityUserJoinIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityUserJoin upsert
   */
  export type ActivityUserJoinUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityUserJoin
     */
    select?: ActivityUserJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityUserJoin
     */
    omit?: ActivityUserJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityUserJoinInclude<ExtArgs> | null
    /**
     * The filter to search for the ActivityUserJoin to update in case it exists.
     */
    where: ActivityUserJoinWhereUniqueInput
    /**
     * In case the ActivityUserJoin found by the `where` argument doesn't exist, create a new ActivityUserJoin with this data.
     */
    create: XOR<ActivityUserJoinCreateInput, ActivityUserJoinUncheckedCreateInput>
    /**
     * In case the ActivityUserJoin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityUserJoinUpdateInput, ActivityUserJoinUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityUserJoin delete
   */
  export type ActivityUserJoinDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityUserJoin
     */
    select?: ActivityUserJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityUserJoin
     */
    omit?: ActivityUserJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityUserJoinInclude<ExtArgs> | null
    /**
     * Filter which ActivityUserJoin to delete.
     */
    where: ActivityUserJoinWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ActivityUserJoin deleteMany
   */
  export type ActivityUserJoinDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityUserJoins to delete
     */
    where?: ActivityUserJoinWhereInput
    /**
     * Limit how many ActivityUserJoins to delete.
     */
    limit?: number
  }

  /**
   * ActivityUserJoin without action
   */
  export type ActivityUserJoinDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityUserJoin
     */
    select?: ActivityUserJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityUserJoin
     */
    omit?: ActivityUserJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityUserJoinInclude<ExtArgs> | null
  }


  /**
   * Model ContactEmail
   */

  export type AggregateContactEmail = {
    _count: ContactEmailCountAggregateOutputType | null
    _min: ContactEmailMinAggregateOutputType | null
    _max: ContactEmailMaxAggregateOutputType | null
  }

  export type ContactEmailMinAggregateOutputType = {
    id: Uint8Array | null
    email: string | null
    isPrimary: boolean | null
    contactId: Uint8Array | null
    tenetId: Uint8Array | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactEmailMaxAggregateOutputType = {
    id: Uint8Array | null
    email: string | null
    isPrimary: boolean | null
    contactId: Uint8Array | null
    tenetId: Uint8Array | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactEmailCountAggregateOutputType = {
    id: number
    email: number
    isPrimary: number
    contactId: number
    tenetId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContactEmailMinAggregateInputType = {
    id?: true
    email?: true
    isPrimary?: true
    contactId?: true
    tenetId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactEmailMaxAggregateInputType = {
    id?: true
    email?: true
    isPrimary?: true
    contactId?: true
    tenetId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactEmailCountAggregateInputType = {
    id?: true
    email?: true
    isPrimary?: true
    contactId?: true
    tenetId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContactEmailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactEmail to aggregate.
     */
    where?: ContactEmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactEmails to fetch.
     */
    orderBy?: ContactEmailOrderByWithRelationInput | ContactEmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactEmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactEmails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactEmails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContactEmails
    **/
    _count?: true | ContactEmailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactEmailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactEmailMaxAggregateInputType
  }

  export type GetContactEmailAggregateType<T extends ContactEmailAggregateArgs> = {
        [P in keyof T & keyof AggregateContactEmail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContactEmail[P]>
      : GetScalarType<T[P], AggregateContactEmail[P]>
  }




  export type ContactEmailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactEmailWhereInput
    orderBy?: ContactEmailOrderByWithAggregationInput | ContactEmailOrderByWithAggregationInput[]
    by: ContactEmailScalarFieldEnum[] | ContactEmailScalarFieldEnum
    having?: ContactEmailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactEmailCountAggregateInputType | true
    _min?: ContactEmailMinAggregateInputType
    _max?: ContactEmailMaxAggregateInputType
  }

  export type ContactEmailGroupByOutputType = {
    id: Uint8Array
    email: string
    isPrimary: boolean
    contactId: Uint8Array
    tenetId: Uint8Array
    createdAt: Date
    updatedAt: Date
    _count: ContactEmailCountAggregateOutputType | null
    _min: ContactEmailMinAggregateOutputType | null
    _max: ContactEmailMaxAggregateOutputType | null
  }

  type GetContactEmailGroupByPayload<T extends ContactEmailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactEmailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactEmailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactEmailGroupByOutputType[P]>
            : GetScalarType<T[P], ContactEmailGroupByOutputType[P]>
        }
      >
    >


  export type ContactEmailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    isPrimary?: boolean
    contactId?: boolean
    tenetId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactEmail"]>

  export type ContactEmailSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    isPrimary?: boolean
    contactId?: boolean
    tenetId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactEmail"]>

  export type ContactEmailSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    isPrimary?: boolean
    contactId?: boolean
    tenetId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactEmail"]>

  export type ContactEmailSelectScalar = {
    id?: boolean
    email?: boolean
    isPrimary?: boolean
    contactId?: boolean
    tenetId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContactEmailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "isPrimary" | "contactId" | "tenetId" | "createdAt" | "updatedAt", ExtArgs["result"]["contactEmail"]>
  export type ContactEmailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }
  export type ContactEmailIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }
  export type ContactEmailIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }

  export type $ContactEmailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContactEmail"
    objects: {
      /**
       * @ai-field
       */
      contact: Prisma.$ContactPayload<ExtArgs>
      tenet: Prisma.$TenetPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      /**
       * @@ai-enabled
       */
      id: Uint8Array
      /**
       * @ai-field
       */
      email: string
      /**
       * @ai-field
       */
      isPrimary: boolean
      /**
       * @ai-field
       */
      contactId: Uint8Array
      tenetId: Uint8Array
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contactEmail"]>
    composites: {}
  }

  type ContactEmailGetPayload<S extends boolean | null | undefined | ContactEmailDefaultArgs> = $Result.GetResult<Prisma.$ContactEmailPayload, S>

  type ContactEmailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactEmailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: ContactEmailCountAggregateInputType | true
    }

  export interface ContactEmailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContactEmail'], meta: { name: 'ContactEmail' } }
    /**
     * Find zero or one ContactEmail that matches the filter.
     * @param {ContactEmailFindUniqueArgs} args - Arguments to find a ContactEmail
     * @example
     * // Get one ContactEmail
     * const contactEmail = await prisma.contactEmail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactEmailFindUniqueArgs>(args: SelectSubset<T, ContactEmailFindUniqueArgs<ExtArgs>>): Prisma__ContactEmailClient<$Result.GetResult<Prisma.$ContactEmailPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ContactEmail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactEmailFindUniqueOrThrowArgs} args - Arguments to find a ContactEmail
     * @example
     * // Get one ContactEmail
     * const contactEmail = await prisma.contactEmail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactEmailFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactEmailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactEmailClient<$Result.GetResult<Prisma.$ContactEmailPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ContactEmail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactEmailFindFirstArgs} args - Arguments to find a ContactEmail
     * @example
     * // Get one ContactEmail
     * const contactEmail = await prisma.contactEmail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactEmailFindFirstArgs>(args?: SelectSubset<T, ContactEmailFindFirstArgs<ExtArgs>>): Prisma__ContactEmailClient<$Result.GetResult<Prisma.$ContactEmailPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ContactEmail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactEmailFindFirstOrThrowArgs} args - Arguments to find a ContactEmail
     * @example
     * // Get one ContactEmail
     * const contactEmail = await prisma.contactEmail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactEmailFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactEmailFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactEmailClient<$Result.GetResult<Prisma.$ContactEmailPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ContactEmails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactEmailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContactEmails
     * const contactEmails = await prisma.contactEmail.findMany()
     * 
     * // Get first 10 ContactEmails
     * const contactEmails = await prisma.contactEmail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactEmailWithIdOnly = await prisma.contactEmail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactEmailFindManyArgs>(args?: SelectSubset<T, ContactEmailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactEmailPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ContactEmail.
     * @param {ContactEmailCreateArgs} args - Arguments to create a ContactEmail.
     * @example
     * // Create one ContactEmail
     * const ContactEmail = await prisma.contactEmail.create({
     *   data: {
     *     // ... data to create a ContactEmail
     *   }
     * })
     * 
     */
    create<T extends ContactEmailCreateArgs>(args: SelectSubset<T, ContactEmailCreateArgs<ExtArgs>>): Prisma__ContactEmailClient<$Result.GetResult<Prisma.$ContactEmailPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ContactEmails.
     * @param {ContactEmailCreateManyArgs} args - Arguments to create many ContactEmails.
     * @example
     * // Create many ContactEmails
     * const contactEmail = await prisma.contactEmail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactEmailCreateManyArgs>(args?: SelectSubset<T, ContactEmailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContactEmails and returns the data saved in the database.
     * @param {ContactEmailCreateManyAndReturnArgs} args - Arguments to create many ContactEmails.
     * @example
     * // Create many ContactEmails
     * const contactEmail = await prisma.contactEmail.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContactEmails and only return the `id`
     * const contactEmailWithIdOnly = await prisma.contactEmail.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactEmailCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactEmailCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactEmailPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a ContactEmail.
     * @param {ContactEmailDeleteArgs} args - Arguments to delete one ContactEmail.
     * @example
     * // Delete one ContactEmail
     * const ContactEmail = await prisma.contactEmail.delete({
     *   where: {
     *     // ... filter to delete one ContactEmail
     *   }
     * })
     * 
     */
    delete<T extends ContactEmailDeleteArgs>(args: SelectSubset<T, ContactEmailDeleteArgs<ExtArgs>>): Prisma__ContactEmailClient<$Result.GetResult<Prisma.$ContactEmailPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ContactEmail.
     * @param {ContactEmailUpdateArgs} args - Arguments to update one ContactEmail.
     * @example
     * // Update one ContactEmail
     * const contactEmail = await prisma.contactEmail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactEmailUpdateArgs>(args: SelectSubset<T, ContactEmailUpdateArgs<ExtArgs>>): Prisma__ContactEmailClient<$Result.GetResult<Prisma.$ContactEmailPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ContactEmails.
     * @param {ContactEmailDeleteManyArgs} args - Arguments to filter ContactEmails to delete.
     * @example
     * // Delete a few ContactEmails
     * const { count } = await prisma.contactEmail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactEmailDeleteManyArgs>(args?: SelectSubset<T, ContactEmailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactEmails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactEmailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContactEmails
     * const contactEmail = await prisma.contactEmail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactEmailUpdateManyArgs>(args: SelectSubset<T, ContactEmailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactEmails and returns the data updated in the database.
     * @param {ContactEmailUpdateManyAndReturnArgs} args - Arguments to update many ContactEmails.
     * @example
     * // Update many ContactEmails
     * const contactEmail = await prisma.contactEmail.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContactEmails and only return the `id`
     * const contactEmailWithIdOnly = await prisma.contactEmail.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContactEmailUpdateManyAndReturnArgs>(args: SelectSubset<T, ContactEmailUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactEmailPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one ContactEmail.
     * @param {ContactEmailUpsertArgs} args - Arguments to update or create a ContactEmail.
     * @example
     * // Update or create a ContactEmail
     * const contactEmail = await prisma.contactEmail.upsert({
     *   create: {
     *     // ... data to create a ContactEmail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContactEmail we want to update
     *   }
     * })
     */
    upsert<T extends ContactEmailUpsertArgs>(args: SelectSubset<T, ContactEmailUpsertArgs<ExtArgs>>): Prisma__ContactEmailClient<$Result.GetResult<Prisma.$ContactEmailPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ContactEmails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactEmailCountArgs} args - Arguments to filter ContactEmails to count.
     * @example
     * // Count the number of ContactEmails
     * const count = await prisma.contactEmail.count({
     *   where: {
     *     // ... the filter for the ContactEmails we want to count
     *   }
     * })
    **/
    count<T extends ContactEmailCountArgs>(
      args?: Subset<T, ContactEmailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactEmailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContactEmail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactEmailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactEmailAggregateArgs>(args: Subset<T, ContactEmailAggregateArgs>): Prisma.PrismaPromise<GetContactEmailAggregateType<T>>

    /**
     * Group by ContactEmail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactEmailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactEmailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactEmailGroupByArgs['orderBy'] }
        : { orderBy?: ContactEmailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactEmailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactEmailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContactEmail model
   */
  readonly fields: ContactEmailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContactEmail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactEmailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contact<T extends ContactDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContactDefaultArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    tenet<T extends TenetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenetDefaultArgs<ExtArgs>>): Prisma__TenetClient<$Result.GetResult<Prisma.$TenetPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContactEmail model
   */ 
  interface ContactEmailFieldRefs {
    readonly id: FieldRef<"ContactEmail", 'Bytes'>
    readonly email: FieldRef<"ContactEmail", 'String'>
    readonly isPrimary: FieldRef<"ContactEmail", 'Boolean'>
    readonly contactId: FieldRef<"ContactEmail", 'Bytes'>
    readonly tenetId: FieldRef<"ContactEmail", 'Bytes'>
    readonly createdAt: FieldRef<"ContactEmail", 'DateTime'>
    readonly updatedAt: FieldRef<"ContactEmail", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContactEmail findUnique
   */
  export type ContactEmailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactEmail
     */
    select?: ContactEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactEmail
     */
    omit?: ContactEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactEmailInclude<ExtArgs> | null
    /**
     * Filter, which ContactEmail to fetch.
     */
    where: ContactEmailWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactEmail findUniqueOrThrow
   */
  export type ContactEmailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactEmail
     */
    select?: ContactEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactEmail
     */
    omit?: ContactEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactEmailInclude<ExtArgs> | null
    /**
     * Filter, which ContactEmail to fetch.
     */
    where: ContactEmailWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactEmail findFirst
   */
  export type ContactEmailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactEmail
     */
    select?: ContactEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactEmail
     */
    omit?: ContactEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactEmailInclude<ExtArgs> | null
    /**
     * Filter, which ContactEmail to fetch.
     */
    where?: ContactEmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactEmails to fetch.
     */
    orderBy?: ContactEmailOrderByWithRelationInput | ContactEmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactEmails.
     */
    cursor?: ContactEmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactEmails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactEmails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactEmails.
     */
    distinct?: ContactEmailScalarFieldEnum | ContactEmailScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactEmail findFirstOrThrow
   */
  export type ContactEmailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactEmail
     */
    select?: ContactEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactEmail
     */
    omit?: ContactEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactEmailInclude<ExtArgs> | null
    /**
     * Filter, which ContactEmail to fetch.
     */
    where?: ContactEmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactEmails to fetch.
     */
    orderBy?: ContactEmailOrderByWithRelationInput | ContactEmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactEmails.
     */
    cursor?: ContactEmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactEmails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactEmails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactEmails.
     */
    distinct?: ContactEmailScalarFieldEnum | ContactEmailScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactEmail findMany
   */
  export type ContactEmailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactEmail
     */
    select?: ContactEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactEmail
     */
    omit?: ContactEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactEmailInclude<ExtArgs> | null
    /**
     * Filter, which ContactEmails to fetch.
     */
    where?: ContactEmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactEmails to fetch.
     */
    orderBy?: ContactEmailOrderByWithRelationInput | ContactEmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContactEmails.
     */
    cursor?: ContactEmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactEmails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactEmails.
     */
    skip?: number
    distinct?: ContactEmailScalarFieldEnum | ContactEmailScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactEmail create
   */
  export type ContactEmailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactEmail
     */
    select?: ContactEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactEmail
     */
    omit?: ContactEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactEmailInclude<ExtArgs> | null
    /**
     * The data needed to create a ContactEmail.
     */
    data: XOR<ContactEmailCreateInput, ContactEmailUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactEmail createMany
   */
  export type ContactEmailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContactEmails.
     */
    data: ContactEmailCreateManyInput | ContactEmailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactEmail createManyAndReturn
   */
  export type ContactEmailCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactEmail
     */
    select?: ContactEmailSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactEmail
     */
    omit?: ContactEmailOmit<ExtArgs> | null
    /**
     * The data used to create many ContactEmails.
     */
    data: ContactEmailCreateManyInput | ContactEmailCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactEmailIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContactEmail update
   */
  export type ContactEmailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactEmail
     */
    select?: ContactEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactEmail
     */
    omit?: ContactEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactEmailInclude<ExtArgs> | null
    /**
     * The data needed to update a ContactEmail.
     */
    data: XOR<ContactEmailUpdateInput, ContactEmailUncheckedUpdateInput>
    /**
     * Choose, which ContactEmail to update.
     */
    where: ContactEmailWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactEmail updateMany
   */
  export type ContactEmailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContactEmails.
     */
    data: XOR<ContactEmailUpdateManyMutationInput, ContactEmailUncheckedUpdateManyInput>
    /**
     * Filter which ContactEmails to update
     */
    where?: ContactEmailWhereInput
    /**
     * Limit how many ContactEmails to update.
     */
    limit?: number
  }

  /**
   * ContactEmail updateManyAndReturn
   */
  export type ContactEmailUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactEmail
     */
    select?: ContactEmailSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactEmail
     */
    omit?: ContactEmailOmit<ExtArgs> | null
    /**
     * The data used to update ContactEmails.
     */
    data: XOR<ContactEmailUpdateManyMutationInput, ContactEmailUncheckedUpdateManyInput>
    /**
     * Filter which ContactEmails to update
     */
    where?: ContactEmailWhereInput
    /**
     * Limit how many ContactEmails to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactEmailIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContactEmail upsert
   */
  export type ContactEmailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactEmail
     */
    select?: ContactEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactEmail
     */
    omit?: ContactEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactEmailInclude<ExtArgs> | null
    /**
     * The filter to search for the ContactEmail to update in case it exists.
     */
    where: ContactEmailWhereUniqueInput
    /**
     * In case the ContactEmail found by the `where` argument doesn't exist, create a new ContactEmail with this data.
     */
    create: XOR<ContactEmailCreateInput, ContactEmailUncheckedCreateInput>
    /**
     * In case the ContactEmail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactEmailUpdateInput, ContactEmailUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactEmail delete
   */
  export type ContactEmailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactEmail
     */
    select?: ContactEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactEmail
     */
    omit?: ContactEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactEmailInclude<ExtArgs> | null
    /**
     * Filter which ContactEmail to delete.
     */
    where: ContactEmailWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactEmail deleteMany
   */
  export type ContactEmailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactEmails to delete
     */
    where?: ContactEmailWhereInput
    /**
     * Limit how many ContactEmails to delete.
     */
    limit?: number
  }

  /**
   * ContactEmail without action
   */
  export type ContactEmailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactEmail
     */
    select?: ContactEmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactEmail
     */
    omit?: ContactEmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactEmailInclude<ExtArgs> | null
  }


  /**
   * Model ContactPhone
   */

  export type AggregateContactPhone = {
    _count: ContactPhoneCountAggregateOutputType | null
    _min: ContactPhoneMinAggregateOutputType | null
    _max: ContactPhoneMaxAggregateOutputType | null
  }

  export type ContactPhoneMinAggregateOutputType = {
    id: Uint8Array | null
    number: string | null
    type: $Enums.PhoneType | null
    isPrimary: boolean | null
    contactId: Uint8Array | null
    tenetId: Uint8Array | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactPhoneMaxAggregateOutputType = {
    id: Uint8Array | null
    number: string | null
    type: $Enums.PhoneType | null
    isPrimary: boolean | null
    contactId: Uint8Array | null
    tenetId: Uint8Array | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactPhoneCountAggregateOutputType = {
    id: number
    number: number
    type: number
    isPrimary: number
    contactId: number
    tenetId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContactPhoneMinAggregateInputType = {
    id?: true
    number?: true
    type?: true
    isPrimary?: true
    contactId?: true
    tenetId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactPhoneMaxAggregateInputType = {
    id?: true
    number?: true
    type?: true
    isPrimary?: true
    contactId?: true
    tenetId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactPhoneCountAggregateInputType = {
    id?: true
    number?: true
    type?: true
    isPrimary?: true
    contactId?: true
    tenetId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContactPhoneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactPhone to aggregate.
     */
    where?: ContactPhoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactPhones to fetch.
     */
    orderBy?: ContactPhoneOrderByWithRelationInput | ContactPhoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactPhoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactPhones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactPhones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContactPhones
    **/
    _count?: true | ContactPhoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactPhoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactPhoneMaxAggregateInputType
  }

  export type GetContactPhoneAggregateType<T extends ContactPhoneAggregateArgs> = {
        [P in keyof T & keyof AggregateContactPhone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContactPhone[P]>
      : GetScalarType<T[P], AggregateContactPhone[P]>
  }




  export type ContactPhoneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactPhoneWhereInput
    orderBy?: ContactPhoneOrderByWithAggregationInput | ContactPhoneOrderByWithAggregationInput[]
    by: ContactPhoneScalarFieldEnum[] | ContactPhoneScalarFieldEnum
    having?: ContactPhoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactPhoneCountAggregateInputType | true
    _min?: ContactPhoneMinAggregateInputType
    _max?: ContactPhoneMaxAggregateInputType
  }

  export type ContactPhoneGroupByOutputType = {
    id: Uint8Array
    number: string
    type: $Enums.PhoneType
    isPrimary: boolean
    contactId: Uint8Array
    tenetId: Uint8Array
    createdAt: Date
    updatedAt: Date
    _count: ContactPhoneCountAggregateOutputType | null
    _min: ContactPhoneMinAggregateOutputType | null
    _max: ContactPhoneMaxAggregateOutputType | null
  }

  type GetContactPhoneGroupByPayload<T extends ContactPhoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactPhoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactPhoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactPhoneGroupByOutputType[P]>
            : GetScalarType<T[P], ContactPhoneGroupByOutputType[P]>
        }
      >
    >


  export type ContactPhoneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    type?: boolean
    isPrimary?: boolean
    contactId?: boolean
    tenetId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactPhone"]>

  export type ContactPhoneSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    type?: boolean
    isPrimary?: boolean
    contactId?: boolean
    tenetId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactPhone"]>

  export type ContactPhoneSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    type?: boolean
    isPrimary?: boolean
    contactId?: boolean
    tenetId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactPhone"]>

  export type ContactPhoneSelectScalar = {
    id?: boolean
    number?: boolean
    type?: boolean
    isPrimary?: boolean
    contactId?: boolean
    tenetId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContactPhoneOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "number" | "type" | "isPrimary" | "contactId" | "tenetId" | "createdAt" | "updatedAt", ExtArgs["result"]["contactPhone"]>
  export type ContactPhoneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }
  export type ContactPhoneIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }
  export type ContactPhoneIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }

  export type $ContactPhonePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContactPhone"
    objects: {
      /**
       * @ai-field
       */
      contact: Prisma.$ContactPayload<ExtArgs>
      tenet: Prisma.$TenetPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      /**
       * @@ai-enabled
       */
      id: Uint8Array
      /**
       * @ai-field
       */
      number: string
      /**
       * @ai-field
       */
      type: $Enums.PhoneType
      /**
       * @ai-field
       */
      isPrimary: boolean
      /**
       * @ai-field
       */
      contactId: Uint8Array
      tenetId: Uint8Array
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contactPhone"]>
    composites: {}
  }

  type ContactPhoneGetPayload<S extends boolean | null | undefined | ContactPhoneDefaultArgs> = $Result.GetResult<Prisma.$ContactPhonePayload, S>

  type ContactPhoneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactPhoneFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: ContactPhoneCountAggregateInputType | true
    }

  export interface ContactPhoneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContactPhone'], meta: { name: 'ContactPhone' } }
    /**
     * Find zero or one ContactPhone that matches the filter.
     * @param {ContactPhoneFindUniqueArgs} args - Arguments to find a ContactPhone
     * @example
     * // Get one ContactPhone
     * const contactPhone = await prisma.contactPhone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactPhoneFindUniqueArgs>(args: SelectSubset<T, ContactPhoneFindUniqueArgs<ExtArgs>>): Prisma__ContactPhoneClient<$Result.GetResult<Prisma.$ContactPhonePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ContactPhone that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactPhoneFindUniqueOrThrowArgs} args - Arguments to find a ContactPhone
     * @example
     * // Get one ContactPhone
     * const contactPhone = await prisma.contactPhone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactPhoneFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactPhoneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactPhoneClient<$Result.GetResult<Prisma.$ContactPhonePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ContactPhone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactPhoneFindFirstArgs} args - Arguments to find a ContactPhone
     * @example
     * // Get one ContactPhone
     * const contactPhone = await prisma.contactPhone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactPhoneFindFirstArgs>(args?: SelectSubset<T, ContactPhoneFindFirstArgs<ExtArgs>>): Prisma__ContactPhoneClient<$Result.GetResult<Prisma.$ContactPhonePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ContactPhone that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactPhoneFindFirstOrThrowArgs} args - Arguments to find a ContactPhone
     * @example
     * // Get one ContactPhone
     * const contactPhone = await prisma.contactPhone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactPhoneFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactPhoneFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactPhoneClient<$Result.GetResult<Prisma.$ContactPhonePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ContactPhones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactPhoneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContactPhones
     * const contactPhones = await prisma.contactPhone.findMany()
     * 
     * // Get first 10 ContactPhones
     * const contactPhones = await prisma.contactPhone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactPhoneWithIdOnly = await prisma.contactPhone.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactPhoneFindManyArgs>(args?: SelectSubset<T, ContactPhoneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPhonePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ContactPhone.
     * @param {ContactPhoneCreateArgs} args - Arguments to create a ContactPhone.
     * @example
     * // Create one ContactPhone
     * const ContactPhone = await prisma.contactPhone.create({
     *   data: {
     *     // ... data to create a ContactPhone
     *   }
     * })
     * 
     */
    create<T extends ContactPhoneCreateArgs>(args: SelectSubset<T, ContactPhoneCreateArgs<ExtArgs>>): Prisma__ContactPhoneClient<$Result.GetResult<Prisma.$ContactPhonePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ContactPhones.
     * @param {ContactPhoneCreateManyArgs} args - Arguments to create many ContactPhones.
     * @example
     * // Create many ContactPhones
     * const contactPhone = await prisma.contactPhone.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactPhoneCreateManyArgs>(args?: SelectSubset<T, ContactPhoneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContactPhones and returns the data saved in the database.
     * @param {ContactPhoneCreateManyAndReturnArgs} args - Arguments to create many ContactPhones.
     * @example
     * // Create many ContactPhones
     * const contactPhone = await prisma.contactPhone.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContactPhones and only return the `id`
     * const contactPhoneWithIdOnly = await prisma.contactPhone.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactPhoneCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactPhoneCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPhonePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a ContactPhone.
     * @param {ContactPhoneDeleteArgs} args - Arguments to delete one ContactPhone.
     * @example
     * // Delete one ContactPhone
     * const ContactPhone = await prisma.contactPhone.delete({
     *   where: {
     *     // ... filter to delete one ContactPhone
     *   }
     * })
     * 
     */
    delete<T extends ContactPhoneDeleteArgs>(args: SelectSubset<T, ContactPhoneDeleteArgs<ExtArgs>>): Prisma__ContactPhoneClient<$Result.GetResult<Prisma.$ContactPhonePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ContactPhone.
     * @param {ContactPhoneUpdateArgs} args - Arguments to update one ContactPhone.
     * @example
     * // Update one ContactPhone
     * const contactPhone = await prisma.contactPhone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactPhoneUpdateArgs>(args: SelectSubset<T, ContactPhoneUpdateArgs<ExtArgs>>): Prisma__ContactPhoneClient<$Result.GetResult<Prisma.$ContactPhonePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ContactPhones.
     * @param {ContactPhoneDeleteManyArgs} args - Arguments to filter ContactPhones to delete.
     * @example
     * // Delete a few ContactPhones
     * const { count } = await prisma.contactPhone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactPhoneDeleteManyArgs>(args?: SelectSubset<T, ContactPhoneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactPhones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactPhoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContactPhones
     * const contactPhone = await prisma.contactPhone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactPhoneUpdateManyArgs>(args: SelectSubset<T, ContactPhoneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactPhones and returns the data updated in the database.
     * @param {ContactPhoneUpdateManyAndReturnArgs} args - Arguments to update many ContactPhones.
     * @example
     * // Update many ContactPhones
     * const contactPhone = await prisma.contactPhone.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContactPhones and only return the `id`
     * const contactPhoneWithIdOnly = await prisma.contactPhone.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContactPhoneUpdateManyAndReturnArgs>(args: SelectSubset<T, ContactPhoneUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPhonePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one ContactPhone.
     * @param {ContactPhoneUpsertArgs} args - Arguments to update or create a ContactPhone.
     * @example
     * // Update or create a ContactPhone
     * const contactPhone = await prisma.contactPhone.upsert({
     *   create: {
     *     // ... data to create a ContactPhone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContactPhone we want to update
     *   }
     * })
     */
    upsert<T extends ContactPhoneUpsertArgs>(args: SelectSubset<T, ContactPhoneUpsertArgs<ExtArgs>>): Prisma__ContactPhoneClient<$Result.GetResult<Prisma.$ContactPhonePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ContactPhones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactPhoneCountArgs} args - Arguments to filter ContactPhones to count.
     * @example
     * // Count the number of ContactPhones
     * const count = await prisma.contactPhone.count({
     *   where: {
     *     // ... the filter for the ContactPhones we want to count
     *   }
     * })
    **/
    count<T extends ContactPhoneCountArgs>(
      args?: Subset<T, ContactPhoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactPhoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContactPhone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactPhoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactPhoneAggregateArgs>(args: Subset<T, ContactPhoneAggregateArgs>): Prisma.PrismaPromise<GetContactPhoneAggregateType<T>>

    /**
     * Group by ContactPhone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactPhoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactPhoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactPhoneGroupByArgs['orderBy'] }
        : { orderBy?: ContactPhoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactPhoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactPhoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContactPhone model
   */
  readonly fields: ContactPhoneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContactPhone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactPhoneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contact<T extends ContactDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContactDefaultArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    tenet<T extends TenetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenetDefaultArgs<ExtArgs>>): Prisma__TenetClient<$Result.GetResult<Prisma.$TenetPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContactPhone model
   */ 
  interface ContactPhoneFieldRefs {
    readonly id: FieldRef<"ContactPhone", 'Bytes'>
    readonly number: FieldRef<"ContactPhone", 'String'>
    readonly type: FieldRef<"ContactPhone", 'PhoneType'>
    readonly isPrimary: FieldRef<"ContactPhone", 'Boolean'>
    readonly contactId: FieldRef<"ContactPhone", 'Bytes'>
    readonly tenetId: FieldRef<"ContactPhone", 'Bytes'>
    readonly createdAt: FieldRef<"ContactPhone", 'DateTime'>
    readonly updatedAt: FieldRef<"ContactPhone", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContactPhone findUnique
   */
  export type ContactPhoneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactPhone
     */
    select?: ContactPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactPhone
     */
    omit?: ContactPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactPhoneInclude<ExtArgs> | null
    /**
     * Filter, which ContactPhone to fetch.
     */
    where: ContactPhoneWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactPhone findUniqueOrThrow
   */
  export type ContactPhoneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactPhone
     */
    select?: ContactPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactPhone
     */
    omit?: ContactPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactPhoneInclude<ExtArgs> | null
    /**
     * Filter, which ContactPhone to fetch.
     */
    where: ContactPhoneWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactPhone findFirst
   */
  export type ContactPhoneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactPhone
     */
    select?: ContactPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactPhone
     */
    omit?: ContactPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactPhoneInclude<ExtArgs> | null
    /**
     * Filter, which ContactPhone to fetch.
     */
    where?: ContactPhoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactPhones to fetch.
     */
    orderBy?: ContactPhoneOrderByWithRelationInput | ContactPhoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactPhones.
     */
    cursor?: ContactPhoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactPhones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactPhones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactPhones.
     */
    distinct?: ContactPhoneScalarFieldEnum | ContactPhoneScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactPhone findFirstOrThrow
   */
  export type ContactPhoneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactPhone
     */
    select?: ContactPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactPhone
     */
    omit?: ContactPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactPhoneInclude<ExtArgs> | null
    /**
     * Filter, which ContactPhone to fetch.
     */
    where?: ContactPhoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactPhones to fetch.
     */
    orderBy?: ContactPhoneOrderByWithRelationInput | ContactPhoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactPhones.
     */
    cursor?: ContactPhoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactPhones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactPhones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactPhones.
     */
    distinct?: ContactPhoneScalarFieldEnum | ContactPhoneScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactPhone findMany
   */
  export type ContactPhoneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactPhone
     */
    select?: ContactPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactPhone
     */
    omit?: ContactPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactPhoneInclude<ExtArgs> | null
    /**
     * Filter, which ContactPhones to fetch.
     */
    where?: ContactPhoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactPhones to fetch.
     */
    orderBy?: ContactPhoneOrderByWithRelationInput | ContactPhoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContactPhones.
     */
    cursor?: ContactPhoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactPhones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactPhones.
     */
    skip?: number
    distinct?: ContactPhoneScalarFieldEnum | ContactPhoneScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactPhone create
   */
  export type ContactPhoneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactPhone
     */
    select?: ContactPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactPhone
     */
    omit?: ContactPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactPhoneInclude<ExtArgs> | null
    /**
     * The data needed to create a ContactPhone.
     */
    data: XOR<ContactPhoneCreateInput, ContactPhoneUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactPhone createMany
   */
  export type ContactPhoneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContactPhones.
     */
    data: ContactPhoneCreateManyInput | ContactPhoneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactPhone createManyAndReturn
   */
  export type ContactPhoneCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactPhone
     */
    select?: ContactPhoneSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactPhone
     */
    omit?: ContactPhoneOmit<ExtArgs> | null
    /**
     * The data used to create many ContactPhones.
     */
    data: ContactPhoneCreateManyInput | ContactPhoneCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactPhoneIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContactPhone update
   */
  export type ContactPhoneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactPhone
     */
    select?: ContactPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactPhone
     */
    omit?: ContactPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactPhoneInclude<ExtArgs> | null
    /**
     * The data needed to update a ContactPhone.
     */
    data: XOR<ContactPhoneUpdateInput, ContactPhoneUncheckedUpdateInput>
    /**
     * Choose, which ContactPhone to update.
     */
    where: ContactPhoneWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactPhone updateMany
   */
  export type ContactPhoneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContactPhones.
     */
    data: XOR<ContactPhoneUpdateManyMutationInput, ContactPhoneUncheckedUpdateManyInput>
    /**
     * Filter which ContactPhones to update
     */
    where?: ContactPhoneWhereInput
    /**
     * Limit how many ContactPhones to update.
     */
    limit?: number
  }

  /**
   * ContactPhone updateManyAndReturn
   */
  export type ContactPhoneUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactPhone
     */
    select?: ContactPhoneSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactPhone
     */
    omit?: ContactPhoneOmit<ExtArgs> | null
    /**
     * The data used to update ContactPhones.
     */
    data: XOR<ContactPhoneUpdateManyMutationInput, ContactPhoneUncheckedUpdateManyInput>
    /**
     * Filter which ContactPhones to update
     */
    where?: ContactPhoneWhereInput
    /**
     * Limit how many ContactPhones to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactPhoneIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContactPhone upsert
   */
  export type ContactPhoneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactPhone
     */
    select?: ContactPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactPhone
     */
    omit?: ContactPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactPhoneInclude<ExtArgs> | null
    /**
     * The filter to search for the ContactPhone to update in case it exists.
     */
    where: ContactPhoneWhereUniqueInput
    /**
     * In case the ContactPhone found by the `where` argument doesn't exist, create a new ContactPhone with this data.
     */
    create: XOR<ContactPhoneCreateInput, ContactPhoneUncheckedCreateInput>
    /**
     * In case the ContactPhone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactPhoneUpdateInput, ContactPhoneUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactPhone delete
   */
  export type ContactPhoneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactPhone
     */
    select?: ContactPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactPhone
     */
    omit?: ContactPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactPhoneInclude<ExtArgs> | null
    /**
     * Filter which ContactPhone to delete.
     */
    where: ContactPhoneWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactPhone deleteMany
   */
  export type ContactPhoneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactPhones to delete
     */
    where?: ContactPhoneWhereInput
    /**
     * Limit how many ContactPhones to delete.
     */
    limit?: number
  }

  /**
   * ContactPhone without action
   */
  export type ContactPhoneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactPhone
     */
    select?: ContactPhoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactPhone
     */
    omit?: ContactPhoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactPhoneInclude<ExtArgs> | null
  }


  /**
   * Model Address
   */

  export type AggregateAddress = {
    _count: AddressCountAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  export type AddressMinAggregateOutputType = {
    id: Uint8Array | null
    street: string | null
    city: string | null
    state: string | null
    zip: string | null
    country: string | null
    type: $Enums.AddressType | null
    primary: boolean | null
    contactId: Uint8Array | null
    tenetId: Uint8Array | null
    createdAt: Date | null
    updatedAt: Date | null
    timezone: string | null
  }

  export type AddressMaxAggregateOutputType = {
    id: Uint8Array | null
    street: string | null
    city: string | null
    state: string | null
    zip: string | null
    country: string | null
    type: $Enums.AddressType | null
    primary: boolean | null
    contactId: Uint8Array | null
    tenetId: Uint8Array | null
    createdAt: Date | null
    updatedAt: Date | null
    timezone: string | null
  }

  export type AddressCountAggregateOutputType = {
    id: number
    street: number
    city: number
    state: number
    zip: number
    country: number
    type: number
    primary: number
    contactId: number
    tenetId: number
    createdAt: number
    updatedAt: number
    timezone: number
    _all: number
  }


  export type AddressMinAggregateInputType = {
    id?: true
    street?: true
    city?: true
    state?: true
    zip?: true
    country?: true
    type?: true
    primary?: true
    contactId?: true
    tenetId?: true
    createdAt?: true
    updatedAt?: true
    timezone?: true
  }

  export type AddressMaxAggregateInputType = {
    id?: true
    street?: true
    city?: true
    state?: true
    zip?: true
    country?: true
    type?: true
    primary?: true
    contactId?: true
    tenetId?: true
    createdAt?: true
    updatedAt?: true
    timezone?: true
  }

  export type AddressCountAggregateInputType = {
    id?: true
    street?: true
    city?: true
    state?: true
    zip?: true
    country?: true
    type?: true
    primary?: true
    contactId?: true
    tenetId?: true
    createdAt?: true
    updatedAt?: true
    timezone?: true
    _all?: true
  }

  export type AddressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Address to aggregate.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Addresses
    **/
    _count?: true | AddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddressMaxAggregateInputType
  }

  export type GetAddressAggregateType<T extends AddressAggregateArgs> = {
        [P in keyof T & keyof AggregateAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddress[P]>
      : GetScalarType<T[P], AggregateAddress[P]>
  }




  export type AddressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressWhereInput
    orderBy?: AddressOrderByWithAggregationInput | AddressOrderByWithAggregationInput[]
    by: AddressScalarFieldEnum[] | AddressScalarFieldEnum
    having?: AddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddressCountAggregateInputType | true
    _min?: AddressMinAggregateInputType
    _max?: AddressMaxAggregateInputType
  }

  export type AddressGroupByOutputType = {
    id: Uint8Array
    street: string
    city: string
    state: string
    zip: string
    country: string
    type: $Enums.AddressType
    primary: boolean
    contactId: Uint8Array
    tenetId: Uint8Array
    createdAt: Date
    updatedAt: Date
    timezone: string | null
    _count: AddressCountAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  type GetAddressGroupByPayload<T extends AddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddressGroupByOutputType[P]>
            : GetScalarType<T[P], AddressGroupByOutputType[P]>
        }
      >
    >


  export type AddressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    street?: boolean
    city?: boolean
    state?: boolean
    zip?: boolean
    country?: boolean
    type?: boolean
    primary?: boolean
    contactId?: boolean
    tenetId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    timezone?: boolean
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    street?: boolean
    city?: boolean
    state?: boolean
    zip?: boolean
    country?: boolean
    type?: boolean
    primary?: boolean
    contactId?: boolean
    tenetId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    timezone?: boolean
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    street?: boolean
    city?: boolean
    state?: boolean
    zip?: boolean
    country?: boolean
    type?: boolean
    primary?: boolean
    contactId?: boolean
    tenetId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    timezone?: boolean
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectScalar = {
    id?: boolean
    street?: boolean
    city?: boolean
    state?: boolean
    zip?: boolean
    country?: boolean
    type?: boolean
    primary?: boolean
    contactId?: boolean
    tenetId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    timezone?: boolean
  }

  export type AddressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "street" | "city" | "state" | "zip" | "country" | "type" | "primary" | "contactId" | "tenetId" | "createdAt" | "updatedAt" | "timezone", ExtArgs["result"]["address"]>
  export type AddressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }
  export type AddressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }
  export type AddressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }

  export type $AddressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Address"
    objects: {
      /**
       * @ai-field
       */
      contact: Prisma.$ContactPayload<ExtArgs>
      tenet: Prisma.$TenetPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      /**
       * @@ai-enabled
       */
      id: Uint8Array
      /**
       * @ai-field
       */
      street: string
      /**
       * @ai-field
       */
      city: string
      /**
       * @ai-field
       */
      state: string
      /**
       * @ai-field
       */
      zip: string
      /**
       * @ai-field
       */
      country: string
      /**
       * @ai-field
       */
      type: $Enums.AddressType
      /**
       * @ai-field
       */
      primary: boolean
      /**
       * @ai-field
       */
      contactId: Uint8Array
      tenetId: Uint8Array
      createdAt: Date
      updatedAt: Date
      /**
       * @ai-field
       */
      timezone: string | null
    }, ExtArgs["result"]["address"]>
    composites: {}
  }

  type AddressGetPayload<S extends boolean | null | undefined | AddressDefaultArgs> = $Result.GetResult<Prisma.$AddressPayload, S>

  type AddressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AddressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: AddressCountAggregateInputType | true
    }

  export interface AddressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Address'], meta: { name: 'Address' } }
    /**
     * Find zero or one Address that matches the filter.
     * @param {AddressFindUniqueArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AddressFindUniqueArgs>(args: SelectSubset<T, AddressFindUniqueArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Address that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AddressFindUniqueOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AddressFindUniqueOrThrowArgs>(args: SelectSubset<T, AddressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Address that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AddressFindFirstArgs>(args?: SelectSubset<T, AddressFindFirstArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Address that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AddressFindFirstOrThrowArgs>(args?: SelectSubset<T, AddressFindFirstOrThrowArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Addresses
     * const addresses = await prisma.address.findMany()
     * 
     * // Get first 10 Addresses
     * const addresses = await prisma.address.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addressWithIdOnly = await prisma.address.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AddressFindManyArgs>(args?: SelectSubset<T, AddressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Address.
     * @param {AddressCreateArgs} args - Arguments to create a Address.
     * @example
     * // Create one Address
     * const Address = await prisma.address.create({
     *   data: {
     *     // ... data to create a Address
     *   }
     * })
     * 
     */
    create<T extends AddressCreateArgs>(args: SelectSubset<T, AddressCreateArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Addresses.
     * @param {AddressCreateManyArgs} args - Arguments to create many Addresses.
     * @example
     * // Create many Addresses
     * const address = await prisma.address.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AddressCreateManyArgs>(args?: SelectSubset<T, AddressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Addresses and returns the data saved in the database.
     * @param {AddressCreateManyAndReturnArgs} args - Arguments to create many Addresses.
     * @example
     * // Create many Addresses
     * const address = await prisma.address.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Addresses and only return the `id`
     * const addressWithIdOnly = await prisma.address.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AddressCreateManyAndReturnArgs>(args?: SelectSubset<T, AddressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Address.
     * @param {AddressDeleteArgs} args - Arguments to delete one Address.
     * @example
     * // Delete one Address
     * const Address = await prisma.address.delete({
     *   where: {
     *     // ... filter to delete one Address
     *   }
     * })
     * 
     */
    delete<T extends AddressDeleteArgs>(args: SelectSubset<T, AddressDeleteArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Address.
     * @param {AddressUpdateArgs} args - Arguments to update one Address.
     * @example
     * // Update one Address
     * const address = await prisma.address.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AddressUpdateArgs>(args: SelectSubset<T, AddressUpdateArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Addresses.
     * @param {AddressDeleteManyArgs} args - Arguments to filter Addresses to delete.
     * @example
     * // Delete a few Addresses
     * const { count } = await prisma.address.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AddressDeleteManyArgs>(args?: SelectSubset<T, AddressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AddressUpdateManyArgs>(args: SelectSubset<T, AddressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses and returns the data updated in the database.
     * @param {AddressUpdateManyAndReturnArgs} args - Arguments to update many Addresses.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Addresses and only return the `id`
     * const addressWithIdOnly = await prisma.address.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AddressUpdateManyAndReturnArgs>(args: SelectSubset<T, AddressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Address.
     * @param {AddressUpsertArgs} args - Arguments to update or create a Address.
     * @example
     * // Update or create a Address
     * const address = await prisma.address.upsert({
     *   create: {
     *     // ... data to create a Address
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Address we want to update
     *   }
     * })
     */
    upsert<T extends AddressUpsertArgs>(args: SelectSubset<T, AddressUpsertArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressCountArgs} args - Arguments to filter Addresses to count.
     * @example
     * // Count the number of Addresses
     * const count = await prisma.address.count({
     *   where: {
     *     // ... the filter for the Addresses we want to count
     *   }
     * })
    **/
    count<T extends AddressCountArgs>(
      args?: Subset<T, AddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddressAggregateArgs>(args: Subset<T, AddressAggregateArgs>): Prisma.PrismaPromise<GetAddressAggregateType<T>>

    /**
     * Group by Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddressGroupByArgs['orderBy'] }
        : { orderBy?: AddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Address model
   */
  readonly fields: AddressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Address.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AddressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contact<T extends ContactDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContactDefaultArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    tenet<T extends TenetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenetDefaultArgs<ExtArgs>>): Prisma__TenetClient<$Result.GetResult<Prisma.$TenetPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Address model
   */ 
  interface AddressFieldRefs {
    readonly id: FieldRef<"Address", 'Bytes'>
    readonly street: FieldRef<"Address", 'String'>
    readonly city: FieldRef<"Address", 'String'>
    readonly state: FieldRef<"Address", 'String'>
    readonly zip: FieldRef<"Address", 'String'>
    readonly country: FieldRef<"Address", 'String'>
    readonly type: FieldRef<"Address", 'AddressType'>
    readonly primary: FieldRef<"Address", 'Boolean'>
    readonly contactId: FieldRef<"Address", 'Bytes'>
    readonly tenetId: FieldRef<"Address", 'Bytes'>
    readonly createdAt: FieldRef<"Address", 'DateTime'>
    readonly updatedAt: FieldRef<"Address", 'DateTime'>
    readonly timezone: FieldRef<"Address", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Address findUnique
   */
  export type AddressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Address findUniqueOrThrow
   */
  export type AddressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Address findFirst
   */
  export type AddressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Address findFirstOrThrow
   */
  export type AddressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Address findMany
   */
  export type AddressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Addresses to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Address create
   */
  export type AddressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The data needed to create a Address.
     */
    data: XOR<AddressCreateInput, AddressUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Address createMany
   */
  export type AddressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Addresses.
     */
    data: AddressCreateManyInput | AddressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Address createManyAndReturn
   */
  export type AddressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * The data used to create many Addresses.
     */
    data: AddressCreateManyInput | AddressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Address update
   */
  export type AddressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The data needed to update a Address.
     */
    data: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
    /**
     * Choose, which Address to update.
     */
    where: AddressWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Address updateMany
   */
  export type AddressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Addresses.
     */
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    /**
     * Filter which Addresses to update
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to update.
     */
    limit?: number
  }

  /**
   * Address updateManyAndReturn
   */
  export type AddressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * The data used to update Addresses.
     */
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    /**
     * Filter which Addresses to update
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Address upsert
   */
  export type AddressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The filter to search for the Address to update in case it exists.
     */
    where: AddressWhereUniqueInput
    /**
     * In case the Address found by the `where` argument doesn't exist, create a new Address with this data.
     */
    create: XOR<AddressCreateInput, AddressUncheckedCreateInput>
    /**
     * In case the Address was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Address delete
   */
  export type AddressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter which Address to delete.
     */
    where: AddressWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Address deleteMany
   */
  export type AddressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Addresses to delete
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to delete.
     */
    limit?: number
  }

  /**
   * Address without action
   */
  export type AddressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
  }


  /**
   * Model ConfigOption
   */

  export type AggregateConfigOption = {
    _count: ConfigOptionCountAggregateOutputType | null
    _min: ConfigOptionMinAggregateOutputType | null
    _max: ConfigOptionMaxAggregateOutputType | null
  }

  export type ConfigOptionMinAggregateOutputType = {
    id: Uint8Array | null
    name: string | null
    value: string | null
  }

  export type ConfigOptionMaxAggregateOutputType = {
    id: Uint8Array | null
    name: string | null
    value: string | null
  }

  export type ConfigOptionCountAggregateOutputType = {
    id: number
    name: number
    value: number
    _all: number
  }


  export type ConfigOptionMinAggregateInputType = {
    id?: true
    name?: true
    value?: true
  }

  export type ConfigOptionMaxAggregateInputType = {
    id?: true
    name?: true
    value?: true
  }

  export type ConfigOptionCountAggregateInputType = {
    id?: true
    name?: true
    value?: true
    _all?: true
  }

  export type ConfigOptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConfigOption to aggregate.
     */
    where?: ConfigOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfigOptions to fetch.
     */
    orderBy?: ConfigOptionOrderByWithRelationInput | ConfigOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConfigOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfigOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfigOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConfigOptions
    **/
    _count?: true | ConfigOptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConfigOptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConfigOptionMaxAggregateInputType
  }

  export type GetConfigOptionAggregateType<T extends ConfigOptionAggregateArgs> = {
        [P in keyof T & keyof AggregateConfigOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConfigOption[P]>
      : GetScalarType<T[P], AggregateConfigOption[P]>
  }




  export type ConfigOptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConfigOptionWhereInput
    orderBy?: ConfigOptionOrderByWithAggregationInput | ConfigOptionOrderByWithAggregationInput[]
    by: ConfigOptionScalarFieldEnum[] | ConfigOptionScalarFieldEnum
    having?: ConfigOptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConfigOptionCountAggregateInputType | true
    _min?: ConfigOptionMinAggregateInputType
    _max?: ConfigOptionMaxAggregateInputType
  }

  export type ConfigOptionGroupByOutputType = {
    id: Uint8Array
    name: string
    value: string
    _count: ConfigOptionCountAggregateOutputType | null
    _min: ConfigOptionMinAggregateOutputType | null
    _max: ConfigOptionMaxAggregateOutputType | null
  }

  type GetConfigOptionGroupByPayload<T extends ConfigOptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConfigOptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConfigOptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConfigOptionGroupByOutputType[P]>
            : GetScalarType<T[P], ConfigOptionGroupByOutputType[P]>
        }
      >
    >


  export type ConfigOptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    value?: boolean
  }, ExtArgs["result"]["configOption"]>

  export type ConfigOptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    value?: boolean
  }, ExtArgs["result"]["configOption"]>

  export type ConfigOptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    value?: boolean
  }, ExtArgs["result"]["configOption"]>

  export type ConfigOptionSelectScalar = {
    id?: boolean
    name?: boolean
    value?: boolean
  }

  export type ConfigOptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "value", ExtArgs["result"]["configOption"]>

  export type $ConfigOptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConfigOption"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: Uint8Array
      name: string
      /**
       * @uniqueEncrypted
       */
      value: string
    }, ExtArgs["result"]["configOption"]>
    composites: {}
  }

  type ConfigOptionGetPayload<S extends boolean | null | undefined | ConfigOptionDefaultArgs> = $Result.GetResult<Prisma.$ConfigOptionPayload, S>

  type ConfigOptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConfigOptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: ConfigOptionCountAggregateInputType | true
    }

  export interface ConfigOptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConfigOption'], meta: { name: 'ConfigOption' } }
    /**
     * Find zero or one ConfigOption that matches the filter.
     * @param {ConfigOptionFindUniqueArgs} args - Arguments to find a ConfigOption
     * @example
     * // Get one ConfigOption
     * const configOption = await prisma.configOption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConfigOptionFindUniqueArgs>(args: SelectSubset<T, ConfigOptionFindUniqueArgs<ExtArgs>>): Prisma__ConfigOptionClient<$Result.GetResult<Prisma.$ConfigOptionPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ConfigOption that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConfigOptionFindUniqueOrThrowArgs} args - Arguments to find a ConfigOption
     * @example
     * // Get one ConfigOption
     * const configOption = await prisma.configOption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConfigOptionFindUniqueOrThrowArgs>(args: SelectSubset<T, ConfigOptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConfigOptionClient<$Result.GetResult<Prisma.$ConfigOptionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ConfigOption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigOptionFindFirstArgs} args - Arguments to find a ConfigOption
     * @example
     * // Get one ConfigOption
     * const configOption = await prisma.configOption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConfigOptionFindFirstArgs>(args?: SelectSubset<T, ConfigOptionFindFirstArgs<ExtArgs>>): Prisma__ConfigOptionClient<$Result.GetResult<Prisma.$ConfigOptionPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ConfigOption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigOptionFindFirstOrThrowArgs} args - Arguments to find a ConfigOption
     * @example
     * // Get one ConfigOption
     * const configOption = await prisma.configOption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConfigOptionFindFirstOrThrowArgs>(args?: SelectSubset<T, ConfigOptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConfigOptionClient<$Result.GetResult<Prisma.$ConfigOptionPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ConfigOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigOptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConfigOptions
     * const configOptions = await prisma.configOption.findMany()
     * 
     * // Get first 10 ConfigOptions
     * const configOptions = await prisma.configOption.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const configOptionWithIdOnly = await prisma.configOption.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConfigOptionFindManyArgs>(args?: SelectSubset<T, ConfigOptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfigOptionPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ConfigOption.
     * @param {ConfigOptionCreateArgs} args - Arguments to create a ConfigOption.
     * @example
     * // Create one ConfigOption
     * const ConfigOption = await prisma.configOption.create({
     *   data: {
     *     // ... data to create a ConfigOption
     *   }
     * })
     * 
     */
    create<T extends ConfigOptionCreateArgs>(args: SelectSubset<T, ConfigOptionCreateArgs<ExtArgs>>): Prisma__ConfigOptionClient<$Result.GetResult<Prisma.$ConfigOptionPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ConfigOptions.
     * @param {ConfigOptionCreateManyArgs} args - Arguments to create many ConfigOptions.
     * @example
     * // Create many ConfigOptions
     * const configOption = await prisma.configOption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConfigOptionCreateManyArgs>(args?: SelectSubset<T, ConfigOptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConfigOptions and returns the data saved in the database.
     * @param {ConfigOptionCreateManyAndReturnArgs} args - Arguments to create many ConfigOptions.
     * @example
     * // Create many ConfigOptions
     * const configOption = await prisma.configOption.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConfigOptions and only return the `id`
     * const configOptionWithIdOnly = await prisma.configOption.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConfigOptionCreateManyAndReturnArgs>(args?: SelectSubset<T, ConfigOptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfigOptionPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a ConfigOption.
     * @param {ConfigOptionDeleteArgs} args - Arguments to delete one ConfigOption.
     * @example
     * // Delete one ConfigOption
     * const ConfigOption = await prisma.configOption.delete({
     *   where: {
     *     // ... filter to delete one ConfigOption
     *   }
     * })
     * 
     */
    delete<T extends ConfigOptionDeleteArgs>(args: SelectSubset<T, ConfigOptionDeleteArgs<ExtArgs>>): Prisma__ConfigOptionClient<$Result.GetResult<Prisma.$ConfigOptionPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ConfigOption.
     * @param {ConfigOptionUpdateArgs} args - Arguments to update one ConfigOption.
     * @example
     * // Update one ConfigOption
     * const configOption = await prisma.configOption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConfigOptionUpdateArgs>(args: SelectSubset<T, ConfigOptionUpdateArgs<ExtArgs>>): Prisma__ConfigOptionClient<$Result.GetResult<Prisma.$ConfigOptionPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ConfigOptions.
     * @param {ConfigOptionDeleteManyArgs} args - Arguments to filter ConfigOptions to delete.
     * @example
     * // Delete a few ConfigOptions
     * const { count } = await prisma.configOption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConfigOptionDeleteManyArgs>(args?: SelectSubset<T, ConfigOptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConfigOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigOptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConfigOptions
     * const configOption = await prisma.configOption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConfigOptionUpdateManyArgs>(args: SelectSubset<T, ConfigOptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConfigOptions and returns the data updated in the database.
     * @param {ConfigOptionUpdateManyAndReturnArgs} args - Arguments to update many ConfigOptions.
     * @example
     * // Update many ConfigOptions
     * const configOption = await prisma.configOption.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ConfigOptions and only return the `id`
     * const configOptionWithIdOnly = await prisma.configOption.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConfigOptionUpdateManyAndReturnArgs>(args: SelectSubset<T, ConfigOptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfigOptionPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one ConfigOption.
     * @param {ConfigOptionUpsertArgs} args - Arguments to update or create a ConfigOption.
     * @example
     * // Update or create a ConfigOption
     * const configOption = await prisma.configOption.upsert({
     *   create: {
     *     // ... data to create a ConfigOption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConfigOption we want to update
     *   }
     * })
     */
    upsert<T extends ConfigOptionUpsertArgs>(args: SelectSubset<T, ConfigOptionUpsertArgs<ExtArgs>>): Prisma__ConfigOptionClient<$Result.GetResult<Prisma.$ConfigOptionPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ConfigOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigOptionCountArgs} args - Arguments to filter ConfigOptions to count.
     * @example
     * // Count the number of ConfigOptions
     * const count = await prisma.configOption.count({
     *   where: {
     *     // ... the filter for the ConfigOptions we want to count
     *   }
     * })
    **/
    count<T extends ConfigOptionCountArgs>(
      args?: Subset<T, ConfigOptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConfigOptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConfigOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigOptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConfigOptionAggregateArgs>(args: Subset<T, ConfigOptionAggregateArgs>): Prisma.PrismaPromise<GetConfigOptionAggregateType<T>>

    /**
     * Group by ConfigOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigOptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConfigOptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConfigOptionGroupByArgs['orderBy'] }
        : { orderBy?: ConfigOptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConfigOptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConfigOptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConfigOption model
   */
  readonly fields: ConfigOptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConfigOption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConfigOptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConfigOption model
   */ 
  interface ConfigOptionFieldRefs {
    readonly id: FieldRef<"ConfigOption", 'Bytes'>
    readonly name: FieldRef<"ConfigOption", 'String'>
    readonly value: FieldRef<"ConfigOption", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ConfigOption findUnique
   */
  export type ConfigOptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigOption
     */
    select?: ConfigOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigOption
     */
    omit?: ConfigOptionOmit<ExtArgs> | null
    /**
     * Filter, which ConfigOption to fetch.
     */
    where: ConfigOptionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ConfigOption findUniqueOrThrow
   */
  export type ConfigOptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigOption
     */
    select?: ConfigOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigOption
     */
    omit?: ConfigOptionOmit<ExtArgs> | null
    /**
     * Filter, which ConfigOption to fetch.
     */
    where: ConfigOptionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ConfigOption findFirst
   */
  export type ConfigOptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigOption
     */
    select?: ConfigOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigOption
     */
    omit?: ConfigOptionOmit<ExtArgs> | null
    /**
     * Filter, which ConfigOption to fetch.
     */
    where?: ConfigOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfigOptions to fetch.
     */
    orderBy?: ConfigOptionOrderByWithRelationInput | ConfigOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConfigOptions.
     */
    cursor?: ConfigOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfigOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfigOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConfigOptions.
     */
    distinct?: ConfigOptionScalarFieldEnum | ConfigOptionScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ConfigOption findFirstOrThrow
   */
  export type ConfigOptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigOption
     */
    select?: ConfigOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigOption
     */
    omit?: ConfigOptionOmit<ExtArgs> | null
    /**
     * Filter, which ConfigOption to fetch.
     */
    where?: ConfigOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfigOptions to fetch.
     */
    orderBy?: ConfigOptionOrderByWithRelationInput | ConfigOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConfigOptions.
     */
    cursor?: ConfigOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfigOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfigOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConfigOptions.
     */
    distinct?: ConfigOptionScalarFieldEnum | ConfigOptionScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ConfigOption findMany
   */
  export type ConfigOptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigOption
     */
    select?: ConfigOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigOption
     */
    omit?: ConfigOptionOmit<ExtArgs> | null
    /**
     * Filter, which ConfigOptions to fetch.
     */
    where?: ConfigOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfigOptions to fetch.
     */
    orderBy?: ConfigOptionOrderByWithRelationInput | ConfigOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConfigOptions.
     */
    cursor?: ConfigOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfigOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfigOptions.
     */
    skip?: number
    distinct?: ConfigOptionScalarFieldEnum | ConfigOptionScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ConfigOption create
   */
  export type ConfigOptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigOption
     */
    select?: ConfigOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigOption
     */
    omit?: ConfigOptionOmit<ExtArgs> | null
    /**
     * The data needed to create a ConfigOption.
     */
    data: XOR<ConfigOptionCreateInput, ConfigOptionUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ConfigOption createMany
   */
  export type ConfigOptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConfigOptions.
     */
    data: ConfigOptionCreateManyInput | ConfigOptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConfigOption createManyAndReturn
   */
  export type ConfigOptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigOption
     */
    select?: ConfigOptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigOption
     */
    omit?: ConfigOptionOmit<ExtArgs> | null
    /**
     * The data used to create many ConfigOptions.
     */
    data: ConfigOptionCreateManyInput | ConfigOptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConfigOption update
   */
  export type ConfigOptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigOption
     */
    select?: ConfigOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigOption
     */
    omit?: ConfigOptionOmit<ExtArgs> | null
    /**
     * The data needed to update a ConfigOption.
     */
    data: XOR<ConfigOptionUpdateInput, ConfigOptionUncheckedUpdateInput>
    /**
     * Choose, which ConfigOption to update.
     */
    where: ConfigOptionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ConfigOption updateMany
   */
  export type ConfigOptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConfigOptions.
     */
    data: XOR<ConfigOptionUpdateManyMutationInput, ConfigOptionUncheckedUpdateManyInput>
    /**
     * Filter which ConfigOptions to update
     */
    where?: ConfigOptionWhereInput
    /**
     * Limit how many ConfigOptions to update.
     */
    limit?: number
  }

  /**
   * ConfigOption updateManyAndReturn
   */
  export type ConfigOptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigOption
     */
    select?: ConfigOptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigOption
     */
    omit?: ConfigOptionOmit<ExtArgs> | null
    /**
     * The data used to update ConfigOptions.
     */
    data: XOR<ConfigOptionUpdateManyMutationInput, ConfigOptionUncheckedUpdateManyInput>
    /**
     * Filter which ConfigOptions to update
     */
    where?: ConfigOptionWhereInput
    /**
     * Limit how many ConfigOptions to update.
     */
    limit?: number
  }

  /**
   * ConfigOption upsert
   */
  export type ConfigOptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigOption
     */
    select?: ConfigOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigOption
     */
    omit?: ConfigOptionOmit<ExtArgs> | null
    /**
     * The filter to search for the ConfigOption to update in case it exists.
     */
    where: ConfigOptionWhereUniqueInput
    /**
     * In case the ConfigOption found by the `where` argument doesn't exist, create a new ConfigOption with this data.
     */
    create: XOR<ConfigOptionCreateInput, ConfigOptionUncheckedCreateInput>
    /**
     * In case the ConfigOption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConfigOptionUpdateInput, ConfigOptionUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ConfigOption delete
   */
  export type ConfigOptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigOption
     */
    select?: ConfigOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigOption
     */
    omit?: ConfigOptionOmit<ExtArgs> | null
    /**
     * Filter which ConfigOption to delete.
     */
    where: ConfigOptionWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ConfigOption deleteMany
   */
  export type ConfigOptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConfigOptions to delete
     */
    where?: ConfigOptionWhereInput
    /**
     * Limit how many ConfigOptions to delete.
     */
    limit?: number
  }

  /**
   * ConfigOption without action
   */
  export type ConfigOptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigOption
     */
    select?: ConfigOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigOption
     */
    omit?: ConfigOptionOmit<ExtArgs> | null
  }


  /**
   * Model ImportantDate
   */

  export type AggregateImportantDate = {
    _count: ImportantDateCountAggregateOutputType | null
    _min: ImportantDateMinAggregateOutputType | null
    _max: ImportantDateMaxAggregateOutputType | null
  }

  export type ImportantDateMinAggregateOutputType = {
    id: Uint8Array | null
    date: Date | null
    type: $Enums.ImportantDateType | null
    contactId: Uint8Array | null
    tenetId: Uint8Array | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ImportantDateMaxAggregateOutputType = {
    id: Uint8Array | null
    date: Date | null
    type: $Enums.ImportantDateType | null
    contactId: Uint8Array | null
    tenetId: Uint8Array | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ImportantDateCountAggregateOutputType = {
    id: number
    date: number
    type: number
    contactId: number
    tenetId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ImportantDateMinAggregateInputType = {
    id?: true
    date?: true
    type?: true
    contactId?: true
    tenetId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ImportantDateMaxAggregateInputType = {
    id?: true
    date?: true
    type?: true
    contactId?: true
    tenetId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ImportantDateCountAggregateInputType = {
    id?: true
    date?: true
    type?: true
    contactId?: true
    tenetId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ImportantDateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImportantDate to aggregate.
     */
    where?: ImportantDateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportantDates to fetch.
     */
    orderBy?: ImportantDateOrderByWithRelationInput | ImportantDateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ImportantDateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportantDates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportantDates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ImportantDates
    **/
    _count?: true | ImportantDateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImportantDateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImportantDateMaxAggregateInputType
  }

  export type GetImportantDateAggregateType<T extends ImportantDateAggregateArgs> = {
        [P in keyof T & keyof AggregateImportantDate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImportantDate[P]>
      : GetScalarType<T[P], AggregateImportantDate[P]>
  }




  export type ImportantDateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImportantDateWhereInput
    orderBy?: ImportantDateOrderByWithAggregationInput | ImportantDateOrderByWithAggregationInput[]
    by: ImportantDateScalarFieldEnum[] | ImportantDateScalarFieldEnum
    having?: ImportantDateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImportantDateCountAggregateInputType | true
    _min?: ImportantDateMinAggregateInputType
    _max?: ImportantDateMaxAggregateInputType
  }

  export type ImportantDateGroupByOutputType = {
    id: Uint8Array
    date: Date
    type: $Enums.ImportantDateType
    contactId: Uint8Array
    tenetId: Uint8Array
    createdAt: Date
    updatedAt: Date
    _count: ImportantDateCountAggregateOutputType | null
    _min: ImportantDateMinAggregateOutputType | null
    _max: ImportantDateMaxAggregateOutputType | null
  }

  type GetImportantDateGroupByPayload<T extends ImportantDateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ImportantDateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImportantDateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImportantDateGroupByOutputType[P]>
            : GetScalarType<T[P], ImportantDateGroupByOutputType[P]>
        }
      >
    >


  export type ImportantDateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    type?: boolean
    contactId?: boolean
    tenetId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["importantDate"]>

  export type ImportantDateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    type?: boolean
    contactId?: boolean
    tenetId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["importantDate"]>

  export type ImportantDateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    type?: boolean
    contactId?: boolean
    tenetId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["importantDate"]>

  export type ImportantDateSelectScalar = {
    id?: boolean
    date?: boolean
    type?: boolean
    contactId?: boolean
    tenetId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ImportantDateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "type" | "contactId" | "tenetId" | "createdAt" | "updatedAt", ExtArgs["result"]["importantDate"]>
  export type ImportantDateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }
  export type ImportantDateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }
  export type ImportantDateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }

  export type $ImportantDatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ImportantDate"
    objects: {
      /**
       * @ai-field
       */
      contact: Prisma.$ContactPayload<ExtArgs>
      tenet: Prisma.$TenetPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      /**
       * @@ai-enabled
       */
      id: Uint8Array
      /**
       * @ai-field
       */
      date: Date
      /**
       * @ai-field
       */
      type: $Enums.ImportantDateType
      /**
       * @ai-field
       */
      contactId: Uint8Array
      tenetId: Uint8Array
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["importantDate"]>
    composites: {}
  }

  type ImportantDateGetPayload<S extends boolean | null | undefined | ImportantDateDefaultArgs> = $Result.GetResult<Prisma.$ImportantDatePayload, S>

  type ImportantDateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ImportantDateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: ImportantDateCountAggregateInputType | true
    }

  export interface ImportantDateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ImportantDate'], meta: { name: 'ImportantDate' } }
    /**
     * Find zero or one ImportantDate that matches the filter.
     * @param {ImportantDateFindUniqueArgs} args - Arguments to find a ImportantDate
     * @example
     * // Get one ImportantDate
     * const importantDate = await prisma.importantDate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ImportantDateFindUniqueArgs>(args: SelectSubset<T, ImportantDateFindUniqueArgs<ExtArgs>>): Prisma__ImportantDateClient<$Result.GetResult<Prisma.$ImportantDatePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ImportantDate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ImportantDateFindUniqueOrThrowArgs} args - Arguments to find a ImportantDate
     * @example
     * // Get one ImportantDate
     * const importantDate = await prisma.importantDate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ImportantDateFindUniqueOrThrowArgs>(args: SelectSubset<T, ImportantDateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ImportantDateClient<$Result.GetResult<Prisma.$ImportantDatePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ImportantDate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportantDateFindFirstArgs} args - Arguments to find a ImportantDate
     * @example
     * // Get one ImportantDate
     * const importantDate = await prisma.importantDate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ImportantDateFindFirstArgs>(args?: SelectSubset<T, ImportantDateFindFirstArgs<ExtArgs>>): Prisma__ImportantDateClient<$Result.GetResult<Prisma.$ImportantDatePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ImportantDate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportantDateFindFirstOrThrowArgs} args - Arguments to find a ImportantDate
     * @example
     * // Get one ImportantDate
     * const importantDate = await prisma.importantDate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ImportantDateFindFirstOrThrowArgs>(args?: SelectSubset<T, ImportantDateFindFirstOrThrowArgs<ExtArgs>>): Prisma__ImportantDateClient<$Result.GetResult<Prisma.$ImportantDatePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ImportantDates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportantDateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ImportantDates
     * const importantDates = await prisma.importantDate.findMany()
     * 
     * // Get first 10 ImportantDates
     * const importantDates = await prisma.importantDate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const importantDateWithIdOnly = await prisma.importantDate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ImportantDateFindManyArgs>(args?: SelectSubset<T, ImportantDateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImportantDatePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ImportantDate.
     * @param {ImportantDateCreateArgs} args - Arguments to create a ImportantDate.
     * @example
     * // Create one ImportantDate
     * const ImportantDate = await prisma.importantDate.create({
     *   data: {
     *     // ... data to create a ImportantDate
     *   }
     * })
     * 
     */
    create<T extends ImportantDateCreateArgs>(args: SelectSubset<T, ImportantDateCreateArgs<ExtArgs>>): Prisma__ImportantDateClient<$Result.GetResult<Prisma.$ImportantDatePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ImportantDates.
     * @param {ImportantDateCreateManyArgs} args - Arguments to create many ImportantDates.
     * @example
     * // Create many ImportantDates
     * const importantDate = await prisma.importantDate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ImportantDateCreateManyArgs>(args?: SelectSubset<T, ImportantDateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ImportantDates and returns the data saved in the database.
     * @param {ImportantDateCreateManyAndReturnArgs} args - Arguments to create many ImportantDates.
     * @example
     * // Create many ImportantDates
     * const importantDate = await prisma.importantDate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ImportantDates and only return the `id`
     * const importantDateWithIdOnly = await prisma.importantDate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ImportantDateCreateManyAndReturnArgs>(args?: SelectSubset<T, ImportantDateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImportantDatePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a ImportantDate.
     * @param {ImportantDateDeleteArgs} args - Arguments to delete one ImportantDate.
     * @example
     * // Delete one ImportantDate
     * const ImportantDate = await prisma.importantDate.delete({
     *   where: {
     *     // ... filter to delete one ImportantDate
     *   }
     * })
     * 
     */
    delete<T extends ImportantDateDeleteArgs>(args: SelectSubset<T, ImportantDateDeleteArgs<ExtArgs>>): Prisma__ImportantDateClient<$Result.GetResult<Prisma.$ImportantDatePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ImportantDate.
     * @param {ImportantDateUpdateArgs} args - Arguments to update one ImportantDate.
     * @example
     * // Update one ImportantDate
     * const importantDate = await prisma.importantDate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ImportantDateUpdateArgs>(args: SelectSubset<T, ImportantDateUpdateArgs<ExtArgs>>): Prisma__ImportantDateClient<$Result.GetResult<Prisma.$ImportantDatePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ImportantDates.
     * @param {ImportantDateDeleteManyArgs} args - Arguments to filter ImportantDates to delete.
     * @example
     * // Delete a few ImportantDates
     * const { count } = await prisma.importantDate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ImportantDateDeleteManyArgs>(args?: SelectSubset<T, ImportantDateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ImportantDates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportantDateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ImportantDates
     * const importantDate = await prisma.importantDate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ImportantDateUpdateManyArgs>(args: SelectSubset<T, ImportantDateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ImportantDates and returns the data updated in the database.
     * @param {ImportantDateUpdateManyAndReturnArgs} args - Arguments to update many ImportantDates.
     * @example
     * // Update many ImportantDates
     * const importantDate = await prisma.importantDate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ImportantDates and only return the `id`
     * const importantDateWithIdOnly = await prisma.importantDate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ImportantDateUpdateManyAndReturnArgs>(args: SelectSubset<T, ImportantDateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImportantDatePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one ImportantDate.
     * @param {ImportantDateUpsertArgs} args - Arguments to update or create a ImportantDate.
     * @example
     * // Update or create a ImportantDate
     * const importantDate = await prisma.importantDate.upsert({
     *   create: {
     *     // ... data to create a ImportantDate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ImportantDate we want to update
     *   }
     * })
     */
    upsert<T extends ImportantDateUpsertArgs>(args: SelectSubset<T, ImportantDateUpsertArgs<ExtArgs>>): Prisma__ImportantDateClient<$Result.GetResult<Prisma.$ImportantDatePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ImportantDates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportantDateCountArgs} args - Arguments to filter ImportantDates to count.
     * @example
     * // Count the number of ImportantDates
     * const count = await prisma.importantDate.count({
     *   where: {
     *     // ... the filter for the ImportantDates we want to count
     *   }
     * })
    **/
    count<T extends ImportantDateCountArgs>(
      args?: Subset<T, ImportantDateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImportantDateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ImportantDate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportantDateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImportantDateAggregateArgs>(args: Subset<T, ImportantDateAggregateArgs>): Prisma.PrismaPromise<GetImportantDateAggregateType<T>>

    /**
     * Group by ImportantDate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportantDateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImportantDateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImportantDateGroupByArgs['orderBy'] }
        : { orderBy?: ImportantDateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImportantDateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImportantDateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ImportantDate model
   */
  readonly fields: ImportantDateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ImportantDate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ImportantDateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contact<T extends ContactDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContactDefaultArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    tenet<T extends TenetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenetDefaultArgs<ExtArgs>>): Prisma__TenetClient<$Result.GetResult<Prisma.$TenetPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ImportantDate model
   */ 
  interface ImportantDateFieldRefs {
    readonly id: FieldRef<"ImportantDate", 'Bytes'>
    readonly date: FieldRef<"ImportantDate", 'DateTime'>
    readonly type: FieldRef<"ImportantDate", 'ImportantDateType'>
    readonly contactId: FieldRef<"ImportantDate", 'Bytes'>
    readonly tenetId: FieldRef<"ImportantDate", 'Bytes'>
    readonly createdAt: FieldRef<"ImportantDate", 'DateTime'>
    readonly updatedAt: FieldRef<"ImportantDate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ImportantDate findUnique
   */
  export type ImportantDateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportantDate
     */
    select?: ImportantDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportantDate
     */
    omit?: ImportantDateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportantDateInclude<ExtArgs> | null
    /**
     * Filter, which ImportantDate to fetch.
     */
    where: ImportantDateWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ImportantDate findUniqueOrThrow
   */
  export type ImportantDateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportantDate
     */
    select?: ImportantDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportantDate
     */
    omit?: ImportantDateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportantDateInclude<ExtArgs> | null
    /**
     * Filter, which ImportantDate to fetch.
     */
    where: ImportantDateWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ImportantDate findFirst
   */
  export type ImportantDateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportantDate
     */
    select?: ImportantDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportantDate
     */
    omit?: ImportantDateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportantDateInclude<ExtArgs> | null
    /**
     * Filter, which ImportantDate to fetch.
     */
    where?: ImportantDateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportantDates to fetch.
     */
    orderBy?: ImportantDateOrderByWithRelationInput | ImportantDateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImportantDates.
     */
    cursor?: ImportantDateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportantDates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportantDates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImportantDates.
     */
    distinct?: ImportantDateScalarFieldEnum | ImportantDateScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ImportantDate findFirstOrThrow
   */
  export type ImportantDateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportantDate
     */
    select?: ImportantDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportantDate
     */
    omit?: ImportantDateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportantDateInclude<ExtArgs> | null
    /**
     * Filter, which ImportantDate to fetch.
     */
    where?: ImportantDateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportantDates to fetch.
     */
    orderBy?: ImportantDateOrderByWithRelationInput | ImportantDateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImportantDates.
     */
    cursor?: ImportantDateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportantDates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportantDates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImportantDates.
     */
    distinct?: ImportantDateScalarFieldEnum | ImportantDateScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ImportantDate findMany
   */
  export type ImportantDateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportantDate
     */
    select?: ImportantDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportantDate
     */
    omit?: ImportantDateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportantDateInclude<ExtArgs> | null
    /**
     * Filter, which ImportantDates to fetch.
     */
    where?: ImportantDateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportantDates to fetch.
     */
    orderBy?: ImportantDateOrderByWithRelationInput | ImportantDateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ImportantDates.
     */
    cursor?: ImportantDateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportantDates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportantDates.
     */
    skip?: number
    distinct?: ImportantDateScalarFieldEnum | ImportantDateScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ImportantDate create
   */
  export type ImportantDateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportantDate
     */
    select?: ImportantDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportantDate
     */
    omit?: ImportantDateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportantDateInclude<ExtArgs> | null
    /**
     * The data needed to create a ImportantDate.
     */
    data: XOR<ImportantDateCreateInput, ImportantDateUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ImportantDate createMany
   */
  export type ImportantDateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ImportantDates.
     */
    data: ImportantDateCreateManyInput | ImportantDateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ImportantDate createManyAndReturn
   */
  export type ImportantDateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportantDate
     */
    select?: ImportantDateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ImportantDate
     */
    omit?: ImportantDateOmit<ExtArgs> | null
    /**
     * The data used to create many ImportantDates.
     */
    data: ImportantDateCreateManyInput | ImportantDateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportantDateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ImportantDate update
   */
  export type ImportantDateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportantDate
     */
    select?: ImportantDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportantDate
     */
    omit?: ImportantDateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportantDateInclude<ExtArgs> | null
    /**
     * The data needed to update a ImportantDate.
     */
    data: XOR<ImportantDateUpdateInput, ImportantDateUncheckedUpdateInput>
    /**
     * Choose, which ImportantDate to update.
     */
    where: ImportantDateWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ImportantDate updateMany
   */
  export type ImportantDateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ImportantDates.
     */
    data: XOR<ImportantDateUpdateManyMutationInput, ImportantDateUncheckedUpdateManyInput>
    /**
     * Filter which ImportantDates to update
     */
    where?: ImportantDateWhereInput
    /**
     * Limit how many ImportantDates to update.
     */
    limit?: number
  }

  /**
   * ImportantDate updateManyAndReturn
   */
  export type ImportantDateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportantDate
     */
    select?: ImportantDateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ImportantDate
     */
    omit?: ImportantDateOmit<ExtArgs> | null
    /**
     * The data used to update ImportantDates.
     */
    data: XOR<ImportantDateUpdateManyMutationInput, ImportantDateUncheckedUpdateManyInput>
    /**
     * Filter which ImportantDates to update
     */
    where?: ImportantDateWhereInput
    /**
     * Limit how many ImportantDates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportantDateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ImportantDate upsert
   */
  export type ImportantDateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportantDate
     */
    select?: ImportantDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportantDate
     */
    omit?: ImportantDateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportantDateInclude<ExtArgs> | null
    /**
     * The filter to search for the ImportantDate to update in case it exists.
     */
    where: ImportantDateWhereUniqueInput
    /**
     * In case the ImportantDate found by the `where` argument doesn't exist, create a new ImportantDate with this data.
     */
    create: XOR<ImportantDateCreateInput, ImportantDateUncheckedCreateInput>
    /**
     * In case the ImportantDate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ImportantDateUpdateInput, ImportantDateUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ImportantDate delete
   */
  export type ImportantDateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportantDate
     */
    select?: ImportantDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportantDate
     */
    omit?: ImportantDateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportantDateInclude<ExtArgs> | null
    /**
     * Filter which ImportantDate to delete.
     */
    where: ImportantDateWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ImportantDate deleteMany
   */
  export type ImportantDateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImportantDates to delete
     */
    where?: ImportantDateWhereInput
    /**
     * Limit how many ImportantDates to delete.
     */
    limit?: number
  }

  /**
   * ImportantDate without action
   */
  export type ImportantDateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportantDate
     */
    select?: ImportantDateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportantDate
     */
    omit?: ImportantDateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportantDateInclude<ExtArgs> | null
  }


  /**
   * Model Opportunity
   */

  export type AggregateOpportunity = {
    _count: OpportunityCountAggregateOutputType | null
    _avg: OpportunityAvgAggregateOutputType | null
    _sum: OpportunitySumAggregateOutputType | null
    _min: OpportunityMinAggregateOutputType | null
    _max: OpportunityMaxAggregateOutputType | null
  }

  export type OpportunityAvgAggregateOutputType = {
    value: number | null
    probability: number | null
    expectedValue: number | null
  }

  export type OpportunitySumAggregateOutputType = {
    value: number | null
    probability: number | null
    expectedValue: number | null
  }

  export type OpportunityMinAggregateOutputType = {
    id: Uint8Array | null
    title: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    value: number | null
    probability: number | null
    expectedCloseDate: Date | null
    actualCloseDate: Date | null
    status: $Enums.OpportunityStatus | null
    deleted: boolean | null
    deletedAt: Date | null
    tenetId: Uint8Array | null
    expectedValue: number | null
  }

  export type OpportunityMaxAggregateOutputType = {
    id: Uint8Array | null
    title: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    value: number | null
    probability: number | null
    expectedCloseDate: Date | null
    actualCloseDate: Date | null
    status: $Enums.OpportunityStatus | null
    deleted: boolean | null
    deletedAt: Date | null
    tenetId: Uint8Array | null
    expectedValue: number | null
  }

  export type OpportunityCountAggregateOutputType = {
    id: number
    title: number
    description: number
    createdAt: number
    updatedAt: number
    value: number
    probability: number
    expectedCloseDate: number
    actualCloseDate: number
    status: number
    statusHistory: number
    deleted: number
    deletedAt: number
    tenetId: number
    expectedValue: number
    _all: number
  }


  export type OpportunityAvgAggregateInputType = {
    value?: true
    probability?: true
    expectedValue?: true
  }

  export type OpportunitySumAggregateInputType = {
    value?: true
    probability?: true
    expectedValue?: true
  }

  export type OpportunityMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    value?: true
    probability?: true
    expectedCloseDate?: true
    actualCloseDate?: true
    status?: true
    deleted?: true
    deletedAt?: true
    tenetId?: true
    expectedValue?: true
  }

  export type OpportunityMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    value?: true
    probability?: true
    expectedCloseDate?: true
    actualCloseDate?: true
    status?: true
    deleted?: true
    deletedAt?: true
    tenetId?: true
    expectedValue?: true
  }

  export type OpportunityCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    value?: true
    probability?: true
    expectedCloseDate?: true
    actualCloseDate?: true
    status?: true
    statusHistory?: true
    deleted?: true
    deletedAt?: true
    tenetId?: true
    expectedValue?: true
    _all?: true
  }

  export type OpportunityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Opportunity to aggregate.
     */
    where?: OpportunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Opportunities to fetch.
     */
    orderBy?: OpportunityOrderByWithRelationInput | OpportunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OpportunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Opportunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Opportunities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Opportunities
    **/
    _count?: true | OpportunityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OpportunityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OpportunitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OpportunityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OpportunityMaxAggregateInputType
  }

  export type GetOpportunityAggregateType<T extends OpportunityAggregateArgs> = {
        [P in keyof T & keyof AggregateOpportunity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOpportunity[P]>
      : GetScalarType<T[P], AggregateOpportunity[P]>
  }




  export type OpportunityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OpportunityWhereInput
    orderBy?: OpportunityOrderByWithAggregationInput | OpportunityOrderByWithAggregationInput[]
    by: OpportunityScalarFieldEnum[] | OpportunityScalarFieldEnum
    having?: OpportunityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OpportunityCountAggregateInputType | true
    _avg?: OpportunityAvgAggregateInputType
    _sum?: OpportunitySumAggregateInputType
    _min?: OpportunityMinAggregateInputType
    _max?: OpportunityMaxAggregateInputType
  }

  export type OpportunityGroupByOutputType = {
    id: Uint8Array
    title: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    value: number
    probability: number
    expectedCloseDate: Date
    actualCloseDate: Date | null
    status: $Enums.OpportunityStatus
    statusHistory: $Enums.OpportunityStatus[]
    deleted: boolean
    deletedAt: Date | null
    tenetId: Uint8Array
    expectedValue: number
    _count: OpportunityCountAggregateOutputType | null
    _avg: OpportunityAvgAggregateOutputType | null
    _sum: OpportunitySumAggregateOutputType | null
    _min: OpportunityMinAggregateOutputType | null
    _max: OpportunityMaxAggregateOutputType | null
  }

  type GetOpportunityGroupByPayload<T extends OpportunityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OpportunityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OpportunityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OpportunityGroupByOutputType[P]>
            : GetScalarType<T[P], OpportunityGroupByOutputType[P]>
        }
      >
    >


  export type OpportunitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    value?: boolean
    probability?: boolean
    expectedCloseDate?: boolean
    actualCloseDate?: boolean
    status?: boolean
    statusHistory?: boolean
    deleted?: boolean
    deletedAt?: boolean
    tenetId?: boolean
    expectedValue?: boolean
    contacts?: boolean | Opportunity$contactsArgs<ExtArgs>
    teamMembers?: boolean | Opportunity$teamMembersArgs<ExtArgs>
    activities?: boolean | Opportunity$activitiesArgs<ExtArgs>
    products?: boolean | Opportunity$productsArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
    events?: boolean | Opportunity$eventsArgs<ExtArgs>
    notes?: boolean | Opportunity$notesArgs<ExtArgs>
    _count?: boolean | OpportunityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["opportunity"]>

  export type OpportunitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    value?: boolean
    probability?: boolean
    expectedCloseDate?: boolean
    actualCloseDate?: boolean
    status?: boolean
    statusHistory?: boolean
    deleted?: boolean
    deletedAt?: boolean
    tenetId?: boolean
    expectedValue?: boolean
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["opportunity"]>

  export type OpportunitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    value?: boolean
    probability?: boolean
    expectedCloseDate?: boolean
    actualCloseDate?: boolean
    status?: boolean
    statusHistory?: boolean
    deleted?: boolean
    deletedAt?: boolean
    tenetId?: boolean
    expectedValue?: boolean
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["opportunity"]>

  export type OpportunitySelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    value?: boolean
    probability?: boolean
    expectedCloseDate?: boolean
    actualCloseDate?: boolean
    status?: boolean
    statusHistory?: boolean
    deleted?: boolean
    deletedAt?: boolean
    tenetId?: boolean
    expectedValue?: boolean
  }

  export type OpportunityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "createdAt" | "updatedAt" | "value" | "probability" | "expectedCloseDate" | "actualCloseDate" | "status" | "statusHistory" | "deleted" | "deletedAt" | "tenetId" | "expectedValue", ExtArgs["result"]["opportunity"]>
  export type OpportunityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contacts?: boolean | Opportunity$contactsArgs<ExtArgs>
    teamMembers?: boolean | Opportunity$teamMembersArgs<ExtArgs>
    activities?: boolean | Opportunity$activitiesArgs<ExtArgs>
    products?: boolean | Opportunity$productsArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
    events?: boolean | Opportunity$eventsArgs<ExtArgs>
    notes?: boolean | Opportunity$notesArgs<ExtArgs>
    _count?: boolean | OpportunityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OpportunityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }
  export type OpportunityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }

  export type $OpportunityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Opportunity"
    objects: {
      /**
       * @jointable(Contact, contactRelation)
       * @ai-field(Associated contacts)
       */
      contacts: Prisma.$ContactOpportunityJoinPayload<ExtArgs>[]
      /**
       * @jointable(User, userRelation)
       * @ai-field
       */
      teamMembers: Prisma.$UserOpportunityJoinPayload<ExtArgs>[]
      /**
       * @ai-field(Activities related to this opportunity)
       */
      activities: Prisma.$ActivityPayload<ExtArgs>[]
      /**
       * @ai-field(The products this opportunity is related to)
       */
      products: Prisma.$OpportunityProductPayload<ExtArgs>[]
      tenet: Prisma.$TenetPayload<ExtArgs>
      events: Prisma.$ContactTimelineEventPayload<ExtArgs>[]
      notes: Prisma.$NotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      /**
       * @@ai-enabled
       */
      id: Uint8Array
      /**
       * @ai-field
       */
      title: string
      /**
       * @ai-field
       */
      description: string | null
      createdAt: Date
      updatedAt: Date
      /**
       * @ai-field(Value of the opportunity)
       */
      value: number
      /**
       * @ai-field(Probability of closing the opportunity based on historical data)
       */
      probability: number
      /**
       * @ai-field
       */
      expectedCloseDate: Date
      /**
       * @ai-field
       */
      actualCloseDate: Date | null
      /**
       * @ai-field
       */
      status: $Enums.OpportunityStatus
      statusHistory: $Enums.OpportunityStatus[]
      /**
       * @@soft-delete
       */
      deleted: boolean
      deletedAt: Date | null
      tenetId: Uint8Array
      /**
       * @wrapper-ignore
       */
      expectedValue: number
    }, ExtArgs["result"]["opportunity"]>
    composites: {}
  }

  type OpportunityGetPayload<S extends boolean | null | undefined | OpportunityDefaultArgs> = $Result.GetResult<Prisma.$OpportunityPayload, S>

  type OpportunityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OpportunityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: OpportunityCountAggregateInputType | true
    }

  export interface OpportunityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Opportunity'], meta: { name: 'Opportunity' } }
    /**
     * Find zero or one Opportunity that matches the filter.
     * @param {OpportunityFindUniqueArgs} args - Arguments to find a Opportunity
     * @example
     * // Get one Opportunity
     * const opportunity = await prisma.opportunity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OpportunityFindUniqueArgs>(args: SelectSubset<T, OpportunityFindUniqueArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Opportunity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OpportunityFindUniqueOrThrowArgs} args - Arguments to find a Opportunity
     * @example
     * // Get one Opportunity
     * const opportunity = await prisma.opportunity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OpportunityFindUniqueOrThrowArgs>(args: SelectSubset<T, OpportunityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Opportunity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityFindFirstArgs} args - Arguments to find a Opportunity
     * @example
     * // Get one Opportunity
     * const opportunity = await prisma.opportunity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OpportunityFindFirstArgs>(args?: SelectSubset<T, OpportunityFindFirstArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Opportunity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityFindFirstOrThrowArgs} args - Arguments to find a Opportunity
     * @example
     * // Get one Opportunity
     * const opportunity = await prisma.opportunity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OpportunityFindFirstOrThrowArgs>(args?: SelectSubset<T, OpportunityFindFirstOrThrowArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Opportunities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Opportunities
     * const opportunities = await prisma.opportunity.findMany()
     * 
     * // Get first 10 Opportunities
     * const opportunities = await prisma.opportunity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const opportunityWithIdOnly = await prisma.opportunity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OpportunityFindManyArgs>(args?: SelectSubset<T, OpportunityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Opportunity.
     * @param {OpportunityCreateArgs} args - Arguments to create a Opportunity.
     * @example
     * // Create one Opportunity
     * const Opportunity = await prisma.opportunity.create({
     *   data: {
     *     // ... data to create a Opportunity
     *   }
     * })
     * 
     */
    create<T extends OpportunityCreateArgs>(args: SelectSubset<T, OpportunityCreateArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Opportunities.
     * @param {OpportunityCreateManyArgs} args - Arguments to create many Opportunities.
     * @example
     * // Create many Opportunities
     * const opportunity = await prisma.opportunity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OpportunityCreateManyArgs>(args?: SelectSubset<T, OpportunityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Opportunities and returns the data saved in the database.
     * @param {OpportunityCreateManyAndReturnArgs} args - Arguments to create many Opportunities.
     * @example
     * // Create many Opportunities
     * const opportunity = await prisma.opportunity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Opportunities and only return the `id`
     * const opportunityWithIdOnly = await prisma.opportunity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OpportunityCreateManyAndReturnArgs>(args?: SelectSubset<T, OpportunityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Opportunity.
     * @param {OpportunityDeleteArgs} args - Arguments to delete one Opportunity.
     * @example
     * // Delete one Opportunity
     * const Opportunity = await prisma.opportunity.delete({
     *   where: {
     *     // ... filter to delete one Opportunity
     *   }
     * })
     * 
     */
    delete<T extends OpportunityDeleteArgs>(args: SelectSubset<T, OpportunityDeleteArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Opportunity.
     * @param {OpportunityUpdateArgs} args - Arguments to update one Opportunity.
     * @example
     * // Update one Opportunity
     * const opportunity = await prisma.opportunity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OpportunityUpdateArgs>(args: SelectSubset<T, OpportunityUpdateArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Opportunities.
     * @param {OpportunityDeleteManyArgs} args - Arguments to filter Opportunities to delete.
     * @example
     * // Delete a few Opportunities
     * const { count } = await prisma.opportunity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OpportunityDeleteManyArgs>(args?: SelectSubset<T, OpportunityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Opportunities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Opportunities
     * const opportunity = await prisma.opportunity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OpportunityUpdateManyArgs>(args: SelectSubset<T, OpportunityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Opportunities and returns the data updated in the database.
     * @param {OpportunityUpdateManyAndReturnArgs} args - Arguments to update many Opportunities.
     * @example
     * // Update many Opportunities
     * const opportunity = await prisma.opportunity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Opportunities and only return the `id`
     * const opportunityWithIdOnly = await prisma.opportunity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OpportunityUpdateManyAndReturnArgs>(args: SelectSubset<T, OpportunityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Opportunity.
     * @param {OpportunityUpsertArgs} args - Arguments to update or create a Opportunity.
     * @example
     * // Update or create a Opportunity
     * const opportunity = await prisma.opportunity.upsert({
     *   create: {
     *     // ... data to create a Opportunity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Opportunity we want to update
     *   }
     * })
     */
    upsert<T extends OpportunityUpsertArgs>(args: SelectSubset<T, OpportunityUpsertArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Opportunities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityCountArgs} args - Arguments to filter Opportunities to count.
     * @example
     * // Count the number of Opportunities
     * const count = await prisma.opportunity.count({
     *   where: {
     *     // ... the filter for the Opportunities we want to count
     *   }
     * })
    **/
    count<T extends OpportunityCountArgs>(
      args?: Subset<T, OpportunityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OpportunityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Opportunity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OpportunityAggregateArgs>(args: Subset<T, OpportunityAggregateArgs>): Prisma.PrismaPromise<GetOpportunityAggregateType<T>>

    /**
     * Group by Opportunity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OpportunityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OpportunityGroupByArgs['orderBy'] }
        : { orderBy?: OpportunityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OpportunityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOpportunityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Opportunity model
   */
  readonly fields: OpportunityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Opportunity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OpportunityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contacts<T extends Opportunity$contactsArgs<ExtArgs> = {}>(args?: Subset<T, Opportunity$contactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactOpportunityJoinPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    teamMembers<T extends Opportunity$teamMembersArgs<ExtArgs> = {}>(args?: Subset<T, Opportunity$teamMembersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserOpportunityJoinPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    activities<T extends Opportunity$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, Opportunity$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    products<T extends Opportunity$productsArgs<ExtArgs> = {}>(args?: Subset<T, Opportunity$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpportunityProductPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    tenet<T extends TenetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenetDefaultArgs<ExtArgs>>): Prisma__TenetClient<$Result.GetResult<Prisma.$TenetPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    events<T extends Opportunity$eventsArgs<ExtArgs> = {}>(args?: Subset<T, Opportunity$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactTimelineEventPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    notes<T extends Opportunity$notesArgs<ExtArgs> = {}>(args?: Subset<T, Opportunity$notesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Opportunity model
   */ 
  interface OpportunityFieldRefs {
    readonly id: FieldRef<"Opportunity", 'Bytes'>
    readonly title: FieldRef<"Opportunity", 'String'>
    readonly description: FieldRef<"Opportunity", 'String'>
    readonly createdAt: FieldRef<"Opportunity", 'DateTime'>
    readonly updatedAt: FieldRef<"Opportunity", 'DateTime'>
    readonly value: FieldRef<"Opportunity", 'Float'>
    readonly probability: FieldRef<"Opportunity", 'Float'>
    readonly expectedCloseDate: FieldRef<"Opportunity", 'DateTime'>
    readonly actualCloseDate: FieldRef<"Opportunity", 'DateTime'>
    readonly status: FieldRef<"Opportunity", 'OpportunityStatus'>
    readonly statusHistory: FieldRef<"Opportunity", 'OpportunityStatus[]'>
    readonly deleted: FieldRef<"Opportunity", 'Boolean'>
    readonly deletedAt: FieldRef<"Opportunity", 'DateTime'>
    readonly tenetId: FieldRef<"Opportunity", 'Bytes'>
    readonly expectedValue: FieldRef<"Opportunity", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Opportunity findUnique
   */
  export type OpportunityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * Filter, which Opportunity to fetch.
     */
    where: OpportunityWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Opportunity findUniqueOrThrow
   */
  export type OpportunityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * Filter, which Opportunity to fetch.
     */
    where: OpportunityWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Opportunity findFirst
   */
  export type OpportunityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * Filter, which Opportunity to fetch.
     */
    where?: OpportunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Opportunities to fetch.
     */
    orderBy?: OpportunityOrderByWithRelationInput | OpportunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Opportunities.
     */
    cursor?: OpportunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Opportunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Opportunities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Opportunities.
     */
    distinct?: OpportunityScalarFieldEnum | OpportunityScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Opportunity findFirstOrThrow
   */
  export type OpportunityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * Filter, which Opportunity to fetch.
     */
    where?: OpportunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Opportunities to fetch.
     */
    orderBy?: OpportunityOrderByWithRelationInput | OpportunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Opportunities.
     */
    cursor?: OpportunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Opportunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Opportunities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Opportunities.
     */
    distinct?: OpportunityScalarFieldEnum | OpportunityScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Opportunity findMany
   */
  export type OpportunityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * Filter, which Opportunities to fetch.
     */
    where?: OpportunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Opportunities to fetch.
     */
    orderBy?: OpportunityOrderByWithRelationInput | OpportunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Opportunities.
     */
    cursor?: OpportunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Opportunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Opportunities.
     */
    skip?: number
    distinct?: OpportunityScalarFieldEnum | OpportunityScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Opportunity create
   */
  export type OpportunityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * The data needed to create a Opportunity.
     */
    data: XOR<OpportunityCreateInput, OpportunityUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Opportunity createMany
   */
  export type OpportunityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Opportunities.
     */
    data: OpportunityCreateManyInput | OpportunityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Opportunity createManyAndReturn
   */
  export type OpportunityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * The data used to create many Opportunities.
     */
    data: OpportunityCreateManyInput | OpportunityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Opportunity update
   */
  export type OpportunityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * The data needed to update a Opportunity.
     */
    data: XOR<OpportunityUpdateInput, OpportunityUncheckedUpdateInput>
    /**
     * Choose, which Opportunity to update.
     */
    where: OpportunityWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Opportunity updateMany
   */
  export type OpportunityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Opportunities.
     */
    data: XOR<OpportunityUpdateManyMutationInput, OpportunityUncheckedUpdateManyInput>
    /**
     * Filter which Opportunities to update
     */
    where?: OpportunityWhereInput
    /**
     * Limit how many Opportunities to update.
     */
    limit?: number
  }

  /**
   * Opportunity updateManyAndReturn
   */
  export type OpportunityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * The data used to update Opportunities.
     */
    data: XOR<OpportunityUpdateManyMutationInput, OpportunityUncheckedUpdateManyInput>
    /**
     * Filter which Opportunities to update
     */
    where?: OpportunityWhereInput
    /**
     * Limit how many Opportunities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Opportunity upsert
   */
  export type OpportunityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * The filter to search for the Opportunity to update in case it exists.
     */
    where: OpportunityWhereUniqueInput
    /**
     * In case the Opportunity found by the `where` argument doesn't exist, create a new Opportunity with this data.
     */
    create: XOR<OpportunityCreateInput, OpportunityUncheckedCreateInput>
    /**
     * In case the Opportunity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OpportunityUpdateInput, OpportunityUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Opportunity delete
   */
  export type OpportunityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
    /**
     * Filter which Opportunity to delete.
     */
    where: OpportunityWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Opportunity deleteMany
   */
  export type OpportunityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Opportunities to delete
     */
    where?: OpportunityWhereInput
    /**
     * Limit how many Opportunities to delete.
     */
    limit?: number
  }

  /**
   * Opportunity.contacts
   */
  export type Opportunity$contactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactOpportunityJoin
     */
    select?: ContactOpportunityJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactOpportunityJoin
     */
    omit?: ContactOpportunityJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactOpportunityJoinInclude<ExtArgs> | null
    where?: ContactOpportunityJoinWhereInput
    orderBy?: ContactOpportunityJoinOrderByWithRelationInput | ContactOpportunityJoinOrderByWithRelationInput[]
    cursor?: ContactOpportunityJoinWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactOpportunityJoinScalarFieldEnum | ContactOpportunityJoinScalarFieldEnum[]
  }

  /**
   * Opportunity.teamMembers
   */
  export type Opportunity$teamMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOpportunityJoin
     */
    select?: UserOpportunityJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserOpportunityJoin
     */
    omit?: UserOpportunityJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOpportunityJoinInclude<ExtArgs> | null
    where?: UserOpportunityJoinWhereInput
    orderBy?: UserOpportunityJoinOrderByWithRelationInput | UserOpportunityJoinOrderByWithRelationInput[]
    cursor?: UserOpportunityJoinWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserOpportunityJoinScalarFieldEnum | UserOpportunityJoinScalarFieldEnum[]
  }

  /**
   * Opportunity.activities
   */
  export type Opportunity$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Activity
     */
    omit?: ActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    cursor?: ActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Opportunity.products
   */
  export type Opportunity$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpportunityProduct
     */
    select?: OpportunityProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpportunityProduct
     */
    omit?: OpportunityProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityProductInclude<ExtArgs> | null
    where?: OpportunityProductWhereInput
    orderBy?: OpportunityProductOrderByWithRelationInput | OpportunityProductOrderByWithRelationInput[]
    cursor?: OpportunityProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OpportunityProductScalarFieldEnum | OpportunityProductScalarFieldEnum[]
  }

  /**
   * Opportunity.events
   */
  export type Opportunity$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTimelineEvent
     */
    select?: ContactTimelineEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTimelineEvent
     */
    omit?: ContactTimelineEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTimelineEventInclude<ExtArgs> | null
    where?: ContactTimelineEventWhereInput
    orderBy?: ContactTimelineEventOrderByWithRelationInput | ContactTimelineEventOrderByWithRelationInput[]
    cursor?: ContactTimelineEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactTimelineEventScalarFieldEnum | ContactTimelineEventScalarFieldEnum[]
  }

  /**
   * Opportunity.notes
   */
  export type Opportunity$notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Note
     */
    omit?: NoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteInclude<ExtArgs> | null
    where?: NoteWhereInput
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    cursor?: NoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * Opportunity without action
   */
  export type OpportunityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Opportunity
     */
    select?: OpportunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Opportunity
     */
    omit?: OpportunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityInclude<ExtArgs> | null
  }


  /**
   * Model ContactOpportunityJoin
   */

  export type AggregateContactOpportunityJoin = {
    _count: ContactOpportunityJoinCountAggregateOutputType | null
    _min: ContactOpportunityJoinMinAggregateOutputType | null
    _max: ContactOpportunityJoinMaxAggregateOutputType | null
  }

  export type ContactOpportunityJoinMinAggregateOutputType = {
    contactId: Uint8Array | null
    opportunityId: Uint8Array | null
  }

  export type ContactOpportunityJoinMaxAggregateOutputType = {
    contactId: Uint8Array | null
    opportunityId: Uint8Array | null
  }

  export type ContactOpportunityJoinCountAggregateOutputType = {
    contactId: number
    opportunityId: number
    _all: number
  }


  export type ContactOpportunityJoinMinAggregateInputType = {
    contactId?: true
    opportunityId?: true
  }

  export type ContactOpportunityJoinMaxAggregateInputType = {
    contactId?: true
    opportunityId?: true
  }

  export type ContactOpportunityJoinCountAggregateInputType = {
    contactId?: true
    opportunityId?: true
    _all?: true
  }

  export type ContactOpportunityJoinAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactOpportunityJoin to aggregate.
     */
    where?: ContactOpportunityJoinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactOpportunityJoins to fetch.
     */
    orderBy?: ContactOpportunityJoinOrderByWithRelationInput | ContactOpportunityJoinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactOpportunityJoinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactOpportunityJoins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactOpportunityJoins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContactOpportunityJoins
    **/
    _count?: true | ContactOpportunityJoinCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactOpportunityJoinMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactOpportunityJoinMaxAggregateInputType
  }

  export type GetContactOpportunityJoinAggregateType<T extends ContactOpportunityJoinAggregateArgs> = {
        [P in keyof T & keyof AggregateContactOpportunityJoin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContactOpportunityJoin[P]>
      : GetScalarType<T[P], AggregateContactOpportunityJoin[P]>
  }




  export type ContactOpportunityJoinGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactOpportunityJoinWhereInput
    orderBy?: ContactOpportunityJoinOrderByWithAggregationInput | ContactOpportunityJoinOrderByWithAggregationInput[]
    by: ContactOpportunityJoinScalarFieldEnum[] | ContactOpportunityJoinScalarFieldEnum
    having?: ContactOpportunityJoinScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactOpportunityJoinCountAggregateInputType | true
    _min?: ContactOpportunityJoinMinAggregateInputType
    _max?: ContactOpportunityJoinMaxAggregateInputType
  }

  export type ContactOpportunityJoinGroupByOutputType = {
    contactId: Uint8Array
    opportunityId: Uint8Array
    _count: ContactOpportunityJoinCountAggregateOutputType | null
    _min: ContactOpportunityJoinMinAggregateOutputType | null
    _max: ContactOpportunityJoinMaxAggregateOutputType | null
  }

  type GetContactOpportunityJoinGroupByPayload<T extends ContactOpportunityJoinGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactOpportunityJoinGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactOpportunityJoinGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactOpportunityJoinGroupByOutputType[P]>
            : GetScalarType<T[P], ContactOpportunityJoinGroupByOutputType[P]>
        }
      >
    >


  export type ContactOpportunityJoinSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    contactId?: boolean
    opportunityId?: boolean
    contactRelation?: boolean | ContactDefaultArgs<ExtArgs>
    opportunityRelation?: boolean | OpportunityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactOpportunityJoin"]>

  export type ContactOpportunityJoinSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    contactId?: boolean
    opportunityId?: boolean
    contactRelation?: boolean | ContactDefaultArgs<ExtArgs>
    opportunityRelation?: boolean | OpportunityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactOpportunityJoin"]>

  export type ContactOpportunityJoinSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    contactId?: boolean
    opportunityId?: boolean
    contactRelation?: boolean | ContactDefaultArgs<ExtArgs>
    opportunityRelation?: boolean | OpportunityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactOpportunityJoin"]>

  export type ContactOpportunityJoinSelectScalar = {
    contactId?: boolean
    opportunityId?: boolean
  }

  export type ContactOpportunityJoinOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"contactId" | "opportunityId", ExtArgs["result"]["contactOpportunityJoin"]>
  export type ContactOpportunityJoinInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contactRelation?: boolean | ContactDefaultArgs<ExtArgs>
    opportunityRelation?: boolean | OpportunityDefaultArgs<ExtArgs>
  }
  export type ContactOpportunityJoinIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contactRelation?: boolean | ContactDefaultArgs<ExtArgs>
    opportunityRelation?: boolean | OpportunityDefaultArgs<ExtArgs>
  }
  export type ContactOpportunityJoinIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contactRelation?: boolean | ContactDefaultArgs<ExtArgs>
    opportunityRelation?: boolean | OpportunityDefaultArgs<ExtArgs>
  }

  export type $ContactOpportunityJoinPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContactOpportunityJoin"
    objects: {
      contactRelation: Prisma.$ContactPayload<ExtArgs>
      opportunityRelation: Prisma.$OpportunityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      /**
       * @@wrapper-ignore
       */
      contactId: Uint8Array
      opportunityId: Uint8Array
    }, ExtArgs["result"]["contactOpportunityJoin"]>
    composites: {}
  }

  type ContactOpportunityJoinGetPayload<S extends boolean | null | undefined | ContactOpportunityJoinDefaultArgs> = $Result.GetResult<Prisma.$ContactOpportunityJoinPayload, S>

  type ContactOpportunityJoinCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactOpportunityJoinFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: ContactOpportunityJoinCountAggregateInputType | true
    }

  export interface ContactOpportunityJoinDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContactOpportunityJoin'], meta: { name: 'ContactOpportunityJoin' } }
    /**
     * Find zero or one ContactOpportunityJoin that matches the filter.
     * @param {ContactOpportunityJoinFindUniqueArgs} args - Arguments to find a ContactOpportunityJoin
     * @example
     * // Get one ContactOpportunityJoin
     * const contactOpportunityJoin = await prisma.contactOpportunityJoin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactOpportunityJoinFindUniqueArgs>(args: SelectSubset<T, ContactOpportunityJoinFindUniqueArgs<ExtArgs>>): Prisma__ContactOpportunityJoinClient<$Result.GetResult<Prisma.$ContactOpportunityJoinPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ContactOpportunityJoin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactOpportunityJoinFindUniqueOrThrowArgs} args - Arguments to find a ContactOpportunityJoin
     * @example
     * // Get one ContactOpportunityJoin
     * const contactOpportunityJoin = await prisma.contactOpportunityJoin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactOpportunityJoinFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactOpportunityJoinFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactOpportunityJoinClient<$Result.GetResult<Prisma.$ContactOpportunityJoinPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ContactOpportunityJoin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactOpportunityJoinFindFirstArgs} args - Arguments to find a ContactOpportunityJoin
     * @example
     * // Get one ContactOpportunityJoin
     * const contactOpportunityJoin = await prisma.contactOpportunityJoin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactOpportunityJoinFindFirstArgs>(args?: SelectSubset<T, ContactOpportunityJoinFindFirstArgs<ExtArgs>>): Prisma__ContactOpportunityJoinClient<$Result.GetResult<Prisma.$ContactOpportunityJoinPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ContactOpportunityJoin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactOpportunityJoinFindFirstOrThrowArgs} args - Arguments to find a ContactOpportunityJoin
     * @example
     * // Get one ContactOpportunityJoin
     * const contactOpportunityJoin = await prisma.contactOpportunityJoin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactOpportunityJoinFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactOpportunityJoinFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactOpportunityJoinClient<$Result.GetResult<Prisma.$ContactOpportunityJoinPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ContactOpportunityJoins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactOpportunityJoinFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContactOpportunityJoins
     * const contactOpportunityJoins = await prisma.contactOpportunityJoin.findMany()
     * 
     * // Get first 10 ContactOpportunityJoins
     * const contactOpportunityJoins = await prisma.contactOpportunityJoin.findMany({ take: 10 })
     * 
     * // Only select the `contactId`
     * const contactOpportunityJoinWithContactIdOnly = await prisma.contactOpportunityJoin.findMany({ select: { contactId: true } })
     * 
     */
    findMany<T extends ContactOpportunityJoinFindManyArgs>(args?: SelectSubset<T, ContactOpportunityJoinFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactOpportunityJoinPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ContactOpportunityJoin.
     * @param {ContactOpportunityJoinCreateArgs} args - Arguments to create a ContactOpportunityJoin.
     * @example
     * // Create one ContactOpportunityJoin
     * const ContactOpportunityJoin = await prisma.contactOpportunityJoin.create({
     *   data: {
     *     // ... data to create a ContactOpportunityJoin
     *   }
     * })
     * 
     */
    create<T extends ContactOpportunityJoinCreateArgs>(args: SelectSubset<T, ContactOpportunityJoinCreateArgs<ExtArgs>>): Prisma__ContactOpportunityJoinClient<$Result.GetResult<Prisma.$ContactOpportunityJoinPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ContactOpportunityJoins.
     * @param {ContactOpportunityJoinCreateManyArgs} args - Arguments to create many ContactOpportunityJoins.
     * @example
     * // Create many ContactOpportunityJoins
     * const contactOpportunityJoin = await prisma.contactOpportunityJoin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactOpportunityJoinCreateManyArgs>(args?: SelectSubset<T, ContactOpportunityJoinCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContactOpportunityJoins and returns the data saved in the database.
     * @param {ContactOpportunityJoinCreateManyAndReturnArgs} args - Arguments to create many ContactOpportunityJoins.
     * @example
     * // Create many ContactOpportunityJoins
     * const contactOpportunityJoin = await prisma.contactOpportunityJoin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContactOpportunityJoins and only return the `contactId`
     * const contactOpportunityJoinWithContactIdOnly = await prisma.contactOpportunityJoin.createManyAndReturn({
     *   select: { contactId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactOpportunityJoinCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactOpportunityJoinCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactOpportunityJoinPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a ContactOpportunityJoin.
     * @param {ContactOpportunityJoinDeleteArgs} args - Arguments to delete one ContactOpportunityJoin.
     * @example
     * // Delete one ContactOpportunityJoin
     * const ContactOpportunityJoin = await prisma.contactOpportunityJoin.delete({
     *   where: {
     *     // ... filter to delete one ContactOpportunityJoin
     *   }
     * })
     * 
     */
    delete<T extends ContactOpportunityJoinDeleteArgs>(args: SelectSubset<T, ContactOpportunityJoinDeleteArgs<ExtArgs>>): Prisma__ContactOpportunityJoinClient<$Result.GetResult<Prisma.$ContactOpportunityJoinPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ContactOpportunityJoin.
     * @param {ContactOpportunityJoinUpdateArgs} args - Arguments to update one ContactOpportunityJoin.
     * @example
     * // Update one ContactOpportunityJoin
     * const contactOpportunityJoin = await prisma.contactOpportunityJoin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactOpportunityJoinUpdateArgs>(args: SelectSubset<T, ContactOpportunityJoinUpdateArgs<ExtArgs>>): Prisma__ContactOpportunityJoinClient<$Result.GetResult<Prisma.$ContactOpportunityJoinPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ContactOpportunityJoins.
     * @param {ContactOpportunityJoinDeleteManyArgs} args - Arguments to filter ContactOpportunityJoins to delete.
     * @example
     * // Delete a few ContactOpportunityJoins
     * const { count } = await prisma.contactOpportunityJoin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactOpportunityJoinDeleteManyArgs>(args?: SelectSubset<T, ContactOpportunityJoinDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactOpportunityJoins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactOpportunityJoinUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContactOpportunityJoins
     * const contactOpportunityJoin = await prisma.contactOpportunityJoin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactOpportunityJoinUpdateManyArgs>(args: SelectSubset<T, ContactOpportunityJoinUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactOpportunityJoins and returns the data updated in the database.
     * @param {ContactOpportunityJoinUpdateManyAndReturnArgs} args - Arguments to update many ContactOpportunityJoins.
     * @example
     * // Update many ContactOpportunityJoins
     * const contactOpportunityJoin = await prisma.contactOpportunityJoin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContactOpportunityJoins and only return the `contactId`
     * const contactOpportunityJoinWithContactIdOnly = await prisma.contactOpportunityJoin.updateManyAndReturn({
     *   select: { contactId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContactOpportunityJoinUpdateManyAndReturnArgs>(args: SelectSubset<T, ContactOpportunityJoinUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactOpportunityJoinPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one ContactOpportunityJoin.
     * @param {ContactOpportunityJoinUpsertArgs} args - Arguments to update or create a ContactOpportunityJoin.
     * @example
     * // Update or create a ContactOpportunityJoin
     * const contactOpportunityJoin = await prisma.contactOpportunityJoin.upsert({
     *   create: {
     *     // ... data to create a ContactOpportunityJoin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContactOpportunityJoin we want to update
     *   }
     * })
     */
    upsert<T extends ContactOpportunityJoinUpsertArgs>(args: SelectSubset<T, ContactOpportunityJoinUpsertArgs<ExtArgs>>): Prisma__ContactOpportunityJoinClient<$Result.GetResult<Prisma.$ContactOpportunityJoinPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ContactOpportunityJoins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactOpportunityJoinCountArgs} args - Arguments to filter ContactOpportunityJoins to count.
     * @example
     * // Count the number of ContactOpportunityJoins
     * const count = await prisma.contactOpportunityJoin.count({
     *   where: {
     *     // ... the filter for the ContactOpportunityJoins we want to count
     *   }
     * })
    **/
    count<T extends ContactOpportunityJoinCountArgs>(
      args?: Subset<T, ContactOpportunityJoinCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactOpportunityJoinCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContactOpportunityJoin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactOpportunityJoinAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactOpportunityJoinAggregateArgs>(args: Subset<T, ContactOpportunityJoinAggregateArgs>): Prisma.PrismaPromise<GetContactOpportunityJoinAggregateType<T>>

    /**
     * Group by ContactOpportunityJoin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactOpportunityJoinGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactOpportunityJoinGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactOpportunityJoinGroupByArgs['orderBy'] }
        : { orderBy?: ContactOpportunityJoinGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactOpportunityJoinGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactOpportunityJoinGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContactOpportunityJoin model
   */
  readonly fields: ContactOpportunityJoinFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContactOpportunityJoin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactOpportunityJoinClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contactRelation<T extends ContactDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContactDefaultArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    opportunityRelation<T extends OpportunityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OpportunityDefaultArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContactOpportunityJoin model
   */ 
  interface ContactOpportunityJoinFieldRefs {
    readonly contactId: FieldRef<"ContactOpportunityJoin", 'Bytes'>
    readonly opportunityId: FieldRef<"ContactOpportunityJoin", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * ContactOpportunityJoin findUnique
   */
  export type ContactOpportunityJoinFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactOpportunityJoin
     */
    select?: ContactOpportunityJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactOpportunityJoin
     */
    omit?: ContactOpportunityJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactOpportunityJoinInclude<ExtArgs> | null
    /**
     * Filter, which ContactOpportunityJoin to fetch.
     */
    where: ContactOpportunityJoinWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactOpportunityJoin findUniqueOrThrow
   */
  export type ContactOpportunityJoinFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactOpportunityJoin
     */
    select?: ContactOpportunityJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactOpportunityJoin
     */
    omit?: ContactOpportunityJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactOpportunityJoinInclude<ExtArgs> | null
    /**
     * Filter, which ContactOpportunityJoin to fetch.
     */
    where: ContactOpportunityJoinWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactOpportunityJoin findFirst
   */
  export type ContactOpportunityJoinFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactOpportunityJoin
     */
    select?: ContactOpportunityJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactOpportunityJoin
     */
    omit?: ContactOpportunityJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactOpportunityJoinInclude<ExtArgs> | null
    /**
     * Filter, which ContactOpportunityJoin to fetch.
     */
    where?: ContactOpportunityJoinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactOpportunityJoins to fetch.
     */
    orderBy?: ContactOpportunityJoinOrderByWithRelationInput | ContactOpportunityJoinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactOpportunityJoins.
     */
    cursor?: ContactOpportunityJoinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactOpportunityJoins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactOpportunityJoins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactOpportunityJoins.
     */
    distinct?: ContactOpportunityJoinScalarFieldEnum | ContactOpportunityJoinScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactOpportunityJoin findFirstOrThrow
   */
  export type ContactOpportunityJoinFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactOpportunityJoin
     */
    select?: ContactOpportunityJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactOpportunityJoin
     */
    omit?: ContactOpportunityJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactOpportunityJoinInclude<ExtArgs> | null
    /**
     * Filter, which ContactOpportunityJoin to fetch.
     */
    where?: ContactOpportunityJoinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactOpportunityJoins to fetch.
     */
    orderBy?: ContactOpportunityJoinOrderByWithRelationInput | ContactOpportunityJoinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactOpportunityJoins.
     */
    cursor?: ContactOpportunityJoinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactOpportunityJoins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactOpportunityJoins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactOpportunityJoins.
     */
    distinct?: ContactOpportunityJoinScalarFieldEnum | ContactOpportunityJoinScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactOpportunityJoin findMany
   */
  export type ContactOpportunityJoinFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactOpportunityJoin
     */
    select?: ContactOpportunityJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactOpportunityJoin
     */
    omit?: ContactOpportunityJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactOpportunityJoinInclude<ExtArgs> | null
    /**
     * Filter, which ContactOpportunityJoins to fetch.
     */
    where?: ContactOpportunityJoinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactOpportunityJoins to fetch.
     */
    orderBy?: ContactOpportunityJoinOrderByWithRelationInput | ContactOpportunityJoinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContactOpportunityJoins.
     */
    cursor?: ContactOpportunityJoinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactOpportunityJoins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactOpportunityJoins.
     */
    skip?: number
    distinct?: ContactOpportunityJoinScalarFieldEnum | ContactOpportunityJoinScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactOpportunityJoin create
   */
  export type ContactOpportunityJoinCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactOpportunityJoin
     */
    select?: ContactOpportunityJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactOpportunityJoin
     */
    omit?: ContactOpportunityJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactOpportunityJoinInclude<ExtArgs> | null
    /**
     * The data needed to create a ContactOpportunityJoin.
     */
    data: XOR<ContactOpportunityJoinCreateInput, ContactOpportunityJoinUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactOpportunityJoin createMany
   */
  export type ContactOpportunityJoinCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContactOpportunityJoins.
     */
    data: ContactOpportunityJoinCreateManyInput | ContactOpportunityJoinCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactOpportunityJoin createManyAndReturn
   */
  export type ContactOpportunityJoinCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactOpportunityJoin
     */
    select?: ContactOpportunityJoinSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactOpportunityJoin
     */
    omit?: ContactOpportunityJoinOmit<ExtArgs> | null
    /**
     * The data used to create many ContactOpportunityJoins.
     */
    data: ContactOpportunityJoinCreateManyInput | ContactOpportunityJoinCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactOpportunityJoinIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContactOpportunityJoin update
   */
  export type ContactOpportunityJoinUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactOpportunityJoin
     */
    select?: ContactOpportunityJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactOpportunityJoin
     */
    omit?: ContactOpportunityJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactOpportunityJoinInclude<ExtArgs> | null
    /**
     * The data needed to update a ContactOpportunityJoin.
     */
    data: XOR<ContactOpportunityJoinUpdateInput, ContactOpportunityJoinUncheckedUpdateInput>
    /**
     * Choose, which ContactOpportunityJoin to update.
     */
    where: ContactOpportunityJoinWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactOpportunityJoin updateMany
   */
  export type ContactOpportunityJoinUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContactOpportunityJoins.
     */
    data: XOR<ContactOpportunityJoinUpdateManyMutationInput, ContactOpportunityJoinUncheckedUpdateManyInput>
    /**
     * Filter which ContactOpportunityJoins to update
     */
    where?: ContactOpportunityJoinWhereInput
    /**
     * Limit how many ContactOpportunityJoins to update.
     */
    limit?: number
  }

  /**
   * ContactOpportunityJoin updateManyAndReturn
   */
  export type ContactOpportunityJoinUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactOpportunityJoin
     */
    select?: ContactOpportunityJoinSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactOpportunityJoin
     */
    omit?: ContactOpportunityJoinOmit<ExtArgs> | null
    /**
     * The data used to update ContactOpportunityJoins.
     */
    data: XOR<ContactOpportunityJoinUpdateManyMutationInput, ContactOpportunityJoinUncheckedUpdateManyInput>
    /**
     * Filter which ContactOpportunityJoins to update
     */
    where?: ContactOpportunityJoinWhereInput
    /**
     * Limit how many ContactOpportunityJoins to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactOpportunityJoinIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContactOpportunityJoin upsert
   */
  export type ContactOpportunityJoinUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactOpportunityJoin
     */
    select?: ContactOpportunityJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactOpportunityJoin
     */
    omit?: ContactOpportunityJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactOpportunityJoinInclude<ExtArgs> | null
    /**
     * The filter to search for the ContactOpportunityJoin to update in case it exists.
     */
    where: ContactOpportunityJoinWhereUniqueInput
    /**
     * In case the ContactOpportunityJoin found by the `where` argument doesn't exist, create a new ContactOpportunityJoin with this data.
     */
    create: XOR<ContactOpportunityJoinCreateInput, ContactOpportunityJoinUncheckedCreateInput>
    /**
     * In case the ContactOpportunityJoin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactOpportunityJoinUpdateInput, ContactOpportunityJoinUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactOpportunityJoin delete
   */
  export type ContactOpportunityJoinDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactOpportunityJoin
     */
    select?: ContactOpportunityJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactOpportunityJoin
     */
    omit?: ContactOpportunityJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactOpportunityJoinInclude<ExtArgs> | null
    /**
     * Filter which ContactOpportunityJoin to delete.
     */
    where: ContactOpportunityJoinWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ContactOpportunityJoin deleteMany
   */
  export type ContactOpportunityJoinDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactOpportunityJoins to delete
     */
    where?: ContactOpportunityJoinWhereInput
    /**
     * Limit how many ContactOpportunityJoins to delete.
     */
    limit?: number
  }

  /**
   * ContactOpportunityJoin without action
   */
  export type ContactOpportunityJoinDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactOpportunityJoin
     */
    select?: ContactOpportunityJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactOpportunityJoin
     */
    omit?: ContactOpportunityJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactOpportunityJoinInclude<ExtArgs> | null
  }


  /**
   * Model UserOpportunityJoin
   */

  export type AggregateUserOpportunityJoin = {
    _count: UserOpportunityJoinCountAggregateOutputType | null
    _min: UserOpportunityJoinMinAggregateOutputType | null
    _max: UserOpportunityJoinMaxAggregateOutputType | null
  }

  export type UserOpportunityJoinMinAggregateOutputType = {
    userId: Uint8Array | null
    opportunityId: Uint8Array | null
  }

  export type UserOpportunityJoinMaxAggregateOutputType = {
    userId: Uint8Array | null
    opportunityId: Uint8Array | null
  }

  export type UserOpportunityJoinCountAggregateOutputType = {
    userId: number
    opportunityId: number
    _all: number
  }


  export type UserOpportunityJoinMinAggregateInputType = {
    userId?: true
    opportunityId?: true
  }

  export type UserOpportunityJoinMaxAggregateInputType = {
    userId?: true
    opportunityId?: true
  }

  export type UserOpportunityJoinCountAggregateInputType = {
    userId?: true
    opportunityId?: true
    _all?: true
  }

  export type UserOpportunityJoinAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserOpportunityJoin to aggregate.
     */
    where?: UserOpportunityJoinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserOpportunityJoins to fetch.
     */
    orderBy?: UserOpportunityJoinOrderByWithRelationInput | UserOpportunityJoinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserOpportunityJoinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserOpportunityJoins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserOpportunityJoins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserOpportunityJoins
    **/
    _count?: true | UserOpportunityJoinCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserOpportunityJoinMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserOpportunityJoinMaxAggregateInputType
  }

  export type GetUserOpportunityJoinAggregateType<T extends UserOpportunityJoinAggregateArgs> = {
        [P in keyof T & keyof AggregateUserOpportunityJoin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserOpportunityJoin[P]>
      : GetScalarType<T[P], AggregateUserOpportunityJoin[P]>
  }




  export type UserOpportunityJoinGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserOpportunityJoinWhereInput
    orderBy?: UserOpportunityJoinOrderByWithAggregationInput | UserOpportunityJoinOrderByWithAggregationInput[]
    by: UserOpportunityJoinScalarFieldEnum[] | UserOpportunityJoinScalarFieldEnum
    having?: UserOpportunityJoinScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserOpportunityJoinCountAggregateInputType | true
    _min?: UserOpportunityJoinMinAggregateInputType
    _max?: UserOpportunityJoinMaxAggregateInputType
  }

  export type UserOpportunityJoinGroupByOutputType = {
    userId: Uint8Array
    opportunityId: Uint8Array
    _count: UserOpportunityJoinCountAggregateOutputType | null
    _min: UserOpportunityJoinMinAggregateOutputType | null
    _max: UserOpportunityJoinMaxAggregateOutputType | null
  }

  type GetUserOpportunityJoinGroupByPayload<T extends UserOpportunityJoinGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserOpportunityJoinGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserOpportunityJoinGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserOpportunityJoinGroupByOutputType[P]>
            : GetScalarType<T[P], UserOpportunityJoinGroupByOutputType[P]>
        }
      >
    >


  export type UserOpportunityJoinSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    opportunityId?: boolean
    userRelation?: boolean | UserDefaultArgs<ExtArgs>
    opportunityRelation?: boolean | OpportunityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userOpportunityJoin"]>

  export type UserOpportunityJoinSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    opportunityId?: boolean
    userRelation?: boolean | UserDefaultArgs<ExtArgs>
    opportunityRelation?: boolean | OpportunityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userOpportunityJoin"]>

  export type UserOpportunityJoinSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    opportunityId?: boolean
    userRelation?: boolean | UserDefaultArgs<ExtArgs>
    opportunityRelation?: boolean | OpportunityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userOpportunityJoin"]>

  export type UserOpportunityJoinSelectScalar = {
    userId?: boolean
    opportunityId?: boolean
  }

  export type UserOpportunityJoinOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "opportunityId", ExtArgs["result"]["userOpportunityJoin"]>
  export type UserOpportunityJoinInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userRelation?: boolean | UserDefaultArgs<ExtArgs>
    opportunityRelation?: boolean | OpportunityDefaultArgs<ExtArgs>
  }
  export type UserOpportunityJoinIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userRelation?: boolean | UserDefaultArgs<ExtArgs>
    opportunityRelation?: boolean | OpportunityDefaultArgs<ExtArgs>
  }
  export type UserOpportunityJoinIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userRelation?: boolean | UserDefaultArgs<ExtArgs>
    opportunityRelation?: boolean | OpportunityDefaultArgs<ExtArgs>
  }

  export type $UserOpportunityJoinPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserOpportunityJoin"
    objects: {
      userRelation: Prisma.$UserPayload<ExtArgs>
      opportunityRelation: Prisma.$OpportunityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      /**
       * @@wrapper-ignore
       */
      userId: Uint8Array
      opportunityId: Uint8Array
    }, ExtArgs["result"]["userOpportunityJoin"]>
    composites: {}
  }

  type UserOpportunityJoinGetPayload<S extends boolean | null | undefined | UserOpportunityJoinDefaultArgs> = $Result.GetResult<Prisma.$UserOpportunityJoinPayload, S>

  type UserOpportunityJoinCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserOpportunityJoinFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: UserOpportunityJoinCountAggregateInputType | true
    }

  export interface UserOpportunityJoinDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserOpportunityJoin'], meta: { name: 'UserOpportunityJoin' } }
    /**
     * Find zero or one UserOpportunityJoin that matches the filter.
     * @param {UserOpportunityJoinFindUniqueArgs} args - Arguments to find a UserOpportunityJoin
     * @example
     * // Get one UserOpportunityJoin
     * const userOpportunityJoin = await prisma.userOpportunityJoin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserOpportunityJoinFindUniqueArgs>(args: SelectSubset<T, UserOpportunityJoinFindUniqueArgs<ExtArgs>>): Prisma__UserOpportunityJoinClient<$Result.GetResult<Prisma.$UserOpportunityJoinPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one UserOpportunityJoin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserOpportunityJoinFindUniqueOrThrowArgs} args - Arguments to find a UserOpportunityJoin
     * @example
     * // Get one UserOpportunityJoin
     * const userOpportunityJoin = await prisma.userOpportunityJoin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserOpportunityJoinFindUniqueOrThrowArgs>(args: SelectSubset<T, UserOpportunityJoinFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserOpportunityJoinClient<$Result.GetResult<Prisma.$UserOpportunityJoinPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first UserOpportunityJoin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOpportunityJoinFindFirstArgs} args - Arguments to find a UserOpportunityJoin
     * @example
     * // Get one UserOpportunityJoin
     * const userOpportunityJoin = await prisma.userOpportunityJoin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserOpportunityJoinFindFirstArgs>(args?: SelectSubset<T, UserOpportunityJoinFindFirstArgs<ExtArgs>>): Prisma__UserOpportunityJoinClient<$Result.GetResult<Prisma.$UserOpportunityJoinPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first UserOpportunityJoin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOpportunityJoinFindFirstOrThrowArgs} args - Arguments to find a UserOpportunityJoin
     * @example
     * // Get one UserOpportunityJoin
     * const userOpportunityJoin = await prisma.userOpportunityJoin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserOpportunityJoinFindFirstOrThrowArgs>(args?: SelectSubset<T, UserOpportunityJoinFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserOpportunityJoinClient<$Result.GetResult<Prisma.$UserOpportunityJoinPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more UserOpportunityJoins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOpportunityJoinFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserOpportunityJoins
     * const userOpportunityJoins = await prisma.userOpportunityJoin.findMany()
     * 
     * // Get first 10 UserOpportunityJoins
     * const userOpportunityJoins = await prisma.userOpportunityJoin.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userOpportunityJoinWithUserIdOnly = await prisma.userOpportunityJoin.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserOpportunityJoinFindManyArgs>(args?: SelectSubset<T, UserOpportunityJoinFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserOpportunityJoinPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a UserOpportunityJoin.
     * @param {UserOpportunityJoinCreateArgs} args - Arguments to create a UserOpportunityJoin.
     * @example
     * // Create one UserOpportunityJoin
     * const UserOpportunityJoin = await prisma.userOpportunityJoin.create({
     *   data: {
     *     // ... data to create a UserOpportunityJoin
     *   }
     * })
     * 
     */
    create<T extends UserOpportunityJoinCreateArgs>(args: SelectSubset<T, UserOpportunityJoinCreateArgs<ExtArgs>>): Prisma__UserOpportunityJoinClient<$Result.GetResult<Prisma.$UserOpportunityJoinPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many UserOpportunityJoins.
     * @param {UserOpportunityJoinCreateManyArgs} args - Arguments to create many UserOpportunityJoins.
     * @example
     * // Create many UserOpportunityJoins
     * const userOpportunityJoin = await prisma.userOpportunityJoin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserOpportunityJoinCreateManyArgs>(args?: SelectSubset<T, UserOpportunityJoinCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserOpportunityJoins and returns the data saved in the database.
     * @param {UserOpportunityJoinCreateManyAndReturnArgs} args - Arguments to create many UserOpportunityJoins.
     * @example
     * // Create many UserOpportunityJoins
     * const userOpportunityJoin = await prisma.userOpportunityJoin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserOpportunityJoins and only return the `userId`
     * const userOpportunityJoinWithUserIdOnly = await prisma.userOpportunityJoin.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserOpportunityJoinCreateManyAndReturnArgs>(args?: SelectSubset<T, UserOpportunityJoinCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserOpportunityJoinPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a UserOpportunityJoin.
     * @param {UserOpportunityJoinDeleteArgs} args - Arguments to delete one UserOpportunityJoin.
     * @example
     * // Delete one UserOpportunityJoin
     * const UserOpportunityJoin = await prisma.userOpportunityJoin.delete({
     *   where: {
     *     // ... filter to delete one UserOpportunityJoin
     *   }
     * })
     * 
     */
    delete<T extends UserOpportunityJoinDeleteArgs>(args: SelectSubset<T, UserOpportunityJoinDeleteArgs<ExtArgs>>): Prisma__UserOpportunityJoinClient<$Result.GetResult<Prisma.$UserOpportunityJoinPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one UserOpportunityJoin.
     * @param {UserOpportunityJoinUpdateArgs} args - Arguments to update one UserOpportunityJoin.
     * @example
     * // Update one UserOpportunityJoin
     * const userOpportunityJoin = await prisma.userOpportunityJoin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserOpportunityJoinUpdateArgs>(args: SelectSubset<T, UserOpportunityJoinUpdateArgs<ExtArgs>>): Prisma__UserOpportunityJoinClient<$Result.GetResult<Prisma.$UserOpportunityJoinPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more UserOpportunityJoins.
     * @param {UserOpportunityJoinDeleteManyArgs} args - Arguments to filter UserOpportunityJoins to delete.
     * @example
     * // Delete a few UserOpportunityJoins
     * const { count } = await prisma.userOpportunityJoin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserOpportunityJoinDeleteManyArgs>(args?: SelectSubset<T, UserOpportunityJoinDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserOpportunityJoins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOpportunityJoinUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserOpportunityJoins
     * const userOpportunityJoin = await prisma.userOpportunityJoin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserOpportunityJoinUpdateManyArgs>(args: SelectSubset<T, UserOpportunityJoinUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserOpportunityJoins and returns the data updated in the database.
     * @param {UserOpportunityJoinUpdateManyAndReturnArgs} args - Arguments to update many UserOpportunityJoins.
     * @example
     * // Update many UserOpportunityJoins
     * const userOpportunityJoin = await prisma.userOpportunityJoin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserOpportunityJoins and only return the `userId`
     * const userOpportunityJoinWithUserIdOnly = await prisma.userOpportunityJoin.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserOpportunityJoinUpdateManyAndReturnArgs>(args: SelectSubset<T, UserOpportunityJoinUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserOpportunityJoinPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one UserOpportunityJoin.
     * @param {UserOpportunityJoinUpsertArgs} args - Arguments to update or create a UserOpportunityJoin.
     * @example
     * // Update or create a UserOpportunityJoin
     * const userOpportunityJoin = await prisma.userOpportunityJoin.upsert({
     *   create: {
     *     // ... data to create a UserOpportunityJoin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserOpportunityJoin we want to update
     *   }
     * })
     */
    upsert<T extends UserOpportunityJoinUpsertArgs>(args: SelectSubset<T, UserOpportunityJoinUpsertArgs<ExtArgs>>): Prisma__UserOpportunityJoinClient<$Result.GetResult<Prisma.$UserOpportunityJoinPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of UserOpportunityJoins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOpportunityJoinCountArgs} args - Arguments to filter UserOpportunityJoins to count.
     * @example
     * // Count the number of UserOpportunityJoins
     * const count = await prisma.userOpportunityJoin.count({
     *   where: {
     *     // ... the filter for the UserOpportunityJoins we want to count
     *   }
     * })
    **/
    count<T extends UserOpportunityJoinCountArgs>(
      args?: Subset<T, UserOpportunityJoinCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserOpportunityJoinCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserOpportunityJoin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOpportunityJoinAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserOpportunityJoinAggregateArgs>(args: Subset<T, UserOpportunityJoinAggregateArgs>): Prisma.PrismaPromise<GetUserOpportunityJoinAggregateType<T>>

    /**
     * Group by UserOpportunityJoin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOpportunityJoinGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserOpportunityJoinGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserOpportunityJoinGroupByArgs['orderBy'] }
        : { orderBy?: UserOpportunityJoinGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserOpportunityJoinGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserOpportunityJoinGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserOpportunityJoin model
   */
  readonly fields: UserOpportunityJoinFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserOpportunityJoin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserOpportunityJoinClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userRelation<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    opportunityRelation<T extends OpportunityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OpportunityDefaultArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserOpportunityJoin model
   */ 
  interface UserOpportunityJoinFieldRefs {
    readonly userId: FieldRef<"UserOpportunityJoin", 'Bytes'>
    readonly opportunityId: FieldRef<"UserOpportunityJoin", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * UserOpportunityJoin findUnique
   */
  export type UserOpportunityJoinFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOpportunityJoin
     */
    select?: UserOpportunityJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserOpportunityJoin
     */
    omit?: UserOpportunityJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOpportunityJoinInclude<ExtArgs> | null
    /**
     * Filter, which UserOpportunityJoin to fetch.
     */
    where: UserOpportunityJoinWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserOpportunityJoin findUniqueOrThrow
   */
  export type UserOpportunityJoinFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOpportunityJoin
     */
    select?: UserOpportunityJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserOpportunityJoin
     */
    omit?: UserOpportunityJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOpportunityJoinInclude<ExtArgs> | null
    /**
     * Filter, which UserOpportunityJoin to fetch.
     */
    where: UserOpportunityJoinWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserOpportunityJoin findFirst
   */
  export type UserOpportunityJoinFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOpportunityJoin
     */
    select?: UserOpportunityJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserOpportunityJoin
     */
    omit?: UserOpportunityJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOpportunityJoinInclude<ExtArgs> | null
    /**
     * Filter, which UserOpportunityJoin to fetch.
     */
    where?: UserOpportunityJoinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserOpportunityJoins to fetch.
     */
    orderBy?: UserOpportunityJoinOrderByWithRelationInput | UserOpportunityJoinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserOpportunityJoins.
     */
    cursor?: UserOpportunityJoinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserOpportunityJoins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserOpportunityJoins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserOpportunityJoins.
     */
    distinct?: UserOpportunityJoinScalarFieldEnum | UserOpportunityJoinScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserOpportunityJoin findFirstOrThrow
   */
  export type UserOpportunityJoinFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOpportunityJoin
     */
    select?: UserOpportunityJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserOpportunityJoin
     */
    omit?: UserOpportunityJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOpportunityJoinInclude<ExtArgs> | null
    /**
     * Filter, which UserOpportunityJoin to fetch.
     */
    where?: UserOpportunityJoinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserOpportunityJoins to fetch.
     */
    orderBy?: UserOpportunityJoinOrderByWithRelationInput | UserOpportunityJoinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserOpportunityJoins.
     */
    cursor?: UserOpportunityJoinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserOpportunityJoins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserOpportunityJoins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserOpportunityJoins.
     */
    distinct?: UserOpportunityJoinScalarFieldEnum | UserOpportunityJoinScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserOpportunityJoin findMany
   */
  export type UserOpportunityJoinFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOpportunityJoin
     */
    select?: UserOpportunityJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserOpportunityJoin
     */
    omit?: UserOpportunityJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOpportunityJoinInclude<ExtArgs> | null
    /**
     * Filter, which UserOpportunityJoins to fetch.
     */
    where?: UserOpportunityJoinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserOpportunityJoins to fetch.
     */
    orderBy?: UserOpportunityJoinOrderByWithRelationInput | UserOpportunityJoinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserOpportunityJoins.
     */
    cursor?: UserOpportunityJoinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserOpportunityJoins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserOpportunityJoins.
     */
    skip?: number
    distinct?: UserOpportunityJoinScalarFieldEnum | UserOpportunityJoinScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserOpportunityJoin create
   */
  export type UserOpportunityJoinCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOpportunityJoin
     */
    select?: UserOpportunityJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserOpportunityJoin
     */
    omit?: UserOpportunityJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOpportunityJoinInclude<ExtArgs> | null
    /**
     * The data needed to create a UserOpportunityJoin.
     */
    data: XOR<UserOpportunityJoinCreateInput, UserOpportunityJoinUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserOpportunityJoin createMany
   */
  export type UserOpportunityJoinCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserOpportunityJoins.
     */
    data: UserOpportunityJoinCreateManyInput | UserOpportunityJoinCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserOpportunityJoin createManyAndReturn
   */
  export type UserOpportunityJoinCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOpportunityJoin
     */
    select?: UserOpportunityJoinSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserOpportunityJoin
     */
    omit?: UserOpportunityJoinOmit<ExtArgs> | null
    /**
     * The data used to create many UserOpportunityJoins.
     */
    data: UserOpportunityJoinCreateManyInput | UserOpportunityJoinCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOpportunityJoinIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserOpportunityJoin update
   */
  export type UserOpportunityJoinUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOpportunityJoin
     */
    select?: UserOpportunityJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserOpportunityJoin
     */
    omit?: UserOpportunityJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOpportunityJoinInclude<ExtArgs> | null
    /**
     * The data needed to update a UserOpportunityJoin.
     */
    data: XOR<UserOpportunityJoinUpdateInput, UserOpportunityJoinUncheckedUpdateInput>
    /**
     * Choose, which UserOpportunityJoin to update.
     */
    where: UserOpportunityJoinWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserOpportunityJoin updateMany
   */
  export type UserOpportunityJoinUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserOpportunityJoins.
     */
    data: XOR<UserOpportunityJoinUpdateManyMutationInput, UserOpportunityJoinUncheckedUpdateManyInput>
    /**
     * Filter which UserOpportunityJoins to update
     */
    where?: UserOpportunityJoinWhereInput
    /**
     * Limit how many UserOpportunityJoins to update.
     */
    limit?: number
  }

  /**
   * UserOpportunityJoin updateManyAndReturn
   */
  export type UserOpportunityJoinUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOpportunityJoin
     */
    select?: UserOpportunityJoinSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserOpportunityJoin
     */
    omit?: UserOpportunityJoinOmit<ExtArgs> | null
    /**
     * The data used to update UserOpportunityJoins.
     */
    data: XOR<UserOpportunityJoinUpdateManyMutationInput, UserOpportunityJoinUncheckedUpdateManyInput>
    /**
     * Filter which UserOpportunityJoins to update
     */
    where?: UserOpportunityJoinWhereInput
    /**
     * Limit how many UserOpportunityJoins to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOpportunityJoinIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserOpportunityJoin upsert
   */
  export type UserOpportunityJoinUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOpportunityJoin
     */
    select?: UserOpportunityJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserOpportunityJoin
     */
    omit?: UserOpportunityJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOpportunityJoinInclude<ExtArgs> | null
    /**
     * The filter to search for the UserOpportunityJoin to update in case it exists.
     */
    where: UserOpportunityJoinWhereUniqueInput
    /**
     * In case the UserOpportunityJoin found by the `where` argument doesn't exist, create a new UserOpportunityJoin with this data.
     */
    create: XOR<UserOpportunityJoinCreateInput, UserOpportunityJoinUncheckedCreateInput>
    /**
     * In case the UserOpportunityJoin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserOpportunityJoinUpdateInput, UserOpportunityJoinUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserOpportunityJoin delete
   */
  export type UserOpportunityJoinDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOpportunityJoin
     */
    select?: UserOpportunityJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserOpportunityJoin
     */
    omit?: UserOpportunityJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOpportunityJoinInclude<ExtArgs> | null
    /**
     * Filter which UserOpportunityJoin to delete.
     */
    where: UserOpportunityJoinWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * UserOpportunityJoin deleteMany
   */
  export type UserOpportunityJoinDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserOpportunityJoins to delete
     */
    where?: UserOpportunityJoinWhereInput
    /**
     * Limit how many UserOpportunityJoins to delete.
     */
    limit?: number
  }

  /**
   * UserOpportunityJoin without action
   */
  export type UserOpportunityJoinDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOpportunityJoin
     */
    select?: UserOpportunityJoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserOpportunityJoin
     */
    omit?: UserOpportunityJoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOpportunityJoinInclude<ExtArgs> | null
  }


  /**
   * Model OpportunityProduct
   */

  export type AggregateOpportunityProduct = {
    _count: OpportunityProductCountAggregateOutputType | null
    _avg: OpportunityProductAvgAggregateOutputType | null
    _sum: OpportunityProductSumAggregateOutputType | null
    _min: OpportunityProductMinAggregateOutputType | null
    _max: OpportunityProductMaxAggregateOutputType | null
  }

  export type OpportunityProductAvgAggregateOutputType = {
    price: number | null
    order: number | null
    commission: number | null
  }

  export type OpportunityProductSumAggregateOutputType = {
    price: number | null
    order: number | null
    commission: number | null
  }

  export type OpportunityProductMinAggregateOutputType = {
    id: Uint8Array | null
    price: number | null
    order: number | null
    commission: number | null
    opportunityId: Uint8Array | null
    productTypeId: Uint8Array | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OpportunityProductMaxAggregateOutputType = {
    id: Uint8Array | null
    price: number | null
    order: number | null
    commission: number | null
    opportunityId: Uint8Array | null
    productTypeId: Uint8Array | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OpportunityProductCountAggregateOutputType = {
    id: number
    price: number
    order: number
    commission: number
    opportunityId: number
    productTypeId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OpportunityProductAvgAggregateInputType = {
    price?: true
    order?: true
    commission?: true
  }

  export type OpportunityProductSumAggregateInputType = {
    price?: true
    order?: true
    commission?: true
  }

  export type OpportunityProductMinAggregateInputType = {
    id?: true
    price?: true
    order?: true
    commission?: true
    opportunityId?: true
    productTypeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OpportunityProductMaxAggregateInputType = {
    id?: true
    price?: true
    order?: true
    commission?: true
    opportunityId?: true
    productTypeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OpportunityProductCountAggregateInputType = {
    id?: true
    price?: true
    order?: true
    commission?: true
    opportunityId?: true
    productTypeId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OpportunityProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OpportunityProduct to aggregate.
     */
    where?: OpportunityProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpportunityProducts to fetch.
     */
    orderBy?: OpportunityProductOrderByWithRelationInput | OpportunityProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OpportunityProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpportunityProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpportunityProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OpportunityProducts
    **/
    _count?: true | OpportunityProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OpportunityProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OpportunityProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OpportunityProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OpportunityProductMaxAggregateInputType
  }

  export type GetOpportunityProductAggregateType<T extends OpportunityProductAggregateArgs> = {
        [P in keyof T & keyof AggregateOpportunityProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOpportunityProduct[P]>
      : GetScalarType<T[P], AggregateOpportunityProduct[P]>
  }




  export type OpportunityProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OpportunityProductWhereInput
    orderBy?: OpportunityProductOrderByWithAggregationInput | OpportunityProductOrderByWithAggregationInput[]
    by: OpportunityProductScalarFieldEnum[] | OpportunityProductScalarFieldEnum
    having?: OpportunityProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OpportunityProductCountAggregateInputType | true
    _avg?: OpportunityProductAvgAggregateInputType
    _sum?: OpportunityProductSumAggregateInputType
    _min?: OpportunityProductMinAggregateInputType
    _max?: OpportunityProductMaxAggregateInputType
  }

  export type OpportunityProductGroupByOutputType = {
    id: Uint8Array
    price: number
    order: number
    commission: number
    opportunityId: Uint8Array
    productTypeId: Uint8Array
    createdAt: Date
    updatedAt: Date
    _count: OpportunityProductCountAggregateOutputType | null
    _avg: OpportunityProductAvgAggregateOutputType | null
    _sum: OpportunityProductSumAggregateOutputType | null
    _min: OpportunityProductMinAggregateOutputType | null
    _max: OpportunityProductMaxAggregateOutputType | null
  }

  type GetOpportunityProductGroupByPayload<T extends OpportunityProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OpportunityProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OpportunityProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OpportunityProductGroupByOutputType[P]>
            : GetScalarType<T[P], OpportunityProductGroupByOutputType[P]>
        }
      >
    >


  export type OpportunityProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    price?: boolean
    order?: boolean
    commission?: boolean
    opportunityId?: boolean
    productTypeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    opportunity?: boolean | OpportunityDefaultArgs<ExtArgs>
    productType?: boolean | ProductTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["opportunityProduct"]>

  export type OpportunityProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    price?: boolean
    order?: boolean
    commission?: boolean
    opportunityId?: boolean
    productTypeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    opportunity?: boolean | OpportunityDefaultArgs<ExtArgs>
    productType?: boolean | ProductTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["opportunityProduct"]>

  export type OpportunityProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    price?: boolean
    order?: boolean
    commission?: boolean
    opportunityId?: boolean
    productTypeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    opportunity?: boolean | OpportunityDefaultArgs<ExtArgs>
    productType?: boolean | ProductTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["opportunityProduct"]>

  export type OpportunityProductSelectScalar = {
    id?: boolean
    price?: boolean
    order?: boolean
    commission?: boolean
    opportunityId?: boolean
    productTypeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OpportunityProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "price" | "order" | "commission" | "opportunityId" | "productTypeId" | "createdAt" | "updatedAt", ExtArgs["result"]["opportunityProduct"]>
  export type OpportunityProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    opportunity?: boolean | OpportunityDefaultArgs<ExtArgs>
    productType?: boolean | ProductTypeDefaultArgs<ExtArgs>
  }
  export type OpportunityProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    opportunity?: boolean | OpportunityDefaultArgs<ExtArgs>
    productType?: boolean | ProductTypeDefaultArgs<ExtArgs>
  }
  export type OpportunityProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    opportunity?: boolean | OpportunityDefaultArgs<ExtArgs>
    productType?: boolean | ProductTypeDefaultArgs<ExtArgs>
  }

  export type $OpportunityProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OpportunityProduct"
    objects: {
      opportunity: Prisma.$OpportunityPayload<ExtArgs>
      productType: Prisma.$ProductTypePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      /**
       * @@ai-enabled
       */
      id: Uint8Array
      /**
       * @ai-field
       */
      price: number
      /**
       * @ai-field(Display order)
       */
      order: number
      /**
       * @ai-field
       */
      commission: number
      opportunityId: Uint8Array
      productTypeId: Uint8Array
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["opportunityProduct"]>
    composites: {}
  }

  type OpportunityProductGetPayload<S extends boolean | null | undefined | OpportunityProductDefaultArgs> = $Result.GetResult<Prisma.$OpportunityProductPayload, S>

  type OpportunityProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OpportunityProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: OpportunityProductCountAggregateInputType | true
    }

  export interface OpportunityProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OpportunityProduct'], meta: { name: 'OpportunityProduct' } }
    /**
     * Find zero or one OpportunityProduct that matches the filter.
     * @param {OpportunityProductFindUniqueArgs} args - Arguments to find a OpportunityProduct
     * @example
     * // Get one OpportunityProduct
     * const opportunityProduct = await prisma.opportunityProduct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OpportunityProductFindUniqueArgs>(args: SelectSubset<T, OpportunityProductFindUniqueArgs<ExtArgs>>): Prisma__OpportunityProductClient<$Result.GetResult<Prisma.$OpportunityProductPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one OpportunityProduct that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OpportunityProductFindUniqueOrThrowArgs} args - Arguments to find a OpportunityProduct
     * @example
     * // Get one OpportunityProduct
     * const opportunityProduct = await prisma.opportunityProduct.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OpportunityProductFindUniqueOrThrowArgs>(args: SelectSubset<T, OpportunityProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OpportunityProductClient<$Result.GetResult<Prisma.$OpportunityProductPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first OpportunityProduct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityProductFindFirstArgs} args - Arguments to find a OpportunityProduct
     * @example
     * // Get one OpportunityProduct
     * const opportunityProduct = await prisma.opportunityProduct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OpportunityProductFindFirstArgs>(args?: SelectSubset<T, OpportunityProductFindFirstArgs<ExtArgs>>): Prisma__OpportunityProductClient<$Result.GetResult<Prisma.$OpportunityProductPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first OpportunityProduct that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityProductFindFirstOrThrowArgs} args - Arguments to find a OpportunityProduct
     * @example
     * // Get one OpportunityProduct
     * const opportunityProduct = await prisma.opportunityProduct.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OpportunityProductFindFirstOrThrowArgs>(args?: SelectSubset<T, OpportunityProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__OpportunityProductClient<$Result.GetResult<Prisma.$OpportunityProductPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more OpportunityProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OpportunityProducts
     * const opportunityProducts = await prisma.opportunityProduct.findMany()
     * 
     * // Get first 10 OpportunityProducts
     * const opportunityProducts = await prisma.opportunityProduct.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const opportunityProductWithIdOnly = await prisma.opportunityProduct.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OpportunityProductFindManyArgs>(args?: SelectSubset<T, OpportunityProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpportunityProductPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a OpportunityProduct.
     * @param {OpportunityProductCreateArgs} args - Arguments to create a OpportunityProduct.
     * @example
     * // Create one OpportunityProduct
     * const OpportunityProduct = await prisma.opportunityProduct.create({
     *   data: {
     *     // ... data to create a OpportunityProduct
     *   }
     * })
     * 
     */
    create<T extends OpportunityProductCreateArgs>(args: SelectSubset<T, OpportunityProductCreateArgs<ExtArgs>>): Prisma__OpportunityProductClient<$Result.GetResult<Prisma.$OpportunityProductPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many OpportunityProducts.
     * @param {OpportunityProductCreateManyArgs} args - Arguments to create many OpportunityProducts.
     * @example
     * // Create many OpportunityProducts
     * const opportunityProduct = await prisma.opportunityProduct.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OpportunityProductCreateManyArgs>(args?: SelectSubset<T, OpportunityProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OpportunityProducts and returns the data saved in the database.
     * @param {OpportunityProductCreateManyAndReturnArgs} args - Arguments to create many OpportunityProducts.
     * @example
     * // Create many OpportunityProducts
     * const opportunityProduct = await prisma.opportunityProduct.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OpportunityProducts and only return the `id`
     * const opportunityProductWithIdOnly = await prisma.opportunityProduct.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OpportunityProductCreateManyAndReturnArgs>(args?: SelectSubset<T, OpportunityProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpportunityProductPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a OpportunityProduct.
     * @param {OpportunityProductDeleteArgs} args - Arguments to delete one OpportunityProduct.
     * @example
     * // Delete one OpportunityProduct
     * const OpportunityProduct = await prisma.opportunityProduct.delete({
     *   where: {
     *     // ... filter to delete one OpportunityProduct
     *   }
     * })
     * 
     */
    delete<T extends OpportunityProductDeleteArgs>(args: SelectSubset<T, OpportunityProductDeleteArgs<ExtArgs>>): Prisma__OpportunityProductClient<$Result.GetResult<Prisma.$OpportunityProductPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one OpportunityProduct.
     * @param {OpportunityProductUpdateArgs} args - Arguments to update one OpportunityProduct.
     * @example
     * // Update one OpportunityProduct
     * const opportunityProduct = await prisma.opportunityProduct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OpportunityProductUpdateArgs>(args: SelectSubset<T, OpportunityProductUpdateArgs<ExtArgs>>): Prisma__OpportunityProductClient<$Result.GetResult<Prisma.$OpportunityProductPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more OpportunityProducts.
     * @param {OpportunityProductDeleteManyArgs} args - Arguments to filter OpportunityProducts to delete.
     * @example
     * // Delete a few OpportunityProducts
     * const { count } = await prisma.opportunityProduct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OpportunityProductDeleteManyArgs>(args?: SelectSubset<T, OpportunityProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OpportunityProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OpportunityProducts
     * const opportunityProduct = await prisma.opportunityProduct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OpportunityProductUpdateManyArgs>(args: SelectSubset<T, OpportunityProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OpportunityProducts and returns the data updated in the database.
     * @param {OpportunityProductUpdateManyAndReturnArgs} args - Arguments to update many OpportunityProducts.
     * @example
     * // Update many OpportunityProducts
     * const opportunityProduct = await prisma.opportunityProduct.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OpportunityProducts and only return the `id`
     * const opportunityProductWithIdOnly = await prisma.opportunityProduct.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OpportunityProductUpdateManyAndReturnArgs>(args: SelectSubset<T, OpportunityProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpportunityProductPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one OpportunityProduct.
     * @param {OpportunityProductUpsertArgs} args - Arguments to update or create a OpportunityProduct.
     * @example
     * // Update or create a OpportunityProduct
     * const opportunityProduct = await prisma.opportunityProduct.upsert({
     *   create: {
     *     // ... data to create a OpportunityProduct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OpportunityProduct we want to update
     *   }
     * })
     */
    upsert<T extends OpportunityProductUpsertArgs>(args: SelectSubset<T, OpportunityProductUpsertArgs<ExtArgs>>): Prisma__OpportunityProductClient<$Result.GetResult<Prisma.$OpportunityProductPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of OpportunityProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityProductCountArgs} args - Arguments to filter OpportunityProducts to count.
     * @example
     * // Count the number of OpportunityProducts
     * const count = await prisma.opportunityProduct.count({
     *   where: {
     *     // ... the filter for the OpportunityProducts we want to count
     *   }
     * })
    **/
    count<T extends OpportunityProductCountArgs>(
      args?: Subset<T, OpportunityProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OpportunityProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OpportunityProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OpportunityProductAggregateArgs>(args: Subset<T, OpportunityProductAggregateArgs>): Prisma.PrismaPromise<GetOpportunityProductAggregateType<T>>

    /**
     * Group by OpportunityProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpportunityProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OpportunityProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OpportunityProductGroupByArgs['orderBy'] }
        : { orderBy?: OpportunityProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OpportunityProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOpportunityProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OpportunityProduct model
   */
  readonly fields: OpportunityProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OpportunityProduct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OpportunityProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    opportunity<T extends OpportunityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OpportunityDefaultArgs<ExtArgs>>): Prisma__OpportunityClient<$Result.GetResult<Prisma.$OpportunityPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    productType<T extends ProductTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductTypeDefaultArgs<ExtArgs>>): Prisma__ProductTypeClient<$Result.GetResult<Prisma.$ProductTypePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OpportunityProduct model
   */ 
  interface OpportunityProductFieldRefs {
    readonly id: FieldRef<"OpportunityProduct", 'Bytes'>
    readonly price: FieldRef<"OpportunityProduct", 'Float'>
    readonly order: FieldRef<"OpportunityProduct", 'Int'>
    readonly commission: FieldRef<"OpportunityProduct", 'Float'>
    readonly opportunityId: FieldRef<"OpportunityProduct", 'Bytes'>
    readonly productTypeId: FieldRef<"OpportunityProduct", 'Bytes'>
    readonly createdAt: FieldRef<"OpportunityProduct", 'DateTime'>
    readonly updatedAt: FieldRef<"OpportunityProduct", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OpportunityProduct findUnique
   */
  export type OpportunityProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpportunityProduct
     */
    select?: OpportunityProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpportunityProduct
     */
    omit?: OpportunityProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityProductInclude<ExtArgs> | null
    /**
     * Filter, which OpportunityProduct to fetch.
     */
    where: OpportunityProductWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * OpportunityProduct findUniqueOrThrow
   */
  export type OpportunityProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpportunityProduct
     */
    select?: OpportunityProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpportunityProduct
     */
    omit?: OpportunityProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityProductInclude<ExtArgs> | null
    /**
     * Filter, which OpportunityProduct to fetch.
     */
    where: OpportunityProductWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * OpportunityProduct findFirst
   */
  export type OpportunityProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpportunityProduct
     */
    select?: OpportunityProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpportunityProduct
     */
    omit?: OpportunityProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityProductInclude<ExtArgs> | null
    /**
     * Filter, which OpportunityProduct to fetch.
     */
    where?: OpportunityProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpportunityProducts to fetch.
     */
    orderBy?: OpportunityProductOrderByWithRelationInput | OpportunityProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OpportunityProducts.
     */
    cursor?: OpportunityProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpportunityProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpportunityProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OpportunityProducts.
     */
    distinct?: OpportunityProductScalarFieldEnum | OpportunityProductScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * OpportunityProduct findFirstOrThrow
   */
  export type OpportunityProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpportunityProduct
     */
    select?: OpportunityProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpportunityProduct
     */
    omit?: OpportunityProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityProductInclude<ExtArgs> | null
    /**
     * Filter, which OpportunityProduct to fetch.
     */
    where?: OpportunityProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpportunityProducts to fetch.
     */
    orderBy?: OpportunityProductOrderByWithRelationInput | OpportunityProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OpportunityProducts.
     */
    cursor?: OpportunityProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpportunityProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpportunityProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OpportunityProducts.
     */
    distinct?: OpportunityProductScalarFieldEnum | OpportunityProductScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * OpportunityProduct findMany
   */
  export type OpportunityProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpportunityProduct
     */
    select?: OpportunityProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpportunityProduct
     */
    omit?: OpportunityProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityProductInclude<ExtArgs> | null
    /**
     * Filter, which OpportunityProducts to fetch.
     */
    where?: OpportunityProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpportunityProducts to fetch.
     */
    orderBy?: OpportunityProductOrderByWithRelationInput | OpportunityProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OpportunityProducts.
     */
    cursor?: OpportunityProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpportunityProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpportunityProducts.
     */
    skip?: number
    distinct?: OpportunityProductScalarFieldEnum | OpportunityProductScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * OpportunityProduct create
   */
  export type OpportunityProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpportunityProduct
     */
    select?: OpportunityProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpportunityProduct
     */
    omit?: OpportunityProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityProductInclude<ExtArgs> | null
    /**
     * The data needed to create a OpportunityProduct.
     */
    data: XOR<OpportunityProductCreateInput, OpportunityProductUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * OpportunityProduct createMany
   */
  export type OpportunityProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OpportunityProducts.
     */
    data: OpportunityProductCreateManyInput | OpportunityProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OpportunityProduct createManyAndReturn
   */
  export type OpportunityProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpportunityProduct
     */
    select?: OpportunityProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OpportunityProduct
     */
    omit?: OpportunityProductOmit<ExtArgs> | null
    /**
     * The data used to create many OpportunityProducts.
     */
    data: OpportunityProductCreateManyInput | OpportunityProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OpportunityProduct update
   */
  export type OpportunityProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpportunityProduct
     */
    select?: OpportunityProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpportunityProduct
     */
    omit?: OpportunityProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityProductInclude<ExtArgs> | null
    /**
     * The data needed to update a OpportunityProduct.
     */
    data: XOR<OpportunityProductUpdateInput, OpportunityProductUncheckedUpdateInput>
    /**
     * Choose, which OpportunityProduct to update.
     */
    where: OpportunityProductWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * OpportunityProduct updateMany
   */
  export type OpportunityProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OpportunityProducts.
     */
    data: XOR<OpportunityProductUpdateManyMutationInput, OpportunityProductUncheckedUpdateManyInput>
    /**
     * Filter which OpportunityProducts to update
     */
    where?: OpportunityProductWhereInput
    /**
     * Limit how many OpportunityProducts to update.
     */
    limit?: number
  }

  /**
   * OpportunityProduct updateManyAndReturn
   */
  export type OpportunityProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpportunityProduct
     */
    select?: OpportunityProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OpportunityProduct
     */
    omit?: OpportunityProductOmit<ExtArgs> | null
    /**
     * The data used to update OpportunityProducts.
     */
    data: XOR<OpportunityProductUpdateManyMutationInput, OpportunityProductUncheckedUpdateManyInput>
    /**
     * Filter which OpportunityProducts to update
     */
    where?: OpportunityProductWhereInput
    /**
     * Limit how many OpportunityProducts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OpportunityProduct upsert
   */
  export type OpportunityProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpportunityProduct
     */
    select?: OpportunityProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpportunityProduct
     */
    omit?: OpportunityProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityProductInclude<ExtArgs> | null
    /**
     * The filter to search for the OpportunityProduct to update in case it exists.
     */
    where: OpportunityProductWhereUniqueInput
    /**
     * In case the OpportunityProduct found by the `where` argument doesn't exist, create a new OpportunityProduct with this data.
     */
    create: XOR<OpportunityProductCreateInput, OpportunityProductUncheckedCreateInput>
    /**
     * In case the OpportunityProduct was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OpportunityProductUpdateInput, OpportunityProductUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * OpportunityProduct delete
   */
  export type OpportunityProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpportunityProduct
     */
    select?: OpportunityProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpportunityProduct
     */
    omit?: OpportunityProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityProductInclude<ExtArgs> | null
    /**
     * Filter which OpportunityProduct to delete.
     */
    where: OpportunityProductWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * OpportunityProduct deleteMany
   */
  export type OpportunityProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OpportunityProducts to delete
     */
    where?: OpportunityProductWhereInput
    /**
     * Limit how many OpportunityProducts to delete.
     */
    limit?: number
  }

  /**
   * OpportunityProduct without action
   */
  export type OpportunityProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpportunityProduct
     */
    select?: OpportunityProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpportunityProduct
     */
    omit?: OpportunityProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityProductInclude<ExtArgs> | null
  }


  /**
   * Model ProductType
   */

  export type AggregateProductType = {
    _count: ProductTypeCountAggregateOutputType | null
    _avg: ProductTypeAvgAggregateOutputType | null
    _sum: ProductTypeSumAggregateOutputType | null
    _min: ProductTypeMinAggregateOutputType | null
    _max: ProductTypeMaxAggregateOutputType | null
  }

  export type ProductTypeAvgAggregateOutputType = {
    defaultCommission: number | null
  }

  export type ProductTypeSumAggregateOutputType = {
    defaultCommission: number | null
  }

  export type ProductTypeMinAggregateOutputType = {
    id: Uint8Array | null
    title: string | null
    description: string | null
    defaultCommission: number | null
    createdAt: Date | null
    updatedAt: Date | null
    tenetId: Uint8Array | null
  }

  export type ProductTypeMaxAggregateOutputType = {
    id: Uint8Array | null
    title: string | null
    description: string | null
    defaultCommission: number | null
    createdAt: Date | null
    updatedAt: Date | null
    tenetId: Uint8Array | null
  }

  export type ProductTypeCountAggregateOutputType = {
    id: number
    title: number
    description: number
    defaultCommission: number
    createdAt: number
    updatedAt: number
    tenetId: number
    _all: number
  }


  export type ProductTypeAvgAggregateInputType = {
    defaultCommission?: true
  }

  export type ProductTypeSumAggregateInputType = {
    defaultCommission?: true
  }

  export type ProductTypeMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    defaultCommission?: true
    createdAt?: true
    updatedAt?: true
    tenetId?: true
  }

  export type ProductTypeMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    defaultCommission?: true
    createdAt?: true
    updatedAt?: true
    tenetId?: true
  }

  export type ProductTypeCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    defaultCommission?: true
    createdAt?: true
    updatedAt?: true
    tenetId?: true
    _all?: true
  }

  export type ProductTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductType to aggregate.
     */
    where?: ProductTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductTypes to fetch.
     */
    orderBy?: ProductTypeOrderByWithRelationInput | ProductTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductTypes
    **/
    _count?: true | ProductTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductTypeMaxAggregateInputType
  }

  export type GetProductTypeAggregateType<T extends ProductTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateProductType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductType[P]>
      : GetScalarType<T[P], AggregateProductType[P]>
  }




  export type ProductTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductTypeWhereInput
    orderBy?: ProductTypeOrderByWithAggregationInput | ProductTypeOrderByWithAggregationInput[]
    by: ProductTypeScalarFieldEnum[] | ProductTypeScalarFieldEnum
    having?: ProductTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductTypeCountAggregateInputType | true
    _avg?: ProductTypeAvgAggregateInputType
    _sum?: ProductTypeSumAggregateInputType
    _min?: ProductTypeMinAggregateInputType
    _max?: ProductTypeMaxAggregateInputType
  }

  export type ProductTypeGroupByOutputType = {
    id: Uint8Array
    title: string
    description: string | null
    defaultCommission: number
    createdAt: Date
    updatedAt: Date
    tenetId: Uint8Array
    _count: ProductTypeCountAggregateOutputType | null
    _avg: ProductTypeAvgAggregateOutputType | null
    _sum: ProductTypeSumAggregateOutputType | null
    _min: ProductTypeMinAggregateOutputType | null
    _max: ProductTypeMaxAggregateOutputType | null
  }

  type GetProductTypeGroupByPayload<T extends ProductTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductTypeGroupByOutputType[P]>
            : GetScalarType<T[P], ProductTypeGroupByOutputType[P]>
        }
      >
    >


  export type ProductTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    defaultCommission?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenetId?: boolean
    opportunities?: boolean | ProductType$opportunitiesArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
    _count?: boolean | ProductTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productType"]>

  export type ProductTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    defaultCommission?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenetId?: boolean
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productType"]>

  export type ProductTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    defaultCommission?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenetId?: boolean
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productType"]>

  export type ProductTypeSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    defaultCommission?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenetId?: boolean
  }

  export type ProductTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "defaultCommission" | "createdAt" | "updatedAt" | "tenetId", ExtArgs["result"]["productType"]>
  export type ProductTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    opportunities?: boolean | ProductType$opportunitiesArgs<ExtArgs>
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
    _count?: boolean | ProductTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }
  export type ProductTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenet?: boolean | TenetDefaultArgs<ExtArgs>
  }

  export type $ProductTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductType"
    objects: {
      /**
       * @ai-field(Opportunities that depend on this product)
       */
      opportunities: Prisma.$OpportunityProductPayload<ExtArgs>[]
      tenet: Prisma.$TenetPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      /**
       * @@ai-enabled
       */
      id: Uint8Array
      /**
       * @ai-field
       */
      title: string
      /**
       * @ai-field
       */
      description: string | null
      /**
       * @ai-field
       */
      defaultCommission: number
      createdAt: Date
      updatedAt: Date
      tenetId: Uint8Array
    }, ExtArgs["result"]["productType"]>
    composites: {}
  }

  type ProductTypeGetPayload<S extends boolean | null | undefined | ProductTypeDefaultArgs> = $Result.GetResult<Prisma.$ProductTypePayload, S>

  type ProductTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: ProductTypeCountAggregateInputType | true
    }

  export interface ProductTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductType'], meta: { name: 'ProductType' } }
    /**
     * Find zero or one ProductType that matches the filter.
     * @param {ProductTypeFindUniqueArgs} args - Arguments to find a ProductType
     * @example
     * // Get one ProductType
     * const productType = await prisma.productType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductTypeFindUniqueArgs>(args: SelectSubset<T, ProductTypeFindUniqueArgs<ExtArgs>>): Prisma__ProductTypeClient<$Result.GetResult<Prisma.$ProductTypePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ProductType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductTypeFindUniqueOrThrowArgs} args - Arguments to find a ProductType
     * @example
     * // Get one ProductType
     * const productType = await prisma.productType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductTypeClient<$Result.GetResult<Prisma.$ProductTypePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ProductType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTypeFindFirstArgs} args - Arguments to find a ProductType
     * @example
     * // Get one ProductType
     * const productType = await prisma.productType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductTypeFindFirstArgs>(args?: SelectSubset<T, ProductTypeFindFirstArgs<ExtArgs>>): Prisma__ProductTypeClient<$Result.GetResult<Prisma.$ProductTypePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ProductType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTypeFindFirstOrThrowArgs} args - Arguments to find a ProductType
     * @example
     * // Get one ProductType
     * const productType = await prisma.productType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductTypeClient<$Result.GetResult<Prisma.$ProductTypePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ProductTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductTypes
     * const productTypes = await prisma.productType.findMany()
     * 
     * // Get first 10 ProductTypes
     * const productTypes = await prisma.productType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productTypeWithIdOnly = await prisma.productType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductTypeFindManyArgs>(args?: SelectSubset<T, ProductTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductTypePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ProductType.
     * @param {ProductTypeCreateArgs} args - Arguments to create a ProductType.
     * @example
     * // Create one ProductType
     * const ProductType = await prisma.productType.create({
     *   data: {
     *     // ... data to create a ProductType
     *   }
     * })
     * 
     */
    create<T extends ProductTypeCreateArgs>(args: SelectSubset<T, ProductTypeCreateArgs<ExtArgs>>): Prisma__ProductTypeClient<$Result.GetResult<Prisma.$ProductTypePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ProductTypes.
     * @param {ProductTypeCreateManyArgs} args - Arguments to create many ProductTypes.
     * @example
     * // Create many ProductTypes
     * const productType = await prisma.productType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductTypeCreateManyArgs>(args?: SelectSubset<T, ProductTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductTypes and returns the data saved in the database.
     * @param {ProductTypeCreateManyAndReturnArgs} args - Arguments to create many ProductTypes.
     * @example
     * // Create many ProductTypes
     * const productType = await prisma.productType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductTypes and only return the `id`
     * const productTypeWithIdOnly = await prisma.productType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductTypePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a ProductType.
     * @param {ProductTypeDeleteArgs} args - Arguments to delete one ProductType.
     * @example
     * // Delete one ProductType
     * const ProductType = await prisma.productType.delete({
     *   where: {
     *     // ... filter to delete one ProductType
     *   }
     * })
     * 
     */
    delete<T extends ProductTypeDeleteArgs>(args: SelectSubset<T, ProductTypeDeleteArgs<ExtArgs>>): Prisma__ProductTypeClient<$Result.GetResult<Prisma.$ProductTypePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ProductType.
     * @param {ProductTypeUpdateArgs} args - Arguments to update one ProductType.
     * @example
     * // Update one ProductType
     * const productType = await prisma.productType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductTypeUpdateArgs>(args: SelectSubset<T, ProductTypeUpdateArgs<ExtArgs>>): Prisma__ProductTypeClient<$Result.GetResult<Prisma.$ProductTypePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ProductTypes.
     * @param {ProductTypeDeleteManyArgs} args - Arguments to filter ProductTypes to delete.
     * @example
     * // Delete a few ProductTypes
     * const { count } = await prisma.productType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductTypeDeleteManyArgs>(args?: SelectSubset<T, ProductTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductTypes
     * const productType = await prisma.productType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductTypeUpdateManyArgs>(args: SelectSubset<T, ProductTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductTypes and returns the data updated in the database.
     * @param {ProductTypeUpdateManyAndReturnArgs} args - Arguments to update many ProductTypes.
     * @example
     * // Update many ProductTypes
     * const productType = await prisma.productType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductTypes and only return the `id`
     * const productTypeWithIdOnly = await prisma.productType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductTypePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one ProductType.
     * @param {ProductTypeUpsertArgs} args - Arguments to update or create a ProductType.
     * @example
     * // Update or create a ProductType
     * const productType = await prisma.productType.upsert({
     *   create: {
     *     // ... data to create a ProductType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductType we want to update
     *   }
     * })
     */
    upsert<T extends ProductTypeUpsertArgs>(args: SelectSubset<T, ProductTypeUpsertArgs<ExtArgs>>): Prisma__ProductTypeClient<$Result.GetResult<Prisma.$ProductTypePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ProductTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTypeCountArgs} args - Arguments to filter ProductTypes to count.
     * @example
     * // Count the number of ProductTypes
     * const count = await prisma.productType.count({
     *   where: {
     *     // ... the filter for the ProductTypes we want to count
     *   }
     * })
    **/
    count<T extends ProductTypeCountArgs>(
      args?: Subset<T, ProductTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductTypeAggregateArgs>(args: Subset<T, ProductTypeAggregateArgs>): Prisma.PrismaPromise<GetProductTypeAggregateType<T>>

    /**
     * Group by ProductType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductTypeGroupByArgs['orderBy'] }
        : { orderBy?: ProductTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductType model
   */
  readonly fields: ProductTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    opportunities<T extends ProductType$opportunitiesArgs<ExtArgs> = {}>(args?: Subset<T, ProductType$opportunitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpportunityProductPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    tenet<T extends TenetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenetDefaultArgs<ExtArgs>>): Prisma__TenetClient<$Result.GetResult<Prisma.$TenetPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductType model
   */ 
  interface ProductTypeFieldRefs {
    readonly id: FieldRef<"ProductType", 'Bytes'>
    readonly title: FieldRef<"ProductType", 'String'>
    readonly description: FieldRef<"ProductType", 'String'>
    readonly defaultCommission: FieldRef<"ProductType", 'Float'>
    readonly createdAt: FieldRef<"ProductType", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductType", 'DateTime'>
    readonly tenetId: FieldRef<"ProductType", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * ProductType findUnique
   */
  export type ProductTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductType
     */
    select?: ProductTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductType
     */
    omit?: ProductTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTypeInclude<ExtArgs> | null
    /**
     * Filter, which ProductType to fetch.
     */
    where: ProductTypeWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProductType findUniqueOrThrow
   */
  export type ProductTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductType
     */
    select?: ProductTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductType
     */
    omit?: ProductTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTypeInclude<ExtArgs> | null
    /**
     * Filter, which ProductType to fetch.
     */
    where: ProductTypeWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProductType findFirst
   */
  export type ProductTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductType
     */
    select?: ProductTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductType
     */
    omit?: ProductTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTypeInclude<ExtArgs> | null
    /**
     * Filter, which ProductType to fetch.
     */
    where?: ProductTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductTypes to fetch.
     */
    orderBy?: ProductTypeOrderByWithRelationInput | ProductTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductTypes.
     */
    cursor?: ProductTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductTypes.
     */
    distinct?: ProductTypeScalarFieldEnum | ProductTypeScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProductType findFirstOrThrow
   */
  export type ProductTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductType
     */
    select?: ProductTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductType
     */
    omit?: ProductTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTypeInclude<ExtArgs> | null
    /**
     * Filter, which ProductType to fetch.
     */
    where?: ProductTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductTypes to fetch.
     */
    orderBy?: ProductTypeOrderByWithRelationInput | ProductTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductTypes.
     */
    cursor?: ProductTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductTypes.
     */
    distinct?: ProductTypeScalarFieldEnum | ProductTypeScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProductType findMany
   */
  export type ProductTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductType
     */
    select?: ProductTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductType
     */
    omit?: ProductTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTypeInclude<ExtArgs> | null
    /**
     * Filter, which ProductTypes to fetch.
     */
    where?: ProductTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductTypes to fetch.
     */
    orderBy?: ProductTypeOrderByWithRelationInput | ProductTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductTypes.
     */
    cursor?: ProductTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductTypes.
     */
    skip?: number
    distinct?: ProductTypeScalarFieldEnum | ProductTypeScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProductType create
   */
  export type ProductTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductType
     */
    select?: ProductTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductType
     */
    omit?: ProductTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductType.
     */
    data: XOR<ProductTypeCreateInput, ProductTypeUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProductType createMany
   */
  export type ProductTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductTypes.
     */
    data: ProductTypeCreateManyInput | ProductTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductType createManyAndReturn
   */
  export type ProductTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductType
     */
    select?: ProductTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductType
     */
    omit?: ProductTypeOmit<ExtArgs> | null
    /**
     * The data used to create many ProductTypes.
     */
    data: ProductTypeCreateManyInput | ProductTypeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTypeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductType update
   */
  export type ProductTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductType
     */
    select?: ProductTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductType
     */
    omit?: ProductTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductType.
     */
    data: XOR<ProductTypeUpdateInput, ProductTypeUncheckedUpdateInput>
    /**
     * Choose, which ProductType to update.
     */
    where: ProductTypeWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProductType updateMany
   */
  export type ProductTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductTypes.
     */
    data: XOR<ProductTypeUpdateManyMutationInput, ProductTypeUncheckedUpdateManyInput>
    /**
     * Filter which ProductTypes to update
     */
    where?: ProductTypeWhereInput
    /**
     * Limit how many ProductTypes to update.
     */
    limit?: number
  }

  /**
   * ProductType updateManyAndReturn
   */
  export type ProductTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductType
     */
    select?: ProductTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductType
     */
    omit?: ProductTypeOmit<ExtArgs> | null
    /**
     * The data used to update ProductTypes.
     */
    data: XOR<ProductTypeUpdateManyMutationInput, ProductTypeUncheckedUpdateManyInput>
    /**
     * Filter which ProductTypes to update
     */
    where?: ProductTypeWhereInput
    /**
     * Limit how many ProductTypes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTypeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductType upsert
   */
  export type ProductTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductType
     */
    select?: ProductTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductType
     */
    omit?: ProductTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductType to update in case it exists.
     */
    where: ProductTypeWhereUniqueInput
    /**
     * In case the ProductType found by the `where` argument doesn't exist, create a new ProductType with this data.
     */
    create: XOR<ProductTypeCreateInput, ProductTypeUncheckedCreateInput>
    /**
     * In case the ProductType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductTypeUpdateInput, ProductTypeUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProductType delete
   */
  export type ProductTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductType
     */
    select?: ProductTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductType
     */
    omit?: ProductTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTypeInclude<ExtArgs> | null
    /**
     * Filter which ProductType to delete.
     */
    where: ProductTypeWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * ProductType deleteMany
   */
  export type ProductTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductTypes to delete
     */
    where?: ProductTypeWhereInput
    /**
     * Limit how many ProductTypes to delete.
     */
    limit?: number
  }

  /**
   * ProductType.opportunities
   */
  export type ProductType$opportunitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpportunityProduct
     */
    select?: OpportunityProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpportunityProduct
     */
    omit?: OpportunityProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpportunityProductInclude<ExtArgs> | null
    where?: OpportunityProductWhereInput
    orderBy?: OpportunityProductOrderByWithRelationInput | OpportunityProductOrderByWithRelationInput[]
    cursor?: OpportunityProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OpportunityProductScalarFieldEnum | OpportunityProductScalarFieldEnum[]
  }

  /**
   * ProductType without action
   */
  export type ProductTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductType
     */
    select?: ProductTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductType
     */
    omit?: ProductTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTypeInclude<ExtArgs> | null
  }


  /**
   * Model Log
   */

  export type AggregateLog = {
    _count: LogCountAggregateOutputType | null
    _min: LogMinAggregateOutputType | null
    _max: LogMaxAggregateOutputType | null
  }

  export type LogMinAggregateOutputType = {
    id: Uint8Array | null
    userEmail: string | null
    tenetId: Uint8Array | null
    message: string | null
    createdAt: Date | null
    updatedAt: Date | null
    severity: $Enums.LogLevel | null
    stacktrace: string | null
    source: string | null
    secureDetails: string | null
  }

  export type LogMaxAggregateOutputType = {
    id: Uint8Array | null
    userEmail: string | null
    tenetId: Uint8Array | null
    message: string | null
    createdAt: Date | null
    updatedAt: Date | null
    severity: $Enums.LogLevel | null
    stacktrace: string | null
    source: string | null
    secureDetails: string | null
  }

  export type LogCountAggregateOutputType = {
    id: number
    userEmail: number
    tenetId: number
    message: number
    createdAt: number
    updatedAt: number
    severity: number
    stacktrace: number
    source: number
    secureDetails: number
    _all: number
  }


  export type LogMinAggregateInputType = {
    id?: true
    userEmail?: true
    tenetId?: true
    message?: true
    createdAt?: true
    updatedAt?: true
    severity?: true
    stacktrace?: true
    source?: true
    secureDetails?: true
  }

  export type LogMaxAggregateInputType = {
    id?: true
    userEmail?: true
    tenetId?: true
    message?: true
    createdAt?: true
    updatedAt?: true
    severity?: true
    stacktrace?: true
    source?: true
    secureDetails?: true
  }

  export type LogCountAggregateInputType = {
    id?: true
    userEmail?: true
    tenetId?: true
    message?: true
    createdAt?: true
    updatedAt?: true
    severity?: true
    stacktrace?: true
    source?: true
    secureDetails?: true
    _all?: true
  }

  export type LogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Log to aggregate.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Logs
    **/
    _count?: true | LogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogMaxAggregateInputType
  }

  export type GetLogAggregateType<T extends LogAggregateArgs> = {
        [P in keyof T & keyof AggregateLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLog[P]>
      : GetScalarType<T[P], AggregateLog[P]>
  }




  export type LogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogWhereInput
    orderBy?: LogOrderByWithAggregationInput | LogOrderByWithAggregationInput[]
    by: LogScalarFieldEnum[] | LogScalarFieldEnum
    having?: LogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogCountAggregateInputType | true
    _min?: LogMinAggregateInputType
    _max?: LogMaxAggregateInputType
  }

  export type LogGroupByOutputType = {
    id: Uint8Array
    userEmail: string | null
    tenetId: Uint8Array | null
    message: string
    createdAt: Date
    updatedAt: Date
    severity: $Enums.LogLevel
    stacktrace: string | null
    source: string | null
    secureDetails: string | null
    _count: LogCountAggregateOutputType | null
    _min: LogMinAggregateOutputType | null
    _max: LogMaxAggregateOutputType | null
  }

  type GetLogGroupByPayload<T extends LogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogGroupByOutputType[P]>
            : GetScalarType<T[P], LogGroupByOutputType[P]>
        }
      >
    >


  export type LogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userEmail?: boolean
    tenetId?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    severity?: boolean
    stacktrace?: boolean
    source?: boolean
    secureDetails?: boolean
    tenet?: boolean | Log$tenetArgs<ExtArgs>
  }, ExtArgs["result"]["log"]>

  export type LogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userEmail?: boolean
    tenetId?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    severity?: boolean
    stacktrace?: boolean
    source?: boolean
    secureDetails?: boolean
    tenet?: boolean | Log$tenetArgs<ExtArgs>
  }, ExtArgs["result"]["log"]>

  export type LogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userEmail?: boolean
    tenetId?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    severity?: boolean
    stacktrace?: boolean
    source?: boolean
    secureDetails?: boolean
    tenet?: boolean | Log$tenetArgs<ExtArgs>
  }, ExtArgs["result"]["log"]>

  export type LogSelectScalar = {
    id?: boolean
    userEmail?: boolean
    tenetId?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    severity?: boolean
    stacktrace?: boolean
    source?: boolean
    secureDetails?: boolean
  }

  export type LogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userEmail" | "tenetId" | "message" | "createdAt" | "updatedAt" | "severity" | "stacktrace" | "source" | "secureDetails", ExtArgs["result"]["log"]>
  export type LogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenet?: boolean | Log$tenetArgs<ExtArgs>
  }
  export type LogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenet?: boolean | Log$tenetArgs<ExtArgs>
  }
  export type LogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenet?: boolean | Log$tenetArgs<ExtArgs>
  }

  export type $LogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Log"
    objects: {
      tenet: Prisma.$TenetPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: Uint8Array
      /**
       * @uniqueEncrypted
       */
      userEmail: string | null
      tenetId: Uint8Array | null
      message: string
      createdAt: Date
      updatedAt: Date
      severity: $Enums.LogLevel
      /**
       * @encrypted
       */
      stacktrace: string | null
      /**
       * @uniqueEncrypted
       */
      source: string | null
      /**
       * @uniqueEncrypted
       */
      secureDetails: string | null
    }, ExtArgs["result"]["log"]>
    composites: {}
  }

  type LogGetPayload<S extends boolean | null | undefined | LogDefaultArgs> = $Result.GetResult<Prisma.$LogPayload, S>

  type LogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: LogCountAggregateInputType | true
    }

  export interface LogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Log'], meta: { name: 'Log' } }
    /**
     * Find zero or one Log that matches the filter.
     * @param {LogFindUniqueArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LogFindUniqueArgs>(args: SelectSubset<T, LogFindUniqueArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Log that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LogFindUniqueOrThrowArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LogFindUniqueOrThrowArgs>(args: SelectSubset<T, LogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Log that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindFirstArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LogFindFirstArgs>(args?: SelectSubset<T, LogFindFirstArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Log that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindFirstOrThrowArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LogFindFirstOrThrowArgs>(args?: SelectSubset<T, LogFindFirstOrThrowArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Logs
     * const logs = await prisma.log.findMany()
     * 
     * // Get first 10 Logs
     * const logs = await prisma.log.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logWithIdOnly = await prisma.log.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LogFindManyArgs>(args?: SelectSubset<T, LogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Log.
     * @param {LogCreateArgs} args - Arguments to create a Log.
     * @example
     * // Create one Log
     * const Log = await prisma.log.create({
     *   data: {
     *     // ... data to create a Log
     *   }
     * })
     * 
     */
    create<T extends LogCreateArgs>(args: SelectSubset<T, LogCreateArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Logs.
     * @param {LogCreateManyArgs} args - Arguments to create many Logs.
     * @example
     * // Create many Logs
     * const log = await prisma.log.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LogCreateManyArgs>(args?: SelectSubset<T, LogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Logs and returns the data saved in the database.
     * @param {LogCreateManyAndReturnArgs} args - Arguments to create many Logs.
     * @example
     * // Create many Logs
     * const log = await prisma.log.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Logs and only return the `id`
     * const logWithIdOnly = await prisma.log.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LogCreateManyAndReturnArgs>(args?: SelectSubset<T, LogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Log.
     * @param {LogDeleteArgs} args - Arguments to delete one Log.
     * @example
     * // Delete one Log
     * const Log = await prisma.log.delete({
     *   where: {
     *     // ... filter to delete one Log
     *   }
     * })
     * 
     */
    delete<T extends LogDeleteArgs>(args: SelectSubset<T, LogDeleteArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Log.
     * @param {LogUpdateArgs} args - Arguments to update one Log.
     * @example
     * // Update one Log
     * const log = await prisma.log.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LogUpdateArgs>(args: SelectSubset<T, LogUpdateArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Logs.
     * @param {LogDeleteManyArgs} args - Arguments to filter Logs to delete.
     * @example
     * // Delete a few Logs
     * const { count } = await prisma.log.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LogDeleteManyArgs>(args?: SelectSubset<T, LogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Logs
     * const log = await prisma.log.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LogUpdateManyArgs>(args: SelectSubset<T, LogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Logs and returns the data updated in the database.
     * @param {LogUpdateManyAndReturnArgs} args - Arguments to update many Logs.
     * @example
     * // Update many Logs
     * const log = await prisma.log.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Logs and only return the `id`
     * const logWithIdOnly = await prisma.log.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LogUpdateManyAndReturnArgs>(args: SelectSubset<T, LogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Log.
     * @param {LogUpsertArgs} args - Arguments to update or create a Log.
     * @example
     * // Update or create a Log
     * const log = await prisma.log.upsert({
     *   create: {
     *     // ... data to create a Log
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Log we want to update
     *   }
     * })
     */
    upsert<T extends LogUpsertArgs>(args: SelectSubset<T, LogUpsertArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogCountArgs} args - Arguments to filter Logs to count.
     * @example
     * // Count the number of Logs
     * const count = await prisma.log.count({
     *   where: {
     *     // ... the filter for the Logs we want to count
     *   }
     * })
    **/
    count<T extends LogCountArgs>(
      args?: Subset<T, LogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogAggregateArgs>(args: Subset<T, LogAggregateArgs>): Prisma.PrismaPromise<GetLogAggregateType<T>>

    /**
     * Group by Log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogGroupByArgs['orderBy'] }
        : { orderBy?: LogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Log model
   */
  readonly fields: LogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Log.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenet<T extends Log$tenetArgs<ExtArgs> = {}>(args?: Subset<T, Log$tenetArgs<ExtArgs>>): Prisma__TenetClient<$Result.GetResult<Prisma.$TenetPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Log model
   */ 
  interface LogFieldRefs {
    readonly id: FieldRef<"Log", 'Bytes'>
    readonly userEmail: FieldRef<"Log", 'String'>
    readonly tenetId: FieldRef<"Log", 'Bytes'>
    readonly message: FieldRef<"Log", 'String'>
    readonly createdAt: FieldRef<"Log", 'DateTime'>
    readonly updatedAt: FieldRef<"Log", 'DateTime'>
    readonly severity: FieldRef<"Log", 'LogLevel'>
    readonly stacktrace: FieldRef<"Log", 'String'>
    readonly source: FieldRef<"Log", 'String'>
    readonly secureDetails: FieldRef<"Log", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Log findUnique
   */
  export type LogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where: LogWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Log findUniqueOrThrow
   */
  export type LogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where: LogWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Log findFirst
   */
  export type LogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logs.
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logs.
     */
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Log findFirstOrThrow
   */
  export type LogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logs.
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logs.
     */
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Log findMany
   */
  export type LogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Logs to fetch.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Logs.
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Log create
   */
  export type LogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * The data needed to create a Log.
     */
    data: XOR<LogCreateInput, LogUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Log createMany
   */
  export type LogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Logs.
     */
    data: LogCreateManyInput | LogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Log createManyAndReturn
   */
  export type LogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * The data used to create many Logs.
     */
    data: LogCreateManyInput | LogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Log update
   */
  export type LogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * The data needed to update a Log.
     */
    data: XOR<LogUpdateInput, LogUncheckedUpdateInput>
    /**
     * Choose, which Log to update.
     */
    where: LogWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Log updateMany
   */
  export type LogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Logs.
     */
    data: XOR<LogUpdateManyMutationInput, LogUncheckedUpdateManyInput>
    /**
     * Filter which Logs to update
     */
    where?: LogWhereInput
    /**
     * Limit how many Logs to update.
     */
    limit?: number
  }

  /**
   * Log updateManyAndReturn
   */
  export type LogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * The data used to update Logs.
     */
    data: XOR<LogUpdateManyMutationInput, LogUncheckedUpdateManyInput>
    /**
     * Filter which Logs to update
     */
    where?: LogWhereInput
    /**
     * Limit how many Logs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Log upsert
   */
  export type LogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * The filter to search for the Log to update in case it exists.
     */
    where: LogWhereUniqueInput
    /**
     * In case the Log found by the `where` argument doesn't exist, create a new Log with this data.
     */
    create: XOR<LogCreateInput, LogUncheckedCreateInput>
    /**
     * In case the Log was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LogUpdateInput, LogUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Log delete
   */
  export type LogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter which Log to delete.
     */
    where: LogWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Log deleteMany
   */
  export type LogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Logs to delete
     */
    where?: LogWhereInput
    /**
     * Limit how many Logs to delete.
     */
    limit?: number
  }

  /**
   * Log.tenet
   */
  export type Log$tenetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenet
     */
    select?: TenetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenet
     */
    omit?: TenetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenetInclude<ExtArgs> | null
    where?: TenetWhereInput
  }

  /**
   * Log without action
   */
  export type LogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
  }


  /**
   * Model Token
   */

  export type AggregateToken = {
    _count: TokenCountAggregateOutputType | null
    _min: TokenMinAggregateOutputType | null
    _max: TokenMaxAggregateOutputType | null
  }

  export type TokenMinAggregateOutputType = {
    id: Uint8Array | null
    userId: Uint8Array | null
    createdAt: Date | null
    refresh: boolean | null
  }

  export type TokenMaxAggregateOutputType = {
    id: Uint8Array | null
    userId: Uint8Array | null
    createdAt: Date | null
    refresh: boolean | null
  }

  export type TokenCountAggregateOutputType = {
    id: number
    userId: number
    createdAt: number
    refresh: number
    _all: number
  }


  export type TokenMinAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    refresh?: true
  }

  export type TokenMaxAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    refresh?: true
  }

  export type TokenCountAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    refresh?: true
    _all?: true
  }

  export type TokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Token to aggregate.
     */
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     */
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tokens
    **/
    _count?: true | TokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TokenMaxAggregateInputType
  }

  export type GetTokenAggregateType<T extends TokenAggregateArgs> = {
        [P in keyof T & keyof AggregateToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateToken[P]>
      : GetScalarType<T[P], AggregateToken[P]>
  }




  export type TokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TokenWhereInput
    orderBy?: TokenOrderByWithAggregationInput | TokenOrderByWithAggregationInput[]
    by: TokenScalarFieldEnum[] | TokenScalarFieldEnum
    having?: TokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TokenCountAggregateInputType | true
    _min?: TokenMinAggregateInputType
    _max?: TokenMaxAggregateInputType
  }

  export type TokenGroupByOutputType = {
    id: Uint8Array
    userId: Uint8Array
    createdAt: Date
    refresh: boolean
    _count: TokenCountAggregateOutputType | null
    _min: TokenMinAggregateOutputType | null
    _max: TokenMaxAggregateOutputType | null
  }

  type GetTokenGroupByPayload<T extends TokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TokenGroupByOutputType[P]>
            : GetScalarType<T[P], TokenGroupByOutputType[P]>
        }
      >
    >


  export type TokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    refresh?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["token"]>

  export type TokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    refresh?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["token"]>

  export type TokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    refresh?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["token"]>

  export type TokenSelectScalar = {
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    refresh?: boolean
  }

  export type TokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "createdAt" | "refresh", ExtArgs["result"]["token"]>
  export type TokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Token"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: Uint8Array
      userId: Uint8Array
      createdAt: Date
      refresh: boolean
    }, ExtArgs["result"]["token"]>
    composites: {}
  }

  type TokenGetPayload<S extends boolean | null | undefined | TokenDefaultArgs> = $Result.GetResult<Prisma.$TokenPayload, S>

  type TokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: TokenCountAggregateInputType | true
    }

  export interface TokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Token'], meta: { name: 'Token' } }
    /**
     * Find zero or one Token that matches the filter.
     * @param {TokenFindUniqueArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TokenFindUniqueArgs>(args: SelectSubset<T, TokenFindUniqueArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Token that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TokenFindUniqueOrThrowArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TokenFindUniqueOrThrowArgs>(args: SelectSubset<T, TokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Token that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenFindFirstArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TokenFindFirstArgs>(args?: SelectSubset<T, TokenFindFirstArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Token that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenFindFirstOrThrowArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TokenFindFirstOrThrowArgs>(args?: SelectSubset<T, TokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tokens
     * const tokens = await prisma.token.findMany()
     * 
     * // Get first 10 Tokens
     * const tokens = await prisma.token.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tokenWithIdOnly = await prisma.token.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TokenFindManyArgs>(args?: SelectSubset<T, TokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Token.
     * @param {TokenCreateArgs} args - Arguments to create a Token.
     * @example
     * // Create one Token
     * const Token = await prisma.token.create({
     *   data: {
     *     // ... data to create a Token
     *   }
     * })
     * 
     */
    create<T extends TokenCreateArgs>(args: SelectSubset<T, TokenCreateArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Tokens.
     * @param {TokenCreateManyArgs} args - Arguments to create many Tokens.
     * @example
     * // Create many Tokens
     * const token = await prisma.token.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TokenCreateManyArgs>(args?: SelectSubset<T, TokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tokens and returns the data saved in the database.
     * @param {TokenCreateManyAndReturnArgs} args - Arguments to create many Tokens.
     * @example
     * // Create many Tokens
     * const token = await prisma.token.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tokens and only return the `id`
     * const tokenWithIdOnly = await prisma.token.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TokenCreateManyAndReturnArgs>(args?: SelectSubset<T, TokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Token.
     * @param {TokenDeleteArgs} args - Arguments to delete one Token.
     * @example
     * // Delete one Token
     * const Token = await prisma.token.delete({
     *   where: {
     *     // ... filter to delete one Token
     *   }
     * })
     * 
     */
    delete<T extends TokenDeleteArgs>(args: SelectSubset<T, TokenDeleteArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Token.
     * @param {TokenUpdateArgs} args - Arguments to update one Token.
     * @example
     * // Update one Token
     * const token = await prisma.token.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TokenUpdateArgs>(args: SelectSubset<T, TokenUpdateArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Tokens.
     * @param {TokenDeleteManyArgs} args - Arguments to filter Tokens to delete.
     * @example
     * // Delete a few Tokens
     * const { count } = await prisma.token.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TokenDeleteManyArgs>(args?: SelectSubset<T, TokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tokens
     * const token = await prisma.token.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TokenUpdateManyArgs>(args: SelectSubset<T, TokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tokens and returns the data updated in the database.
     * @param {TokenUpdateManyAndReturnArgs} args - Arguments to update many Tokens.
     * @example
     * // Update many Tokens
     * const token = await prisma.token.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tokens and only return the `id`
     * const tokenWithIdOnly = await prisma.token.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TokenUpdateManyAndReturnArgs>(args: SelectSubset<T, TokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Token.
     * @param {TokenUpsertArgs} args - Arguments to update or create a Token.
     * @example
     * // Update or create a Token
     * const token = await prisma.token.upsert({
     *   create: {
     *     // ... data to create a Token
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Token we want to update
     *   }
     * })
     */
    upsert<T extends TokenUpsertArgs>(args: SelectSubset<T, TokenUpsertArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenCountArgs} args - Arguments to filter Tokens to count.
     * @example
     * // Count the number of Tokens
     * const count = await prisma.token.count({
     *   where: {
     *     // ... the filter for the Tokens we want to count
     *   }
     * })
    **/
    count<T extends TokenCountArgs>(
      args?: Subset<T, TokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Token.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TokenAggregateArgs>(args: Subset<T, TokenAggregateArgs>): Prisma.PrismaPromise<GetTokenAggregateType<T>>

    /**
     * Group by Token.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TokenGroupByArgs['orderBy'] }
        : { orderBy?: TokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Token model
   */
  readonly fields: TokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Token.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Token model
   */ 
  interface TokenFieldRefs {
    readonly id: FieldRef<"Token", 'Bytes'>
    readonly userId: FieldRef<"Token", 'Bytes'>
    readonly createdAt: FieldRef<"Token", 'DateTime'>
    readonly refresh: FieldRef<"Token", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Token findUnique
   */
  export type TokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Token to fetch.
     */
    where: TokenWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Token findUniqueOrThrow
   */
  export type TokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Token to fetch.
     */
    where: TokenWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Token findFirst
   */
  export type TokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Token to fetch.
     */
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     */
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tokens.
     */
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tokens.
     */
    distinct?: TokenScalarFieldEnum | TokenScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Token findFirstOrThrow
   */
  export type TokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Token to fetch.
     */
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     */
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tokens.
     */
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tokens.
     */
    distinct?: TokenScalarFieldEnum | TokenScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Token findMany
   */
  export type TokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Tokens to fetch.
     */
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     */
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tokens.
     */
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     */
    skip?: number
    distinct?: TokenScalarFieldEnum | TokenScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Token create
   */
  export type TokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * The data needed to create a Token.
     */
    data: XOR<TokenCreateInput, TokenUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Token createMany
   */
  export type TokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tokens.
     */
    data: TokenCreateManyInput | TokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Token createManyAndReturn
   */
  export type TokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * The data used to create many Tokens.
     */
    data: TokenCreateManyInput | TokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Token update
   */
  export type TokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * The data needed to update a Token.
     */
    data: XOR<TokenUpdateInput, TokenUncheckedUpdateInput>
    /**
     * Choose, which Token to update.
     */
    where: TokenWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Token updateMany
   */
  export type TokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tokens.
     */
    data: XOR<TokenUpdateManyMutationInput, TokenUncheckedUpdateManyInput>
    /**
     * Filter which Tokens to update
     */
    where?: TokenWhereInput
    /**
     * Limit how many Tokens to update.
     */
    limit?: number
  }

  /**
   * Token updateManyAndReturn
   */
  export type TokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * The data used to update Tokens.
     */
    data: XOR<TokenUpdateManyMutationInput, TokenUncheckedUpdateManyInput>
    /**
     * Filter which Tokens to update
     */
    where?: TokenWhereInput
    /**
     * Limit how many Tokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Token upsert
   */
  export type TokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * The filter to search for the Token to update in case it exists.
     */
    where: TokenWhereUniqueInput
    /**
     * In case the Token found by the `where` argument doesn't exist, create a new Token with this data.
     */
    create: XOR<TokenCreateInput, TokenUncheckedCreateInput>
    /**
     * In case the Token was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TokenUpdateInput, TokenUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Token delete
   */
  export type TokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter which Token to delete.
     */
    where: TokenWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * Token deleteMany
   */
  export type TokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tokens to delete
     */
    where?: TokenWhereInput
    /**
     * Limit how many Tokens to delete.
     */
    limit?: number
  }

  /**
   * Token without action
   */
  export type TokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
  }


  /**
   * Model TZData
   */

  export type AggregateTZData = {
    _count: TZDataCountAggregateOutputType | null
    _avg: TZDataAvgAggregateOutputType | null
    _sum: TZDataSumAggregateOutputType | null
    _min: TZDataMinAggregateOutputType | null
    _max: TZDataMaxAggregateOutputType | null
  }

  export type TZDataAvgAggregateOutputType = {
    id: number | null
  }

  export type TZDataSumAggregateOutputType = {
    id: number | null
  }

  export type TZDataMinAggregateOutputType = {
    id: number | null
    name: string | null
    provinceName: string | null
    countryCode: string | null
    tz: string | null
  }

  export type TZDataMaxAggregateOutputType = {
    id: number | null
    name: string | null
    provinceName: string | null
    countryCode: string | null
    tz: string | null
  }

  export type TZDataCountAggregateOutputType = {
    id: number
    name: number
    provinceName: number
    countryCode: number
    tz: number
    _all: number
  }


  export type TZDataAvgAggregateInputType = {
    id?: true
  }

  export type TZDataSumAggregateInputType = {
    id?: true
  }

  export type TZDataMinAggregateInputType = {
    id?: true
    name?: true
    provinceName?: true
    countryCode?: true
    tz?: true
  }

  export type TZDataMaxAggregateInputType = {
    id?: true
    name?: true
    provinceName?: true
    countryCode?: true
    tz?: true
  }

  export type TZDataCountAggregateInputType = {
    id?: true
    name?: true
    provinceName?: true
    countryCode?: true
    tz?: true
    _all?: true
  }

  export type TZDataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TZData to aggregate.
     */
    where?: TZDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TZData to fetch.
     */
    orderBy?: TZDataOrderByWithRelationInput | TZDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TZDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TZData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TZData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TZData
    **/
    _count?: true | TZDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TZDataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TZDataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TZDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TZDataMaxAggregateInputType
  }

  export type GetTZDataAggregateType<T extends TZDataAggregateArgs> = {
        [P in keyof T & keyof AggregateTZData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTZData[P]>
      : GetScalarType<T[P], AggregateTZData[P]>
  }




  export type TZDataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TZDataWhereInput
    orderBy?: TZDataOrderByWithAggregationInput | TZDataOrderByWithAggregationInput[]
    by: TZDataScalarFieldEnum[] | TZDataScalarFieldEnum
    having?: TZDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TZDataCountAggregateInputType | true
    _avg?: TZDataAvgAggregateInputType
    _sum?: TZDataSumAggregateInputType
    _min?: TZDataMinAggregateInputType
    _max?: TZDataMaxAggregateInputType
  }

  export type TZDataGroupByOutputType = {
    id: number
    name: string
    provinceName: string
    countryCode: string
    tz: string
    _count: TZDataCountAggregateOutputType | null
    _avg: TZDataAvgAggregateOutputType | null
    _sum: TZDataSumAggregateOutputType | null
    _min: TZDataMinAggregateOutputType | null
    _max: TZDataMaxAggregateOutputType | null
  }

  type GetTZDataGroupByPayload<T extends TZDataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TZDataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TZDataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TZDataGroupByOutputType[P]>
            : GetScalarType<T[P], TZDataGroupByOutputType[P]>
        }
      >
    >


  export type TZDataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    provinceName?: boolean
    countryCode?: boolean
    tz?: boolean
  }, ExtArgs["result"]["tZData"]>

  export type TZDataSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    provinceName?: boolean
    countryCode?: boolean
    tz?: boolean
  }, ExtArgs["result"]["tZData"]>

  export type TZDataSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    provinceName?: boolean
    countryCode?: boolean
    tz?: boolean
  }, ExtArgs["result"]["tZData"]>

  export type TZDataSelectScalar = {
    id?: boolean
    name?: boolean
    provinceName?: boolean
    countryCode?: boolean
    tz?: boolean
  }

  export type TZDataOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "provinceName" | "countryCode" | "tz", ExtArgs["result"]["tZData"]>

  export type $TZDataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TZData"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      /**
       * @@wrapper-ignore
       */
      id: number
      name: string
      provinceName: string
      countryCode: string
      tz: string
    }, ExtArgs["result"]["tZData"]>
    composites: {}
  }

  type TZDataGetPayload<S extends boolean | null | undefined | TZDataDefaultArgs> = $Result.GetResult<Prisma.$TZDataPayload, S>

  type TZDataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TZDataFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: TZDataCountAggregateInputType | true
    }

  export interface TZDataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TZData'], meta: { name: 'TZData' } }
    /**
     * Find zero or one TZData that matches the filter.
     * @param {TZDataFindUniqueArgs} args - Arguments to find a TZData
     * @example
     * // Get one TZData
     * const tZData = await prisma.tZData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TZDataFindUniqueArgs>(args: SelectSubset<T, TZDataFindUniqueArgs<ExtArgs>>): Prisma__TZDataClient<$Result.GetResult<Prisma.$TZDataPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one TZData that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TZDataFindUniqueOrThrowArgs} args - Arguments to find a TZData
     * @example
     * // Get one TZData
     * const tZData = await prisma.tZData.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TZDataFindUniqueOrThrowArgs>(args: SelectSubset<T, TZDataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TZDataClient<$Result.GetResult<Prisma.$TZDataPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first TZData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TZDataFindFirstArgs} args - Arguments to find a TZData
     * @example
     * // Get one TZData
     * const tZData = await prisma.tZData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TZDataFindFirstArgs>(args?: SelectSubset<T, TZDataFindFirstArgs<ExtArgs>>): Prisma__TZDataClient<$Result.GetResult<Prisma.$TZDataPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first TZData that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TZDataFindFirstOrThrowArgs} args - Arguments to find a TZData
     * @example
     * // Get one TZData
     * const tZData = await prisma.tZData.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TZDataFindFirstOrThrowArgs>(args?: SelectSubset<T, TZDataFindFirstOrThrowArgs<ExtArgs>>): Prisma__TZDataClient<$Result.GetResult<Prisma.$TZDataPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more TZData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TZDataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TZData
     * const tZData = await prisma.tZData.findMany()
     * 
     * // Get first 10 TZData
     * const tZData = await prisma.tZData.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tZDataWithIdOnly = await prisma.tZData.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TZDataFindManyArgs>(args?: SelectSubset<T, TZDataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TZDataPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a TZData.
     * @param {TZDataCreateArgs} args - Arguments to create a TZData.
     * @example
     * // Create one TZData
     * const TZData = await prisma.tZData.create({
     *   data: {
     *     // ... data to create a TZData
     *   }
     * })
     * 
     */
    create<T extends TZDataCreateArgs>(args: SelectSubset<T, TZDataCreateArgs<ExtArgs>>): Prisma__TZDataClient<$Result.GetResult<Prisma.$TZDataPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many TZData.
     * @param {TZDataCreateManyArgs} args - Arguments to create many TZData.
     * @example
     * // Create many TZData
     * const tZData = await prisma.tZData.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TZDataCreateManyArgs>(args?: SelectSubset<T, TZDataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TZData and returns the data saved in the database.
     * @param {TZDataCreateManyAndReturnArgs} args - Arguments to create many TZData.
     * @example
     * // Create many TZData
     * const tZData = await prisma.tZData.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TZData and only return the `id`
     * const tZDataWithIdOnly = await prisma.tZData.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TZDataCreateManyAndReturnArgs>(args?: SelectSubset<T, TZDataCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TZDataPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a TZData.
     * @param {TZDataDeleteArgs} args - Arguments to delete one TZData.
     * @example
     * // Delete one TZData
     * const TZData = await prisma.tZData.delete({
     *   where: {
     *     // ... filter to delete one TZData
     *   }
     * })
     * 
     */
    delete<T extends TZDataDeleteArgs>(args: SelectSubset<T, TZDataDeleteArgs<ExtArgs>>): Prisma__TZDataClient<$Result.GetResult<Prisma.$TZDataPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one TZData.
     * @param {TZDataUpdateArgs} args - Arguments to update one TZData.
     * @example
     * // Update one TZData
     * const tZData = await prisma.tZData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TZDataUpdateArgs>(args: SelectSubset<T, TZDataUpdateArgs<ExtArgs>>): Prisma__TZDataClient<$Result.GetResult<Prisma.$TZDataPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more TZData.
     * @param {TZDataDeleteManyArgs} args - Arguments to filter TZData to delete.
     * @example
     * // Delete a few TZData
     * const { count } = await prisma.tZData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TZDataDeleteManyArgs>(args?: SelectSubset<T, TZDataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TZData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TZDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TZData
     * const tZData = await prisma.tZData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TZDataUpdateManyArgs>(args: SelectSubset<T, TZDataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TZData and returns the data updated in the database.
     * @param {TZDataUpdateManyAndReturnArgs} args - Arguments to update many TZData.
     * @example
     * // Update many TZData
     * const tZData = await prisma.tZData.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TZData and only return the `id`
     * const tZDataWithIdOnly = await prisma.tZData.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TZDataUpdateManyAndReturnArgs>(args: SelectSubset<T, TZDataUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TZDataPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one TZData.
     * @param {TZDataUpsertArgs} args - Arguments to update or create a TZData.
     * @example
     * // Update or create a TZData
     * const tZData = await prisma.tZData.upsert({
     *   create: {
     *     // ... data to create a TZData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TZData we want to update
     *   }
     * })
     */
    upsert<T extends TZDataUpsertArgs>(args: SelectSubset<T, TZDataUpsertArgs<ExtArgs>>): Prisma__TZDataClient<$Result.GetResult<Prisma.$TZDataPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of TZData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TZDataCountArgs} args - Arguments to filter TZData to count.
     * @example
     * // Count the number of TZData
     * const count = await prisma.tZData.count({
     *   where: {
     *     // ... the filter for the TZData we want to count
     *   }
     * })
    **/
    count<T extends TZDataCountArgs>(
      args?: Subset<T, TZDataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TZDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TZData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TZDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TZDataAggregateArgs>(args: Subset<T, TZDataAggregateArgs>): Prisma.PrismaPromise<GetTZDataAggregateType<T>>

    /**
     * Group by TZData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TZDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TZDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TZDataGroupByArgs['orderBy'] }
        : { orderBy?: TZDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TZDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTZDataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TZData model
   */
  readonly fields: TZDataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TZData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TZDataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TZData model
   */ 
  interface TZDataFieldRefs {
    readonly id: FieldRef<"TZData", 'Int'>
    readonly name: FieldRef<"TZData", 'String'>
    readonly provinceName: FieldRef<"TZData", 'String'>
    readonly countryCode: FieldRef<"TZData", 'String'>
    readonly tz: FieldRef<"TZData", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TZData findUnique
   */
  export type TZDataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TZData
     */
    select?: TZDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TZData
     */
    omit?: TZDataOmit<ExtArgs> | null
    /**
     * Filter, which TZData to fetch.
     */
    where: TZDataWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TZData findUniqueOrThrow
   */
  export type TZDataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TZData
     */
    select?: TZDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TZData
     */
    omit?: TZDataOmit<ExtArgs> | null
    /**
     * Filter, which TZData to fetch.
     */
    where: TZDataWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TZData findFirst
   */
  export type TZDataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TZData
     */
    select?: TZDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TZData
     */
    omit?: TZDataOmit<ExtArgs> | null
    /**
     * Filter, which TZData to fetch.
     */
    where?: TZDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TZData to fetch.
     */
    orderBy?: TZDataOrderByWithRelationInput | TZDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TZData.
     */
    cursor?: TZDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TZData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TZData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TZData.
     */
    distinct?: TZDataScalarFieldEnum | TZDataScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TZData findFirstOrThrow
   */
  export type TZDataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TZData
     */
    select?: TZDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TZData
     */
    omit?: TZDataOmit<ExtArgs> | null
    /**
     * Filter, which TZData to fetch.
     */
    where?: TZDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TZData to fetch.
     */
    orderBy?: TZDataOrderByWithRelationInput | TZDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TZData.
     */
    cursor?: TZDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TZData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TZData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TZData.
     */
    distinct?: TZDataScalarFieldEnum | TZDataScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TZData findMany
   */
  export type TZDataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TZData
     */
    select?: TZDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TZData
     */
    omit?: TZDataOmit<ExtArgs> | null
    /**
     * Filter, which TZData to fetch.
     */
    where?: TZDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TZData to fetch.
     */
    orderBy?: TZDataOrderByWithRelationInput | TZDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TZData.
     */
    cursor?: TZDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TZData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TZData.
     */
    skip?: number
    distinct?: TZDataScalarFieldEnum | TZDataScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TZData create
   */
  export type TZDataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TZData
     */
    select?: TZDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TZData
     */
    omit?: TZDataOmit<ExtArgs> | null
    /**
     * The data needed to create a TZData.
     */
    data: XOR<TZDataCreateInput, TZDataUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TZData createMany
   */
  export type TZDataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TZData.
     */
    data: TZDataCreateManyInput | TZDataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TZData createManyAndReturn
   */
  export type TZDataCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TZData
     */
    select?: TZDataSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TZData
     */
    omit?: TZDataOmit<ExtArgs> | null
    /**
     * The data used to create many TZData.
     */
    data: TZDataCreateManyInput | TZDataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TZData update
   */
  export type TZDataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TZData
     */
    select?: TZDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TZData
     */
    omit?: TZDataOmit<ExtArgs> | null
    /**
     * The data needed to update a TZData.
     */
    data: XOR<TZDataUpdateInput, TZDataUncheckedUpdateInput>
    /**
     * Choose, which TZData to update.
     */
    where: TZDataWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TZData updateMany
   */
  export type TZDataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TZData.
     */
    data: XOR<TZDataUpdateManyMutationInput, TZDataUncheckedUpdateManyInput>
    /**
     * Filter which TZData to update
     */
    where?: TZDataWhereInput
    /**
     * Limit how many TZData to update.
     */
    limit?: number
  }

  /**
   * TZData updateManyAndReturn
   */
  export type TZDataUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TZData
     */
    select?: TZDataSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TZData
     */
    omit?: TZDataOmit<ExtArgs> | null
    /**
     * The data used to update TZData.
     */
    data: XOR<TZDataUpdateManyMutationInput, TZDataUncheckedUpdateManyInput>
    /**
     * Filter which TZData to update
     */
    where?: TZDataWhereInput
    /**
     * Limit how many TZData to update.
     */
    limit?: number
  }

  /**
   * TZData upsert
   */
  export type TZDataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TZData
     */
    select?: TZDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TZData
     */
    omit?: TZDataOmit<ExtArgs> | null
    /**
     * The filter to search for the TZData to update in case it exists.
     */
    where: TZDataWhereUniqueInput
    /**
     * In case the TZData found by the `where` argument doesn't exist, create a new TZData with this data.
     */
    create: XOR<TZDataCreateInput, TZDataUncheckedCreateInput>
    /**
     * In case the TZData was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TZDataUpdateInput, TZDataUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TZData delete
   */
  export type TZDataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TZData
     */
    select?: TZDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TZData
     */
    omit?: TZDataOmit<ExtArgs> | null
    /**
     * Filter which TZData to delete.
     */
    where: TZDataWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TZData deleteMany
   */
  export type TZDataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TZData to delete
     */
    where?: TZDataWhereInput
    /**
     * Limit how many TZData to delete.
     */
    limit?: number
  }

  /**
   * TZData without action
   */
  export type TZDataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TZData
     */
    select?: TZDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TZData
     */
    omit?: TZDataOmit<ExtArgs> | null
  }


  /**
   * Model TestObject
   */

  export type AggregateTestObject = {
    _count: TestObjectCountAggregateOutputType | null
    _min: TestObjectMinAggregateOutputType | null
    _max: TestObjectMaxAggregateOutputType | null
  }

  export type TestObjectMinAggregateOutputType = {
    id: Uint8Array | null
    required: string | null
    persisted: string | null
  }

  export type TestObjectMaxAggregateOutputType = {
    id: Uint8Array | null
    required: string | null
    persisted: string | null
  }

  export type TestObjectCountAggregateOutputType = {
    id: number
    required: number
    persisted: number
    _all: number
  }


  export type TestObjectMinAggregateInputType = {
    id?: true
    required?: true
    persisted?: true
  }

  export type TestObjectMaxAggregateInputType = {
    id?: true
    required?: true
    persisted?: true
  }

  export type TestObjectCountAggregateInputType = {
    id?: true
    required?: true
    persisted?: true
    _all?: true
  }

  export type TestObjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestObject to aggregate.
     */
    where?: TestObjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestObjects to fetch.
     */
    orderBy?: TestObjectOrderByWithRelationInput | TestObjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TestObjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestObjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestObjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TestObjects
    **/
    _count?: true | TestObjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestObjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestObjectMaxAggregateInputType
  }

  export type GetTestObjectAggregateType<T extends TestObjectAggregateArgs> = {
        [P in keyof T & keyof AggregateTestObject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTestObject[P]>
      : GetScalarType<T[P], AggregateTestObject[P]>
  }




  export type TestObjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestObjectWhereInput
    orderBy?: TestObjectOrderByWithAggregationInput | TestObjectOrderByWithAggregationInput[]
    by: TestObjectScalarFieldEnum[] | TestObjectScalarFieldEnum
    having?: TestObjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestObjectCountAggregateInputType | true
    _min?: TestObjectMinAggregateInputType
    _max?: TestObjectMaxAggregateInputType
  }

  export type TestObjectGroupByOutputType = {
    id: Uint8Array
    required: string
    persisted: string | null
    _count: TestObjectCountAggregateOutputType | null
    _min: TestObjectMinAggregateOutputType | null
    _max: TestObjectMaxAggregateOutputType | null
  }

  type GetTestObjectGroupByPayload<T extends TestObjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TestObjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestObjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestObjectGroupByOutputType[P]>
            : GetScalarType<T[P], TestObjectGroupByOutputType[P]>
        }
      >
    >


  export type TestObjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    required?: boolean
    persisted?: boolean
    wrapped?: boolean | TestObject$wrappedArgs<ExtArgs>
    join1?: boolean | TestObject$join1Args<ExtArgs>
    join2?: boolean | TestObject$join2Args<ExtArgs>
    _count?: boolean | TestObjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testObject"]>

  export type TestObjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    required?: boolean
    persisted?: boolean
  }, ExtArgs["result"]["testObject"]>

  export type TestObjectSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    required?: boolean
    persisted?: boolean
  }, ExtArgs["result"]["testObject"]>

  export type TestObjectSelectScalar = {
    id?: boolean
    required?: boolean
    persisted?: boolean
  }

  export type TestObjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "required" | "persisted", ExtArgs["result"]["testObject"]>
  export type TestObjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wrapped?: boolean | TestObject$wrappedArgs<ExtArgs>
    join1?: boolean | TestObject$join1Args<ExtArgs>
    join2?: boolean | TestObject$join2Args<ExtArgs>
    _count?: boolean | TestObjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TestObjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TestObjectIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TestObjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TestObject"
    objects: {
      wrapped: Prisma.$WrappedObjectPayload<ExtArgs>[]
      /**
       * @jointable(JoinedObject1, joinedObjectRelation)
       * @join(joinProperty, joinProperty1)
       */
      join1: Prisma.$JoinTestObjectPayload<ExtArgs>[]
      /**
       * @jointable(JoinedObject2, joinedObjectRelation)
       * @join(joinProperty, joinProperty2)
       * @joinid(joinId)
       */
      join2: Prisma.$JoinTestObject2Payload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: Uint8Array
      required: string
      persisted: string | null
    }, ExtArgs["result"]["testObject"]>
    composites: {}
  }

  type TestObjectGetPayload<S extends boolean | null | undefined | TestObjectDefaultArgs> = $Result.GetResult<Prisma.$TestObjectPayload, S>

  type TestObjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TestObjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: TestObjectCountAggregateInputType | true
    }

  export interface TestObjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TestObject'], meta: { name: 'TestObject' } }
    /**
     * Find zero or one TestObject that matches the filter.
     * @param {TestObjectFindUniqueArgs} args - Arguments to find a TestObject
     * @example
     * // Get one TestObject
     * const testObject = await prisma.testObject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TestObjectFindUniqueArgs>(args: SelectSubset<T, TestObjectFindUniqueArgs<ExtArgs>>): Prisma__TestObjectClient<$Result.GetResult<Prisma.$TestObjectPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one TestObject that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TestObjectFindUniqueOrThrowArgs} args - Arguments to find a TestObject
     * @example
     * // Get one TestObject
     * const testObject = await prisma.testObject.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TestObjectFindUniqueOrThrowArgs>(args: SelectSubset<T, TestObjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TestObjectClient<$Result.GetResult<Prisma.$TestObjectPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first TestObject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestObjectFindFirstArgs} args - Arguments to find a TestObject
     * @example
     * // Get one TestObject
     * const testObject = await prisma.testObject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TestObjectFindFirstArgs>(args?: SelectSubset<T, TestObjectFindFirstArgs<ExtArgs>>): Prisma__TestObjectClient<$Result.GetResult<Prisma.$TestObjectPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first TestObject that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestObjectFindFirstOrThrowArgs} args - Arguments to find a TestObject
     * @example
     * // Get one TestObject
     * const testObject = await prisma.testObject.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TestObjectFindFirstOrThrowArgs>(args?: SelectSubset<T, TestObjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__TestObjectClient<$Result.GetResult<Prisma.$TestObjectPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more TestObjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestObjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TestObjects
     * const testObjects = await prisma.testObject.findMany()
     * 
     * // Get first 10 TestObjects
     * const testObjects = await prisma.testObject.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testObjectWithIdOnly = await prisma.testObject.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TestObjectFindManyArgs>(args?: SelectSubset<T, TestObjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestObjectPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a TestObject.
     * @param {TestObjectCreateArgs} args - Arguments to create a TestObject.
     * @example
     * // Create one TestObject
     * const TestObject = await prisma.testObject.create({
     *   data: {
     *     // ... data to create a TestObject
     *   }
     * })
     * 
     */
    create<T extends TestObjectCreateArgs>(args: SelectSubset<T, TestObjectCreateArgs<ExtArgs>>): Prisma__TestObjectClient<$Result.GetResult<Prisma.$TestObjectPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many TestObjects.
     * @param {TestObjectCreateManyArgs} args - Arguments to create many TestObjects.
     * @example
     * // Create many TestObjects
     * const testObject = await prisma.testObject.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TestObjectCreateManyArgs>(args?: SelectSubset<T, TestObjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TestObjects and returns the data saved in the database.
     * @param {TestObjectCreateManyAndReturnArgs} args - Arguments to create many TestObjects.
     * @example
     * // Create many TestObjects
     * const testObject = await prisma.testObject.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TestObjects and only return the `id`
     * const testObjectWithIdOnly = await prisma.testObject.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TestObjectCreateManyAndReturnArgs>(args?: SelectSubset<T, TestObjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestObjectPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a TestObject.
     * @param {TestObjectDeleteArgs} args - Arguments to delete one TestObject.
     * @example
     * // Delete one TestObject
     * const TestObject = await prisma.testObject.delete({
     *   where: {
     *     // ... filter to delete one TestObject
     *   }
     * })
     * 
     */
    delete<T extends TestObjectDeleteArgs>(args: SelectSubset<T, TestObjectDeleteArgs<ExtArgs>>): Prisma__TestObjectClient<$Result.GetResult<Prisma.$TestObjectPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one TestObject.
     * @param {TestObjectUpdateArgs} args - Arguments to update one TestObject.
     * @example
     * // Update one TestObject
     * const testObject = await prisma.testObject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TestObjectUpdateArgs>(args: SelectSubset<T, TestObjectUpdateArgs<ExtArgs>>): Prisma__TestObjectClient<$Result.GetResult<Prisma.$TestObjectPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more TestObjects.
     * @param {TestObjectDeleteManyArgs} args - Arguments to filter TestObjects to delete.
     * @example
     * // Delete a few TestObjects
     * const { count } = await prisma.testObject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TestObjectDeleteManyArgs>(args?: SelectSubset<T, TestObjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TestObjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestObjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TestObjects
     * const testObject = await prisma.testObject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TestObjectUpdateManyArgs>(args: SelectSubset<T, TestObjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TestObjects and returns the data updated in the database.
     * @param {TestObjectUpdateManyAndReturnArgs} args - Arguments to update many TestObjects.
     * @example
     * // Update many TestObjects
     * const testObject = await prisma.testObject.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TestObjects and only return the `id`
     * const testObjectWithIdOnly = await prisma.testObject.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TestObjectUpdateManyAndReturnArgs>(args: SelectSubset<T, TestObjectUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestObjectPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one TestObject.
     * @param {TestObjectUpsertArgs} args - Arguments to update or create a TestObject.
     * @example
     * // Update or create a TestObject
     * const testObject = await prisma.testObject.upsert({
     *   create: {
     *     // ... data to create a TestObject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TestObject we want to update
     *   }
     * })
     */
    upsert<T extends TestObjectUpsertArgs>(args: SelectSubset<T, TestObjectUpsertArgs<ExtArgs>>): Prisma__TestObjectClient<$Result.GetResult<Prisma.$TestObjectPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of TestObjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestObjectCountArgs} args - Arguments to filter TestObjects to count.
     * @example
     * // Count the number of TestObjects
     * const count = await prisma.testObject.count({
     *   where: {
     *     // ... the filter for the TestObjects we want to count
     *   }
     * })
    **/
    count<T extends TestObjectCountArgs>(
      args?: Subset<T, TestObjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestObjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TestObject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestObjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestObjectAggregateArgs>(args: Subset<T, TestObjectAggregateArgs>): Prisma.PrismaPromise<GetTestObjectAggregateType<T>>

    /**
     * Group by TestObject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestObjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TestObjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TestObjectGroupByArgs['orderBy'] }
        : { orderBy?: TestObjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TestObjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestObjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TestObject model
   */
  readonly fields: TestObjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TestObject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TestObjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    wrapped<T extends TestObject$wrappedArgs<ExtArgs> = {}>(args?: Subset<T, TestObject$wrappedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WrappedObjectPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    join1<T extends TestObject$join1Args<ExtArgs> = {}>(args?: Subset<T, TestObject$join1Args<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JoinTestObjectPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    join2<T extends TestObject$join2Args<ExtArgs> = {}>(args?: Subset<T, TestObject$join2Args<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JoinTestObject2Payload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TestObject model
   */ 
  interface TestObjectFieldRefs {
    readonly id: FieldRef<"TestObject", 'Bytes'>
    readonly required: FieldRef<"TestObject", 'String'>
    readonly persisted: FieldRef<"TestObject", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TestObject findUnique
   */
  export type TestObjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestObject
     */
    select?: TestObjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestObject
     */
    omit?: TestObjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestObjectInclude<ExtArgs> | null
    /**
     * Filter, which TestObject to fetch.
     */
    where: TestObjectWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TestObject findUniqueOrThrow
   */
  export type TestObjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestObject
     */
    select?: TestObjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestObject
     */
    omit?: TestObjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestObjectInclude<ExtArgs> | null
    /**
     * Filter, which TestObject to fetch.
     */
    where: TestObjectWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TestObject findFirst
   */
  export type TestObjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestObject
     */
    select?: TestObjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestObject
     */
    omit?: TestObjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestObjectInclude<ExtArgs> | null
    /**
     * Filter, which TestObject to fetch.
     */
    where?: TestObjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestObjects to fetch.
     */
    orderBy?: TestObjectOrderByWithRelationInput | TestObjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestObjects.
     */
    cursor?: TestObjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestObjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestObjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestObjects.
     */
    distinct?: TestObjectScalarFieldEnum | TestObjectScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TestObject findFirstOrThrow
   */
  export type TestObjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestObject
     */
    select?: TestObjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestObject
     */
    omit?: TestObjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestObjectInclude<ExtArgs> | null
    /**
     * Filter, which TestObject to fetch.
     */
    where?: TestObjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestObjects to fetch.
     */
    orderBy?: TestObjectOrderByWithRelationInput | TestObjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestObjects.
     */
    cursor?: TestObjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestObjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestObjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestObjects.
     */
    distinct?: TestObjectScalarFieldEnum | TestObjectScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TestObject findMany
   */
  export type TestObjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestObject
     */
    select?: TestObjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestObject
     */
    omit?: TestObjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestObjectInclude<ExtArgs> | null
    /**
     * Filter, which TestObjects to fetch.
     */
    where?: TestObjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestObjects to fetch.
     */
    orderBy?: TestObjectOrderByWithRelationInput | TestObjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TestObjects.
     */
    cursor?: TestObjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestObjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestObjects.
     */
    skip?: number
    distinct?: TestObjectScalarFieldEnum | TestObjectScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TestObject create
   */
  export type TestObjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestObject
     */
    select?: TestObjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestObject
     */
    omit?: TestObjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestObjectInclude<ExtArgs> | null
    /**
     * The data needed to create a TestObject.
     */
    data: XOR<TestObjectCreateInput, TestObjectUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TestObject createMany
   */
  export type TestObjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TestObjects.
     */
    data: TestObjectCreateManyInput | TestObjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TestObject createManyAndReturn
   */
  export type TestObjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestObject
     */
    select?: TestObjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TestObject
     */
    omit?: TestObjectOmit<ExtArgs> | null
    /**
     * The data used to create many TestObjects.
     */
    data: TestObjectCreateManyInput | TestObjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TestObject update
   */
  export type TestObjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestObject
     */
    select?: TestObjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestObject
     */
    omit?: TestObjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestObjectInclude<ExtArgs> | null
    /**
     * The data needed to update a TestObject.
     */
    data: XOR<TestObjectUpdateInput, TestObjectUncheckedUpdateInput>
    /**
     * Choose, which TestObject to update.
     */
    where: TestObjectWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TestObject updateMany
   */
  export type TestObjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TestObjects.
     */
    data: XOR<TestObjectUpdateManyMutationInput, TestObjectUncheckedUpdateManyInput>
    /**
     * Filter which TestObjects to update
     */
    where?: TestObjectWhereInput
    /**
     * Limit how many TestObjects to update.
     */
    limit?: number
  }

  /**
   * TestObject updateManyAndReturn
   */
  export type TestObjectUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestObject
     */
    select?: TestObjectSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TestObject
     */
    omit?: TestObjectOmit<ExtArgs> | null
    /**
     * The data used to update TestObjects.
     */
    data: XOR<TestObjectUpdateManyMutationInput, TestObjectUncheckedUpdateManyInput>
    /**
     * Filter which TestObjects to update
     */
    where?: TestObjectWhereInput
    /**
     * Limit how many TestObjects to update.
     */
    limit?: number
  }

  /**
   * TestObject upsert
   */
  export type TestObjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestObject
     */
    select?: TestObjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestObject
     */
    omit?: TestObjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestObjectInclude<ExtArgs> | null
    /**
     * The filter to search for the TestObject to update in case it exists.
     */
    where: TestObjectWhereUniqueInput
    /**
     * In case the TestObject found by the `where` argument doesn't exist, create a new TestObject with this data.
     */
    create: XOR<TestObjectCreateInput, TestObjectUncheckedCreateInput>
    /**
     * In case the TestObject was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TestObjectUpdateInput, TestObjectUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TestObject delete
   */
  export type TestObjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestObject
     */
    select?: TestObjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestObject
     */
    omit?: TestObjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestObjectInclude<ExtArgs> | null
    /**
     * Filter which TestObject to delete.
     */
    where: TestObjectWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * TestObject deleteMany
   */
  export type TestObjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestObjects to delete
     */
    where?: TestObjectWhereInput
    /**
     * Limit how many TestObjects to delete.
     */
    limit?: number
  }

  /**
   * TestObject.wrapped
   */
  export type TestObject$wrappedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WrappedObject
     */
    select?: WrappedObjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WrappedObject
     */
    omit?: WrappedObjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WrappedObjectInclude<ExtArgs> | null
    where?: WrappedObjectWhereInput
    orderBy?: WrappedObjectOrderByWithRelationInput | WrappedObjectOrderByWithRelationInput[]
    cursor?: WrappedObjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WrappedObjectScalarFieldEnum | WrappedObjectScalarFieldEnum[]
  }

  /**
   * TestObject.join1
   */
  export type TestObject$join1Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinTestObject
     */
    select?: JoinTestObjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JoinTestObject
     */
    omit?: JoinTestObjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinTestObjectInclude<ExtArgs> | null
    where?: JoinTestObjectWhereInput
    orderBy?: JoinTestObjectOrderByWithRelationInput | JoinTestObjectOrderByWithRelationInput[]
    cursor?: JoinTestObjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JoinTestObjectScalarFieldEnum | JoinTestObjectScalarFieldEnum[]
  }

  /**
   * TestObject.join2
   */
  export type TestObject$join2Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinTestObject2
     */
    select?: JoinTestObject2Select<ExtArgs> | null
    /**
     * Omit specific fields from the JoinTestObject2
     */
    omit?: JoinTestObject2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinTestObject2Include<ExtArgs> | null
    where?: JoinTestObject2WhereInput
    orderBy?: JoinTestObject2OrderByWithRelationInput | JoinTestObject2OrderByWithRelationInput[]
    cursor?: JoinTestObject2WhereUniqueInput
    take?: number
    skip?: number
    distinct?: JoinTestObject2ScalarFieldEnum | JoinTestObject2ScalarFieldEnum[]
  }

  /**
   * TestObject without action
   */
  export type TestObjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestObject
     */
    select?: TestObjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestObject
     */
    omit?: TestObjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestObjectInclude<ExtArgs> | null
  }


  /**
   * Model WrappedObject
   */

  export type AggregateWrappedObject = {
    _count: WrappedObjectCountAggregateOutputType | null
    _min: WrappedObjectMinAggregateOutputType | null
    _max: WrappedObjectMaxAggregateOutputType | null
  }

  export type WrappedObjectMinAggregateOutputType = {
    id: Uint8Array | null
    persisted: string | null
    testObjectId: Uint8Array | null
  }

  export type WrappedObjectMaxAggregateOutputType = {
    id: Uint8Array | null
    persisted: string | null
    testObjectId: Uint8Array | null
  }

  export type WrappedObjectCountAggregateOutputType = {
    id: number
    persisted: number
    testObjectId: number
    _all: number
  }


  export type WrappedObjectMinAggregateInputType = {
    id?: true
    persisted?: true
    testObjectId?: true
  }

  export type WrappedObjectMaxAggregateInputType = {
    id?: true
    persisted?: true
    testObjectId?: true
  }

  export type WrappedObjectCountAggregateInputType = {
    id?: true
    persisted?: true
    testObjectId?: true
    _all?: true
  }

  export type WrappedObjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WrappedObject to aggregate.
     */
    where?: WrappedObjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WrappedObjects to fetch.
     */
    orderBy?: WrappedObjectOrderByWithRelationInput | WrappedObjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WrappedObjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WrappedObjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WrappedObjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WrappedObjects
    **/
    _count?: true | WrappedObjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WrappedObjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WrappedObjectMaxAggregateInputType
  }

  export type GetWrappedObjectAggregateType<T extends WrappedObjectAggregateArgs> = {
        [P in keyof T & keyof AggregateWrappedObject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWrappedObject[P]>
      : GetScalarType<T[P], AggregateWrappedObject[P]>
  }




  export type WrappedObjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WrappedObjectWhereInput
    orderBy?: WrappedObjectOrderByWithAggregationInput | WrappedObjectOrderByWithAggregationInput[]
    by: WrappedObjectScalarFieldEnum[] | WrappedObjectScalarFieldEnum
    having?: WrappedObjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WrappedObjectCountAggregateInputType | true
    _min?: WrappedObjectMinAggregateInputType
    _max?: WrappedObjectMaxAggregateInputType
  }

  export type WrappedObjectGroupByOutputType = {
    id: Uint8Array
    persisted: string | null
    testObjectId: Uint8Array
    _count: WrappedObjectCountAggregateOutputType | null
    _min: WrappedObjectMinAggregateOutputType | null
    _max: WrappedObjectMaxAggregateOutputType | null
  }

  type GetWrappedObjectGroupByPayload<T extends WrappedObjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WrappedObjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WrappedObjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WrappedObjectGroupByOutputType[P]>
            : GetScalarType<T[P], WrappedObjectGroupByOutputType[P]>
        }
      >
    >


  export type WrappedObjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    persisted?: boolean
    testObjectId?: boolean
    testObject?: boolean | TestObjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wrappedObject"]>

  export type WrappedObjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    persisted?: boolean
    testObjectId?: boolean
    testObject?: boolean | TestObjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wrappedObject"]>

  export type WrappedObjectSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    persisted?: boolean
    testObjectId?: boolean
    testObject?: boolean | TestObjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wrappedObject"]>

  export type WrappedObjectSelectScalar = {
    id?: boolean
    persisted?: boolean
    testObjectId?: boolean
  }

  export type WrappedObjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "persisted" | "testObjectId", ExtArgs["result"]["wrappedObject"]>
  export type WrappedObjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    testObject?: boolean | TestObjectDefaultArgs<ExtArgs>
  }
  export type WrappedObjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    testObject?: boolean | TestObjectDefaultArgs<ExtArgs>
  }
  export type WrappedObjectIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    testObject?: boolean | TestObjectDefaultArgs<ExtArgs>
  }

  export type $WrappedObjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WrappedObject"
    objects: {
      testObject: Prisma.$TestObjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: Uint8Array
      persisted: string | null
      testObjectId: Uint8Array
    }, ExtArgs["result"]["wrappedObject"]>
    composites: {}
  }

  type WrappedObjectGetPayload<S extends boolean | null | undefined | WrappedObjectDefaultArgs> = $Result.GetResult<Prisma.$WrappedObjectPayload, S>

  type WrappedObjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WrappedObjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: WrappedObjectCountAggregateInputType | true
    }

  export interface WrappedObjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WrappedObject'], meta: { name: 'WrappedObject' } }
    /**
     * Find zero or one WrappedObject that matches the filter.
     * @param {WrappedObjectFindUniqueArgs} args - Arguments to find a WrappedObject
     * @example
     * // Get one WrappedObject
     * const wrappedObject = await prisma.wrappedObject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WrappedObjectFindUniqueArgs>(args: SelectSubset<T, WrappedObjectFindUniqueArgs<ExtArgs>>): Prisma__WrappedObjectClient<$Result.GetResult<Prisma.$WrappedObjectPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one WrappedObject that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WrappedObjectFindUniqueOrThrowArgs} args - Arguments to find a WrappedObject
     * @example
     * // Get one WrappedObject
     * const wrappedObject = await prisma.wrappedObject.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WrappedObjectFindUniqueOrThrowArgs>(args: SelectSubset<T, WrappedObjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WrappedObjectClient<$Result.GetResult<Prisma.$WrappedObjectPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first WrappedObject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WrappedObjectFindFirstArgs} args - Arguments to find a WrappedObject
     * @example
     * // Get one WrappedObject
     * const wrappedObject = await prisma.wrappedObject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WrappedObjectFindFirstArgs>(args?: SelectSubset<T, WrappedObjectFindFirstArgs<ExtArgs>>): Prisma__WrappedObjectClient<$Result.GetResult<Prisma.$WrappedObjectPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first WrappedObject that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WrappedObjectFindFirstOrThrowArgs} args - Arguments to find a WrappedObject
     * @example
     * // Get one WrappedObject
     * const wrappedObject = await prisma.wrappedObject.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WrappedObjectFindFirstOrThrowArgs>(args?: SelectSubset<T, WrappedObjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__WrappedObjectClient<$Result.GetResult<Prisma.$WrappedObjectPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more WrappedObjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WrappedObjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WrappedObjects
     * const wrappedObjects = await prisma.wrappedObject.findMany()
     * 
     * // Get first 10 WrappedObjects
     * const wrappedObjects = await prisma.wrappedObject.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wrappedObjectWithIdOnly = await prisma.wrappedObject.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WrappedObjectFindManyArgs>(args?: SelectSubset<T, WrappedObjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WrappedObjectPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a WrappedObject.
     * @param {WrappedObjectCreateArgs} args - Arguments to create a WrappedObject.
     * @example
     * // Create one WrappedObject
     * const WrappedObject = await prisma.wrappedObject.create({
     *   data: {
     *     // ... data to create a WrappedObject
     *   }
     * })
     * 
     */
    create<T extends WrappedObjectCreateArgs>(args: SelectSubset<T, WrappedObjectCreateArgs<ExtArgs>>): Prisma__WrappedObjectClient<$Result.GetResult<Prisma.$WrappedObjectPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many WrappedObjects.
     * @param {WrappedObjectCreateManyArgs} args - Arguments to create many WrappedObjects.
     * @example
     * // Create many WrappedObjects
     * const wrappedObject = await prisma.wrappedObject.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WrappedObjectCreateManyArgs>(args?: SelectSubset<T, WrappedObjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WrappedObjects and returns the data saved in the database.
     * @param {WrappedObjectCreateManyAndReturnArgs} args - Arguments to create many WrappedObjects.
     * @example
     * // Create many WrappedObjects
     * const wrappedObject = await prisma.wrappedObject.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WrappedObjects and only return the `id`
     * const wrappedObjectWithIdOnly = await prisma.wrappedObject.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WrappedObjectCreateManyAndReturnArgs>(args?: SelectSubset<T, WrappedObjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WrappedObjectPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a WrappedObject.
     * @param {WrappedObjectDeleteArgs} args - Arguments to delete one WrappedObject.
     * @example
     * // Delete one WrappedObject
     * const WrappedObject = await prisma.wrappedObject.delete({
     *   where: {
     *     // ... filter to delete one WrappedObject
     *   }
     * })
     * 
     */
    delete<T extends WrappedObjectDeleteArgs>(args: SelectSubset<T, WrappedObjectDeleteArgs<ExtArgs>>): Prisma__WrappedObjectClient<$Result.GetResult<Prisma.$WrappedObjectPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one WrappedObject.
     * @param {WrappedObjectUpdateArgs} args - Arguments to update one WrappedObject.
     * @example
     * // Update one WrappedObject
     * const wrappedObject = await prisma.wrappedObject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WrappedObjectUpdateArgs>(args: SelectSubset<T, WrappedObjectUpdateArgs<ExtArgs>>): Prisma__WrappedObjectClient<$Result.GetResult<Prisma.$WrappedObjectPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more WrappedObjects.
     * @param {WrappedObjectDeleteManyArgs} args - Arguments to filter WrappedObjects to delete.
     * @example
     * // Delete a few WrappedObjects
     * const { count } = await prisma.wrappedObject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WrappedObjectDeleteManyArgs>(args?: SelectSubset<T, WrappedObjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WrappedObjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WrappedObjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WrappedObjects
     * const wrappedObject = await prisma.wrappedObject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WrappedObjectUpdateManyArgs>(args: SelectSubset<T, WrappedObjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WrappedObjects and returns the data updated in the database.
     * @param {WrappedObjectUpdateManyAndReturnArgs} args - Arguments to update many WrappedObjects.
     * @example
     * // Update many WrappedObjects
     * const wrappedObject = await prisma.wrappedObject.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WrappedObjects and only return the `id`
     * const wrappedObjectWithIdOnly = await prisma.wrappedObject.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WrappedObjectUpdateManyAndReturnArgs>(args: SelectSubset<T, WrappedObjectUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WrappedObjectPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one WrappedObject.
     * @param {WrappedObjectUpsertArgs} args - Arguments to update or create a WrappedObject.
     * @example
     * // Update or create a WrappedObject
     * const wrappedObject = await prisma.wrappedObject.upsert({
     *   create: {
     *     // ... data to create a WrappedObject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WrappedObject we want to update
     *   }
     * })
     */
    upsert<T extends WrappedObjectUpsertArgs>(args: SelectSubset<T, WrappedObjectUpsertArgs<ExtArgs>>): Prisma__WrappedObjectClient<$Result.GetResult<Prisma.$WrappedObjectPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of WrappedObjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WrappedObjectCountArgs} args - Arguments to filter WrappedObjects to count.
     * @example
     * // Count the number of WrappedObjects
     * const count = await prisma.wrappedObject.count({
     *   where: {
     *     // ... the filter for the WrappedObjects we want to count
     *   }
     * })
    **/
    count<T extends WrappedObjectCountArgs>(
      args?: Subset<T, WrappedObjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WrappedObjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WrappedObject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WrappedObjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WrappedObjectAggregateArgs>(args: Subset<T, WrappedObjectAggregateArgs>): Prisma.PrismaPromise<GetWrappedObjectAggregateType<T>>

    /**
     * Group by WrappedObject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WrappedObjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WrappedObjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WrappedObjectGroupByArgs['orderBy'] }
        : { orderBy?: WrappedObjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WrappedObjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWrappedObjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WrappedObject model
   */
  readonly fields: WrappedObjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WrappedObject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WrappedObjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    testObject<T extends TestObjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TestObjectDefaultArgs<ExtArgs>>): Prisma__TestObjectClient<$Result.GetResult<Prisma.$TestObjectPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WrappedObject model
   */ 
  interface WrappedObjectFieldRefs {
    readonly id: FieldRef<"WrappedObject", 'Bytes'>
    readonly persisted: FieldRef<"WrappedObject", 'String'>
    readonly testObjectId: FieldRef<"WrappedObject", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * WrappedObject findUnique
   */
  export type WrappedObjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WrappedObject
     */
    select?: WrappedObjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WrappedObject
     */
    omit?: WrappedObjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WrappedObjectInclude<ExtArgs> | null
    /**
     * Filter, which WrappedObject to fetch.
     */
    where: WrappedObjectWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * WrappedObject findUniqueOrThrow
   */
  export type WrappedObjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WrappedObject
     */
    select?: WrappedObjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WrappedObject
     */
    omit?: WrappedObjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WrappedObjectInclude<ExtArgs> | null
    /**
     * Filter, which WrappedObject to fetch.
     */
    where: WrappedObjectWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * WrappedObject findFirst
   */
  export type WrappedObjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WrappedObject
     */
    select?: WrappedObjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WrappedObject
     */
    omit?: WrappedObjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WrappedObjectInclude<ExtArgs> | null
    /**
     * Filter, which WrappedObject to fetch.
     */
    where?: WrappedObjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WrappedObjects to fetch.
     */
    orderBy?: WrappedObjectOrderByWithRelationInput | WrappedObjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WrappedObjects.
     */
    cursor?: WrappedObjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WrappedObjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WrappedObjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WrappedObjects.
     */
    distinct?: WrappedObjectScalarFieldEnum | WrappedObjectScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * WrappedObject findFirstOrThrow
   */
  export type WrappedObjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WrappedObject
     */
    select?: WrappedObjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WrappedObject
     */
    omit?: WrappedObjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WrappedObjectInclude<ExtArgs> | null
    /**
     * Filter, which WrappedObject to fetch.
     */
    where?: WrappedObjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WrappedObjects to fetch.
     */
    orderBy?: WrappedObjectOrderByWithRelationInput | WrappedObjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WrappedObjects.
     */
    cursor?: WrappedObjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WrappedObjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WrappedObjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WrappedObjects.
     */
    distinct?: WrappedObjectScalarFieldEnum | WrappedObjectScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * WrappedObject findMany
   */
  export type WrappedObjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WrappedObject
     */
    select?: WrappedObjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WrappedObject
     */
    omit?: WrappedObjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WrappedObjectInclude<ExtArgs> | null
    /**
     * Filter, which WrappedObjects to fetch.
     */
    where?: WrappedObjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WrappedObjects to fetch.
     */
    orderBy?: WrappedObjectOrderByWithRelationInput | WrappedObjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WrappedObjects.
     */
    cursor?: WrappedObjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WrappedObjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WrappedObjects.
     */
    skip?: number
    distinct?: WrappedObjectScalarFieldEnum | WrappedObjectScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * WrappedObject create
   */
  export type WrappedObjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WrappedObject
     */
    select?: WrappedObjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WrappedObject
     */
    omit?: WrappedObjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WrappedObjectInclude<ExtArgs> | null
    /**
     * The data needed to create a WrappedObject.
     */
    data: XOR<WrappedObjectCreateInput, WrappedObjectUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * WrappedObject createMany
   */
  export type WrappedObjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WrappedObjects.
     */
    data: WrappedObjectCreateManyInput | WrappedObjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WrappedObject createManyAndReturn
   */
  export type WrappedObjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WrappedObject
     */
    select?: WrappedObjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WrappedObject
     */
    omit?: WrappedObjectOmit<ExtArgs> | null
    /**
     * The data used to create many WrappedObjects.
     */
    data: WrappedObjectCreateManyInput | WrappedObjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WrappedObjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WrappedObject update
   */
  export type WrappedObjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WrappedObject
     */
    select?: WrappedObjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WrappedObject
     */
    omit?: WrappedObjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WrappedObjectInclude<ExtArgs> | null
    /**
     * The data needed to update a WrappedObject.
     */
    data: XOR<WrappedObjectUpdateInput, WrappedObjectUncheckedUpdateInput>
    /**
     * Choose, which WrappedObject to update.
     */
    where: WrappedObjectWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * WrappedObject updateMany
   */
  export type WrappedObjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WrappedObjects.
     */
    data: XOR<WrappedObjectUpdateManyMutationInput, WrappedObjectUncheckedUpdateManyInput>
    /**
     * Filter which WrappedObjects to update
     */
    where?: WrappedObjectWhereInput
    /**
     * Limit how many WrappedObjects to update.
     */
    limit?: number
  }

  /**
   * WrappedObject updateManyAndReturn
   */
  export type WrappedObjectUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WrappedObject
     */
    select?: WrappedObjectSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WrappedObject
     */
    omit?: WrappedObjectOmit<ExtArgs> | null
    /**
     * The data used to update WrappedObjects.
     */
    data: XOR<WrappedObjectUpdateManyMutationInput, WrappedObjectUncheckedUpdateManyInput>
    /**
     * Filter which WrappedObjects to update
     */
    where?: WrappedObjectWhereInput
    /**
     * Limit how many WrappedObjects to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WrappedObjectIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WrappedObject upsert
   */
  export type WrappedObjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WrappedObject
     */
    select?: WrappedObjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WrappedObject
     */
    omit?: WrappedObjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WrappedObjectInclude<ExtArgs> | null
    /**
     * The filter to search for the WrappedObject to update in case it exists.
     */
    where: WrappedObjectWhereUniqueInput
    /**
     * In case the WrappedObject found by the `where` argument doesn't exist, create a new WrappedObject with this data.
     */
    create: XOR<WrappedObjectCreateInput, WrappedObjectUncheckedCreateInput>
    /**
     * In case the WrappedObject was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WrappedObjectUpdateInput, WrappedObjectUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * WrappedObject delete
   */
  export type WrappedObjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WrappedObject
     */
    select?: WrappedObjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WrappedObject
     */
    omit?: WrappedObjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WrappedObjectInclude<ExtArgs> | null
    /**
     * Filter which WrappedObject to delete.
     */
    where: WrappedObjectWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * WrappedObject deleteMany
   */
  export type WrappedObjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WrappedObjects to delete
     */
    where?: WrappedObjectWhereInput
    /**
     * Limit how many WrappedObjects to delete.
     */
    limit?: number
  }

  /**
   * WrappedObject without action
   */
  export type WrappedObjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WrappedObject
     */
    select?: WrappedObjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WrappedObject
     */
    omit?: WrappedObjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WrappedObjectInclude<ExtArgs> | null
  }


  /**
   * Model JoinTestObject
   */

  export type AggregateJoinTestObject = {
    _count: JoinTestObjectCountAggregateOutputType | null
    _min: JoinTestObjectMinAggregateOutputType | null
    _max: JoinTestObjectMaxAggregateOutputType | null
  }

  export type JoinTestObjectMinAggregateOutputType = {
    testObjectId: Uint8Array | null
    joinedObjectId: Uint8Array | null
    joinProperty: string | null
  }

  export type JoinTestObjectMaxAggregateOutputType = {
    testObjectId: Uint8Array | null
    joinedObjectId: Uint8Array | null
    joinProperty: string | null
  }

  export type JoinTestObjectCountAggregateOutputType = {
    testObjectId: number
    joinedObjectId: number
    joinProperty: number
    _all: number
  }


  export type JoinTestObjectMinAggregateInputType = {
    testObjectId?: true
    joinedObjectId?: true
    joinProperty?: true
  }

  export type JoinTestObjectMaxAggregateInputType = {
    testObjectId?: true
    joinedObjectId?: true
    joinProperty?: true
  }

  export type JoinTestObjectCountAggregateInputType = {
    testObjectId?: true
    joinedObjectId?: true
    joinProperty?: true
    _all?: true
  }

  export type JoinTestObjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JoinTestObject to aggregate.
     */
    where?: JoinTestObjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JoinTestObjects to fetch.
     */
    orderBy?: JoinTestObjectOrderByWithRelationInput | JoinTestObjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JoinTestObjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JoinTestObjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JoinTestObjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JoinTestObjects
    **/
    _count?: true | JoinTestObjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JoinTestObjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JoinTestObjectMaxAggregateInputType
  }

  export type GetJoinTestObjectAggregateType<T extends JoinTestObjectAggregateArgs> = {
        [P in keyof T & keyof AggregateJoinTestObject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJoinTestObject[P]>
      : GetScalarType<T[P], AggregateJoinTestObject[P]>
  }




  export type JoinTestObjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JoinTestObjectWhereInput
    orderBy?: JoinTestObjectOrderByWithAggregationInput | JoinTestObjectOrderByWithAggregationInput[]
    by: JoinTestObjectScalarFieldEnum[] | JoinTestObjectScalarFieldEnum
    having?: JoinTestObjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JoinTestObjectCountAggregateInputType | true
    _min?: JoinTestObjectMinAggregateInputType
    _max?: JoinTestObjectMaxAggregateInputType
  }

  export type JoinTestObjectGroupByOutputType = {
    testObjectId: Uint8Array
    joinedObjectId: Uint8Array
    joinProperty: string
    _count: JoinTestObjectCountAggregateOutputType | null
    _min: JoinTestObjectMinAggregateOutputType | null
    _max: JoinTestObjectMaxAggregateOutputType | null
  }

  type GetJoinTestObjectGroupByPayload<T extends JoinTestObjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JoinTestObjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JoinTestObjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JoinTestObjectGroupByOutputType[P]>
            : GetScalarType<T[P], JoinTestObjectGroupByOutputType[P]>
        }
      >
    >


  export type JoinTestObjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    testObjectId?: boolean
    joinedObjectId?: boolean
    joinProperty?: boolean
    testObjectRelation?: boolean | TestObjectDefaultArgs<ExtArgs>
    joinedObjectRelation?: boolean | JoinedObject1DefaultArgs<ExtArgs>
  }, ExtArgs["result"]["joinTestObject"]>

  export type JoinTestObjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    testObjectId?: boolean
    joinedObjectId?: boolean
    joinProperty?: boolean
    testObjectRelation?: boolean | TestObjectDefaultArgs<ExtArgs>
    joinedObjectRelation?: boolean | JoinedObject1DefaultArgs<ExtArgs>
  }, ExtArgs["result"]["joinTestObject"]>

  export type JoinTestObjectSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    testObjectId?: boolean
    joinedObjectId?: boolean
    joinProperty?: boolean
    testObjectRelation?: boolean | TestObjectDefaultArgs<ExtArgs>
    joinedObjectRelation?: boolean | JoinedObject1DefaultArgs<ExtArgs>
  }, ExtArgs["result"]["joinTestObject"]>

  export type JoinTestObjectSelectScalar = {
    testObjectId?: boolean
    joinedObjectId?: boolean
    joinProperty?: boolean
  }

  export type JoinTestObjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"testObjectId" | "joinedObjectId" | "joinProperty", ExtArgs["result"]["joinTestObject"]>
  export type JoinTestObjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    testObjectRelation?: boolean | TestObjectDefaultArgs<ExtArgs>
    joinedObjectRelation?: boolean | JoinedObject1DefaultArgs<ExtArgs>
  }
  export type JoinTestObjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    testObjectRelation?: boolean | TestObjectDefaultArgs<ExtArgs>
    joinedObjectRelation?: boolean | JoinedObject1DefaultArgs<ExtArgs>
  }
  export type JoinTestObjectIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    testObjectRelation?: boolean | TestObjectDefaultArgs<ExtArgs>
    joinedObjectRelation?: boolean | JoinedObject1DefaultArgs<ExtArgs>
  }

  export type $JoinTestObjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JoinTestObject"
    objects: {
      testObjectRelation: Prisma.$TestObjectPayload<ExtArgs>
      joinedObjectRelation: Prisma.$JoinedObject1Payload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      /**
       * @@wrapper-ignore
       */
      testObjectId: Uint8Array
      joinedObjectId: Uint8Array
      joinProperty: string
    }, ExtArgs["result"]["joinTestObject"]>
    composites: {}
  }

  type JoinTestObjectGetPayload<S extends boolean | null | undefined | JoinTestObjectDefaultArgs> = $Result.GetResult<Prisma.$JoinTestObjectPayload, S>

  type JoinTestObjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JoinTestObjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: JoinTestObjectCountAggregateInputType | true
    }

  export interface JoinTestObjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JoinTestObject'], meta: { name: 'JoinTestObject' } }
    /**
     * Find zero or one JoinTestObject that matches the filter.
     * @param {JoinTestObjectFindUniqueArgs} args - Arguments to find a JoinTestObject
     * @example
     * // Get one JoinTestObject
     * const joinTestObject = await prisma.joinTestObject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JoinTestObjectFindUniqueArgs>(args: SelectSubset<T, JoinTestObjectFindUniqueArgs<ExtArgs>>): Prisma__JoinTestObjectClient<$Result.GetResult<Prisma.$JoinTestObjectPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one JoinTestObject that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JoinTestObjectFindUniqueOrThrowArgs} args - Arguments to find a JoinTestObject
     * @example
     * // Get one JoinTestObject
     * const joinTestObject = await prisma.joinTestObject.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JoinTestObjectFindUniqueOrThrowArgs>(args: SelectSubset<T, JoinTestObjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JoinTestObjectClient<$Result.GetResult<Prisma.$JoinTestObjectPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first JoinTestObject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JoinTestObjectFindFirstArgs} args - Arguments to find a JoinTestObject
     * @example
     * // Get one JoinTestObject
     * const joinTestObject = await prisma.joinTestObject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JoinTestObjectFindFirstArgs>(args?: SelectSubset<T, JoinTestObjectFindFirstArgs<ExtArgs>>): Prisma__JoinTestObjectClient<$Result.GetResult<Prisma.$JoinTestObjectPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first JoinTestObject that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JoinTestObjectFindFirstOrThrowArgs} args - Arguments to find a JoinTestObject
     * @example
     * // Get one JoinTestObject
     * const joinTestObject = await prisma.joinTestObject.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JoinTestObjectFindFirstOrThrowArgs>(args?: SelectSubset<T, JoinTestObjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__JoinTestObjectClient<$Result.GetResult<Prisma.$JoinTestObjectPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more JoinTestObjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JoinTestObjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JoinTestObjects
     * const joinTestObjects = await prisma.joinTestObject.findMany()
     * 
     * // Get first 10 JoinTestObjects
     * const joinTestObjects = await prisma.joinTestObject.findMany({ take: 10 })
     * 
     * // Only select the `testObjectId`
     * const joinTestObjectWithTestObjectIdOnly = await prisma.joinTestObject.findMany({ select: { testObjectId: true } })
     * 
     */
    findMany<T extends JoinTestObjectFindManyArgs>(args?: SelectSubset<T, JoinTestObjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JoinTestObjectPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a JoinTestObject.
     * @param {JoinTestObjectCreateArgs} args - Arguments to create a JoinTestObject.
     * @example
     * // Create one JoinTestObject
     * const JoinTestObject = await prisma.joinTestObject.create({
     *   data: {
     *     // ... data to create a JoinTestObject
     *   }
     * })
     * 
     */
    create<T extends JoinTestObjectCreateArgs>(args: SelectSubset<T, JoinTestObjectCreateArgs<ExtArgs>>): Prisma__JoinTestObjectClient<$Result.GetResult<Prisma.$JoinTestObjectPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many JoinTestObjects.
     * @param {JoinTestObjectCreateManyArgs} args - Arguments to create many JoinTestObjects.
     * @example
     * // Create many JoinTestObjects
     * const joinTestObject = await prisma.joinTestObject.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JoinTestObjectCreateManyArgs>(args?: SelectSubset<T, JoinTestObjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JoinTestObjects and returns the data saved in the database.
     * @param {JoinTestObjectCreateManyAndReturnArgs} args - Arguments to create many JoinTestObjects.
     * @example
     * // Create many JoinTestObjects
     * const joinTestObject = await prisma.joinTestObject.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JoinTestObjects and only return the `testObjectId`
     * const joinTestObjectWithTestObjectIdOnly = await prisma.joinTestObject.createManyAndReturn({
     *   select: { testObjectId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JoinTestObjectCreateManyAndReturnArgs>(args?: SelectSubset<T, JoinTestObjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JoinTestObjectPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a JoinTestObject.
     * @param {JoinTestObjectDeleteArgs} args - Arguments to delete one JoinTestObject.
     * @example
     * // Delete one JoinTestObject
     * const JoinTestObject = await prisma.joinTestObject.delete({
     *   where: {
     *     // ... filter to delete one JoinTestObject
     *   }
     * })
     * 
     */
    delete<T extends JoinTestObjectDeleteArgs>(args: SelectSubset<T, JoinTestObjectDeleteArgs<ExtArgs>>): Prisma__JoinTestObjectClient<$Result.GetResult<Prisma.$JoinTestObjectPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one JoinTestObject.
     * @param {JoinTestObjectUpdateArgs} args - Arguments to update one JoinTestObject.
     * @example
     * // Update one JoinTestObject
     * const joinTestObject = await prisma.joinTestObject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JoinTestObjectUpdateArgs>(args: SelectSubset<T, JoinTestObjectUpdateArgs<ExtArgs>>): Prisma__JoinTestObjectClient<$Result.GetResult<Prisma.$JoinTestObjectPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more JoinTestObjects.
     * @param {JoinTestObjectDeleteManyArgs} args - Arguments to filter JoinTestObjects to delete.
     * @example
     * // Delete a few JoinTestObjects
     * const { count } = await prisma.joinTestObject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JoinTestObjectDeleteManyArgs>(args?: SelectSubset<T, JoinTestObjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JoinTestObjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JoinTestObjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JoinTestObjects
     * const joinTestObject = await prisma.joinTestObject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JoinTestObjectUpdateManyArgs>(args: SelectSubset<T, JoinTestObjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JoinTestObjects and returns the data updated in the database.
     * @param {JoinTestObjectUpdateManyAndReturnArgs} args - Arguments to update many JoinTestObjects.
     * @example
     * // Update many JoinTestObjects
     * const joinTestObject = await prisma.joinTestObject.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JoinTestObjects and only return the `testObjectId`
     * const joinTestObjectWithTestObjectIdOnly = await prisma.joinTestObject.updateManyAndReturn({
     *   select: { testObjectId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JoinTestObjectUpdateManyAndReturnArgs>(args: SelectSubset<T, JoinTestObjectUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JoinTestObjectPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one JoinTestObject.
     * @param {JoinTestObjectUpsertArgs} args - Arguments to update or create a JoinTestObject.
     * @example
     * // Update or create a JoinTestObject
     * const joinTestObject = await prisma.joinTestObject.upsert({
     *   create: {
     *     // ... data to create a JoinTestObject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JoinTestObject we want to update
     *   }
     * })
     */
    upsert<T extends JoinTestObjectUpsertArgs>(args: SelectSubset<T, JoinTestObjectUpsertArgs<ExtArgs>>): Prisma__JoinTestObjectClient<$Result.GetResult<Prisma.$JoinTestObjectPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of JoinTestObjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JoinTestObjectCountArgs} args - Arguments to filter JoinTestObjects to count.
     * @example
     * // Count the number of JoinTestObjects
     * const count = await prisma.joinTestObject.count({
     *   where: {
     *     // ... the filter for the JoinTestObjects we want to count
     *   }
     * })
    **/
    count<T extends JoinTestObjectCountArgs>(
      args?: Subset<T, JoinTestObjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JoinTestObjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JoinTestObject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JoinTestObjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JoinTestObjectAggregateArgs>(args: Subset<T, JoinTestObjectAggregateArgs>): Prisma.PrismaPromise<GetJoinTestObjectAggregateType<T>>

    /**
     * Group by JoinTestObject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JoinTestObjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JoinTestObjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JoinTestObjectGroupByArgs['orderBy'] }
        : { orderBy?: JoinTestObjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JoinTestObjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJoinTestObjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JoinTestObject model
   */
  readonly fields: JoinTestObjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JoinTestObject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JoinTestObjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    testObjectRelation<T extends TestObjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TestObjectDefaultArgs<ExtArgs>>): Prisma__TestObjectClient<$Result.GetResult<Prisma.$TestObjectPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    joinedObjectRelation<T extends JoinedObject1DefaultArgs<ExtArgs> = {}>(args?: Subset<T, JoinedObject1DefaultArgs<ExtArgs>>): Prisma__JoinedObject1Client<$Result.GetResult<Prisma.$JoinedObject1Payload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JoinTestObject model
   */ 
  interface JoinTestObjectFieldRefs {
    readonly testObjectId: FieldRef<"JoinTestObject", 'Bytes'>
    readonly joinedObjectId: FieldRef<"JoinTestObject", 'Bytes'>
    readonly joinProperty: FieldRef<"JoinTestObject", 'String'>
  }
    

  // Custom InputTypes
  /**
   * JoinTestObject findUnique
   */
  export type JoinTestObjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinTestObject
     */
    select?: JoinTestObjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JoinTestObject
     */
    omit?: JoinTestObjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinTestObjectInclude<ExtArgs> | null
    /**
     * Filter, which JoinTestObject to fetch.
     */
    where: JoinTestObjectWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * JoinTestObject findUniqueOrThrow
   */
  export type JoinTestObjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinTestObject
     */
    select?: JoinTestObjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JoinTestObject
     */
    omit?: JoinTestObjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinTestObjectInclude<ExtArgs> | null
    /**
     * Filter, which JoinTestObject to fetch.
     */
    where: JoinTestObjectWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * JoinTestObject findFirst
   */
  export type JoinTestObjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinTestObject
     */
    select?: JoinTestObjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JoinTestObject
     */
    omit?: JoinTestObjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinTestObjectInclude<ExtArgs> | null
    /**
     * Filter, which JoinTestObject to fetch.
     */
    where?: JoinTestObjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JoinTestObjects to fetch.
     */
    orderBy?: JoinTestObjectOrderByWithRelationInput | JoinTestObjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JoinTestObjects.
     */
    cursor?: JoinTestObjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JoinTestObjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JoinTestObjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JoinTestObjects.
     */
    distinct?: JoinTestObjectScalarFieldEnum | JoinTestObjectScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * JoinTestObject findFirstOrThrow
   */
  export type JoinTestObjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinTestObject
     */
    select?: JoinTestObjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JoinTestObject
     */
    omit?: JoinTestObjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinTestObjectInclude<ExtArgs> | null
    /**
     * Filter, which JoinTestObject to fetch.
     */
    where?: JoinTestObjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JoinTestObjects to fetch.
     */
    orderBy?: JoinTestObjectOrderByWithRelationInput | JoinTestObjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JoinTestObjects.
     */
    cursor?: JoinTestObjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JoinTestObjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JoinTestObjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JoinTestObjects.
     */
    distinct?: JoinTestObjectScalarFieldEnum | JoinTestObjectScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * JoinTestObject findMany
   */
  export type JoinTestObjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinTestObject
     */
    select?: JoinTestObjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JoinTestObject
     */
    omit?: JoinTestObjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinTestObjectInclude<ExtArgs> | null
    /**
     * Filter, which JoinTestObjects to fetch.
     */
    where?: JoinTestObjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JoinTestObjects to fetch.
     */
    orderBy?: JoinTestObjectOrderByWithRelationInput | JoinTestObjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JoinTestObjects.
     */
    cursor?: JoinTestObjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JoinTestObjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JoinTestObjects.
     */
    skip?: number
    distinct?: JoinTestObjectScalarFieldEnum | JoinTestObjectScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * JoinTestObject create
   */
  export type JoinTestObjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinTestObject
     */
    select?: JoinTestObjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JoinTestObject
     */
    omit?: JoinTestObjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinTestObjectInclude<ExtArgs> | null
    /**
     * The data needed to create a JoinTestObject.
     */
    data: XOR<JoinTestObjectCreateInput, JoinTestObjectUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * JoinTestObject createMany
   */
  export type JoinTestObjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JoinTestObjects.
     */
    data: JoinTestObjectCreateManyInput | JoinTestObjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JoinTestObject createManyAndReturn
   */
  export type JoinTestObjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinTestObject
     */
    select?: JoinTestObjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JoinTestObject
     */
    omit?: JoinTestObjectOmit<ExtArgs> | null
    /**
     * The data used to create many JoinTestObjects.
     */
    data: JoinTestObjectCreateManyInput | JoinTestObjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinTestObjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JoinTestObject update
   */
  export type JoinTestObjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinTestObject
     */
    select?: JoinTestObjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JoinTestObject
     */
    omit?: JoinTestObjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinTestObjectInclude<ExtArgs> | null
    /**
     * The data needed to update a JoinTestObject.
     */
    data: XOR<JoinTestObjectUpdateInput, JoinTestObjectUncheckedUpdateInput>
    /**
     * Choose, which JoinTestObject to update.
     */
    where: JoinTestObjectWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * JoinTestObject updateMany
   */
  export type JoinTestObjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JoinTestObjects.
     */
    data: XOR<JoinTestObjectUpdateManyMutationInput, JoinTestObjectUncheckedUpdateManyInput>
    /**
     * Filter which JoinTestObjects to update
     */
    where?: JoinTestObjectWhereInput
    /**
     * Limit how many JoinTestObjects to update.
     */
    limit?: number
  }

  /**
   * JoinTestObject updateManyAndReturn
   */
  export type JoinTestObjectUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinTestObject
     */
    select?: JoinTestObjectSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JoinTestObject
     */
    omit?: JoinTestObjectOmit<ExtArgs> | null
    /**
     * The data used to update JoinTestObjects.
     */
    data: XOR<JoinTestObjectUpdateManyMutationInput, JoinTestObjectUncheckedUpdateManyInput>
    /**
     * Filter which JoinTestObjects to update
     */
    where?: JoinTestObjectWhereInput
    /**
     * Limit how many JoinTestObjects to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinTestObjectIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * JoinTestObject upsert
   */
  export type JoinTestObjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinTestObject
     */
    select?: JoinTestObjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JoinTestObject
     */
    omit?: JoinTestObjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinTestObjectInclude<ExtArgs> | null
    /**
     * The filter to search for the JoinTestObject to update in case it exists.
     */
    where: JoinTestObjectWhereUniqueInput
    /**
     * In case the JoinTestObject found by the `where` argument doesn't exist, create a new JoinTestObject with this data.
     */
    create: XOR<JoinTestObjectCreateInput, JoinTestObjectUncheckedCreateInput>
    /**
     * In case the JoinTestObject was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JoinTestObjectUpdateInput, JoinTestObjectUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * JoinTestObject delete
   */
  export type JoinTestObjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinTestObject
     */
    select?: JoinTestObjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JoinTestObject
     */
    omit?: JoinTestObjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinTestObjectInclude<ExtArgs> | null
    /**
     * Filter which JoinTestObject to delete.
     */
    where: JoinTestObjectWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * JoinTestObject deleteMany
   */
  export type JoinTestObjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JoinTestObjects to delete
     */
    where?: JoinTestObjectWhereInput
    /**
     * Limit how many JoinTestObjects to delete.
     */
    limit?: number
  }

  /**
   * JoinTestObject without action
   */
  export type JoinTestObjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinTestObject
     */
    select?: JoinTestObjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JoinTestObject
     */
    omit?: JoinTestObjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinTestObjectInclude<ExtArgs> | null
  }


  /**
   * Model JoinTestObject2
   */

  export type AggregateJoinTestObject2 = {
    _count: JoinTestObject2CountAggregateOutputType | null
    _min: JoinTestObject2MinAggregateOutputType | null
    _max: JoinTestObject2MaxAggregateOutputType | null
  }

  export type JoinTestObject2MinAggregateOutputType = {
    id: Uint8Array | null
    testObjectId: Uint8Array | null
    joinedObjectId: Uint8Array | null
    joinProperty: string | null
  }

  export type JoinTestObject2MaxAggregateOutputType = {
    id: Uint8Array | null
    testObjectId: Uint8Array | null
    joinedObjectId: Uint8Array | null
    joinProperty: string | null
  }

  export type JoinTestObject2CountAggregateOutputType = {
    id: number
    testObjectId: number
    joinedObjectId: number
    joinProperty: number
    _all: number
  }


  export type JoinTestObject2MinAggregateInputType = {
    id?: true
    testObjectId?: true
    joinedObjectId?: true
    joinProperty?: true
  }

  export type JoinTestObject2MaxAggregateInputType = {
    id?: true
    testObjectId?: true
    joinedObjectId?: true
    joinProperty?: true
  }

  export type JoinTestObject2CountAggregateInputType = {
    id?: true
    testObjectId?: true
    joinedObjectId?: true
    joinProperty?: true
    _all?: true
  }

  export type JoinTestObject2AggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JoinTestObject2 to aggregate.
     */
    where?: JoinTestObject2WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JoinTestObject2s to fetch.
     */
    orderBy?: JoinTestObject2OrderByWithRelationInput | JoinTestObject2OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JoinTestObject2WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JoinTestObject2s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JoinTestObject2s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JoinTestObject2s
    **/
    _count?: true | JoinTestObject2CountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JoinTestObject2MinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JoinTestObject2MaxAggregateInputType
  }

  export type GetJoinTestObject2AggregateType<T extends JoinTestObject2AggregateArgs> = {
        [P in keyof T & keyof AggregateJoinTestObject2]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJoinTestObject2[P]>
      : GetScalarType<T[P], AggregateJoinTestObject2[P]>
  }




  export type JoinTestObject2GroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JoinTestObject2WhereInput
    orderBy?: JoinTestObject2OrderByWithAggregationInput | JoinTestObject2OrderByWithAggregationInput[]
    by: JoinTestObject2ScalarFieldEnum[] | JoinTestObject2ScalarFieldEnum
    having?: JoinTestObject2ScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JoinTestObject2CountAggregateInputType | true
    _min?: JoinTestObject2MinAggregateInputType
    _max?: JoinTestObject2MaxAggregateInputType
  }

  export type JoinTestObject2GroupByOutputType = {
    id: Uint8Array
    testObjectId: Uint8Array
    joinedObjectId: Uint8Array
    joinProperty: string
    _count: JoinTestObject2CountAggregateOutputType | null
    _min: JoinTestObject2MinAggregateOutputType | null
    _max: JoinTestObject2MaxAggregateOutputType | null
  }

  type GetJoinTestObject2GroupByPayload<T extends JoinTestObject2GroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JoinTestObject2GroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JoinTestObject2GroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JoinTestObject2GroupByOutputType[P]>
            : GetScalarType<T[P], JoinTestObject2GroupByOutputType[P]>
        }
      >
    >


  export type JoinTestObject2Select<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    testObjectId?: boolean
    joinedObjectId?: boolean
    joinProperty?: boolean
    testObjectRelation?: boolean | TestObjectDefaultArgs<ExtArgs>
    joinedObjectRelation?: boolean | JoinedObject2DefaultArgs<ExtArgs>
  }, ExtArgs["result"]["joinTestObject2"]>

  export type JoinTestObject2SelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    testObjectId?: boolean
    joinedObjectId?: boolean
    joinProperty?: boolean
    testObjectRelation?: boolean | TestObjectDefaultArgs<ExtArgs>
    joinedObjectRelation?: boolean | JoinedObject2DefaultArgs<ExtArgs>
  }, ExtArgs["result"]["joinTestObject2"]>

  export type JoinTestObject2SelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    testObjectId?: boolean
    joinedObjectId?: boolean
    joinProperty?: boolean
    testObjectRelation?: boolean | TestObjectDefaultArgs<ExtArgs>
    joinedObjectRelation?: boolean | JoinedObject2DefaultArgs<ExtArgs>
  }, ExtArgs["result"]["joinTestObject2"]>

  export type JoinTestObject2SelectScalar = {
    id?: boolean
    testObjectId?: boolean
    joinedObjectId?: boolean
    joinProperty?: boolean
  }

  export type JoinTestObject2Omit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "testObjectId" | "joinedObjectId" | "joinProperty", ExtArgs["result"]["joinTestObject2"]>
  export type JoinTestObject2Include<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    testObjectRelation?: boolean | TestObjectDefaultArgs<ExtArgs>
    joinedObjectRelation?: boolean | JoinedObject2DefaultArgs<ExtArgs>
  }
  export type JoinTestObject2IncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    testObjectRelation?: boolean | TestObjectDefaultArgs<ExtArgs>
    joinedObjectRelation?: boolean | JoinedObject2DefaultArgs<ExtArgs>
  }
  export type JoinTestObject2IncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    testObjectRelation?: boolean | TestObjectDefaultArgs<ExtArgs>
    joinedObjectRelation?: boolean | JoinedObject2DefaultArgs<ExtArgs>
  }

  export type $JoinTestObject2Payload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JoinTestObject2"
    objects: {
      testObjectRelation: Prisma.$TestObjectPayload<ExtArgs>
      joinedObjectRelation: Prisma.$JoinedObject2Payload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      /**
       * @@wrapper-ignore
       */
      id: Uint8Array
      testObjectId: Uint8Array
      joinedObjectId: Uint8Array
      joinProperty: string
    }, ExtArgs["result"]["joinTestObject2"]>
    composites: {}
  }

  type JoinTestObject2GetPayload<S extends boolean | null | undefined | JoinTestObject2DefaultArgs> = $Result.GetResult<Prisma.$JoinTestObject2Payload, S>

  type JoinTestObject2CountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JoinTestObject2FindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: JoinTestObject2CountAggregateInputType | true
    }

  export interface JoinTestObject2Delegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JoinTestObject2'], meta: { name: 'JoinTestObject2' } }
    /**
     * Find zero or one JoinTestObject2 that matches the filter.
     * @param {JoinTestObject2FindUniqueArgs} args - Arguments to find a JoinTestObject2
     * @example
     * // Get one JoinTestObject2
     * const joinTestObject2 = await prisma.joinTestObject2.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JoinTestObject2FindUniqueArgs>(args: SelectSubset<T, JoinTestObject2FindUniqueArgs<ExtArgs>>): Prisma__JoinTestObject2Client<$Result.GetResult<Prisma.$JoinTestObject2Payload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one JoinTestObject2 that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JoinTestObject2FindUniqueOrThrowArgs} args - Arguments to find a JoinTestObject2
     * @example
     * // Get one JoinTestObject2
     * const joinTestObject2 = await prisma.joinTestObject2.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JoinTestObject2FindUniqueOrThrowArgs>(args: SelectSubset<T, JoinTestObject2FindUniqueOrThrowArgs<ExtArgs>>): Prisma__JoinTestObject2Client<$Result.GetResult<Prisma.$JoinTestObject2Payload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first JoinTestObject2 that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JoinTestObject2FindFirstArgs} args - Arguments to find a JoinTestObject2
     * @example
     * // Get one JoinTestObject2
     * const joinTestObject2 = await prisma.joinTestObject2.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JoinTestObject2FindFirstArgs>(args?: SelectSubset<T, JoinTestObject2FindFirstArgs<ExtArgs>>): Prisma__JoinTestObject2Client<$Result.GetResult<Prisma.$JoinTestObject2Payload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first JoinTestObject2 that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JoinTestObject2FindFirstOrThrowArgs} args - Arguments to find a JoinTestObject2
     * @example
     * // Get one JoinTestObject2
     * const joinTestObject2 = await prisma.joinTestObject2.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JoinTestObject2FindFirstOrThrowArgs>(args?: SelectSubset<T, JoinTestObject2FindFirstOrThrowArgs<ExtArgs>>): Prisma__JoinTestObject2Client<$Result.GetResult<Prisma.$JoinTestObject2Payload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more JoinTestObject2s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JoinTestObject2FindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JoinTestObject2s
     * const joinTestObject2s = await prisma.joinTestObject2.findMany()
     * 
     * // Get first 10 JoinTestObject2s
     * const joinTestObject2s = await prisma.joinTestObject2.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const joinTestObject2WithIdOnly = await prisma.joinTestObject2.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JoinTestObject2FindManyArgs>(args?: SelectSubset<T, JoinTestObject2FindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JoinTestObject2Payload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a JoinTestObject2.
     * @param {JoinTestObject2CreateArgs} args - Arguments to create a JoinTestObject2.
     * @example
     * // Create one JoinTestObject2
     * const JoinTestObject2 = await prisma.joinTestObject2.create({
     *   data: {
     *     // ... data to create a JoinTestObject2
     *   }
     * })
     * 
     */
    create<T extends JoinTestObject2CreateArgs>(args: SelectSubset<T, JoinTestObject2CreateArgs<ExtArgs>>): Prisma__JoinTestObject2Client<$Result.GetResult<Prisma.$JoinTestObject2Payload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many JoinTestObject2s.
     * @param {JoinTestObject2CreateManyArgs} args - Arguments to create many JoinTestObject2s.
     * @example
     * // Create many JoinTestObject2s
     * const joinTestObject2 = await prisma.joinTestObject2.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JoinTestObject2CreateManyArgs>(args?: SelectSubset<T, JoinTestObject2CreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JoinTestObject2s and returns the data saved in the database.
     * @param {JoinTestObject2CreateManyAndReturnArgs} args - Arguments to create many JoinTestObject2s.
     * @example
     * // Create many JoinTestObject2s
     * const joinTestObject2 = await prisma.joinTestObject2.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JoinTestObject2s and only return the `id`
     * const joinTestObject2WithIdOnly = await prisma.joinTestObject2.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JoinTestObject2CreateManyAndReturnArgs>(args?: SelectSubset<T, JoinTestObject2CreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JoinTestObject2Payload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a JoinTestObject2.
     * @param {JoinTestObject2DeleteArgs} args - Arguments to delete one JoinTestObject2.
     * @example
     * // Delete one JoinTestObject2
     * const JoinTestObject2 = await prisma.joinTestObject2.delete({
     *   where: {
     *     // ... filter to delete one JoinTestObject2
     *   }
     * })
     * 
     */
    delete<T extends JoinTestObject2DeleteArgs>(args: SelectSubset<T, JoinTestObject2DeleteArgs<ExtArgs>>): Prisma__JoinTestObject2Client<$Result.GetResult<Prisma.$JoinTestObject2Payload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one JoinTestObject2.
     * @param {JoinTestObject2UpdateArgs} args - Arguments to update one JoinTestObject2.
     * @example
     * // Update one JoinTestObject2
     * const joinTestObject2 = await prisma.joinTestObject2.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JoinTestObject2UpdateArgs>(args: SelectSubset<T, JoinTestObject2UpdateArgs<ExtArgs>>): Prisma__JoinTestObject2Client<$Result.GetResult<Prisma.$JoinTestObject2Payload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more JoinTestObject2s.
     * @param {JoinTestObject2DeleteManyArgs} args - Arguments to filter JoinTestObject2s to delete.
     * @example
     * // Delete a few JoinTestObject2s
     * const { count } = await prisma.joinTestObject2.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JoinTestObject2DeleteManyArgs>(args?: SelectSubset<T, JoinTestObject2DeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JoinTestObject2s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JoinTestObject2UpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JoinTestObject2s
     * const joinTestObject2 = await prisma.joinTestObject2.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JoinTestObject2UpdateManyArgs>(args: SelectSubset<T, JoinTestObject2UpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JoinTestObject2s and returns the data updated in the database.
     * @param {JoinTestObject2UpdateManyAndReturnArgs} args - Arguments to update many JoinTestObject2s.
     * @example
     * // Update many JoinTestObject2s
     * const joinTestObject2 = await prisma.joinTestObject2.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JoinTestObject2s and only return the `id`
     * const joinTestObject2WithIdOnly = await prisma.joinTestObject2.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JoinTestObject2UpdateManyAndReturnArgs>(args: SelectSubset<T, JoinTestObject2UpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JoinTestObject2Payload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one JoinTestObject2.
     * @param {JoinTestObject2UpsertArgs} args - Arguments to update or create a JoinTestObject2.
     * @example
     * // Update or create a JoinTestObject2
     * const joinTestObject2 = await prisma.joinTestObject2.upsert({
     *   create: {
     *     // ... data to create a JoinTestObject2
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JoinTestObject2 we want to update
     *   }
     * })
     */
    upsert<T extends JoinTestObject2UpsertArgs>(args: SelectSubset<T, JoinTestObject2UpsertArgs<ExtArgs>>): Prisma__JoinTestObject2Client<$Result.GetResult<Prisma.$JoinTestObject2Payload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of JoinTestObject2s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JoinTestObject2CountArgs} args - Arguments to filter JoinTestObject2s to count.
     * @example
     * // Count the number of JoinTestObject2s
     * const count = await prisma.joinTestObject2.count({
     *   where: {
     *     // ... the filter for the JoinTestObject2s we want to count
     *   }
     * })
    **/
    count<T extends JoinTestObject2CountArgs>(
      args?: Subset<T, JoinTestObject2CountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JoinTestObject2CountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JoinTestObject2.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JoinTestObject2AggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JoinTestObject2AggregateArgs>(args: Subset<T, JoinTestObject2AggregateArgs>): Prisma.PrismaPromise<GetJoinTestObject2AggregateType<T>>

    /**
     * Group by JoinTestObject2.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JoinTestObject2GroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JoinTestObject2GroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JoinTestObject2GroupByArgs['orderBy'] }
        : { orderBy?: JoinTestObject2GroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JoinTestObject2GroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJoinTestObject2GroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JoinTestObject2 model
   */
  readonly fields: JoinTestObject2FieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JoinTestObject2.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JoinTestObject2Client<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    testObjectRelation<T extends TestObjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TestObjectDefaultArgs<ExtArgs>>): Prisma__TestObjectClient<$Result.GetResult<Prisma.$TestObjectPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    joinedObjectRelation<T extends JoinedObject2DefaultArgs<ExtArgs> = {}>(args?: Subset<T, JoinedObject2DefaultArgs<ExtArgs>>): Prisma__JoinedObject2Client<$Result.GetResult<Prisma.$JoinedObject2Payload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JoinTestObject2 model
   */ 
  interface JoinTestObject2FieldRefs {
    readonly id: FieldRef<"JoinTestObject2", 'Bytes'>
    readonly testObjectId: FieldRef<"JoinTestObject2", 'Bytes'>
    readonly joinedObjectId: FieldRef<"JoinTestObject2", 'Bytes'>
    readonly joinProperty: FieldRef<"JoinTestObject2", 'String'>
  }
    

  // Custom InputTypes
  /**
   * JoinTestObject2 findUnique
   */
  export type JoinTestObject2FindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinTestObject2
     */
    select?: JoinTestObject2Select<ExtArgs> | null
    /**
     * Omit specific fields from the JoinTestObject2
     */
    omit?: JoinTestObject2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinTestObject2Include<ExtArgs> | null
    /**
     * Filter, which JoinTestObject2 to fetch.
     */
    where: JoinTestObject2WhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * JoinTestObject2 findUniqueOrThrow
   */
  export type JoinTestObject2FindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinTestObject2
     */
    select?: JoinTestObject2Select<ExtArgs> | null
    /**
     * Omit specific fields from the JoinTestObject2
     */
    omit?: JoinTestObject2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinTestObject2Include<ExtArgs> | null
    /**
     * Filter, which JoinTestObject2 to fetch.
     */
    where: JoinTestObject2WhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * JoinTestObject2 findFirst
   */
  export type JoinTestObject2FindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinTestObject2
     */
    select?: JoinTestObject2Select<ExtArgs> | null
    /**
     * Omit specific fields from the JoinTestObject2
     */
    omit?: JoinTestObject2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinTestObject2Include<ExtArgs> | null
    /**
     * Filter, which JoinTestObject2 to fetch.
     */
    where?: JoinTestObject2WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JoinTestObject2s to fetch.
     */
    orderBy?: JoinTestObject2OrderByWithRelationInput | JoinTestObject2OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JoinTestObject2s.
     */
    cursor?: JoinTestObject2WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JoinTestObject2s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JoinTestObject2s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JoinTestObject2s.
     */
    distinct?: JoinTestObject2ScalarFieldEnum | JoinTestObject2ScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * JoinTestObject2 findFirstOrThrow
   */
  export type JoinTestObject2FindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinTestObject2
     */
    select?: JoinTestObject2Select<ExtArgs> | null
    /**
     * Omit specific fields from the JoinTestObject2
     */
    omit?: JoinTestObject2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinTestObject2Include<ExtArgs> | null
    /**
     * Filter, which JoinTestObject2 to fetch.
     */
    where?: JoinTestObject2WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JoinTestObject2s to fetch.
     */
    orderBy?: JoinTestObject2OrderByWithRelationInput | JoinTestObject2OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JoinTestObject2s.
     */
    cursor?: JoinTestObject2WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JoinTestObject2s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JoinTestObject2s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JoinTestObject2s.
     */
    distinct?: JoinTestObject2ScalarFieldEnum | JoinTestObject2ScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * JoinTestObject2 findMany
   */
  export type JoinTestObject2FindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinTestObject2
     */
    select?: JoinTestObject2Select<ExtArgs> | null
    /**
     * Omit specific fields from the JoinTestObject2
     */
    omit?: JoinTestObject2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinTestObject2Include<ExtArgs> | null
    /**
     * Filter, which JoinTestObject2s to fetch.
     */
    where?: JoinTestObject2WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JoinTestObject2s to fetch.
     */
    orderBy?: JoinTestObject2OrderByWithRelationInput | JoinTestObject2OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JoinTestObject2s.
     */
    cursor?: JoinTestObject2WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JoinTestObject2s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JoinTestObject2s.
     */
    skip?: number
    distinct?: JoinTestObject2ScalarFieldEnum | JoinTestObject2ScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * JoinTestObject2 create
   */
  export type JoinTestObject2CreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinTestObject2
     */
    select?: JoinTestObject2Select<ExtArgs> | null
    /**
     * Omit specific fields from the JoinTestObject2
     */
    omit?: JoinTestObject2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinTestObject2Include<ExtArgs> | null
    /**
     * The data needed to create a JoinTestObject2.
     */
    data: XOR<JoinTestObject2CreateInput, JoinTestObject2UncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * JoinTestObject2 createMany
   */
  export type JoinTestObject2CreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JoinTestObject2s.
     */
    data: JoinTestObject2CreateManyInput | JoinTestObject2CreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JoinTestObject2 createManyAndReturn
   */
  export type JoinTestObject2CreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinTestObject2
     */
    select?: JoinTestObject2SelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JoinTestObject2
     */
    omit?: JoinTestObject2Omit<ExtArgs> | null
    /**
     * The data used to create many JoinTestObject2s.
     */
    data: JoinTestObject2CreateManyInput | JoinTestObject2CreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinTestObject2IncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JoinTestObject2 update
   */
  export type JoinTestObject2UpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinTestObject2
     */
    select?: JoinTestObject2Select<ExtArgs> | null
    /**
     * Omit specific fields from the JoinTestObject2
     */
    omit?: JoinTestObject2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinTestObject2Include<ExtArgs> | null
    /**
     * The data needed to update a JoinTestObject2.
     */
    data: XOR<JoinTestObject2UpdateInput, JoinTestObject2UncheckedUpdateInput>
    /**
     * Choose, which JoinTestObject2 to update.
     */
    where: JoinTestObject2WhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * JoinTestObject2 updateMany
   */
  export type JoinTestObject2UpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JoinTestObject2s.
     */
    data: XOR<JoinTestObject2UpdateManyMutationInput, JoinTestObject2UncheckedUpdateManyInput>
    /**
     * Filter which JoinTestObject2s to update
     */
    where?: JoinTestObject2WhereInput
    /**
     * Limit how many JoinTestObject2s to update.
     */
    limit?: number
  }

  /**
   * JoinTestObject2 updateManyAndReturn
   */
  export type JoinTestObject2UpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinTestObject2
     */
    select?: JoinTestObject2SelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JoinTestObject2
     */
    omit?: JoinTestObject2Omit<ExtArgs> | null
    /**
     * The data used to update JoinTestObject2s.
     */
    data: XOR<JoinTestObject2UpdateManyMutationInput, JoinTestObject2UncheckedUpdateManyInput>
    /**
     * Filter which JoinTestObject2s to update
     */
    where?: JoinTestObject2WhereInput
    /**
     * Limit how many JoinTestObject2s to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinTestObject2IncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * JoinTestObject2 upsert
   */
  export type JoinTestObject2UpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinTestObject2
     */
    select?: JoinTestObject2Select<ExtArgs> | null
    /**
     * Omit specific fields from the JoinTestObject2
     */
    omit?: JoinTestObject2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinTestObject2Include<ExtArgs> | null
    /**
     * The filter to search for the JoinTestObject2 to update in case it exists.
     */
    where: JoinTestObject2WhereUniqueInput
    /**
     * In case the JoinTestObject2 found by the `where` argument doesn't exist, create a new JoinTestObject2 with this data.
     */
    create: XOR<JoinTestObject2CreateInput, JoinTestObject2UncheckedCreateInput>
    /**
     * In case the JoinTestObject2 was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JoinTestObject2UpdateInput, JoinTestObject2UncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * JoinTestObject2 delete
   */
  export type JoinTestObject2DeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinTestObject2
     */
    select?: JoinTestObject2Select<ExtArgs> | null
    /**
     * Omit specific fields from the JoinTestObject2
     */
    omit?: JoinTestObject2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinTestObject2Include<ExtArgs> | null
    /**
     * Filter which JoinTestObject2 to delete.
     */
    where: JoinTestObject2WhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * JoinTestObject2 deleteMany
   */
  export type JoinTestObject2DeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JoinTestObject2s to delete
     */
    where?: JoinTestObject2WhereInput
    /**
     * Limit how many JoinTestObject2s to delete.
     */
    limit?: number
  }

  /**
   * JoinTestObject2 without action
   */
  export type JoinTestObject2DefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinTestObject2
     */
    select?: JoinTestObject2Select<ExtArgs> | null
    /**
     * Omit specific fields from the JoinTestObject2
     */
    omit?: JoinTestObject2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinTestObject2Include<ExtArgs> | null
  }


  /**
   * Model JoinedObject1
   */

  export type AggregateJoinedObject1 = {
    _count: JoinedObject1CountAggregateOutputType | null
    _min: JoinedObject1MinAggregateOutputType | null
    _max: JoinedObject1MaxAggregateOutputType | null
  }

  export type JoinedObject1MinAggregateOutputType = {
    id: Uint8Array | null
    persisted: string | null
  }

  export type JoinedObject1MaxAggregateOutputType = {
    id: Uint8Array | null
    persisted: string | null
  }

  export type JoinedObject1CountAggregateOutputType = {
    id: number
    persisted: number
    _all: number
  }


  export type JoinedObject1MinAggregateInputType = {
    id?: true
    persisted?: true
  }

  export type JoinedObject1MaxAggregateInputType = {
    id?: true
    persisted?: true
  }

  export type JoinedObject1CountAggregateInputType = {
    id?: true
    persisted?: true
    _all?: true
  }

  export type JoinedObject1AggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JoinedObject1 to aggregate.
     */
    where?: JoinedObject1WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JoinedObject1s to fetch.
     */
    orderBy?: JoinedObject1OrderByWithRelationInput | JoinedObject1OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JoinedObject1WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JoinedObject1s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JoinedObject1s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JoinedObject1s
    **/
    _count?: true | JoinedObject1CountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JoinedObject1MinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JoinedObject1MaxAggregateInputType
  }

  export type GetJoinedObject1AggregateType<T extends JoinedObject1AggregateArgs> = {
        [P in keyof T & keyof AggregateJoinedObject1]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJoinedObject1[P]>
      : GetScalarType<T[P], AggregateJoinedObject1[P]>
  }




  export type JoinedObject1GroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JoinedObject1WhereInput
    orderBy?: JoinedObject1OrderByWithAggregationInput | JoinedObject1OrderByWithAggregationInput[]
    by: JoinedObject1ScalarFieldEnum[] | JoinedObject1ScalarFieldEnum
    having?: JoinedObject1ScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JoinedObject1CountAggregateInputType | true
    _min?: JoinedObject1MinAggregateInputType
    _max?: JoinedObject1MaxAggregateInputType
  }

  export type JoinedObject1GroupByOutputType = {
    id: Uint8Array
    persisted: string | null
    _count: JoinedObject1CountAggregateOutputType | null
    _min: JoinedObject1MinAggregateOutputType | null
    _max: JoinedObject1MaxAggregateOutputType | null
  }

  type GetJoinedObject1GroupByPayload<T extends JoinedObject1GroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JoinedObject1GroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JoinedObject1GroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JoinedObject1GroupByOutputType[P]>
            : GetScalarType<T[P], JoinedObject1GroupByOutputType[P]>
        }
      >
    >


  export type JoinedObject1Select<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    persisted?: boolean
    testObjects?: boolean | JoinedObject1$testObjectsArgs<ExtArgs>
    _count?: boolean | JoinedObject1CountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["joinedObject1"]>

  export type JoinedObject1SelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    persisted?: boolean
  }, ExtArgs["result"]["joinedObject1"]>

  export type JoinedObject1SelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    persisted?: boolean
  }, ExtArgs["result"]["joinedObject1"]>

  export type JoinedObject1SelectScalar = {
    id?: boolean
    persisted?: boolean
  }

  export type JoinedObject1Omit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "persisted", ExtArgs["result"]["joinedObject1"]>
  export type JoinedObject1Include<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    testObjects?: boolean | JoinedObject1$testObjectsArgs<ExtArgs>
    _count?: boolean | JoinedObject1CountOutputTypeDefaultArgs<ExtArgs>
  }
  export type JoinedObject1IncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type JoinedObject1IncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $JoinedObject1Payload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JoinedObject1"
    objects: {
      /**
       * @jointable(TestObject, testObjectRelation)
       * @join(joinProperty, joinProperty)
       */
      testObjects: Prisma.$JoinTestObjectPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: Uint8Array
      persisted: string | null
    }, ExtArgs["result"]["joinedObject1"]>
    composites: {}
  }

  type JoinedObject1GetPayload<S extends boolean | null | undefined | JoinedObject1DefaultArgs> = $Result.GetResult<Prisma.$JoinedObject1Payload, S>

  type JoinedObject1CountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JoinedObject1FindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: JoinedObject1CountAggregateInputType | true
    }

  export interface JoinedObject1Delegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JoinedObject1'], meta: { name: 'JoinedObject1' } }
    /**
     * Find zero or one JoinedObject1 that matches the filter.
     * @param {JoinedObject1FindUniqueArgs} args - Arguments to find a JoinedObject1
     * @example
     * // Get one JoinedObject1
     * const joinedObject1 = await prisma.joinedObject1.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JoinedObject1FindUniqueArgs>(args: SelectSubset<T, JoinedObject1FindUniqueArgs<ExtArgs>>): Prisma__JoinedObject1Client<$Result.GetResult<Prisma.$JoinedObject1Payload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one JoinedObject1 that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JoinedObject1FindUniqueOrThrowArgs} args - Arguments to find a JoinedObject1
     * @example
     * // Get one JoinedObject1
     * const joinedObject1 = await prisma.joinedObject1.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JoinedObject1FindUniqueOrThrowArgs>(args: SelectSubset<T, JoinedObject1FindUniqueOrThrowArgs<ExtArgs>>): Prisma__JoinedObject1Client<$Result.GetResult<Prisma.$JoinedObject1Payload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first JoinedObject1 that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JoinedObject1FindFirstArgs} args - Arguments to find a JoinedObject1
     * @example
     * // Get one JoinedObject1
     * const joinedObject1 = await prisma.joinedObject1.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JoinedObject1FindFirstArgs>(args?: SelectSubset<T, JoinedObject1FindFirstArgs<ExtArgs>>): Prisma__JoinedObject1Client<$Result.GetResult<Prisma.$JoinedObject1Payload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first JoinedObject1 that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JoinedObject1FindFirstOrThrowArgs} args - Arguments to find a JoinedObject1
     * @example
     * // Get one JoinedObject1
     * const joinedObject1 = await prisma.joinedObject1.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JoinedObject1FindFirstOrThrowArgs>(args?: SelectSubset<T, JoinedObject1FindFirstOrThrowArgs<ExtArgs>>): Prisma__JoinedObject1Client<$Result.GetResult<Prisma.$JoinedObject1Payload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more JoinedObject1s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JoinedObject1FindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JoinedObject1s
     * const joinedObject1s = await prisma.joinedObject1.findMany()
     * 
     * // Get first 10 JoinedObject1s
     * const joinedObject1s = await prisma.joinedObject1.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const joinedObject1WithIdOnly = await prisma.joinedObject1.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JoinedObject1FindManyArgs>(args?: SelectSubset<T, JoinedObject1FindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JoinedObject1Payload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a JoinedObject1.
     * @param {JoinedObject1CreateArgs} args - Arguments to create a JoinedObject1.
     * @example
     * // Create one JoinedObject1
     * const JoinedObject1 = await prisma.joinedObject1.create({
     *   data: {
     *     // ... data to create a JoinedObject1
     *   }
     * })
     * 
     */
    create<T extends JoinedObject1CreateArgs>(args: SelectSubset<T, JoinedObject1CreateArgs<ExtArgs>>): Prisma__JoinedObject1Client<$Result.GetResult<Prisma.$JoinedObject1Payload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many JoinedObject1s.
     * @param {JoinedObject1CreateManyArgs} args - Arguments to create many JoinedObject1s.
     * @example
     * // Create many JoinedObject1s
     * const joinedObject1 = await prisma.joinedObject1.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JoinedObject1CreateManyArgs>(args?: SelectSubset<T, JoinedObject1CreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JoinedObject1s and returns the data saved in the database.
     * @param {JoinedObject1CreateManyAndReturnArgs} args - Arguments to create many JoinedObject1s.
     * @example
     * // Create many JoinedObject1s
     * const joinedObject1 = await prisma.joinedObject1.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JoinedObject1s and only return the `id`
     * const joinedObject1WithIdOnly = await prisma.joinedObject1.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JoinedObject1CreateManyAndReturnArgs>(args?: SelectSubset<T, JoinedObject1CreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JoinedObject1Payload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a JoinedObject1.
     * @param {JoinedObject1DeleteArgs} args - Arguments to delete one JoinedObject1.
     * @example
     * // Delete one JoinedObject1
     * const JoinedObject1 = await prisma.joinedObject1.delete({
     *   where: {
     *     // ... filter to delete one JoinedObject1
     *   }
     * })
     * 
     */
    delete<T extends JoinedObject1DeleteArgs>(args: SelectSubset<T, JoinedObject1DeleteArgs<ExtArgs>>): Prisma__JoinedObject1Client<$Result.GetResult<Prisma.$JoinedObject1Payload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one JoinedObject1.
     * @param {JoinedObject1UpdateArgs} args - Arguments to update one JoinedObject1.
     * @example
     * // Update one JoinedObject1
     * const joinedObject1 = await prisma.joinedObject1.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JoinedObject1UpdateArgs>(args: SelectSubset<T, JoinedObject1UpdateArgs<ExtArgs>>): Prisma__JoinedObject1Client<$Result.GetResult<Prisma.$JoinedObject1Payload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more JoinedObject1s.
     * @param {JoinedObject1DeleteManyArgs} args - Arguments to filter JoinedObject1s to delete.
     * @example
     * // Delete a few JoinedObject1s
     * const { count } = await prisma.joinedObject1.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JoinedObject1DeleteManyArgs>(args?: SelectSubset<T, JoinedObject1DeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JoinedObject1s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JoinedObject1UpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JoinedObject1s
     * const joinedObject1 = await prisma.joinedObject1.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JoinedObject1UpdateManyArgs>(args: SelectSubset<T, JoinedObject1UpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JoinedObject1s and returns the data updated in the database.
     * @param {JoinedObject1UpdateManyAndReturnArgs} args - Arguments to update many JoinedObject1s.
     * @example
     * // Update many JoinedObject1s
     * const joinedObject1 = await prisma.joinedObject1.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JoinedObject1s and only return the `id`
     * const joinedObject1WithIdOnly = await prisma.joinedObject1.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JoinedObject1UpdateManyAndReturnArgs>(args: SelectSubset<T, JoinedObject1UpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JoinedObject1Payload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one JoinedObject1.
     * @param {JoinedObject1UpsertArgs} args - Arguments to update or create a JoinedObject1.
     * @example
     * // Update or create a JoinedObject1
     * const joinedObject1 = await prisma.joinedObject1.upsert({
     *   create: {
     *     // ... data to create a JoinedObject1
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JoinedObject1 we want to update
     *   }
     * })
     */
    upsert<T extends JoinedObject1UpsertArgs>(args: SelectSubset<T, JoinedObject1UpsertArgs<ExtArgs>>): Prisma__JoinedObject1Client<$Result.GetResult<Prisma.$JoinedObject1Payload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of JoinedObject1s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JoinedObject1CountArgs} args - Arguments to filter JoinedObject1s to count.
     * @example
     * // Count the number of JoinedObject1s
     * const count = await prisma.joinedObject1.count({
     *   where: {
     *     // ... the filter for the JoinedObject1s we want to count
     *   }
     * })
    **/
    count<T extends JoinedObject1CountArgs>(
      args?: Subset<T, JoinedObject1CountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JoinedObject1CountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JoinedObject1.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JoinedObject1AggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JoinedObject1AggregateArgs>(args: Subset<T, JoinedObject1AggregateArgs>): Prisma.PrismaPromise<GetJoinedObject1AggregateType<T>>

    /**
     * Group by JoinedObject1.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JoinedObject1GroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JoinedObject1GroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JoinedObject1GroupByArgs['orderBy'] }
        : { orderBy?: JoinedObject1GroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JoinedObject1GroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJoinedObject1GroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JoinedObject1 model
   */
  readonly fields: JoinedObject1FieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JoinedObject1.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JoinedObject1Client<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    testObjects<T extends JoinedObject1$testObjectsArgs<ExtArgs> = {}>(args?: Subset<T, JoinedObject1$testObjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JoinTestObjectPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JoinedObject1 model
   */ 
  interface JoinedObject1FieldRefs {
    readonly id: FieldRef<"JoinedObject1", 'Bytes'>
    readonly persisted: FieldRef<"JoinedObject1", 'String'>
  }
    

  // Custom InputTypes
  /**
   * JoinedObject1 findUnique
   */
  export type JoinedObject1FindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinedObject1
     */
    select?: JoinedObject1Select<ExtArgs> | null
    /**
     * Omit specific fields from the JoinedObject1
     */
    omit?: JoinedObject1Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinedObject1Include<ExtArgs> | null
    /**
     * Filter, which JoinedObject1 to fetch.
     */
    where: JoinedObject1WhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * JoinedObject1 findUniqueOrThrow
   */
  export type JoinedObject1FindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinedObject1
     */
    select?: JoinedObject1Select<ExtArgs> | null
    /**
     * Omit specific fields from the JoinedObject1
     */
    omit?: JoinedObject1Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinedObject1Include<ExtArgs> | null
    /**
     * Filter, which JoinedObject1 to fetch.
     */
    where: JoinedObject1WhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * JoinedObject1 findFirst
   */
  export type JoinedObject1FindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinedObject1
     */
    select?: JoinedObject1Select<ExtArgs> | null
    /**
     * Omit specific fields from the JoinedObject1
     */
    omit?: JoinedObject1Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinedObject1Include<ExtArgs> | null
    /**
     * Filter, which JoinedObject1 to fetch.
     */
    where?: JoinedObject1WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JoinedObject1s to fetch.
     */
    orderBy?: JoinedObject1OrderByWithRelationInput | JoinedObject1OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JoinedObject1s.
     */
    cursor?: JoinedObject1WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JoinedObject1s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JoinedObject1s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JoinedObject1s.
     */
    distinct?: JoinedObject1ScalarFieldEnum | JoinedObject1ScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * JoinedObject1 findFirstOrThrow
   */
  export type JoinedObject1FindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinedObject1
     */
    select?: JoinedObject1Select<ExtArgs> | null
    /**
     * Omit specific fields from the JoinedObject1
     */
    omit?: JoinedObject1Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinedObject1Include<ExtArgs> | null
    /**
     * Filter, which JoinedObject1 to fetch.
     */
    where?: JoinedObject1WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JoinedObject1s to fetch.
     */
    orderBy?: JoinedObject1OrderByWithRelationInput | JoinedObject1OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JoinedObject1s.
     */
    cursor?: JoinedObject1WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JoinedObject1s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JoinedObject1s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JoinedObject1s.
     */
    distinct?: JoinedObject1ScalarFieldEnum | JoinedObject1ScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * JoinedObject1 findMany
   */
  export type JoinedObject1FindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinedObject1
     */
    select?: JoinedObject1Select<ExtArgs> | null
    /**
     * Omit specific fields from the JoinedObject1
     */
    omit?: JoinedObject1Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinedObject1Include<ExtArgs> | null
    /**
     * Filter, which JoinedObject1s to fetch.
     */
    where?: JoinedObject1WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JoinedObject1s to fetch.
     */
    orderBy?: JoinedObject1OrderByWithRelationInput | JoinedObject1OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JoinedObject1s.
     */
    cursor?: JoinedObject1WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JoinedObject1s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JoinedObject1s.
     */
    skip?: number
    distinct?: JoinedObject1ScalarFieldEnum | JoinedObject1ScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * JoinedObject1 create
   */
  export type JoinedObject1CreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinedObject1
     */
    select?: JoinedObject1Select<ExtArgs> | null
    /**
     * Omit specific fields from the JoinedObject1
     */
    omit?: JoinedObject1Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinedObject1Include<ExtArgs> | null
    /**
     * The data needed to create a JoinedObject1.
     */
    data: XOR<JoinedObject1CreateInput, JoinedObject1UncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * JoinedObject1 createMany
   */
  export type JoinedObject1CreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JoinedObject1s.
     */
    data: JoinedObject1CreateManyInput | JoinedObject1CreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JoinedObject1 createManyAndReturn
   */
  export type JoinedObject1CreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinedObject1
     */
    select?: JoinedObject1SelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JoinedObject1
     */
    omit?: JoinedObject1Omit<ExtArgs> | null
    /**
     * The data used to create many JoinedObject1s.
     */
    data: JoinedObject1CreateManyInput | JoinedObject1CreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JoinedObject1 update
   */
  export type JoinedObject1UpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinedObject1
     */
    select?: JoinedObject1Select<ExtArgs> | null
    /**
     * Omit specific fields from the JoinedObject1
     */
    omit?: JoinedObject1Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinedObject1Include<ExtArgs> | null
    /**
     * The data needed to update a JoinedObject1.
     */
    data: XOR<JoinedObject1UpdateInput, JoinedObject1UncheckedUpdateInput>
    /**
     * Choose, which JoinedObject1 to update.
     */
    where: JoinedObject1WhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * JoinedObject1 updateMany
   */
  export type JoinedObject1UpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JoinedObject1s.
     */
    data: XOR<JoinedObject1UpdateManyMutationInput, JoinedObject1UncheckedUpdateManyInput>
    /**
     * Filter which JoinedObject1s to update
     */
    where?: JoinedObject1WhereInput
    /**
     * Limit how many JoinedObject1s to update.
     */
    limit?: number
  }

  /**
   * JoinedObject1 updateManyAndReturn
   */
  export type JoinedObject1UpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinedObject1
     */
    select?: JoinedObject1SelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JoinedObject1
     */
    omit?: JoinedObject1Omit<ExtArgs> | null
    /**
     * The data used to update JoinedObject1s.
     */
    data: XOR<JoinedObject1UpdateManyMutationInput, JoinedObject1UncheckedUpdateManyInput>
    /**
     * Filter which JoinedObject1s to update
     */
    where?: JoinedObject1WhereInput
    /**
     * Limit how many JoinedObject1s to update.
     */
    limit?: number
  }

  /**
   * JoinedObject1 upsert
   */
  export type JoinedObject1UpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinedObject1
     */
    select?: JoinedObject1Select<ExtArgs> | null
    /**
     * Omit specific fields from the JoinedObject1
     */
    omit?: JoinedObject1Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinedObject1Include<ExtArgs> | null
    /**
     * The filter to search for the JoinedObject1 to update in case it exists.
     */
    where: JoinedObject1WhereUniqueInput
    /**
     * In case the JoinedObject1 found by the `where` argument doesn't exist, create a new JoinedObject1 with this data.
     */
    create: XOR<JoinedObject1CreateInput, JoinedObject1UncheckedCreateInput>
    /**
     * In case the JoinedObject1 was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JoinedObject1UpdateInput, JoinedObject1UncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * JoinedObject1 delete
   */
  export type JoinedObject1DeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinedObject1
     */
    select?: JoinedObject1Select<ExtArgs> | null
    /**
     * Omit specific fields from the JoinedObject1
     */
    omit?: JoinedObject1Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinedObject1Include<ExtArgs> | null
    /**
     * Filter which JoinedObject1 to delete.
     */
    where: JoinedObject1WhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * JoinedObject1 deleteMany
   */
  export type JoinedObject1DeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JoinedObject1s to delete
     */
    where?: JoinedObject1WhereInput
    /**
     * Limit how many JoinedObject1s to delete.
     */
    limit?: number
  }

  /**
   * JoinedObject1.testObjects
   */
  export type JoinedObject1$testObjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinTestObject
     */
    select?: JoinTestObjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JoinTestObject
     */
    omit?: JoinTestObjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinTestObjectInclude<ExtArgs> | null
    where?: JoinTestObjectWhereInput
    orderBy?: JoinTestObjectOrderByWithRelationInput | JoinTestObjectOrderByWithRelationInput[]
    cursor?: JoinTestObjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JoinTestObjectScalarFieldEnum | JoinTestObjectScalarFieldEnum[]
  }

  /**
   * JoinedObject1 without action
   */
  export type JoinedObject1DefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinedObject1
     */
    select?: JoinedObject1Select<ExtArgs> | null
    /**
     * Omit specific fields from the JoinedObject1
     */
    omit?: JoinedObject1Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinedObject1Include<ExtArgs> | null
  }


  /**
   * Model JoinedObject2
   */

  export type AggregateJoinedObject2 = {
    _count: JoinedObject2CountAggregateOutputType | null
    _min: JoinedObject2MinAggregateOutputType | null
    _max: JoinedObject2MaxAggregateOutputType | null
  }

  export type JoinedObject2MinAggregateOutputType = {
    id: Uint8Array | null
    persisted: string | null
  }

  export type JoinedObject2MaxAggregateOutputType = {
    id: Uint8Array | null
    persisted: string | null
  }

  export type JoinedObject2CountAggregateOutputType = {
    id: number
    persisted: number
    _all: number
  }


  export type JoinedObject2MinAggregateInputType = {
    id?: true
    persisted?: true
  }

  export type JoinedObject2MaxAggregateInputType = {
    id?: true
    persisted?: true
  }

  export type JoinedObject2CountAggregateInputType = {
    id?: true
    persisted?: true
    _all?: true
  }

  export type JoinedObject2AggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JoinedObject2 to aggregate.
     */
    where?: JoinedObject2WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JoinedObject2s to fetch.
     */
    orderBy?: JoinedObject2OrderByWithRelationInput | JoinedObject2OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JoinedObject2WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JoinedObject2s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JoinedObject2s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JoinedObject2s
    **/
    _count?: true | JoinedObject2CountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JoinedObject2MinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JoinedObject2MaxAggregateInputType
  }

  export type GetJoinedObject2AggregateType<T extends JoinedObject2AggregateArgs> = {
        [P in keyof T & keyof AggregateJoinedObject2]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJoinedObject2[P]>
      : GetScalarType<T[P], AggregateJoinedObject2[P]>
  }




  export type JoinedObject2GroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JoinedObject2WhereInput
    orderBy?: JoinedObject2OrderByWithAggregationInput | JoinedObject2OrderByWithAggregationInput[]
    by: JoinedObject2ScalarFieldEnum[] | JoinedObject2ScalarFieldEnum
    having?: JoinedObject2ScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JoinedObject2CountAggregateInputType | true
    _min?: JoinedObject2MinAggregateInputType
    _max?: JoinedObject2MaxAggregateInputType
  }

  export type JoinedObject2GroupByOutputType = {
    id: Uint8Array
    persisted: string | null
    _count: JoinedObject2CountAggregateOutputType | null
    _min: JoinedObject2MinAggregateOutputType | null
    _max: JoinedObject2MaxAggregateOutputType | null
  }

  type GetJoinedObject2GroupByPayload<T extends JoinedObject2GroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JoinedObject2GroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JoinedObject2GroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JoinedObject2GroupByOutputType[P]>
            : GetScalarType<T[P], JoinedObject2GroupByOutputType[P]>
        }
      >
    >


  export type JoinedObject2Select<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    persisted?: boolean
    testObjects?: boolean | JoinedObject2$testObjectsArgs<ExtArgs>
    _count?: boolean | JoinedObject2CountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["joinedObject2"]>

  export type JoinedObject2SelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    persisted?: boolean
  }, ExtArgs["result"]["joinedObject2"]>

  export type JoinedObject2SelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    persisted?: boolean
  }, ExtArgs["result"]["joinedObject2"]>

  export type JoinedObject2SelectScalar = {
    id?: boolean
    persisted?: boolean
  }

  export type JoinedObject2Omit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "persisted", ExtArgs["result"]["joinedObject2"]>
  export type JoinedObject2Include<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    testObjects?: boolean | JoinedObject2$testObjectsArgs<ExtArgs>
    _count?: boolean | JoinedObject2CountOutputTypeDefaultArgs<ExtArgs>
  }
  export type JoinedObject2IncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type JoinedObject2IncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $JoinedObject2Payload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JoinedObject2"
    objects: {
      /**
       * @jointable(TestObject, testObjectRelation)
       * @join(joinProperty, joinProperty)
       * @joinid(joinId)
       */
      testObjects: Prisma.$JoinTestObject2Payload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: Uint8Array
      persisted: string | null
    }, ExtArgs["result"]["joinedObject2"]>
    composites: {}
  }

  type JoinedObject2GetPayload<S extends boolean | null | undefined | JoinedObject2DefaultArgs> = $Result.GetResult<Prisma.$JoinedObject2Payload, S>

  type JoinedObject2CountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JoinedObject2FindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: JoinedObject2CountAggregateInputType | true
    }

  export interface JoinedObject2Delegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JoinedObject2'], meta: { name: 'JoinedObject2' } }
    /**
     * Find zero or one JoinedObject2 that matches the filter.
     * @param {JoinedObject2FindUniqueArgs} args - Arguments to find a JoinedObject2
     * @example
     * // Get one JoinedObject2
     * const joinedObject2 = await prisma.joinedObject2.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JoinedObject2FindUniqueArgs>(args: SelectSubset<T, JoinedObject2FindUniqueArgs<ExtArgs>>): Prisma__JoinedObject2Client<$Result.GetResult<Prisma.$JoinedObject2Payload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one JoinedObject2 that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JoinedObject2FindUniqueOrThrowArgs} args - Arguments to find a JoinedObject2
     * @example
     * // Get one JoinedObject2
     * const joinedObject2 = await prisma.joinedObject2.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JoinedObject2FindUniqueOrThrowArgs>(args: SelectSubset<T, JoinedObject2FindUniqueOrThrowArgs<ExtArgs>>): Prisma__JoinedObject2Client<$Result.GetResult<Prisma.$JoinedObject2Payload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first JoinedObject2 that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JoinedObject2FindFirstArgs} args - Arguments to find a JoinedObject2
     * @example
     * // Get one JoinedObject2
     * const joinedObject2 = await prisma.joinedObject2.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JoinedObject2FindFirstArgs>(args?: SelectSubset<T, JoinedObject2FindFirstArgs<ExtArgs>>): Prisma__JoinedObject2Client<$Result.GetResult<Prisma.$JoinedObject2Payload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first JoinedObject2 that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JoinedObject2FindFirstOrThrowArgs} args - Arguments to find a JoinedObject2
     * @example
     * // Get one JoinedObject2
     * const joinedObject2 = await prisma.joinedObject2.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JoinedObject2FindFirstOrThrowArgs>(args?: SelectSubset<T, JoinedObject2FindFirstOrThrowArgs<ExtArgs>>): Prisma__JoinedObject2Client<$Result.GetResult<Prisma.$JoinedObject2Payload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more JoinedObject2s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JoinedObject2FindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JoinedObject2s
     * const joinedObject2s = await prisma.joinedObject2.findMany()
     * 
     * // Get first 10 JoinedObject2s
     * const joinedObject2s = await prisma.joinedObject2.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const joinedObject2WithIdOnly = await prisma.joinedObject2.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JoinedObject2FindManyArgs>(args?: SelectSubset<T, JoinedObject2FindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JoinedObject2Payload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a JoinedObject2.
     * @param {JoinedObject2CreateArgs} args - Arguments to create a JoinedObject2.
     * @example
     * // Create one JoinedObject2
     * const JoinedObject2 = await prisma.joinedObject2.create({
     *   data: {
     *     // ... data to create a JoinedObject2
     *   }
     * })
     * 
     */
    create<T extends JoinedObject2CreateArgs>(args: SelectSubset<T, JoinedObject2CreateArgs<ExtArgs>>): Prisma__JoinedObject2Client<$Result.GetResult<Prisma.$JoinedObject2Payload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many JoinedObject2s.
     * @param {JoinedObject2CreateManyArgs} args - Arguments to create many JoinedObject2s.
     * @example
     * // Create many JoinedObject2s
     * const joinedObject2 = await prisma.joinedObject2.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JoinedObject2CreateManyArgs>(args?: SelectSubset<T, JoinedObject2CreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JoinedObject2s and returns the data saved in the database.
     * @param {JoinedObject2CreateManyAndReturnArgs} args - Arguments to create many JoinedObject2s.
     * @example
     * // Create many JoinedObject2s
     * const joinedObject2 = await prisma.joinedObject2.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JoinedObject2s and only return the `id`
     * const joinedObject2WithIdOnly = await prisma.joinedObject2.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JoinedObject2CreateManyAndReturnArgs>(args?: SelectSubset<T, JoinedObject2CreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JoinedObject2Payload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a JoinedObject2.
     * @param {JoinedObject2DeleteArgs} args - Arguments to delete one JoinedObject2.
     * @example
     * // Delete one JoinedObject2
     * const JoinedObject2 = await prisma.joinedObject2.delete({
     *   where: {
     *     // ... filter to delete one JoinedObject2
     *   }
     * })
     * 
     */
    delete<T extends JoinedObject2DeleteArgs>(args: SelectSubset<T, JoinedObject2DeleteArgs<ExtArgs>>): Prisma__JoinedObject2Client<$Result.GetResult<Prisma.$JoinedObject2Payload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one JoinedObject2.
     * @param {JoinedObject2UpdateArgs} args - Arguments to update one JoinedObject2.
     * @example
     * // Update one JoinedObject2
     * const joinedObject2 = await prisma.joinedObject2.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JoinedObject2UpdateArgs>(args: SelectSubset<T, JoinedObject2UpdateArgs<ExtArgs>>): Prisma__JoinedObject2Client<$Result.GetResult<Prisma.$JoinedObject2Payload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more JoinedObject2s.
     * @param {JoinedObject2DeleteManyArgs} args - Arguments to filter JoinedObject2s to delete.
     * @example
     * // Delete a few JoinedObject2s
     * const { count } = await prisma.joinedObject2.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JoinedObject2DeleteManyArgs>(args?: SelectSubset<T, JoinedObject2DeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JoinedObject2s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JoinedObject2UpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JoinedObject2s
     * const joinedObject2 = await prisma.joinedObject2.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JoinedObject2UpdateManyArgs>(args: SelectSubset<T, JoinedObject2UpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JoinedObject2s and returns the data updated in the database.
     * @param {JoinedObject2UpdateManyAndReturnArgs} args - Arguments to update many JoinedObject2s.
     * @example
     * // Update many JoinedObject2s
     * const joinedObject2 = await prisma.joinedObject2.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JoinedObject2s and only return the `id`
     * const joinedObject2WithIdOnly = await prisma.joinedObject2.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JoinedObject2UpdateManyAndReturnArgs>(args: SelectSubset<T, JoinedObject2UpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JoinedObject2Payload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one JoinedObject2.
     * @param {JoinedObject2UpsertArgs} args - Arguments to update or create a JoinedObject2.
     * @example
     * // Update or create a JoinedObject2
     * const joinedObject2 = await prisma.joinedObject2.upsert({
     *   create: {
     *     // ... data to create a JoinedObject2
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JoinedObject2 we want to update
     *   }
     * })
     */
    upsert<T extends JoinedObject2UpsertArgs>(args: SelectSubset<T, JoinedObject2UpsertArgs<ExtArgs>>): Prisma__JoinedObject2Client<$Result.GetResult<Prisma.$JoinedObject2Payload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of JoinedObject2s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JoinedObject2CountArgs} args - Arguments to filter JoinedObject2s to count.
     * @example
     * // Count the number of JoinedObject2s
     * const count = await prisma.joinedObject2.count({
     *   where: {
     *     // ... the filter for the JoinedObject2s we want to count
     *   }
     * })
    **/
    count<T extends JoinedObject2CountArgs>(
      args?: Subset<T, JoinedObject2CountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JoinedObject2CountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JoinedObject2.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JoinedObject2AggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JoinedObject2AggregateArgs>(args: Subset<T, JoinedObject2AggregateArgs>): Prisma.PrismaPromise<GetJoinedObject2AggregateType<T>>

    /**
     * Group by JoinedObject2.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JoinedObject2GroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JoinedObject2GroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JoinedObject2GroupByArgs['orderBy'] }
        : { orderBy?: JoinedObject2GroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JoinedObject2GroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJoinedObject2GroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JoinedObject2 model
   */
  readonly fields: JoinedObject2FieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JoinedObject2.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JoinedObject2Client<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    testObjects<T extends JoinedObject2$testObjectsArgs<ExtArgs> = {}>(args?: Subset<T, JoinedObject2$testObjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JoinTestObject2Payload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JoinedObject2 model
   */ 
  interface JoinedObject2FieldRefs {
    readonly id: FieldRef<"JoinedObject2", 'Bytes'>
    readonly persisted: FieldRef<"JoinedObject2", 'String'>
  }
    

  // Custom InputTypes
  /**
   * JoinedObject2 findUnique
   */
  export type JoinedObject2FindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinedObject2
     */
    select?: JoinedObject2Select<ExtArgs> | null
    /**
     * Omit specific fields from the JoinedObject2
     */
    omit?: JoinedObject2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinedObject2Include<ExtArgs> | null
    /**
     * Filter, which JoinedObject2 to fetch.
     */
    where: JoinedObject2WhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * JoinedObject2 findUniqueOrThrow
   */
  export type JoinedObject2FindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinedObject2
     */
    select?: JoinedObject2Select<ExtArgs> | null
    /**
     * Omit specific fields from the JoinedObject2
     */
    omit?: JoinedObject2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinedObject2Include<ExtArgs> | null
    /**
     * Filter, which JoinedObject2 to fetch.
     */
    where: JoinedObject2WhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * JoinedObject2 findFirst
   */
  export type JoinedObject2FindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinedObject2
     */
    select?: JoinedObject2Select<ExtArgs> | null
    /**
     * Omit specific fields from the JoinedObject2
     */
    omit?: JoinedObject2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinedObject2Include<ExtArgs> | null
    /**
     * Filter, which JoinedObject2 to fetch.
     */
    where?: JoinedObject2WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JoinedObject2s to fetch.
     */
    orderBy?: JoinedObject2OrderByWithRelationInput | JoinedObject2OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JoinedObject2s.
     */
    cursor?: JoinedObject2WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JoinedObject2s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JoinedObject2s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JoinedObject2s.
     */
    distinct?: JoinedObject2ScalarFieldEnum | JoinedObject2ScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * JoinedObject2 findFirstOrThrow
   */
  export type JoinedObject2FindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinedObject2
     */
    select?: JoinedObject2Select<ExtArgs> | null
    /**
     * Omit specific fields from the JoinedObject2
     */
    omit?: JoinedObject2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinedObject2Include<ExtArgs> | null
    /**
     * Filter, which JoinedObject2 to fetch.
     */
    where?: JoinedObject2WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JoinedObject2s to fetch.
     */
    orderBy?: JoinedObject2OrderByWithRelationInput | JoinedObject2OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JoinedObject2s.
     */
    cursor?: JoinedObject2WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JoinedObject2s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JoinedObject2s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JoinedObject2s.
     */
    distinct?: JoinedObject2ScalarFieldEnum | JoinedObject2ScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * JoinedObject2 findMany
   */
  export type JoinedObject2FindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinedObject2
     */
    select?: JoinedObject2Select<ExtArgs> | null
    /**
     * Omit specific fields from the JoinedObject2
     */
    omit?: JoinedObject2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinedObject2Include<ExtArgs> | null
    /**
     * Filter, which JoinedObject2s to fetch.
     */
    where?: JoinedObject2WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JoinedObject2s to fetch.
     */
    orderBy?: JoinedObject2OrderByWithRelationInput | JoinedObject2OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JoinedObject2s.
     */
    cursor?: JoinedObject2WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JoinedObject2s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JoinedObject2s.
     */
    skip?: number
    distinct?: JoinedObject2ScalarFieldEnum | JoinedObject2ScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * JoinedObject2 create
   */
  export type JoinedObject2CreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinedObject2
     */
    select?: JoinedObject2Select<ExtArgs> | null
    /**
     * Omit specific fields from the JoinedObject2
     */
    omit?: JoinedObject2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinedObject2Include<ExtArgs> | null
    /**
     * The data needed to create a JoinedObject2.
     */
    data: XOR<JoinedObject2CreateInput, JoinedObject2UncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * JoinedObject2 createMany
   */
  export type JoinedObject2CreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JoinedObject2s.
     */
    data: JoinedObject2CreateManyInput | JoinedObject2CreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JoinedObject2 createManyAndReturn
   */
  export type JoinedObject2CreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinedObject2
     */
    select?: JoinedObject2SelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JoinedObject2
     */
    omit?: JoinedObject2Omit<ExtArgs> | null
    /**
     * The data used to create many JoinedObject2s.
     */
    data: JoinedObject2CreateManyInput | JoinedObject2CreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JoinedObject2 update
   */
  export type JoinedObject2UpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinedObject2
     */
    select?: JoinedObject2Select<ExtArgs> | null
    /**
     * Omit specific fields from the JoinedObject2
     */
    omit?: JoinedObject2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinedObject2Include<ExtArgs> | null
    /**
     * The data needed to update a JoinedObject2.
     */
    data: XOR<JoinedObject2UpdateInput, JoinedObject2UncheckedUpdateInput>
    /**
     * Choose, which JoinedObject2 to update.
     */
    where: JoinedObject2WhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * JoinedObject2 updateMany
   */
  export type JoinedObject2UpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JoinedObject2s.
     */
    data: XOR<JoinedObject2UpdateManyMutationInput, JoinedObject2UncheckedUpdateManyInput>
    /**
     * Filter which JoinedObject2s to update
     */
    where?: JoinedObject2WhereInput
    /**
     * Limit how many JoinedObject2s to update.
     */
    limit?: number
  }

  /**
   * JoinedObject2 updateManyAndReturn
   */
  export type JoinedObject2UpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinedObject2
     */
    select?: JoinedObject2SelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JoinedObject2
     */
    omit?: JoinedObject2Omit<ExtArgs> | null
    /**
     * The data used to update JoinedObject2s.
     */
    data: XOR<JoinedObject2UpdateManyMutationInput, JoinedObject2UncheckedUpdateManyInput>
    /**
     * Filter which JoinedObject2s to update
     */
    where?: JoinedObject2WhereInput
    /**
     * Limit how many JoinedObject2s to update.
     */
    limit?: number
  }

  /**
   * JoinedObject2 upsert
   */
  export type JoinedObject2UpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinedObject2
     */
    select?: JoinedObject2Select<ExtArgs> | null
    /**
     * Omit specific fields from the JoinedObject2
     */
    omit?: JoinedObject2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinedObject2Include<ExtArgs> | null
    /**
     * The filter to search for the JoinedObject2 to update in case it exists.
     */
    where: JoinedObject2WhereUniqueInput
    /**
     * In case the JoinedObject2 found by the `where` argument doesn't exist, create a new JoinedObject2 with this data.
     */
    create: XOR<JoinedObject2CreateInput, JoinedObject2UncheckedCreateInput>
    /**
     * In case the JoinedObject2 was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JoinedObject2UpdateInput, JoinedObject2UncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * JoinedObject2 delete
   */
  export type JoinedObject2DeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinedObject2
     */
    select?: JoinedObject2Select<ExtArgs> | null
    /**
     * Omit specific fields from the JoinedObject2
     */
    omit?: JoinedObject2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinedObject2Include<ExtArgs> | null
    /**
     * Filter which JoinedObject2 to delete.
     */
    where: JoinedObject2WhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * JoinedObject2 deleteMany
   */
  export type JoinedObject2DeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JoinedObject2s to delete
     */
    where?: JoinedObject2WhereInput
    /**
     * Limit how many JoinedObject2s to delete.
     */
    limit?: number
  }

  /**
   * JoinedObject2.testObjects
   */
  export type JoinedObject2$testObjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinTestObject2
     */
    select?: JoinTestObject2Select<ExtArgs> | null
    /**
     * Omit specific fields from the JoinTestObject2
     */
    omit?: JoinTestObject2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinTestObject2Include<ExtArgs> | null
    where?: JoinTestObject2WhereInput
    orderBy?: JoinTestObject2OrderByWithRelationInput | JoinTestObject2OrderByWithRelationInput[]
    cursor?: JoinTestObject2WhereUniqueInput
    take?: number
    skip?: number
    distinct?: JoinTestObject2ScalarFieldEnum | JoinTestObject2ScalarFieldEnum[]
  }

  /**
   * JoinedObject2 without action
   */
  export type JoinedObject2DefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinedObject2
     */
    select?: JoinedObject2Select<ExtArgs> | null
    /**
     * Omit specific fields from the JoinedObject2
     */
    omit?: JoinedObject2Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinedObject2Include<ExtArgs> | null
  }


  /**
   * Model JoinSelfReference
   */

  export type AggregateJoinSelfReference = {
    _count: JoinSelfReferenceCountAggregateOutputType | null
    _min: JoinSelfReferenceMinAggregateOutputType | null
    _max: JoinSelfReferenceMaxAggregateOutputType | null
  }

  export type JoinSelfReferenceMinAggregateOutputType = {
    id: Uint8Array | null
    sourceId: Uint8Array | null
    targetId: Uint8Array | null
    joinProperty: string | null
  }

  export type JoinSelfReferenceMaxAggregateOutputType = {
    id: Uint8Array | null
    sourceId: Uint8Array | null
    targetId: Uint8Array | null
    joinProperty: string | null
  }

  export type JoinSelfReferenceCountAggregateOutputType = {
    id: number
    sourceId: number
    targetId: number
    joinProperty: number
    _all: number
  }


  export type JoinSelfReferenceMinAggregateInputType = {
    id?: true
    sourceId?: true
    targetId?: true
    joinProperty?: true
  }

  export type JoinSelfReferenceMaxAggregateInputType = {
    id?: true
    sourceId?: true
    targetId?: true
    joinProperty?: true
  }

  export type JoinSelfReferenceCountAggregateInputType = {
    id?: true
    sourceId?: true
    targetId?: true
    joinProperty?: true
    _all?: true
  }

  export type JoinSelfReferenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JoinSelfReference to aggregate.
     */
    where?: JoinSelfReferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JoinSelfReferences to fetch.
     */
    orderBy?: JoinSelfReferenceOrderByWithRelationInput | JoinSelfReferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JoinSelfReferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JoinSelfReferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JoinSelfReferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JoinSelfReferences
    **/
    _count?: true | JoinSelfReferenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JoinSelfReferenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JoinSelfReferenceMaxAggregateInputType
  }

  export type GetJoinSelfReferenceAggregateType<T extends JoinSelfReferenceAggregateArgs> = {
        [P in keyof T & keyof AggregateJoinSelfReference]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJoinSelfReference[P]>
      : GetScalarType<T[P], AggregateJoinSelfReference[P]>
  }




  export type JoinSelfReferenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JoinSelfReferenceWhereInput
    orderBy?: JoinSelfReferenceOrderByWithAggregationInput | JoinSelfReferenceOrderByWithAggregationInput[]
    by: JoinSelfReferenceScalarFieldEnum[] | JoinSelfReferenceScalarFieldEnum
    having?: JoinSelfReferenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JoinSelfReferenceCountAggregateInputType | true
    _min?: JoinSelfReferenceMinAggregateInputType
    _max?: JoinSelfReferenceMaxAggregateInputType
  }

  export type JoinSelfReferenceGroupByOutputType = {
    id: Uint8Array
    sourceId: Uint8Array
    targetId: Uint8Array
    joinProperty: string
    _count: JoinSelfReferenceCountAggregateOutputType | null
    _min: JoinSelfReferenceMinAggregateOutputType | null
    _max: JoinSelfReferenceMaxAggregateOutputType | null
  }

  type GetJoinSelfReferenceGroupByPayload<T extends JoinSelfReferenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JoinSelfReferenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JoinSelfReferenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JoinSelfReferenceGroupByOutputType[P]>
            : GetScalarType<T[P], JoinSelfReferenceGroupByOutputType[P]>
        }
      >
    >


  export type JoinSelfReferenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sourceId?: boolean
    targetId?: boolean
    joinProperty?: boolean
    source?: boolean | SelfReferencialJoinModelDefaultArgs<ExtArgs>
    target?: boolean | SelfReferencialJoinModelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["joinSelfReference"]>

  export type JoinSelfReferenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sourceId?: boolean
    targetId?: boolean
    joinProperty?: boolean
    source?: boolean | SelfReferencialJoinModelDefaultArgs<ExtArgs>
    target?: boolean | SelfReferencialJoinModelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["joinSelfReference"]>

  export type JoinSelfReferenceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sourceId?: boolean
    targetId?: boolean
    joinProperty?: boolean
    source?: boolean | SelfReferencialJoinModelDefaultArgs<ExtArgs>
    target?: boolean | SelfReferencialJoinModelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["joinSelfReference"]>

  export type JoinSelfReferenceSelectScalar = {
    id?: boolean
    sourceId?: boolean
    targetId?: boolean
    joinProperty?: boolean
  }

  export type JoinSelfReferenceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sourceId" | "targetId" | "joinProperty", ExtArgs["result"]["joinSelfReference"]>
  export type JoinSelfReferenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    source?: boolean | SelfReferencialJoinModelDefaultArgs<ExtArgs>
    target?: boolean | SelfReferencialJoinModelDefaultArgs<ExtArgs>
  }
  export type JoinSelfReferenceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    source?: boolean | SelfReferencialJoinModelDefaultArgs<ExtArgs>
    target?: boolean | SelfReferencialJoinModelDefaultArgs<ExtArgs>
  }
  export type JoinSelfReferenceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    source?: boolean | SelfReferencialJoinModelDefaultArgs<ExtArgs>
    target?: boolean | SelfReferencialJoinModelDefaultArgs<ExtArgs>
  }

  export type $JoinSelfReferencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JoinSelfReference"
    objects: {
      source: Prisma.$SelfReferencialJoinModelPayload<ExtArgs>
      target: Prisma.$SelfReferencialJoinModelPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      /**
       * @@wrapper-ignore
       */
      id: Uint8Array
      sourceId: Uint8Array
      targetId: Uint8Array
      joinProperty: string
    }, ExtArgs["result"]["joinSelfReference"]>
    composites: {}
  }

  type JoinSelfReferenceGetPayload<S extends boolean | null | undefined | JoinSelfReferenceDefaultArgs> = $Result.GetResult<Prisma.$JoinSelfReferencePayload, S>

  type JoinSelfReferenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JoinSelfReferenceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: JoinSelfReferenceCountAggregateInputType | true
    }

  export interface JoinSelfReferenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JoinSelfReference'], meta: { name: 'JoinSelfReference' } }
    /**
     * Find zero or one JoinSelfReference that matches the filter.
     * @param {JoinSelfReferenceFindUniqueArgs} args - Arguments to find a JoinSelfReference
     * @example
     * // Get one JoinSelfReference
     * const joinSelfReference = await prisma.joinSelfReference.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JoinSelfReferenceFindUniqueArgs>(args: SelectSubset<T, JoinSelfReferenceFindUniqueArgs<ExtArgs>>): Prisma__JoinSelfReferenceClient<$Result.GetResult<Prisma.$JoinSelfReferencePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one JoinSelfReference that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JoinSelfReferenceFindUniqueOrThrowArgs} args - Arguments to find a JoinSelfReference
     * @example
     * // Get one JoinSelfReference
     * const joinSelfReference = await prisma.joinSelfReference.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JoinSelfReferenceFindUniqueOrThrowArgs>(args: SelectSubset<T, JoinSelfReferenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JoinSelfReferenceClient<$Result.GetResult<Prisma.$JoinSelfReferencePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first JoinSelfReference that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JoinSelfReferenceFindFirstArgs} args - Arguments to find a JoinSelfReference
     * @example
     * // Get one JoinSelfReference
     * const joinSelfReference = await prisma.joinSelfReference.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JoinSelfReferenceFindFirstArgs>(args?: SelectSubset<T, JoinSelfReferenceFindFirstArgs<ExtArgs>>): Prisma__JoinSelfReferenceClient<$Result.GetResult<Prisma.$JoinSelfReferencePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first JoinSelfReference that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JoinSelfReferenceFindFirstOrThrowArgs} args - Arguments to find a JoinSelfReference
     * @example
     * // Get one JoinSelfReference
     * const joinSelfReference = await prisma.joinSelfReference.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JoinSelfReferenceFindFirstOrThrowArgs>(args?: SelectSubset<T, JoinSelfReferenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__JoinSelfReferenceClient<$Result.GetResult<Prisma.$JoinSelfReferencePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more JoinSelfReferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JoinSelfReferenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JoinSelfReferences
     * const joinSelfReferences = await prisma.joinSelfReference.findMany()
     * 
     * // Get first 10 JoinSelfReferences
     * const joinSelfReferences = await prisma.joinSelfReference.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const joinSelfReferenceWithIdOnly = await prisma.joinSelfReference.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JoinSelfReferenceFindManyArgs>(args?: SelectSubset<T, JoinSelfReferenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JoinSelfReferencePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a JoinSelfReference.
     * @param {JoinSelfReferenceCreateArgs} args - Arguments to create a JoinSelfReference.
     * @example
     * // Create one JoinSelfReference
     * const JoinSelfReference = await prisma.joinSelfReference.create({
     *   data: {
     *     // ... data to create a JoinSelfReference
     *   }
     * })
     * 
     */
    create<T extends JoinSelfReferenceCreateArgs>(args: SelectSubset<T, JoinSelfReferenceCreateArgs<ExtArgs>>): Prisma__JoinSelfReferenceClient<$Result.GetResult<Prisma.$JoinSelfReferencePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many JoinSelfReferences.
     * @param {JoinSelfReferenceCreateManyArgs} args - Arguments to create many JoinSelfReferences.
     * @example
     * // Create many JoinSelfReferences
     * const joinSelfReference = await prisma.joinSelfReference.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JoinSelfReferenceCreateManyArgs>(args?: SelectSubset<T, JoinSelfReferenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JoinSelfReferences and returns the data saved in the database.
     * @param {JoinSelfReferenceCreateManyAndReturnArgs} args - Arguments to create many JoinSelfReferences.
     * @example
     * // Create many JoinSelfReferences
     * const joinSelfReference = await prisma.joinSelfReference.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JoinSelfReferences and only return the `id`
     * const joinSelfReferenceWithIdOnly = await prisma.joinSelfReference.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JoinSelfReferenceCreateManyAndReturnArgs>(args?: SelectSubset<T, JoinSelfReferenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JoinSelfReferencePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a JoinSelfReference.
     * @param {JoinSelfReferenceDeleteArgs} args - Arguments to delete one JoinSelfReference.
     * @example
     * // Delete one JoinSelfReference
     * const JoinSelfReference = await prisma.joinSelfReference.delete({
     *   where: {
     *     // ... filter to delete one JoinSelfReference
     *   }
     * })
     * 
     */
    delete<T extends JoinSelfReferenceDeleteArgs>(args: SelectSubset<T, JoinSelfReferenceDeleteArgs<ExtArgs>>): Prisma__JoinSelfReferenceClient<$Result.GetResult<Prisma.$JoinSelfReferencePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one JoinSelfReference.
     * @param {JoinSelfReferenceUpdateArgs} args - Arguments to update one JoinSelfReference.
     * @example
     * // Update one JoinSelfReference
     * const joinSelfReference = await prisma.joinSelfReference.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JoinSelfReferenceUpdateArgs>(args: SelectSubset<T, JoinSelfReferenceUpdateArgs<ExtArgs>>): Prisma__JoinSelfReferenceClient<$Result.GetResult<Prisma.$JoinSelfReferencePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more JoinSelfReferences.
     * @param {JoinSelfReferenceDeleteManyArgs} args - Arguments to filter JoinSelfReferences to delete.
     * @example
     * // Delete a few JoinSelfReferences
     * const { count } = await prisma.joinSelfReference.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JoinSelfReferenceDeleteManyArgs>(args?: SelectSubset<T, JoinSelfReferenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JoinSelfReferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JoinSelfReferenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JoinSelfReferences
     * const joinSelfReference = await prisma.joinSelfReference.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JoinSelfReferenceUpdateManyArgs>(args: SelectSubset<T, JoinSelfReferenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JoinSelfReferences and returns the data updated in the database.
     * @param {JoinSelfReferenceUpdateManyAndReturnArgs} args - Arguments to update many JoinSelfReferences.
     * @example
     * // Update many JoinSelfReferences
     * const joinSelfReference = await prisma.joinSelfReference.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JoinSelfReferences and only return the `id`
     * const joinSelfReferenceWithIdOnly = await prisma.joinSelfReference.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JoinSelfReferenceUpdateManyAndReturnArgs>(args: SelectSubset<T, JoinSelfReferenceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JoinSelfReferencePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one JoinSelfReference.
     * @param {JoinSelfReferenceUpsertArgs} args - Arguments to update or create a JoinSelfReference.
     * @example
     * // Update or create a JoinSelfReference
     * const joinSelfReference = await prisma.joinSelfReference.upsert({
     *   create: {
     *     // ... data to create a JoinSelfReference
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JoinSelfReference we want to update
     *   }
     * })
     */
    upsert<T extends JoinSelfReferenceUpsertArgs>(args: SelectSubset<T, JoinSelfReferenceUpsertArgs<ExtArgs>>): Prisma__JoinSelfReferenceClient<$Result.GetResult<Prisma.$JoinSelfReferencePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of JoinSelfReferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JoinSelfReferenceCountArgs} args - Arguments to filter JoinSelfReferences to count.
     * @example
     * // Count the number of JoinSelfReferences
     * const count = await prisma.joinSelfReference.count({
     *   where: {
     *     // ... the filter for the JoinSelfReferences we want to count
     *   }
     * })
    **/
    count<T extends JoinSelfReferenceCountArgs>(
      args?: Subset<T, JoinSelfReferenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JoinSelfReferenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JoinSelfReference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JoinSelfReferenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JoinSelfReferenceAggregateArgs>(args: Subset<T, JoinSelfReferenceAggregateArgs>): Prisma.PrismaPromise<GetJoinSelfReferenceAggregateType<T>>

    /**
     * Group by JoinSelfReference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JoinSelfReferenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JoinSelfReferenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JoinSelfReferenceGroupByArgs['orderBy'] }
        : { orderBy?: JoinSelfReferenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JoinSelfReferenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJoinSelfReferenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JoinSelfReference model
   */
  readonly fields: JoinSelfReferenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JoinSelfReference.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JoinSelfReferenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    source<T extends SelfReferencialJoinModelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SelfReferencialJoinModelDefaultArgs<ExtArgs>>): Prisma__SelfReferencialJoinModelClient<$Result.GetResult<Prisma.$SelfReferencialJoinModelPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    target<T extends SelfReferencialJoinModelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SelfReferencialJoinModelDefaultArgs<ExtArgs>>): Prisma__SelfReferencialJoinModelClient<$Result.GetResult<Prisma.$SelfReferencialJoinModelPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JoinSelfReference model
   */ 
  interface JoinSelfReferenceFieldRefs {
    readonly id: FieldRef<"JoinSelfReference", 'Bytes'>
    readonly sourceId: FieldRef<"JoinSelfReference", 'Bytes'>
    readonly targetId: FieldRef<"JoinSelfReference", 'Bytes'>
    readonly joinProperty: FieldRef<"JoinSelfReference", 'String'>
  }
    

  // Custom InputTypes
  /**
   * JoinSelfReference findUnique
   */
  export type JoinSelfReferenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinSelfReference
     */
    select?: JoinSelfReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JoinSelfReference
     */
    omit?: JoinSelfReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinSelfReferenceInclude<ExtArgs> | null
    /**
     * Filter, which JoinSelfReference to fetch.
     */
    where: JoinSelfReferenceWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * JoinSelfReference findUniqueOrThrow
   */
  export type JoinSelfReferenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinSelfReference
     */
    select?: JoinSelfReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JoinSelfReference
     */
    omit?: JoinSelfReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinSelfReferenceInclude<ExtArgs> | null
    /**
     * Filter, which JoinSelfReference to fetch.
     */
    where: JoinSelfReferenceWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * JoinSelfReference findFirst
   */
  export type JoinSelfReferenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinSelfReference
     */
    select?: JoinSelfReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JoinSelfReference
     */
    omit?: JoinSelfReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinSelfReferenceInclude<ExtArgs> | null
    /**
     * Filter, which JoinSelfReference to fetch.
     */
    where?: JoinSelfReferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JoinSelfReferences to fetch.
     */
    orderBy?: JoinSelfReferenceOrderByWithRelationInput | JoinSelfReferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JoinSelfReferences.
     */
    cursor?: JoinSelfReferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JoinSelfReferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JoinSelfReferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JoinSelfReferences.
     */
    distinct?: JoinSelfReferenceScalarFieldEnum | JoinSelfReferenceScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * JoinSelfReference findFirstOrThrow
   */
  export type JoinSelfReferenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinSelfReference
     */
    select?: JoinSelfReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JoinSelfReference
     */
    omit?: JoinSelfReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinSelfReferenceInclude<ExtArgs> | null
    /**
     * Filter, which JoinSelfReference to fetch.
     */
    where?: JoinSelfReferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JoinSelfReferences to fetch.
     */
    orderBy?: JoinSelfReferenceOrderByWithRelationInput | JoinSelfReferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JoinSelfReferences.
     */
    cursor?: JoinSelfReferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JoinSelfReferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JoinSelfReferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JoinSelfReferences.
     */
    distinct?: JoinSelfReferenceScalarFieldEnum | JoinSelfReferenceScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * JoinSelfReference findMany
   */
  export type JoinSelfReferenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinSelfReference
     */
    select?: JoinSelfReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JoinSelfReference
     */
    omit?: JoinSelfReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinSelfReferenceInclude<ExtArgs> | null
    /**
     * Filter, which JoinSelfReferences to fetch.
     */
    where?: JoinSelfReferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JoinSelfReferences to fetch.
     */
    orderBy?: JoinSelfReferenceOrderByWithRelationInput | JoinSelfReferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JoinSelfReferences.
     */
    cursor?: JoinSelfReferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JoinSelfReferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JoinSelfReferences.
     */
    skip?: number
    distinct?: JoinSelfReferenceScalarFieldEnum | JoinSelfReferenceScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * JoinSelfReference create
   */
  export type JoinSelfReferenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinSelfReference
     */
    select?: JoinSelfReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JoinSelfReference
     */
    omit?: JoinSelfReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinSelfReferenceInclude<ExtArgs> | null
    /**
     * The data needed to create a JoinSelfReference.
     */
    data: XOR<JoinSelfReferenceCreateInput, JoinSelfReferenceUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * JoinSelfReference createMany
   */
  export type JoinSelfReferenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JoinSelfReferences.
     */
    data: JoinSelfReferenceCreateManyInput | JoinSelfReferenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JoinSelfReference createManyAndReturn
   */
  export type JoinSelfReferenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinSelfReference
     */
    select?: JoinSelfReferenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JoinSelfReference
     */
    omit?: JoinSelfReferenceOmit<ExtArgs> | null
    /**
     * The data used to create many JoinSelfReferences.
     */
    data: JoinSelfReferenceCreateManyInput | JoinSelfReferenceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinSelfReferenceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JoinSelfReference update
   */
  export type JoinSelfReferenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinSelfReference
     */
    select?: JoinSelfReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JoinSelfReference
     */
    omit?: JoinSelfReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinSelfReferenceInclude<ExtArgs> | null
    /**
     * The data needed to update a JoinSelfReference.
     */
    data: XOR<JoinSelfReferenceUpdateInput, JoinSelfReferenceUncheckedUpdateInput>
    /**
     * Choose, which JoinSelfReference to update.
     */
    where: JoinSelfReferenceWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * JoinSelfReference updateMany
   */
  export type JoinSelfReferenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JoinSelfReferences.
     */
    data: XOR<JoinSelfReferenceUpdateManyMutationInput, JoinSelfReferenceUncheckedUpdateManyInput>
    /**
     * Filter which JoinSelfReferences to update
     */
    where?: JoinSelfReferenceWhereInput
    /**
     * Limit how many JoinSelfReferences to update.
     */
    limit?: number
  }

  /**
   * JoinSelfReference updateManyAndReturn
   */
  export type JoinSelfReferenceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinSelfReference
     */
    select?: JoinSelfReferenceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JoinSelfReference
     */
    omit?: JoinSelfReferenceOmit<ExtArgs> | null
    /**
     * The data used to update JoinSelfReferences.
     */
    data: XOR<JoinSelfReferenceUpdateManyMutationInput, JoinSelfReferenceUncheckedUpdateManyInput>
    /**
     * Filter which JoinSelfReferences to update
     */
    where?: JoinSelfReferenceWhereInput
    /**
     * Limit how many JoinSelfReferences to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinSelfReferenceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * JoinSelfReference upsert
   */
  export type JoinSelfReferenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinSelfReference
     */
    select?: JoinSelfReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JoinSelfReference
     */
    omit?: JoinSelfReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinSelfReferenceInclude<ExtArgs> | null
    /**
     * The filter to search for the JoinSelfReference to update in case it exists.
     */
    where: JoinSelfReferenceWhereUniqueInput
    /**
     * In case the JoinSelfReference found by the `where` argument doesn't exist, create a new JoinSelfReference with this data.
     */
    create: XOR<JoinSelfReferenceCreateInput, JoinSelfReferenceUncheckedCreateInput>
    /**
     * In case the JoinSelfReference was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JoinSelfReferenceUpdateInput, JoinSelfReferenceUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * JoinSelfReference delete
   */
  export type JoinSelfReferenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinSelfReference
     */
    select?: JoinSelfReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JoinSelfReference
     */
    omit?: JoinSelfReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinSelfReferenceInclude<ExtArgs> | null
    /**
     * Filter which JoinSelfReference to delete.
     */
    where: JoinSelfReferenceWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * JoinSelfReference deleteMany
   */
  export type JoinSelfReferenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JoinSelfReferences to delete
     */
    where?: JoinSelfReferenceWhereInput
    /**
     * Limit how many JoinSelfReferences to delete.
     */
    limit?: number
  }

  /**
   * JoinSelfReference without action
   */
  export type JoinSelfReferenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinSelfReference
     */
    select?: JoinSelfReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JoinSelfReference
     */
    omit?: JoinSelfReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinSelfReferenceInclude<ExtArgs> | null
  }


  /**
   * Model SelfReferencialJoinModel
   */

  export type AggregateSelfReferencialJoinModel = {
    _count: SelfReferencialJoinModelCountAggregateOutputType | null
    _min: SelfReferencialJoinModelMinAggregateOutputType | null
    _max: SelfReferencialJoinModelMaxAggregateOutputType | null
  }

  export type SelfReferencialJoinModelMinAggregateOutputType = {
    id: Uint8Array | null
  }

  export type SelfReferencialJoinModelMaxAggregateOutputType = {
    id: Uint8Array | null
  }

  export type SelfReferencialJoinModelCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type SelfReferencialJoinModelMinAggregateInputType = {
    id?: true
  }

  export type SelfReferencialJoinModelMaxAggregateInputType = {
    id?: true
  }

  export type SelfReferencialJoinModelCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type SelfReferencialJoinModelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SelfReferencialJoinModel to aggregate.
     */
    where?: SelfReferencialJoinModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SelfReferencialJoinModels to fetch.
     */
    orderBy?: SelfReferencialJoinModelOrderByWithRelationInput | SelfReferencialJoinModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SelfReferencialJoinModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SelfReferencialJoinModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SelfReferencialJoinModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SelfReferencialJoinModels
    **/
    _count?: true | SelfReferencialJoinModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SelfReferencialJoinModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SelfReferencialJoinModelMaxAggregateInputType
  }

  export type GetSelfReferencialJoinModelAggregateType<T extends SelfReferencialJoinModelAggregateArgs> = {
        [P in keyof T & keyof AggregateSelfReferencialJoinModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSelfReferencialJoinModel[P]>
      : GetScalarType<T[P], AggregateSelfReferencialJoinModel[P]>
  }




  export type SelfReferencialJoinModelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SelfReferencialJoinModelWhereInput
    orderBy?: SelfReferencialJoinModelOrderByWithAggregationInput | SelfReferencialJoinModelOrderByWithAggregationInput[]
    by: SelfReferencialJoinModelScalarFieldEnum[] | SelfReferencialJoinModelScalarFieldEnum
    having?: SelfReferencialJoinModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SelfReferencialJoinModelCountAggregateInputType | true
    _min?: SelfReferencialJoinModelMinAggregateInputType
    _max?: SelfReferencialJoinModelMaxAggregateInputType
  }

  export type SelfReferencialJoinModelGroupByOutputType = {
    id: Uint8Array
    _count: SelfReferencialJoinModelCountAggregateOutputType | null
    _min: SelfReferencialJoinModelMinAggregateOutputType | null
    _max: SelfReferencialJoinModelMaxAggregateOutputType | null
  }

  type GetSelfReferencialJoinModelGroupByPayload<T extends SelfReferencialJoinModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SelfReferencialJoinModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SelfReferencialJoinModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SelfReferencialJoinModelGroupByOutputType[P]>
            : GetScalarType<T[P], SelfReferencialJoinModelGroupByOutputType[P]>
        }
      >
    >


  export type SelfReferencialJoinModelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    joinsAsSource?: boolean | SelfReferencialJoinModel$joinsAsSourceArgs<ExtArgs>
    joinsAsTarget?: boolean | SelfReferencialJoinModel$joinsAsTargetArgs<ExtArgs>
    _count?: boolean | SelfReferencialJoinModelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["selfReferencialJoinModel"]>

  export type SelfReferencialJoinModelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
  }, ExtArgs["result"]["selfReferencialJoinModel"]>

  export type SelfReferencialJoinModelSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
  }, ExtArgs["result"]["selfReferencialJoinModel"]>

  export type SelfReferencialJoinModelSelectScalar = {
    id?: boolean
  }

  export type SelfReferencialJoinModelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id", ExtArgs["result"]["selfReferencialJoinModel"]>
  export type SelfReferencialJoinModelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    joinsAsSource?: boolean | SelfReferencialJoinModel$joinsAsSourceArgs<ExtArgs>
    joinsAsTarget?: boolean | SelfReferencialJoinModel$joinsAsTargetArgs<ExtArgs>
    _count?: boolean | SelfReferencialJoinModelCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SelfReferencialJoinModelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SelfReferencialJoinModelIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SelfReferencialJoinModelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SelfReferencialJoinModel"
    objects: {
      /**
       * @jointable(SelfReferencialJoinModel, target)
       * @join(joinProperty, joinProperty)
       * @joinid(joinId)
       */
      joinsAsSource: Prisma.$JoinSelfReferencePayload<ExtArgs>[]
      /**
       * @jointable(SelfReferencialJoinModel, source)
       * @join(joinProperty, joinProperty)
       * @joinid(joinId)
       */
      joinsAsTarget: Prisma.$JoinSelfReferencePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: Uint8Array
    }, ExtArgs["result"]["selfReferencialJoinModel"]>
    composites: {}
  }

  type SelfReferencialJoinModelGetPayload<S extends boolean | null | undefined | SelfReferencialJoinModelDefaultArgs> = $Result.GetResult<Prisma.$SelfReferencialJoinModelPayload, S>

  type SelfReferencialJoinModelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SelfReferencialJoinModelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
      select?: SelfReferencialJoinModelCountAggregateInputType | true
    }

  export interface SelfReferencialJoinModelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SelfReferencialJoinModel'], meta: { name: 'SelfReferencialJoinModel' } }
    /**
     * Find zero or one SelfReferencialJoinModel that matches the filter.
     * @param {SelfReferencialJoinModelFindUniqueArgs} args - Arguments to find a SelfReferencialJoinModel
     * @example
     * // Get one SelfReferencialJoinModel
     * const selfReferencialJoinModel = await prisma.selfReferencialJoinModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SelfReferencialJoinModelFindUniqueArgs>(args: SelectSubset<T, SelfReferencialJoinModelFindUniqueArgs<ExtArgs>>): Prisma__SelfReferencialJoinModelClient<$Result.GetResult<Prisma.$SelfReferencialJoinModelPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one SelfReferencialJoinModel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SelfReferencialJoinModelFindUniqueOrThrowArgs} args - Arguments to find a SelfReferencialJoinModel
     * @example
     * // Get one SelfReferencialJoinModel
     * const selfReferencialJoinModel = await prisma.selfReferencialJoinModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SelfReferencialJoinModelFindUniqueOrThrowArgs>(args: SelectSubset<T, SelfReferencialJoinModelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SelfReferencialJoinModelClient<$Result.GetResult<Prisma.$SelfReferencialJoinModelPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first SelfReferencialJoinModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SelfReferencialJoinModelFindFirstArgs} args - Arguments to find a SelfReferencialJoinModel
     * @example
     * // Get one SelfReferencialJoinModel
     * const selfReferencialJoinModel = await prisma.selfReferencialJoinModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SelfReferencialJoinModelFindFirstArgs>(args?: SelectSubset<T, SelfReferencialJoinModelFindFirstArgs<ExtArgs>>): Prisma__SelfReferencialJoinModelClient<$Result.GetResult<Prisma.$SelfReferencialJoinModelPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first SelfReferencialJoinModel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SelfReferencialJoinModelFindFirstOrThrowArgs} args - Arguments to find a SelfReferencialJoinModel
     * @example
     * // Get one SelfReferencialJoinModel
     * const selfReferencialJoinModel = await prisma.selfReferencialJoinModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SelfReferencialJoinModelFindFirstOrThrowArgs>(args?: SelectSubset<T, SelfReferencialJoinModelFindFirstOrThrowArgs<ExtArgs>>): Prisma__SelfReferencialJoinModelClient<$Result.GetResult<Prisma.$SelfReferencialJoinModelPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more SelfReferencialJoinModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SelfReferencialJoinModelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SelfReferencialJoinModels
     * const selfReferencialJoinModels = await prisma.selfReferencialJoinModel.findMany()
     * 
     * // Get first 10 SelfReferencialJoinModels
     * const selfReferencialJoinModels = await prisma.selfReferencialJoinModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const selfReferencialJoinModelWithIdOnly = await prisma.selfReferencialJoinModel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SelfReferencialJoinModelFindManyArgs>(args?: SelectSubset<T, SelfReferencialJoinModelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SelfReferencialJoinModelPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a SelfReferencialJoinModel.
     * @param {SelfReferencialJoinModelCreateArgs} args - Arguments to create a SelfReferencialJoinModel.
     * @example
     * // Create one SelfReferencialJoinModel
     * const SelfReferencialJoinModel = await prisma.selfReferencialJoinModel.create({
     *   data: {
     *     // ... data to create a SelfReferencialJoinModel
     *   }
     * })
     * 
     */
    create<T extends SelfReferencialJoinModelCreateArgs>(args: SelectSubset<T, SelfReferencialJoinModelCreateArgs<ExtArgs>>): Prisma__SelfReferencialJoinModelClient<$Result.GetResult<Prisma.$SelfReferencialJoinModelPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many SelfReferencialJoinModels.
     * @param {SelfReferencialJoinModelCreateManyArgs} args - Arguments to create many SelfReferencialJoinModels.
     * @example
     * // Create many SelfReferencialJoinModels
     * const selfReferencialJoinModel = await prisma.selfReferencialJoinModel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SelfReferencialJoinModelCreateManyArgs>(args?: SelectSubset<T, SelfReferencialJoinModelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SelfReferencialJoinModels and returns the data saved in the database.
     * @param {SelfReferencialJoinModelCreateManyAndReturnArgs} args - Arguments to create many SelfReferencialJoinModels.
     * @example
     * // Create many SelfReferencialJoinModels
     * const selfReferencialJoinModel = await prisma.selfReferencialJoinModel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SelfReferencialJoinModels and only return the `id`
     * const selfReferencialJoinModelWithIdOnly = await prisma.selfReferencialJoinModel.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SelfReferencialJoinModelCreateManyAndReturnArgs>(args?: SelectSubset<T, SelfReferencialJoinModelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SelfReferencialJoinModelPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a SelfReferencialJoinModel.
     * @param {SelfReferencialJoinModelDeleteArgs} args - Arguments to delete one SelfReferencialJoinModel.
     * @example
     * // Delete one SelfReferencialJoinModel
     * const SelfReferencialJoinModel = await prisma.selfReferencialJoinModel.delete({
     *   where: {
     *     // ... filter to delete one SelfReferencialJoinModel
     *   }
     * })
     * 
     */
    delete<T extends SelfReferencialJoinModelDeleteArgs>(args: SelectSubset<T, SelfReferencialJoinModelDeleteArgs<ExtArgs>>): Prisma__SelfReferencialJoinModelClient<$Result.GetResult<Prisma.$SelfReferencialJoinModelPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one SelfReferencialJoinModel.
     * @param {SelfReferencialJoinModelUpdateArgs} args - Arguments to update one SelfReferencialJoinModel.
     * @example
     * // Update one SelfReferencialJoinModel
     * const selfReferencialJoinModel = await prisma.selfReferencialJoinModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SelfReferencialJoinModelUpdateArgs>(args: SelectSubset<T, SelfReferencialJoinModelUpdateArgs<ExtArgs>>): Prisma__SelfReferencialJoinModelClient<$Result.GetResult<Prisma.$SelfReferencialJoinModelPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more SelfReferencialJoinModels.
     * @param {SelfReferencialJoinModelDeleteManyArgs} args - Arguments to filter SelfReferencialJoinModels to delete.
     * @example
     * // Delete a few SelfReferencialJoinModels
     * const { count } = await prisma.selfReferencialJoinModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SelfReferencialJoinModelDeleteManyArgs>(args?: SelectSubset<T, SelfReferencialJoinModelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SelfReferencialJoinModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SelfReferencialJoinModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SelfReferencialJoinModels
     * const selfReferencialJoinModel = await prisma.selfReferencialJoinModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SelfReferencialJoinModelUpdateManyArgs>(args: SelectSubset<T, SelfReferencialJoinModelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SelfReferencialJoinModels and returns the data updated in the database.
     * @param {SelfReferencialJoinModelUpdateManyAndReturnArgs} args - Arguments to update many SelfReferencialJoinModels.
     * @example
     * // Update many SelfReferencialJoinModels
     * const selfReferencialJoinModel = await prisma.selfReferencialJoinModel.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SelfReferencialJoinModels and only return the `id`
     * const selfReferencialJoinModelWithIdOnly = await prisma.selfReferencialJoinModel.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SelfReferencialJoinModelUpdateManyAndReturnArgs>(args: SelectSubset<T, SelfReferencialJoinModelUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SelfReferencialJoinModelPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one SelfReferencialJoinModel.
     * @param {SelfReferencialJoinModelUpsertArgs} args - Arguments to update or create a SelfReferencialJoinModel.
     * @example
     * // Update or create a SelfReferencialJoinModel
     * const selfReferencialJoinModel = await prisma.selfReferencialJoinModel.upsert({
     *   create: {
     *     // ... data to create a SelfReferencialJoinModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SelfReferencialJoinModel we want to update
     *   }
     * })
     */
    upsert<T extends SelfReferencialJoinModelUpsertArgs>(args: SelectSubset<T, SelfReferencialJoinModelUpsertArgs<ExtArgs>>): Prisma__SelfReferencialJoinModelClient<$Result.GetResult<Prisma.$SelfReferencialJoinModelPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of SelfReferencialJoinModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SelfReferencialJoinModelCountArgs} args - Arguments to filter SelfReferencialJoinModels to count.
     * @example
     * // Count the number of SelfReferencialJoinModels
     * const count = await prisma.selfReferencialJoinModel.count({
     *   where: {
     *     // ... the filter for the SelfReferencialJoinModels we want to count
     *   }
     * })
    **/
    count<T extends SelfReferencialJoinModelCountArgs>(
      args?: Subset<T, SelfReferencialJoinModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SelfReferencialJoinModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SelfReferencialJoinModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SelfReferencialJoinModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SelfReferencialJoinModelAggregateArgs>(args: Subset<T, SelfReferencialJoinModelAggregateArgs>): Prisma.PrismaPromise<GetSelfReferencialJoinModelAggregateType<T>>

    /**
     * Group by SelfReferencialJoinModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SelfReferencialJoinModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SelfReferencialJoinModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SelfReferencialJoinModelGroupByArgs['orderBy'] }
        : { orderBy?: SelfReferencialJoinModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SelfReferencialJoinModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSelfReferencialJoinModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SelfReferencialJoinModel model
   */
  readonly fields: SelfReferencialJoinModelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SelfReferencialJoinModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SelfReferencialJoinModelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    joinsAsSource<T extends SelfReferencialJoinModel$joinsAsSourceArgs<ExtArgs> = {}>(args?: Subset<T, SelfReferencialJoinModel$joinsAsSourceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JoinSelfReferencePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    joinsAsTarget<T extends SelfReferencialJoinModel$joinsAsTargetArgs<ExtArgs> = {}>(args?: Subset<T, SelfReferencialJoinModel$joinsAsTargetArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JoinSelfReferencePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SelfReferencialJoinModel model
   */ 
  interface SelfReferencialJoinModelFieldRefs {
    readonly id: FieldRef<"SelfReferencialJoinModel", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * SelfReferencialJoinModel findUnique
   */
  export type SelfReferencialJoinModelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelfReferencialJoinModel
     */
    select?: SelfReferencialJoinModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SelfReferencialJoinModel
     */
    omit?: SelfReferencialJoinModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SelfReferencialJoinModelInclude<ExtArgs> | null
    /**
     * Filter, which SelfReferencialJoinModel to fetch.
     */
    where: SelfReferencialJoinModelWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * SelfReferencialJoinModel findUniqueOrThrow
   */
  export type SelfReferencialJoinModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelfReferencialJoinModel
     */
    select?: SelfReferencialJoinModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SelfReferencialJoinModel
     */
    omit?: SelfReferencialJoinModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SelfReferencialJoinModelInclude<ExtArgs> | null
    /**
     * Filter, which SelfReferencialJoinModel to fetch.
     */
    where: SelfReferencialJoinModelWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * SelfReferencialJoinModel findFirst
   */
  export type SelfReferencialJoinModelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelfReferencialJoinModel
     */
    select?: SelfReferencialJoinModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SelfReferencialJoinModel
     */
    omit?: SelfReferencialJoinModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SelfReferencialJoinModelInclude<ExtArgs> | null
    /**
     * Filter, which SelfReferencialJoinModel to fetch.
     */
    where?: SelfReferencialJoinModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SelfReferencialJoinModels to fetch.
     */
    orderBy?: SelfReferencialJoinModelOrderByWithRelationInput | SelfReferencialJoinModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SelfReferencialJoinModels.
     */
    cursor?: SelfReferencialJoinModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SelfReferencialJoinModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SelfReferencialJoinModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SelfReferencialJoinModels.
     */
    distinct?: SelfReferencialJoinModelScalarFieldEnum | SelfReferencialJoinModelScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * SelfReferencialJoinModel findFirstOrThrow
   */
  export type SelfReferencialJoinModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelfReferencialJoinModel
     */
    select?: SelfReferencialJoinModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SelfReferencialJoinModel
     */
    omit?: SelfReferencialJoinModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SelfReferencialJoinModelInclude<ExtArgs> | null
    /**
     * Filter, which SelfReferencialJoinModel to fetch.
     */
    where?: SelfReferencialJoinModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SelfReferencialJoinModels to fetch.
     */
    orderBy?: SelfReferencialJoinModelOrderByWithRelationInput | SelfReferencialJoinModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SelfReferencialJoinModels.
     */
    cursor?: SelfReferencialJoinModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SelfReferencialJoinModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SelfReferencialJoinModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SelfReferencialJoinModels.
     */
    distinct?: SelfReferencialJoinModelScalarFieldEnum | SelfReferencialJoinModelScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * SelfReferencialJoinModel findMany
   */
  export type SelfReferencialJoinModelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelfReferencialJoinModel
     */
    select?: SelfReferencialJoinModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SelfReferencialJoinModel
     */
    omit?: SelfReferencialJoinModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SelfReferencialJoinModelInclude<ExtArgs> | null
    /**
     * Filter, which SelfReferencialJoinModels to fetch.
     */
    where?: SelfReferencialJoinModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SelfReferencialJoinModels to fetch.
     */
    orderBy?: SelfReferencialJoinModelOrderByWithRelationInput | SelfReferencialJoinModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SelfReferencialJoinModels.
     */
    cursor?: SelfReferencialJoinModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SelfReferencialJoinModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SelfReferencialJoinModels.
     */
    skip?: number
    distinct?: SelfReferencialJoinModelScalarFieldEnum | SelfReferencialJoinModelScalarFieldEnum[]
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * SelfReferencialJoinModel create
   */
  export type SelfReferencialJoinModelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelfReferencialJoinModel
     */
    select?: SelfReferencialJoinModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SelfReferencialJoinModel
     */
    omit?: SelfReferencialJoinModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SelfReferencialJoinModelInclude<ExtArgs> | null
    /**
     * The data needed to create a SelfReferencialJoinModel.
     */
    data: XOR<SelfReferencialJoinModelCreateInput, SelfReferencialJoinModelUncheckedCreateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * SelfReferencialJoinModel createMany
   */
  export type SelfReferencialJoinModelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SelfReferencialJoinModels.
     */
    data: SelfReferencialJoinModelCreateManyInput | SelfReferencialJoinModelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SelfReferencialJoinModel createManyAndReturn
   */
  export type SelfReferencialJoinModelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelfReferencialJoinModel
     */
    select?: SelfReferencialJoinModelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SelfReferencialJoinModel
     */
    omit?: SelfReferencialJoinModelOmit<ExtArgs> | null
    /**
     * The data used to create many SelfReferencialJoinModels.
     */
    data: SelfReferencialJoinModelCreateManyInput | SelfReferencialJoinModelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SelfReferencialJoinModel update
   */
  export type SelfReferencialJoinModelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelfReferencialJoinModel
     */
    select?: SelfReferencialJoinModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SelfReferencialJoinModel
     */
    omit?: SelfReferencialJoinModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SelfReferencialJoinModelInclude<ExtArgs> | null
    /**
     * The data needed to update a SelfReferencialJoinModel.
     */
    data: XOR<SelfReferencialJoinModelUpdateInput, SelfReferencialJoinModelUncheckedUpdateInput>
    /**
     * Choose, which SelfReferencialJoinModel to update.
     */
    where: SelfReferencialJoinModelWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * SelfReferencialJoinModel updateMany
   */
  export type SelfReferencialJoinModelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SelfReferencialJoinModels.
     */
    data: XOR<SelfReferencialJoinModelUpdateManyMutationInput, SelfReferencialJoinModelUncheckedUpdateManyInput>
    /**
     * Filter which SelfReferencialJoinModels to update
     */
    where?: SelfReferencialJoinModelWhereInput
    /**
     * Limit how many SelfReferencialJoinModels to update.
     */
    limit?: number
  }

  /**
   * SelfReferencialJoinModel updateManyAndReturn
   */
  export type SelfReferencialJoinModelUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelfReferencialJoinModel
     */
    select?: SelfReferencialJoinModelSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SelfReferencialJoinModel
     */
    omit?: SelfReferencialJoinModelOmit<ExtArgs> | null
    /**
     * The data used to update SelfReferencialJoinModels.
     */
    data: XOR<SelfReferencialJoinModelUpdateManyMutationInput, SelfReferencialJoinModelUncheckedUpdateManyInput>
    /**
     * Filter which SelfReferencialJoinModels to update
     */
    where?: SelfReferencialJoinModelWhereInput
    /**
     * Limit how many SelfReferencialJoinModels to update.
     */
    limit?: number
  }

  /**
   * SelfReferencialJoinModel upsert
   */
  export type SelfReferencialJoinModelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelfReferencialJoinModel
     */
    select?: SelfReferencialJoinModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SelfReferencialJoinModel
     */
    omit?: SelfReferencialJoinModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SelfReferencialJoinModelInclude<ExtArgs> | null
    /**
     * The filter to search for the SelfReferencialJoinModel to update in case it exists.
     */
    where: SelfReferencialJoinModelWhereUniqueInput
    /**
     * In case the SelfReferencialJoinModel found by the `where` argument doesn't exist, create a new SelfReferencialJoinModel with this data.
     */
    create: XOR<SelfReferencialJoinModelCreateInput, SelfReferencialJoinModelUncheckedCreateInput>
    /**
     * In case the SelfReferencialJoinModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SelfReferencialJoinModelUpdateInput, SelfReferencialJoinModelUncheckedUpdateInput>
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * SelfReferencialJoinModel delete
   */
  export type SelfReferencialJoinModelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelfReferencialJoinModel
     */
    select?: SelfReferencialJoinModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SelfReferencialJoinModel
     */
    omit?: SelfReferencialJoinModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SelfReferencialJoinModelInclude<ExtArgs> | null
    /**
     * Filter which SelfReferencialJoinModel to delete.
     */
    where: SelfReferencialJoinModelWhereUniqueInput
    relationLoadStrategy?: RelationLoadStrategy
  }

  /**
   * SelfReferencialJoinModel deleteMany
   */
  export type SelfReferencialJoinModelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SelfReferencialJoinModels to delete
     */
    where?: SelfReferencialJoinModelWhereInput
    /**
     * Limit how many SelfReferencialJoinModels to delete.
     */
    limit?: number
  }

  /**
   * SelfReferencialJoinModel.joinsAsSource
   */
  export type SelfReferencialJoinModel$joinsAsSourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinSelfReference
     */
    select?: JoinSelfReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JoinSelfReference
     */
    omit?: JoinSelfReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinSelfReferenceInclude<ExtArgs> | null
    where?: JoinSelfReferenceWhereInput
    orderBy?: JoinSelfReferenceOrderByWithRelationInput | JoinSelfReferenceOrderByWithRelationInput[]
    cursor?: JoinSelfReferenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JoinSelfReferenceScalarFieldEnum | JoinSelfReferenceScalarFieldEnum[]
  }

  /**
   * SelfReferencialJoinModel.joinsAsTarget
   */
  export type SelfReferencialJoinModel$joinsAsTargetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinSelfReference
     */
    select?: JoinSelfReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JoinSelfReference
     */
    omit?: JoinSelfReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinSelfReferenceInclude<ExtArgs> | null
    where?: JoinSelfReferenceWhereInput
    orderBy?: JoinSelfReferenceOrderByWithRelationInput | JoinSelfReferenceOrderByWithRelationInput[]
    cursor?: JoinSelfReferenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JoinSelfReferenceScalarFieldEnum | JoinSelfReferenceScalarFieldEnum[]
  }

  /**
   * SelfReferencialJoinModel without action
   */
  export type SelfReferencialJoinModelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SelfReferencialJoinModel
     */
    select?: SelfReferencialJoinModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SelfReferencialJoinModel
     */
    omit?: SelfReferencialJoinModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SelfReferencialJoinModelInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TenetScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TenetScalarFieldEnum = (typeof TenetScalarFieldEnum)[keyof typeof TenetScalarFieldEnum]


  export const RelationLoadStrategy: {
    query: 'query',
    join: 'join'
  };

  export type RelationLoadStrategy = (typeof RelationLoadStrategy)[keyof typeof RelationLoadStrategy]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    firstName: 'firstName',
    lastName: 'lastName',
    fullName: 'fullName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    password: 'password',
    enabled: 'enabled',
    type: 'type',
    tenetId: 'tenetId',
    system: 'system',
    deleted: 'deleted',
    deletedAt: 'deletedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ContactScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    fullName: 'fullName',
    tenetId: 'tenetId',
    importantNotes: 'importantNotes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    type: 'type',
    status: 'status',
    lifecycleStage: 'lifecycleStage',
    lastContactedDate: 'lastContactedDate',
    followUpDate: 'followUpDate',
    householdId: 'householdId',
    householdStatus: 'householdStatus',
    companyId: 'companyId',
    position: 'position',
    companyStatus: 'companyStatus',
    headOfHouseholdId: 'headOfHouseholdId',
    industry: 'industry',
    website: 'website',
    size: 'size',
    primaryContactId: 'primaryContactId',
    deleted: 'deleted',
    deletedAt: 'deletedAt'
  };

  export type ContactScalarFieldEnum = (typeof ContactScalarFieldEnum)[keyof typeof ContactScalarFieldEnum]


  export const ContactRelationshipScalarFieldEnum: {
    id: 'id',
    sourceId: 'sourceId',
    targetId: 'targetId',
    type: 'type',
    established: 'established',
    notes: 'notes'
  };

  export type ContactRelationshipScalarFieldEnum = (typeof ContactRelationshipScalarFieldEnum)[keyof typeof ContactRelationshipScalarFieldEnum]


  export const ActivityStepScalarFieldEnum: {
    id: 'id',
    title: 'title',
    completed: 'completed',
    activityId: 'activityId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    tenetId: 'tenetId',
    type: 'type',
    order: 'order'
  };

  export type ActivityStepScalarFieldEnum = (typeof ActivityStepScalarFieldEnum)[keyof typeof ActivityStepScalarFieldEnum]


  export const ActivityStepUserJoinScalarFieldEnum: {
    activityStepId: 'activityStepId',
    userId: 'userId'
  };

  export type ActivityStepUserJoinScalarFieldEnum = (typeof ActivityStepUserJoinScalarFieldEnum)[keyof typeof ActivityStepUserJoinScalarFieldEnum]


  export const UserWaypointJoinScalarFieldEnum: {
    userId: 'userId',
    waypointId: 'waypointId'
  };

  export type UserWaypointJoinScalarFieldEnum = (typeof UserWaypointJoinScalarFieldEnum)[keyof typeof UserWaypointJoinScalarFieldEnum]


  export const ActivityWaypointScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    summary: 'summary',
    status: 'status',
    order: 'order',
    actualStart: 'actualStart',
    dueDate: 'dueDate',
    actualEnd: 'actualEnd',
    activityId: 'activityId',
    templateId: 'templateId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    tenetId: 'tenetId'
  };

  export type ActivityWaypointScalarFieldEnum = (typeof ActivityWaypointScalarFieldEnum)[keyof typeof ActivityWaypointScalarFieldEnum]


  export const TemplateAssignmentScalarFieldEnum: {
    id: 'id',
    specificUserId: 'specificUserId',
    specificRole: 'specificRole',
    activityTemplateId: 'activityTemplateId',
    waypointTemplateId: 'waypointTemplateId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    tenetId: 'tenetId'
  };

  export type TemplateAssignmentScalarFieldEnum = (typeof TemplateAssignmentScalarFieldEnum)[keyof typeof TemplateAssignmentScalarFieldEnum]


  export const ActivityWaypointTemplateScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    defaultStatus: 'defaultStatus',
    order: 'order',
    dateOffsetType: 'dateOffsetType',
    dueDate: 'dueDate',
    parentActivityId: 'parentActivityId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    tenetId: 'tenetId'
  };

  export type ActivityWaypointTemplateScalarFieldEnum = (typeof ActivityWaypointTemplateScalarFieldEnum)[keyof typeof ActivityWaypointTemplateScalarFieldEnum]


  export const ActivityTemplateStepScalarFieldEnum: {
    id: 'id',
    order: 'order',
    title: 'title',
    type: 'type',
    activityTemplateId: 'activityTemplateId',
    tenetId: 'tenetId'
  };

  export type ActivityTemplateStepScalarFieldEnum = (typeof ActivityTemplateStepScalarFieldEnum)[keyof typeof ActivityTemplateStepScalarFieldEnum]


  export const ActivityTemplateStepAssignmentScalarFieldEnum: {
    id: 'id',
    specificUserId: 'specificUserId',
    specificRole: 'specificRole',
    activityTemplateStepId: 'activityTemplateStepId',
    tenetId: 'tenetId'
  };

  export type ActivityTemplateStepAssignmentScalarFieldEnum = (typeof ActivityTemplateStepAssignmentScalarFieldEnum)[keyof typeof ActivityTemplateStepAssignmentScalarFieldEnum]


  export const ActivityTemplateScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    type: 'type',
    defaultPriority: 'defaultPriority',
    defaultStatus: 'defaultStatus',
    taskScheduleType: 'taskScheduleType',
    dateOffsetType: 'dateOffsetType',
    startDate: 'startDate',
    endDate: 'endDate',
    startRelativeToId: 'startRelativeToId',
    parentWaypointId: 'parentWaypointId',
    parentActivityId: 'parentActivityId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    tenetId: 'tenetId',
    order: 'order'
  };

  export type ActivityTemplateScalarFieldEnum = (typeof ActivityTemplateScalarFieldEnum)[keyof typeof ActivityTemplateScalarFieldEnum]


  export const ActivityScalarFieldEnum: {
    id: 'id',
    title: 'title',
    type: 'type',
    parentActivityId: 'parentActivityId',
    parentWaypointId: 'parentWaypointId',
    templateId: 'templateId',
    taskScheduleType: 'taskScheduleType',
    startDate: 'startDate',
    endDate: 'endDate',
    completedAt: 'completedAt',
    description: 'description',
    priority: 'priority',
    status: 'status',
    assignedById: 'assignedById',
    phoneNumber: 'phoneNumber',
    location: 'location',
    holdReason: 'holdReason',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    tenetId: 'tenetId',
    deleted: 'deleted',
    deletedAt: 'deletedAt',
    order: 'order',
    opportunityId: 'opportunityId'
  };

  export type ActivityScalarFieldEnum = (typeof ActivityScalarFieldEnum)[keyof typeof ActivityScalarFieldEnum]


  export const ContactTimelineEventScalarFieldEnum: {
    id: 'id',
    activityId: 'activityId',
    waypointId: 'waypointId',
    opportunityId: 'opportunityId',
    noteId: 'noteId',
    extraInfo: 'extraInfo',
    userId: 'userId',
    tenetId: 'tenetId',
    eventType: 'eventType',
    relationshipType: 'relationshipType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContactTimelineEventScalarFieldEnum = (typeof ContactTimelineEventScalarFieldEnum)[keyof typeof ContactTimelineEventScalarFieldEnum]


  export const AuditEventScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    tenetId: 'tenetId',
    type: 'type',
    details: 'details',
    referenceId: 'referenceId',
    reference: 'reference',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AuditEventScalarFieldEnum = (typeof AuditEventScalarFieldEnum)[keyof typeof AuditEventScalarFieldEnum]


  export const ContactTimelineEventContactJoinScalarFieldEnum: {
    contactEventId: 'contactEventId',
    contactId: 'contactId',
    type: 'type'
  };

  export type ContactTimelineEventContactJoinScalarFieldEnum = (typeof ContactTimelineEventContactJoinScalarFieldEnum)[keyof typeof ContactTimelineEventContactJoinScalarFieldEnum]


  export const NoteScalarFieldEnum: {
    id: 'id',
    content: 'content',
    waypointId: 'waypointId',
    activityId: 'activityId',
    contactId: 'contactId',
    opportunityId: 'opportunityId',
    tenetId: 'tenetId',
    authorId: 'authorId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deleted: 'deleted',
    deletedAt: 'deletedAt',
    noteType: 'noteType'
  };

  export type NoteScalarFieldEnum = (typeof NoteScalarFieldEnum)[keyof typeof NoteScalarFieldEnum]


  export const AttachmentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    location: 'location',
    activityId: 'activityId',
    tenetId: 'tenetId'
  };

  export type AttachmentScalarFieldEnum = (typeof AttachmentScalarFieldEnum)[keyof typeof AttachmentScalarFieldEnum]


  export const ActivityContactJoinScalarFieldEnum: {
    activityId: 'activityId',
    contactId: 'contactId'
  };

  export type ActivityContactJoinScalarFieldEnum = (typeof ActivityContactJoinScalarFieldEnum)[keyof typeof ActivityContactJoinScalarFieldEnum]


  export const ActivityUserJoinScalarFieldEnum: {
    activityId: 'activityId',
    userId: 'userId'
  };

  export type ActivityUserJoinScalarFieldEnum = (typeof ActivityUserJoinScalarFieldEnum)[keyof typeof ActivityUserJoinScalarFieldEnum]


  export const ContactEmailScalarFieldEnum: {
    id: 'id',
    email: 'email',
    isPrimary: 'isPrimary',
    contactId: 'contactId',
    tenetId: 'tenetId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContactEmailScalarFieldEnum = (typeof ContactEmailScalarFieldEnum)[keyof typeof ContactEmailScalarFieldEnum]


  export const ContactPhoneScalarFieldEnum: {
    id: 'id',
    number: 'number',
    type: 'type',
    isPrimary: 'isPrimary',
    contactId: 'contactId',
    tenetId: 'tenetId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContactPhoneScalarFieldEnum = (typeof ContactPhoneScalarFieldEnum)[keyof typeof ContactPhoneScalarFieldEnum]


  export const AddressScalarFieldEnum: {
    id: 'id',
    street: 'street',
    city: 'city',
    state: 'state',
    zip: 'zip',
    country: 'country',
    type: 'type',
    primary: 'primary',
    contactId: 'contactId',
    tenetId: 'tenetId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    timezone: 'timezone'
  };

  export type AddressScalarFieldEnum = (typeof AddressScalarFieldEnum)[keyof typeof AddressScalarFieldEnum]


  export const ConfigOptionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    value: 'value'
  };

  export type ConfigOptionScalarFieldEnum = (typeof ConfigOptionScalarFieldEnum)[keyof typeof ConfigOptionScalarFieldEnum]


  export const ImportantDateScalarFieldEnum: {
    id: 'id',
    date: 'date',
    type: 'type',
    contactId: 'contactId',
    tenetId: 'tenetId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ImportantDateScalarFieldEnum = (typeof ImportantDateScalarFieldEnum)[keyof typeof ImportantDateScalarFieldEnum]


  export const OpportunityScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    value: 'value',
    probability: 'probability',
    expectedCloseDate: 'expectedCloseDate',
    actualCloseDate: 'actualCloseDate',
    status: 'status',
    statusHistory: 'statusHistory',
    deleted: 'deleted',
    deletedAt: 'deletedAt',
    tenetId: 'tenetId',
    expectedValue: 'expectedValue'
  };

  export type OpportunityScalarFieldEnum = (typeof OpportunityScalarFieldEnum)[keyof typeof OpportunityScalarFieldEnum]


  export const ContactOpportunityJoinScalarFieldEnum: {
    contactId: 'contactId',
    opportunityId: 'opportunityId'
  };

  export type ContactOpportunityJoinScalarFieldEnum = (typeof ContactOpportunityJoinScalarFieldEnum)[keyof typeof ContactOpportunityJoinScalarFieldEnum]


  export const UserOpportunityJoinScalarFieldEnum: {
    userId: 'userId',
    opportunityId: 'opportunityId'
  };

  export type UserOpportunityJoinScalarFieldEnum = (typeof UserOpportunityJoinScalarFieldEnum)[keyof typeof UserOpportunityJoinScalarFieldEnum]


  export const OpportunityProductScalarFieldEnum: {
    id: 'id',
    price: 'price',
    order: 'order',
    commission: 'commission',
    opportunityId: 'opportunityId',
    productTypeId: 'productTypeId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OpportunityProductScalarFieldEnum = (typeof OpportunityProductScalarFieldEnum)[keyof typeof OpportunityProductScalarFieldEnum]


  export const ProductTypeScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    defaultCommission: 'defaultCommission',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    tenetId: 'tenetId'
  };

  export type ProductTypeScalarFieldEnum = (typeof ProductTypeScalarFieldEnum)[keyof typeof ProductTypeScalarFieldEnum]


  export const LogScalarFieldEnum: {
    id: 'id',
    userEmail: 'userEmail',
    tenetId: 'tenetId',
    message: 'message',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    severity: 'severity',
    stacktrace: 'stacktrace',
    source: 'source',
    secureDetails: 'secureDetails'
  };

  export type LogScalarFieldEnum = (typeof LogScalarFieldEnum)[keyof typeof LogScalarFieldEnum]


  export const TokenScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    createdAt: 'createdAt',
    refresh: 'refresh'
  };

  export type TokenScalarFieldEnum = (typeof TokenScalarFieldEnum)[keyof typeof TokenScalarFieldEnum]


  export const TZDataScalarFieldEnum: {
    id: 'id',
    name: 'name',
    provinceName: 'provinceName',
    countryCode: 'countryCode',
    tz: 'tz'
  };

  export type TZDataScalarFieldEnum = (typeof TZDataScalarFieldEnum)[keyof typeof TZDataScalarFieldEnum]


  export const TestObjectScalarFieldEnum: {
    id: 'id',
    required: 'required',
    persisted: 'persisted'
  };

  export type TestObjectScalarFieldEnum = (typeof TestObjectScalarFieldEnum)[keyof typeof TestObjectScalarFieldEnum]


  export const WrappedObjectScalarFieldEnum: {
    id: 'id',
    persisted: 'persisted',
    testObjectId: 'testObjectId'
  };

  export type WrappedObjectScalarFieldEnum = (typeof WrappedObjectScalarFieldEnum)[keyof typeof WrappedObjectScalarFieldEnum]


  export const JoinTestObjectScalarFieldEnum: {
    testObjectId: 'testObjectId',
    joinedObjectId: 'joinedObjectId',
    joinProperty: 'joinProperty'
  };

  export type JoinTestObjectScalarFieldEnum = (typeof JoinTestObjectScalarFieldEnum)[keyof typeof JoinTestObjectScalarFieldEnum]


  export const JoinTestObject2ScalarFieldEnum: {
    id: 'id',
    testObjectId: 'testObjectId',
    joinedObjectId: 'joinedObjectId',
    joinProperty: 'joinProperty'
  };

  export type JoinTestObject2ScalarFieldEnum = (typeof JoinTestObject2ScalarFieldEnum)[keyof typeof JoinTestObject2ScalarFieldEnum]


  export const JoinedObject1ScalarFieldEnum: {
    id: 'id',
    persisted: 'persisted'
  };

  export type JoinedObject1ScalarFieldEnum = (typeof JoinedObject1ScalarFieldEnum)[keyof typeof JoinedObject1ScalarFieldEnum]


  export const JoinedObject2ScalarFieldEnum: {
    id: 'id',
    persisted: 'persisted'
  };

  export type JoinedObject2ScalarFieldEnum = (typeof JoinedObject2ScalarFieldEnum)[keyof typeof JoinedObject2ScalarFieldEnum]


  export const JoinSelfReferenceScalarFieldEnum: {
    id: 'id',
    sourceId: 'sourceId',
    targetId: 'targetId',
    joinProperty: 'joinProperty'
  };

  export type JoinSelfReferenceScalarFieldEnum = (typeof JoinSelfReferenceScalarFieldEnum)[keyof typeof JoinSelfReferenceScalarFieldEnum]


  export const SelfReferencialJoinModelScalarFieldEnum: {
    id: 'id'
  };

  export type SelfReferencialJoinModelScalarFieldEnum = (typeof SelfReferencialJoinModelScalarFieldEnum)[keyof typeof SelfReferencialJoinModelScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    


  /**
   * Reference to a field of type 'Bytes[]'
   */
  export type ListBytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'AccessGroup'
   */
  export type EnumAccessGroupFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccessGroup'>
    


  /**
   * Reference to a field of type 'AccessGroup[]'
   */
  export type ListEnumAccessGroupFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccessGroup[]'>
    


  /**
   * Reference to a field of type 'ContactType'
   */
  export type EnumContactTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContactType'>
    


  /**
   * Reference to a field of type 'ContactType[]'
   */
  export type ListEnumContactTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContactType[]'>
    


  /**
   * Reference to a field of type 'ContactStatus'
   */
  export type EnumContactStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContactStatus'>
    


  /**
   * Reference to a field of type 'ContactStatus[]'
   */
  export type ListEnumContactStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContactStatus[]'>
    


  /**
   * Reference to a field of type 'LifecycleStage'
   */
  export type EnumLifecycleStageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LifecycleStage'>
    


  /**
   * Reference to a field of type 'LifecycleStage[]'
   */
  export type ListEnumLifecycleStageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LifecycleStage[]'>
    


  /**
   * Reference to a field of type 'HouseholdRelationshipStatus'
   */
  export type EnumHouseholdRelationshipStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HouseholdRelationshipStatus'>
    


  /**
   * Reference to a field of type 'HouseholdRelationshipStatus[]'
   */
  export type ListEnumHouseholdRelationshipStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HouseholdRelationshipStatus[]'>
    


  /**
   * Reference to a field of type 'CompanyRelationshipStatus'
   */
  export type EnumCompanyRelationshipStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompanyRelationshipStatus'>
    


  /**
   * Reference to a field of type 'CompanyRelationshipStatus[]'
   */
  export type ListEnumCompanyRelationshipStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompanyRelationshipStatus[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'ActivityStepType'
   */
  export type EnumActivityStepTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActivityStepType'>
    


  /**
   * Reference to a field of type 'ActivityStepType[]'
   */
  export type ListEnumActivityStepTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActivityStepType[]'>
    


  /**
   * Reference to a field of type 'ActivityStatus'
   */
  export type EnumActivityStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActivityStatus'>
    


  /**
   * Reference to a field of type 'ActivityStatus[]'
   */
  export type ListEnumActivityStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActivityStatus[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'DateOffsetType'
   */
  export type EnumDateOffsetTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateOffsetType'>
    


  /**
   * Reference to a field of type 'DateOffsetType[]'
   */
  export type ListEnumDateOffsetTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateOffsetType[]'>
    


  /**
   * Reference to a field of type 'ActivityType'
   */
  export type EnumActivityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActivityType'>
    


  /**
   * Reference to a field of type 'ActivityType[]'
   */
  export type ListEnumActivityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActivityType[]'>
    


  /**
   * Reference to a field of type 'ActivityPriority'
   */
  export type EnumActivityPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActivityPriority'>
    


  /**
   * Reference to a field of type 'ActivityPriority[]'
   */
  export type ListEnumActivityPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActivityPriority[]'>
    


  /**
   * Reference to a field of type 'TaskScheduleType'
   */
  export type EnumTaskScheduleTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskScheduleType'>
    


  /**
   * Reference to a field of type 'TaskScheduleType[]'
   */
  export type ListEnumTaskScheduleTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskScheduleType[]'>
    


  /**
   * Reference to a field of type 'ContactTimelineEventType'
   */
  export type EnumContactTimelineEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContactTimelineEventType'>
    


  /**
   * Reference to a field of type 'ContactTimelineEventType[]'
   */
  export type ListEnumContactTimelineEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContactTimelineEventType[]'>
    


  /**
   * Reference to a field of type 'AuditEventType'
   */
  export type EnumAuditEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditEventType'>
    


  /**
   * Reference to a field of type 'AuditEventType[]'
   */
  export type ListEnumAuditEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditEventType[]'>
    


  /**
   * Reference to a field of type 'Auditable'
   */
  export type EnumAuditableFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Auditable'>
    


  /**
   * Reference to a field of type 'Auditable[]'
   */
  export type ListEnumAuditableFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Auditable[]'>
    


  /**
   * Reference to a field of type 'ContactTimelineEventJoinType'
   */
  export type EnumContactTimelineEventJoinTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContactTimelineEventJoinType'>
    


  /**
   * Reference to a field of type 'ContactTimelineEventJoinType[]'
   */
  export type ListEnumContactTimelineEventJoinTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContactTimelineEventJoinType[]'>
    


  /**
   * Reference to a field of type 'NoteType'
   */
  export type EnumNoteTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NoteType'>
    


  /**
   * Reference to a field of type 'NoteType[]'
   */
  export type ListEnumNoteTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NoteType[]'>
    


  /**
   * Reference to a field of type 'PhoneType'
   */
  export type EnumPhoneTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PhoneType'>
    


  /**
   * Reference to a field of type 'PhoneType[]'
   */
  export type ListEnumPhoneTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PhoneType[]'>
    


  /**
   * Reference to a field of type 'AddressType'
   */
  export type EnumAddressTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AddressType'>
    


  /**
   * Reference to a field of type 'AddressType[]'
   */
  export type ListEnumAddressTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AddressType[]'>
    


  /**
   * Reference to a field of type 'ImportantDateType'
   */
  export type EnumImportantDateTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ImportantDateType'>
    


  /**
   * Reference to a field of type 'ImportantDateType[]'
   */
  export type ListEnumImportantDateTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ImportantDateType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'OpportunityStatus'
   */
  export type EnumOpportunityStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OpportunityStatus'>
    


  /**
   * Reference to a field of type 'OpportunityStatus[]'
   */
  export type ListEnumOpportunityStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OpportunityStatus[]'>
    


  /**
   * Reference to a field of type 'LogLevel'
   */
  export type EnumLogLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LogLevel'>
    


  /**
   * Reference to a field of type 'LogLevel[]'
   */
  export type ListEnumLogLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LogLevel[]'>
    
  /**
   * Deep Input Types
   */


  export type TenetWhereInput = {
    AND?: TenetWhereInput | TenetWhereInput[]
    OR?: TenetWhereInput[]
    NOT?: TenetWhereInput | TenetWhereInput[]
    id?: BytesFilter<"Tenet"> | Uint8Array
    name?: StringFilter<"Tenet"> | string
    createdAt?: DateTimeFilter<"Tenet"> | Date | string
    updatedAt?: DateTimeFilter<"Tenet"> | Date | string
    users?: UserListRelationFilter
    logs?: LogListRelationFilter
    contacts?: ContactListRelationFilter
    activities?: ActivityListRelationFilter
    addresses?: AddressListRelationFilter
    contactEmails?: ContactEmailListRelationFilter
    contactPhones?: ContactPhoneListRelationFilter
    importantDates?: ImportantDateListRelationFilter
    attachments?: AttachmentListRelationFilter
    notes?: NoteListRelationFilter
    auditEvents?: AuditEventListRelationFilter
    contactTimelineEvents?: ContactTimelineEventListRelationFilter
    activitySteps?: ActivityStepListRelationFilter
    activityWaypoints?: ActivityWaypointListRelationFilter
    templateAssignments?: TemplateAssignmentListRelationFilter
    activityWaypointTemplates?: ActivityWaypointTemplateListRelationFilter
    activityTemplates?: ActivityTemplateListRelationFilter
    activityTemplateSteps?: ActivityTemplateStepListRelationFilter
    opportunities?: OpportunityListRelationFilter
    products?: ProductTypeListRelationFilter
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentListRelationFilter
  }

  export type TenetOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
    logs?: LogOrderByRelationAggregateInput
    contacts?: ContactOrderByRelationAggregateInput
    activities?: ActivityOrderByRelationAggregateInput
    addresses?: AddressOrderByRelationAggregateInput
    contactEmails?: ContactEmailOrderByRelationAggregateInput
    contactPhones?: ContactPhoneOrderByRelationAggregateInput
    importantDates?: ImportantDateOrderByRelationAggregateInput
    attachments?: AttachmentOrderByRelationAggregateInput
    notes?: NoteOrderByRelationAggregateInput
    auditEvents?: AuditEventOrderByRelationAggregateInput
    contactTimelineEvents?: ContactTimelineEventOrderByRelationAggregateInput
    activitySteps?: ActivityStepOrderByRelationAggregateInput
    activityWaypoints?: ActivityWaypointOrderByRelationAggregateInput
    templateAssignments?: TemplateAssignmentOrderByRelationAggregateInput
    activityWaypointTemplates?: ActivityWaypointTemplateOrderByRelationAggregateInput
    activityTemplates?: ActivityTemplateOrderByRelationAggregateInput
    activityTemplateSteps?: ActivityTemplateStepOrderByRelationAggregateInput
    opportunities?: OpportunityOrderByRelationAggregateInput
    products?: ProductTypeOrderByRelationAggregateInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentOrderByRelationAggregateInput
  }

  export type TenetWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    name?: string
    AND?: TenetWhereInput | TenetWhereInput[]
    OR?: TenetWhereInput[]
    NOT?: TenetWhereInput | TenetWhereInput[]
    createdAt?: DateTimeFilter<"Tenet"> | Date | string
    updatedAt?: DateTimeFilter<"Tenet"> | Date | string
    users?: UserListRelationFilter
    logs?: LogListRelationFilter
    contacts?: ContactListRelationFilter
    activities?: ActivityListRelationFilter
    addresses?: AddressListRelationFilter
    contactEmails?: ContactEmailListRelationFilter
    contactPhones?: ContactPhoneListRelationFilter
    importantDates?: ImportantDateListRelationFilter
    attachments?: AttachmentListRelationFilter
    notes?: NoteListRelationFilter
    auditEvents?: AuditEventListRelationFilter
    contactTimelineEvents?: ContactTimelineEventListRelationFilter
    activitySteps?: ActivityStepListRelationFilter
    activityWaypoints?: ActivityWaypointListRelationFilter
    templateAssignments?: TemplateAssignmentListRelationFilter
    activityWaypointTemplates?: ActivityWaypointTemplateListRelationFilter
    activityTemplates?: ActivityTemplateListRelationFilter
    activityTemplateSteps?: ActivityTemplateStepListRelationFilter
    opportunities?: OpportunityListRelationFilter
    products?: ProductTypeListRelationFilter
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentListRelationFilter
  }, "id" | "name">

  export type TenetOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TenetCountOrderByAggregateInput
    _max?: TenetMaxOrderByAggregateInput
    _min?: TenetMinOrderByAggregateInput
  }

  export type TenetScalarWhereWithAggregatesInput = {
    AND?: TenetScalarWhereWithAggregatesInput | TenetScalarWhereWithAggregatesInput[]
    OR?: TenetScalarWhereWithAggregatesInput[]
    NOT?: TenetScalarWhereWithAggregatesInput | TenetScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"Tenet"> | Uint8Array
    name?: StringWithAggregatesFilter<"Tenet"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Tenet"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tenet"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: BytesFilter<"User"> | Uint8Array
    email?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    fullName?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    password?: StringFilter<"User"> | string
    enabled?: BoolFilter<"User"> | boolean
    type?: EnumAccessGroupFilter<"User"> | $Enums.AccessGroup
    tenetId?: BytesNullableFilter<"User"> | Uint8Array | null
    system?: BoolFilter<"User"> | boolean
    deleted?: BoolFilter<"User"> | boolean
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    tokens?: TokenListRelationFilter
    tenet?: XOR<TenetNullableScalarRelationFilter, TenetWhereInput> | null
    activities?: ActivityUserJoinListRelationFilter
    notes?: NoteListRelationFilter
    waypoints?: UserWaypointJoinListRelationFilter
    events?: ContactTimelineEventListRelationFilter
    auditEvents?: AuditEventListRelationFilter
    templateAssignments?: TemplateAssignmentListRelationFilter
    assignedActivities?: ActivityListRelationFilter
    opportunities?: UserOpportunityJoinListRelationFilter
    activitySteps?: ActivityStepUserJoinListRelationFilter
    templateStepAssignments?: ActivityTemplateStepAssignmentListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    fullName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    password?: SortOrder
    enabled?: SortOrder
    type?: SortOrder
    tenetId?: SortOrderInput | SortOrder
    system?: SortOrder
    deleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    tokens?: TokenOrderByRelationAggregateInput
    tenet?: TenetOrderByWithRelationInput
    activities?: ActivityUserJoinOrderByRelationAggregateInput
    notes?: NoteOrderByRelationAggregateInput
    waypoints?: UserWaypointJoinOrderByRelationAggregateInput
    events?: ContactTimelineEventOrderByRelationAggregateInput
    auditEvents?: AuditEventOrderByRelationAggregateInput
    templateAssignments?: TemplateAssignmentOrderByRelationAggregateInput
    assignedActivities?: ActivityOrderByRelationAggregateInput
    opportunities?: UserOpportunityJoinOrderByRelationAggregateInput
    activitySteps?: ActivityStepUserJoinOrderByRelationAggregateInput
    templateStepAssignments?: ActivityTemplateStepAssignmentOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    fullName?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    password?: StringFilter<"User"> | string
    enabled?: BoolFilter<"User"> | boolean
    type?: EnumAccessGroupFilter<"User"> | $Enums.AccessGroup
    tenetId?: BytesNullableFilter<"User"> | Uint8Array | null
    system?: BoolFilter<"User"> | boolean
    deleted?: BoolFilter<"User"> | boolean
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    tokens?: TokenListRelationFilter
    tenet?: XOR<TenetNullableScalarRelationFilter, TenetWhereInput> | null
    activities?: ActivityUserJoinListRelationFilter
    notes?: NoteListRelationFilter
    waypoints?: UserWaypointJoinListRelationFilter
    events?: ContactTimelineEventListRelationFilter
    auditEvents?: AuditEventListRelationFilter
    templateAssignments?: TemplateAssignmentListRelationFilter
    assignedActivities?: ActivityListRelationFilter
    opportunities?: UserOpportunityJoinListRelationFilter
    activitySteps?: ActivityStepUserJoinListRelationFilter
    templateStepAssignments?: ActivityTemplateStepAssignmentListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    fullName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    password?: SortOrder
    enabled?: SortOrder
    type?: SortOrder
    tenetId?: SortOrderInput | SortOrder
    system?: SortOrder
    deleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"User"> | Uint8Array
    email?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    fullName?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    password?: StringWithAggregatesFilter<"User"> | string
    enabled?: BoolWithAggregatesFilter<"User"> | boolean
    type?: EnumAccessGroupWithAggregatesFilter<"User"> | $Enums.AccessGroup
    tenetId?: BytesNullableWithAggregatesFilter<"User"> | Uint8Array | null
    system?: BoolWithAggregatesFilter<"User"> | boolean
    deleted?: BoolWithAggregatesFilter<"User"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type ContactWhereInput = {
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    id?: BytesFilter<"Contact"> | Uint8Array
    firstName?: StringNullableFilter<"Contact"> | string | null
    lastName?: StringFilter<"Contact"> | string
    fullName?: StringFilter<"Contact"> | string
    tenetId?: BytesFilter<"Contact"> | Uint8Array
    importantNotes?: StringNullableFilter<"Contact"> | string | null
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    type?: EnumContactTypeFilter<"Contact"> | $Enums.ContactType
    status?: EnumContactStatusFilter<"Contact"> | $Enums.ContactStatus
    lifecycleStage?: EnumLifecycleStageNullableFilter<"Contact"> | $Enums.LifecycleStage | null
    lastContactedDate?: DateTimeNullableFilter<"Contact"> | Date | string | null
    followUpDate?: DateTimeNullableFilter<"Contact"> | Date | string | null
    householdId?: BytesNullableFilter<"Contact"> | Uint8Array | null
    householdStatus?: EnumHouseholdRelationshipStatusNullableFilter<"Contact"> | $Enums.HouseholdRelationshipStatus | null
    companyId?: BytesNullableFilter<"Contact"> | Uint8Array | null
    position?: StringNullableFilter<"Contact"> | string | null
    companyStatus?: EnumCompanyRelationshipStatusNullableFilter<"Contact"> | $Enums.CompanyRelationshipStatus | null
    headOfHouseholdId?: BytesNullableFilter<"Contact"> | Uint8Array | null
    industry?: StringNullableFilter<"Contact"> | string | null
    website?: StringNullableFilter<"Contact"> | string | null
    size?: IntNullableFilter<"Contact"> | number | null
    primaryContactId?: BytesNullableFilter<"Contact"> | Uint8Array | null
    deleted?: BoolFilter<"Contact"> | boolean
    deletedAt?: DateTimeNullableFilter<"Contact"> | Date | string | null
    tenet?: XOR<TenetScalarRelationFilter, TenetWhereInput>
    notes?: NoteListRelationFilter
    timelineEvents?: ContactTimelineEventContactJoinListRelationFilter
    addresses?: AddressListRelationFilter
    emails?: ContactEmailListRelationFilter
    phones?: ContactPhoneListRelationFilter
    importantDates?: ImportantDateListRelationFilter
    activities?: ActivityContactJoinListRelationFilter
    household?: XOR<ContactNullableScalarRelationFilter, ContactWhereInput> | null
    headOfHouseholdFor?: XOR<ContactNullableScalarRelationFilter, ContactWhereInput> | null
    company?: XOR<ContactNullableScalarRelationFilter, ContactWhereInput> | null
    primaryContactFor?: XOR<ContactNullableScalarRelationFilter, ContactWhereInput> | null
    headOfHousehold?: XOR<ContactNullableScalarRelationFilter, ContactWhereInput> | null
    householdMembers?: ContactListRelationFilter
    employees?: ContactListRelationFilter
    primaryContact?: XOR<ContactNullableScalarRelationFilter, ContactWhereInput> | null
    opportunities?: ContactOpportunityJoinListRelationFilter
    relationAsSource?: ContactRelationshipListRelationFilter
    relationAsTarget?: ContactRelationshipListRelationFilter
  }

  export type ContactOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrder
    fullName?: SortOrder
    tenetId?: SortOrder
    importantNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    type?: SortOrder
    status?: SortOrder
    lifecycleStage?: SortOrderInput | SortOrder
    lastContactedDate?: SortOrderInput | SortOrder
    followUpDate?: SortOrderInput | SortOrder
    householdId?: SortOrderInput | SortOrder
    householdStatus?: SortOrderInput | SortOrder
    companyId?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    companyStatus?: SortOrderInput | SortOrder
    headOfHouseholdId?: SortOrderInput | SortOrder
    industry?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    primaryContactId?: SortOrderInput | SortOrder
    deleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    tenet?: TenetOrderByWithRelationInput
    notes?: NoteOrderByRelationAggregateInput
    timelineEvents?: ContactTimelineEventContactJoinOrderByRelationAggregateInput
    addresses?: AddressOrderByRelationAggregateInput
    emails?: ContactEmailOrderByRelationAggregateInput
    phones?: ContactPhoneOrderByRelationAggregateInput
    importantDates?: ImportantDateOrderByRelationAggregateInput
    activities?: ActivityContactJoinOrderByRelationAggregateInput
    household?: ContactOrderByWithRelationInput
    headOfHouseholdFor?: ContactOrderByWithRelationInput
    company?: ContactOrderByWithRelationInput
    primaryContactFor?: ContactOrderByWithRelationInput
    headOfHousehold?: ContactOrderByWithRelationInput
    householdMembers?: ContactOrderByRelationAggregateInput
    employees?: ContactOrderByRelationAggregateInput
    primaryContact?: ContactOrderByWithRelationInput
    opportunities?: ContactOpportunityJoinOrderByRelationAggregateInput
    relationAsSource?: ContactRelationshipOrderByRelationAggregateInput
    relationAsTarget?: ContactRelationshipOrderByRelationAggregateInput
  }

  export type ContactWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    headOfHouseholdId?: Uint8Array
    primaryContactId?: Uint8Array
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    firstName?: StringNullableFilter<"Contact"> | string | null
    lastName?: StringFilter<"Contact"> | string
    fullName?: StringFilter<"Contact"> | string
    tenetId?: BytesFilter<"Contact"> | Uint8Array
    importantNotes?: StringNullableFilter<"Contact"> | string | null
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    type?: EnumContactTypeFilter<"Contact"> | $Enums.ContactType
    status?: EnumContactStatusFilter<"Contact"> | $Enums.ContactStatus
    lifecycleStage?: EnumLifecycleStageNullableFilter<"Contact"> | $Enums.LifecycleStage | null
    lastContactedDate?: DateTimeNullableFilter<"Contact"> | Date | string | null
    followUpDate?: DateTimeNullableFilter<"Contact"> | Date | string | null
    householdId?: BytesNullableFilter<"Contact"> | Uint8Array | null
    householdStatus?: EnumHouseholdRelationshipStatusNullableFilter<"Contact"> | $Enums.HouseholdRelationshipStatus | null
    companyId?: BytesNullableFilter<"Contact"> | Uint8Array | null
    position?: StringNullableFilter<"Contact"> | string | null
    companyStatus?: EnumCompanyRelationshipStatusNullableFilter<"Contact"> | $Enums.CompanyRelationshipStatus | null
    industry?: StringNullableFilter<"Contact"> | string | null
    website?: StringNullableFilter<"Contact"> | string | null
    size?: IntNullableFilter<"Contact"> | number | null
    deleted?: BoolFilter<"Contact"> | boolean
    deletedAt?: DateTimeNullableFilter<"Contact"> | Date | string | null
    tenet?: XOR<TenetScalarRelationFilter, TenetWhereInput>
    notes?: NoteListRelationFilter
    timelineEvents?: ContactTimelineEventContactJoinListRelationFilter
    addresses?: AddressListRelationFilter
    emails?: ContactEmailListRelationFilter
    phones?: ContactPhoneListRelationFilter
    importantDates?: ImportantDateListRelationFilter
    activities?: ActivityContactJoinListRelationFilter
    household?: XOR<ContactNullableScalarRelationFilter, ContactWhereInput> | null
    headOfHouseholdFor?: XOR<ContactNullableScalarRelationFilter, ContactWhereInput> | null
    company?: XOR<ContactNullableScalarRelationFilter, ContactWhereInput> | null
    primaryContactFor?: XOR<ContactNullableScalarRelationFilter, ContactWhereInput> | null
    headOfHousehold?: XOR<ContactNullableScalarRelationFilter, ContactWhereInput> | null
    householdMembers?: ContactListRelationFilter
    employees?: ContactListRelationFilter
    primaryContact?: XOR<ContactNullableScalarRelationFilter, ContactWhereInput> | null
    opportunities?: ContactOpportunityJoinListRelationFilter
    relationAsSource?: ContactRelationshipListRelationFilter
    relationAsTarget?: ContactRelationshipListRelationFilter
  }, "id" | "headOfHouseholdId" | "primaryContactId">

  export type ContactOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrder
    fullName?: SortOrder
    tenetId?: SortOrder
    importantNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    type?: SortOrder
    status?: SortOrder
    lifecycleStage?: SortOrderInput | SortOrder
    lastContactedDate?: SortOrderInput | SortOrder
    followUpDate?: SortOrderInput | SortOrder
    householdId?: SortOrderInput | SortOrder
    householdStatus?: SortOrderInput | SortOrder
    companyId?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    companyStatus?: SortOrderInput | SortOrder
    headOfHouseholdId?: SortOrderInput | SortOrder
    industry?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    primaryContactId?: SortOrderInput | SortOrder
    deleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ContactCountOrderByAggregateInput
    _avg?: ContactAvgOrderByAggregateInput
    _max?: ContactMaxOrderByAggregateInput
    _min?: ContactMinOrderByAggregateInput
    _sum?: ContactSumOrderByAggregateInput
  }

  export type ContactScalarWhereWithAggregatesInput = {
    AND?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    OR?: ContactScalarWhereWithAggregatesInput[]
    NOT?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"Contact"> | Uint8Array
    firstName?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    lastName?: StringWithAggregatesFilter<"Contact"> | string
    fullName?: StringWithAggregatesFilter<"Contact"> | string
    tenetId?: BytesWithAggregatesFilter<"Contact"> | Uint8Array
    importantNotes?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
    type?: EnumContactTypeWithAggregatesFilter<"Contact"> | $Enums.ContactType
    status?: EnumContactStatusWithAggregatesFilter<"Contact"> | $Enums.ContactStatus
    lifecycleStage?: EnumLifecycleStageNullableWithAggregatesFilter<"Contact"> | $Enums.LifecycleStage | null
    lastContactedDate?: DateTimeNullableWithAggregatesFilter<"Contact"> | Date | string | null
    followUpDate?: DateTimeNullableWithAggregatesFilter<"Contact"> | Date | string | null
    householdId?: BytesNullableWithAggregatesFilter<"Contact"> | Uint8Array | null
    householdStatus?: EnumHouseholdRelationshipStatusNullableWithAggregatesFilter<"Contact"> | $Enums.HouseholdRelationshipStatus | null
    companyId?: BytesNullableWithAggregatesFilter<"Contact"> | Uint8Array | null
    position?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    companyStatus?: EnumCompanyRelationshipStatusNullableWithAggregatesFilter<"Contact"> | $Enums.CompanyRelationshipStatus | null
    headOfHouseholdId?: BytesNullableWithAggregatesFilter<"Contact"> | Uint8Array | null
    industry?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    website?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    size?: IntNullableWithAggregatesFilter<"Contact"> | number | null
    primaryContactId?: BytesNullableWithAggregatesFilter<"Contact"> | Uint8Array | null
    deleted?: BoolWithAggregatesFilter<"Contact"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Contact"> | Date | string | null
  }

  export type ContactRelationshipWhereInput = {
    AND?: ContactRelationshipWhereInput | ContactRelationshipWhereInput[]
    OR?: ContactRelationshipWhereInput[]
    NOT?: ContactRelationshipWhereInput | ContactRelationshipWhereInput[]
    id?: BytesFilter<"ContactRelationship"> | Uint8Array
    sourceId?: BytesFilter<"ContactRelationship"> | Uint8Array
    targetId?: BytesFilter<"ContactRelationship"> | Uint8Array
    type?: StringFilter<"ContactRelationship"> | string
    established?: DateTimeNullableFilter<"ContactRelationship"> | Date | string | null
    notes?: StringNullableFilter<"ContactRelationship"> | string | null
    source?: XOR<ContactScalarRelationFilter, ContactWhereInput>
    target?: XOR<ContactScalarRelationFilter, ContactWhereInput>
  }

  export type ContactRelationshipOrderByWithRelationInput = {
    id?: SortOrder
    sourceId?: SortOrder
    targetId?: SortOrder
    type?: SortOrder
    established?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    source?: ContactOrderByWithRelationInput
    target?: ContactOrderByWithRelationInput
  }

  export type ContactRelationshipWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    sourceId_targetId_type?: ContactRelationshipSourceIdTargetIdTypeCompoundUniqueInput
    AND?: ContactRelationshipWhereInput | ContactRelationshipWhereInput[]
    OR?: ContactRelationshipWhereInput[]
    NOT?: ContactRelationshipWhereInput | ContactRelationshipWhereInput[]
    sourceId?: BytesFilter<"ContactRelationship"> | Uint8Array
    targetId?: BytesFilter<"ContactRelationship"> | Uint8Array
    type?: StringFilter<"ContactRelationship"> | string
    established?: DateTimeNullableFilter<"ContactRelationship"> | Date | string | null
    notes?: StringNullableFilter<"ContactRelationship"> | string | null
    source?: XOR<ContactScalarRelationFilter, ContactWhereInput>
    target?: XOR<ContactScalarRelationFilter, ContactWhereInput>
  }, "id" | "sourceId_targetId_type">

  export type ContactRelationshipOrderByWithAggregationInput = {
    id?: SortOrder
    sourceId?: SortOrder
    targetId?: SortOrder
    type?: SortOrder
    established?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: ContactRelationshipCountOrderByAggregateInput
    _max?: ContactRelationshipMaxOrderByAggregateInput
    _min?: ContactRelationshipMinOrderByAggregateInput
  }

  export type ContactRelationshipScalarWhereWithAggregatesInput = {
    AND?: ContactRelationshipScalarWhereWithAggregatesInput | ContactRelationshipScalarWhereWithAggregatesInput[]
    OR?: ContactRelationshipScalarWhereWithAggregatesInput[]
    NOT?: ContactRelationshipScalarWhereWithAggregatesInput | ContactRelationshipScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"ContactRelationship"> | Uint8Array
    sourceId?: BytesWithAggregatesFilter<"ContactRelationship"> | Uint8Array
    targetId?: BytesWithAggregatesFilter<"ContactRelationship"> | Uint8Array
    type?: StringWithAggregatesFilter<"ContactRelationship"> | string
    established?: DateTimeNullableWithAggregatesFilter<"ContactRelationship"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"ContactRelationship"> | string | null
  }

  export type ActivityStepWhereInput = {
    AND?: ActivityStepWhereInput | ActivityStepWhereInput[]
    OR?: ActivityStepWhereInput[]
    NOT?: ActivityStepWhereInput | ActivityStepWhereInput[]
    id?: BytesFilter<"ActivityStep"> | Uint8Array
    title?: StringFilter<"ActivityStep"> | string
    completed?: BoolFilter<"ActivityStep"> | boolean
    activityId?: BytesFilter<"ActivityStep"> | Uint8Array
    createdAt?: DateTimeFilter<"ActivityStep"> | Date | string
    updatedAt?: DateTimeFilter<"ActivityStep"> | Date | string
    tenetId?: BytesFilter<"ActivityStep"> | Uint8Array
    type?: EnumActivityStepTypeFilter<"ActivityStep"> | $Enums.ActivityStepType
    order?: IntFilter<"ActivityStep"> | number
    activity?: XOR<ActivityScalarRelationFilter, ActivityWhereInput>
    assignedTo?: ActivityStepUserJoinListRelationFilter
    tenet?: XOR<TenetScalarRelationFilter, TenetWhereInput>
  }

  export type ActivityStepOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    completed?: SortOrder
    activityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenetId?: SortOrder
    type?: SortOrder
    order?: SortOrder
    activity?: ActivityOrderByWithRelationInput
    assignedTo?: ActivityStepUserJoinOrderByRelationAggregateInput
    tenet?: TenetOrderByWithRelationInput
  }

  export type ActivityStepWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    AND?: ActivityStepWhereInput | ActivityStepWhereInput[]
    OR?: ActivityStepWhereInput[]
    NOT?: ActivityStepWhereInput | ActivityStepWhereInput[]
    title?: StringFilter<"ActivityStep"> | string
    completed?: BoolFilter<"ActivityStep"> | boolean
    activityId?: BytesFilter<"ActivityStep"> | Uint8Array
    createdAt?: DateTimeFilter<"ActivityStep"> | Date | string
    updatedAt?: DateTimeFilter<"ActivityStep"> | Date | string
    tenetId?: BytesFilter<"ActivityStep"> | Uint8Array
    type?: EnumActivityStepTypeFilter<"ActivityStep"> | $Enums.ActivityStepType
    order?: IntFilter<"ActivityStep"> | number
    activity?: XOR<ActivityScalarRelationFilter, ActivityWhereInput>
    assignedTo?: ActivityStepUserJoinListRelationFilter
    tenet?: XOR<TenetScalarRelationFilter, TenetWhereInput>
  }, "id">

  export type ActivityStepOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    completed?: SortOrder
    activityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenetId?: SortOrder
    type?: SortOrder
    order?: SortOrder
    _count?: ActivityStepCountOrderByAggregateInput
    _avg?: ActivityStepAvgOrderByAggregateInput
    _max?: ActivityStepMaxOrderByAggregateInput
    _min?: ActivityStepMinOrderByAggregateInput
    _sum?: ActivityStepSumOrderByAggregateInput
  }

  export type ActivityStepScalarWhereWithAggregatesInput = {
    AND?: ActivityStepScalarWhereWithAggregatesInput | ActivityStepScalarWhereWithAggregatesInput[]
    OR?: ActivityStepScalarWhereWithAggregatesInput[]
    NOT?: ActivityStepScalarWhereWithAggregatesInput | ActivityStepScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"ActivityStep"> | Uint8Array
    title?: StringWithAggregatesFilter<"ActivityStep"> | string
    completed?: BoolWithAggregatesFilter<"ActivityStep"> | boolean
    activityId?: BytesWithAggregatesFilter<"ActivityStep"> | Uint8Array
    createdAt?: DateTimeWithAggregatesFilter<"ActivityStep"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ActivityStep"> | Date | string
    tenetId?: BytesWithAggregatesFilter<"ActivityStep"> | Uint8Array
    type?: EnumActivityStepTypeWithAggregatesFilter<"ActivityStep"> | $Enums.ActivityStepType
    order?: IntWithAggregatesFilter<"ActivityStep"> | number
  }

  export type ActivityStepUserJoinWhereInput = {
    AND?: ActivityStepUserJoinWhereInput | ActivityStepUserJoinWhereInput[]
    OR?: ActivityStepUserJoinWhereInput[]
    NOT?: ActivityStepUserJoinWhereInput | ActivityStepUserJoinWhereInput[]
    activityStepId?: BytesFilter<"ActivityStepUserJoin"> | Uint8Array
    userId?: BytesFilter<"ActivityStepUserJoin"> | Uint8Array
    stepRelation?: XOR<ActivityStepScalarRelationFilter, ActivityStepWhereInput>
    userRelation?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ActivityStepUserJoinOrderByWithRelationInput = {
    activityStepId?: SortOrder
    userId?: SortOrder
    stepRelation?: ActivityStepOrderByWithRelationInput
    userRelation?: UserOrderByWithRelationInput
  }

  export type ActivityStepUserJoinWhereUniqueInput = Prisma.AtLeast<{
    activityStepId_userId?: ActivityStepUserJoinActivityStepIdUserIdCompoundUniqueInput
    AND?: ActivityStepUserJoinWhereInput | ActivityStepUserJoinWhereInput[]
    OR?: ActivityStepUserJoinWhereInput[]
    NOT?: ActivityStepUserJoinWhereInput | ActivityStepUserJoinWhereInput[]
    activityStepId?: BytesFilter<"ActivityStepUserJoin"> | Uint8Array
    userId?: BytesFilter<"ActivityStepUserJoin"> | Uint8Array
    stepRelation?: XOR<ActivityStepScalarRelationFilter, ActivityStepWhereInput>
    userRelation?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "activityStepId_userId">

  export type ActivityStepUserJoinOrderByWithAggregationInput = {
    activityStepId?: SortOrder
    userId?: SortOrder
    _count?: ActivityStepUserJoinCountOrderByAggregateInput
    _max?: ActivityStepUserJoinMaxOrderByAggregateInput
    _min?: ActivityStepUserJoinMinOrderByAggregateInput
  }

  export type ActivityStepUserJoinScalarWhereWithAggregatesInput = {
    AND?: ActivityStepUserJoinScalarWhereWithAggregatesInput | ActivityStepUserJoinScalarWhereWithAggregatesInput[]
    OR?: ActivityStepUserJoinScalarWhereWithAggregatesInput[]
    NOT?: ActivityStepUserJoinScalarWhereWithAggregatesInput | ActivityStepUserJoinScalarWhereWithAggregatesInput[]
    activityStepId?: BytesWithAggregatesFilter<"ActivityStepUserJoin"> | Uint8Array
    userId?: BytesWithAggregatesFilter<"ActivityStepUserJoin"> | Uint8Array
  }

  export type UserWaypointJoinWhereInput = {
    AND?: UserWaypointJoinWhereInput | UserWaypointJoinWhereInput[]
    OR?: UserWaypointJoinWhereInput[]
    NOT?: UserWaypointJoinWhereInput | UserWaypointJoinWhereInput[]
    userId?: BytesFilter<"UserWaypointJoin"> | Uint8Array
    waypointId?: BytesFilter<"UserWaypointJoin"> | Uint8Array
    userRelation?: XOR<UserScalarRelationFilter, UserWhereInput>
    waypointRelation?: XOR<ActivityWaypointScalarRelationFilter, ActivityWaypointWhereInput>
  }

  export type UserWaypointJoinOrderByWithRelationInput = {
    userId?: SortOrder
    waypointId?: SortOrder
    userRelation?: UserOrderByWithRelationInput
    waypointRelation?: ActivityWaypointOrderByWithRelationInput
  }

  export type UserWaypointJoinWhereUniqueInput = Prisma.AtLeast<{
    userId_waypointId?: UserWaypointJoinUserIdWaypointIdCompoundUniqueInput
    AND?: UserWaypointJoinWhereInput | UserWaypointJoinWhereInput[]
    OR?: UserWaypointJoinWhereInput[]
    NOT?: UserWaypointJoinWhereInput | UserWaypointJoinWhereInput[]
    userId?: BytesFilter<"UserWaypointJoin"> | Uint8Array
    waypointId?: BytesFilter<"UserWaypointJoin"> | Uint8Array
    userRelation?: XOR<UserScalarRelationFilter, UserWhereInput>
    waypointRelation?: XOR<ActivityWaypointScalarRelationFilter, ActivityWaypointWhereInput>
  }, "userId_waypointId">

  export type UserWaypointJoinOrderByWithAggregationInput = {
    userId?: SortOrder
    waypointId?: SortOrder
    _count?: UserWaypointJoinCountOrderByAggregateInput
    _max?: UserWaypointJoinMaxOrderByAggregateInput
    _min?: UserWaypointJoinMinOrderByAggregateInput
  }

  export type UserWaypointJoinScalarWhereWithAggregatesInput = {
    AND?: UserWaypointJoinScalarWhereWithAggregatesInput | UserWaypointJoinScalarWhereWithAggregatesInput[]
    OR?: UserWaypointJoinScalarWhereWithAggregatesInput[]
    NOT?: UserWaypointJoinScalarWhereWithAggregatesInput | UserWaypointJoinScalarWhereWithAggregatesInput[]
    userId?: BytesWithAggregatesFilter<"UserWaypointJoin"> | Uint8Array
    waypointId?: BytesWithAggregatesFilter<"UserWaypointJoin"> | Uint8Array
  }

  export type ActivityWaypointWhereInput = {
    AND?: ActivityWaypointWhereInput | ActivityWaypointWhereInput[]
    OR?: ActivityWaypointWhereInput[]
    NOT?: ActivityWaypointWhereInput | ActivityWaypointWhereInput[]
    id?: BytesFilter<"ActivityWaypoint"> | Uint8Array
    title?: StringFilter<"ActivityWaypoint"> | string
    description?: StringNullableFilter<"ActivityWaypoint"> | string | null
    summary?: StringNullableFilter<"ActivityWaypoint"> | string | null
    status?: EnumActivityStatusFilter<"ActivityWaypoint"> | $Enums.ActivityStatus
    order?: IntFilter<"ActivityWaypoint"> | number
    actualStart?: DateTimeFilter<"ActivityWaypoint"> | Date | string
    dueDate?: DateTimeFilter<"ActivityWaypoint"> | Date | string
    actualEnd?: DateTimeNullableFilter<"ActivityWaypoint"> | Date | string | null
    activityId?: BytesFilter<"ActivityWaypoint"> | Uint8Array
    templateId?: BytesNullableFilter<"ActivityWaypoint"> | Uint8Array | null
    createdAt?: DateTimeFilter<"ActivityWaypoint"> | Date | string
    updatedAt?: DateTimeFilter<"ActivityWaypoint"> | Date | string
    tenetId?: BytesFilter<"ActivityWaypoint"> | Uint8Array
    users?: UserWaypointJoinListRelationFilter
    activity?: XOR<ActivityScalarRelationFilter, ActivityWhereInput>
    childActivities?: ActivityListRelationFilter
    template?: XOR<ActivityWaypointTemplateNullableScalarRelationFilter, ActivityWaypointTemplateWhereInput> | null
    events?: ContactTimelineEventListRelationFilter
    tenet?: XOR<TenetScalarRelationFilter, TenetWhereInput>
    Note?: NoteListRelationFilter
  }

  export type ActivityWaypointOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    summary?: SortOrderInput | SortOrder
    status?: SortOrder
    order?: SortOrder
    actualStart?: SortOrder
    dueDate?: SortOrder
    actualEnd?: SortOrderInput | SortOrder
    activityId?: SortOrder
    templateId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenetId?: SortOrder
    users?: UserWaypointJoinOrderByRelationAggregateInput
    activity?: ActivityOrderByWithRelationInput
    childActivities?: ActivityOrderByRelationAggregateInput
    template?: ActivityWaypointTemplateOrderByWithRelationInput
    events?: ContactTimelineEventOrderByRelationAggregateInput
    tenet?: TenetOrderByWithRelationInput
    Note?: NoteOrderByRelationAggregateInput
  }

  export type ActivityWaypointWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    AND?: ActivityWaypointWhereInput | ActivityWaypointWhereInput[]
    OR?: ActivityWaypointWhereInput[]
    NOT?: ActivityWaypointWhereInput | ActivityWaypointWhereInput[]
    title?: StringFilter<"ActivityWaypoint"> | string
    description?: StringNullableFilter<"ActivityWaypoint"> | string | null
    summary?: StringNullableFilter<"ActivityWaypoint"> | string | null
    status?: EnumActivityStatusFilter<"ActivityWaypoint"> | $Enums.ActivityStatus
    order?: IntFilter<"ActivityWaypoint"> | number
    actualStart?: DateTimeFilter<"ActivityWaypoint"> | Date | string
    dueDate?: DateTimeFilter<"ActivityWaypoint"> | Date | string
    actualEnd?: DateTimeNullableFilter<"ActivityWaypoint"> | Date | string | null
    activityId?: BytesFilter<"ActivityWaypoint"> | Uint8Array
    templateId?: BytesNullableFilter<"ActivityWaypoint"> | Uint8Array | null
    createdAt?: DateTimeFilter<"ActivityWaypoint"> | Date | string
    updatedAt?: DateTimeFilter<"ActivityWaypoint"> | Date | string
    tenetId?: BytesFilter<"ActivityWaypoint"> | Uint8Array
    users?: UserWaypointJoinListRelationFilter
    activity?: XOR<ActivityScalarRelationFilter, ActivityWhereInput>
    childActivities?: ActivityListRelationFilter
    template?: XOR<ActivityWaypointTemplateNullableScalarRelationFilter, ActivityWaypointTemplateWhereInput> | null
    events?: ContactTimelineEventListRelationFilter
    tenet?: XOR<TenetScalarRelationFilter, TenetWhereInput>
    Note?: NoteListRelationFilter
  }, "id">

  export type ActivityWaypointOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    summary?: SortOrderInput | SortOrder
    status?: SortOrder
    order?: SortOrder
    actualStart?: SortOrder
    dueDate?: SortOrder
    actualEnd?: SortOrderInput | SortOrder
    activityId?: SortOrder
    templateId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenetId?: SortOrder
    _count?: ActivityWaypointCountOrderByAggregateInput
    _avg?: ActivityWaypointAvgOrderByAggregateInput
    _max?: ActivityWaypointMaxOrderByAggregateInput
    _min?: ActivityWaypointMinOrderByAggregateInput
    _sum?: ActivityWaypointSumOrderByAggregateInput
  }

  export type ActivityWaypointScalarWhereWithAggregatesInput = {
    AND?: ActivityWaypointScalarWhereWithAggregatesInput | ActivityWaypointScalarWhereWithAggregatesInput[]
    OR?: ActivityWaypointScalarWhereWithAggregatesInput[]
    NOT?: ActivityWaypointScalarWhereWithAggregatesInput | ActivityWaypointScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"ActivityWaypoint"> | Uint8Array
    title?: StringWithAggregatesFilter<"ActivityWaypoint"> | string
    description?: StringNullableWithAggregatesFilter<"ActivityWaypoint"> | string | null
    summary?: StringNullableWithAggregatesFilter<"ActivityWaypoint"> | string | null
    status?: EnumActivityStatusWithAggregatesFilter<"ActivityWaypoint"> | $Enums.ActivityStatus
    order?: IntWithAggregatesFilter<"ActivityWaypoint"> | number
    actualStart?: DateTimeWithAggregatesFilter<"ActivityWaypoint"> | Date | string
    dueDate?: DateTimeWithAggregatesFilter<"ActivityWaypoint"> | Date | string
    actualEnd?: DateTimeNullableWithAggregatesFilter<"ActivityWaypoint"> | Date | string | null
    activityId?: BytesWithAggregatesFilter<"ActivityWaypoint"> | Uint8Array
    templateId?: BytesNullableWithAggregatesFilter<"ActivityWaypoint"> | Uint8Array | null
    createdAt?: DateTimeWithAggregatesFilter<"ActivityWaypoint"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ActivityWaypoint"> | Date | string
    tenetId?: BytesWithAggregatesFilter<"ActivityWaypoint"> | Uint8Array
  }

  export type TemplateAssignmentWhereInput = {
    AND?: TemplateAssignmentWhereInput | TemplateAssignmentWhereInput[]
    OR?: TemplateAssignmentWhereInput[]
    NOT?: TemplateAssignmentWhereInput | TemplateAssignmentWhereInput[]
    id?: BytesFilter<"TemplateAssignment"> | Uint8Array
    specificUserId?: BytesNullableFilter<"TemplateAssignment"> | Uint8Array | null
    specificRole?: EnumRoleNullableFilter<"TemplateAssignment"> | $Enums.Role | null
    activityTemplateId?: BytesNullableFilter<"TemplateAssignment"> | Uint8Array | null
    waypointTemplateId?: BytesNullableFilter<"TemplateAssignment"> | Uint8Array | null
    createdAt?: DateTimeFilter<"TemplateAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"TemplateAssignment"> | Date | string
    tenetId?: BytesFilter<"TemplateAssignment"> | Uint8Array
    specificUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    activityTemplate?: XOR<ActivityTemplateNullableScalarRelationFilter, ActivityTemplateWhereInput> | null
    waypointTemplate?: XOR<ActivityWaypointTemplateNullableScalarRelationFilter, ActivityWaypointTemplateWhereInput> | null
    tenet?: XOR<TenetScalarRelationFilter, TenetWhereInput>
  }

  export type TemplateAssignmentOrderByWithRelationInput = {
    id?: SortOrder
    specificUserId?: SortOrderInput | SortOrder
    specificRole?: SortOrderInput | SortOrder
    activityTemplateId?: SortOrderInput | SortOrder
    waypointTemplateId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenetId?: SortOrder
    specificUser?: UserOrderByWithRelationInput
    activityTemplate?: ActivityTemplateOrderByWithRelationInput
    waypointTemplate?: ActivityWaypointTemplateOrderByWithRelationInput
    tenet?: TenetOrderByWithRelationInput
  }

  export type TemplateAssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    AND?: TemplateAssignmentWhereInput | TemplateAssignmentWhereInput[]
    OR?: TemplateAssignmentWhereInput[]
    NOT?: TemplateAssignmentWhereInput | TemplateAssignmentWhereInput[]
    specificUserId?: BytesNullableFilter<"TemplateAssignment"> | Uint8Array | null
    specificRole?: EnumRoleNullableFilter<"TemplateAssignment"> | $Enums.Role | null
    activityTemplateId?: BytesNullableFilter<"TemplateAssignment"> | Uint8Array | null
    waypointTemplateId?: BytesNullableFilter<"TemplateAssignment"> | Uint8Array | null
    createdAt?: DateTimeFilter<"TemplateAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"TemplateAssignment"> | Date | string
    tenetId?: BytesFilter<"TemplateAssignment"> | Uint8Array
    specificUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    activityTemplate?: XOR<ActivityTemplateNullableScalarRelationFilter, ActivityTemplateWhereInput> | null
    waypointTemplate?: XOR<ActivityWaypointTemplateNullableScalarRelationFilter, ActivityWaypointTemplateWhereInput> | null
    tenet?: XOR<TenetScalarRelationFilter, TenetWhereInput>
  }, "id">

  export type TemplateAssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    specificUserId?: SortOrderInput | SortOrder
    specificRole?: SortOrderInput | SortOrder
    activityTemplateId?: SortOrderInput | SortOrder
    waypointTemplateId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenetId?: SortOrder
    _count?: TemplateAssignmentCountOrderByAggregateInput
    _max?: TemplateAssignmentMaxOrderByAggregateInput
    _min?: TemplateAssignmentMinOrderByAggregateInput
  }

  export type TemplateAssignmentScalarWhereWithAggregatesInput = {
    AND?: TemplateAssignmentScalarWhereWithAggregatesInput | TemplateAssignmentScalarWhereWithAggregatesInput[]
    OR?: TemplateAssignmentScalarWhereWithAggregatesInput[]
    NOT?: TemplateAssignmentScalarWhereWithAggregatesInput | TemplateAssignmentScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"TemplateAssignment"> | Uint8Array
    specificUserId?: BytesNullableWithAggregatesFilter<"TemplateAssignment"> | Uint8Array | null
    specificRole?: EnumRoleNullableWithAggregatesFilter<"TemplateAssignment"> | $Enums.Role | null
    activityTemplateId?: BytesNullableWithAggregatesFilter<"TemplateAssignment"> | Uint8Array | null
    waypointTemplateId?: BytesNullableWithAggregatesFilter<"TemplateAssignment"> | Uint8Array | null
    createdAt?: DateTimeWithAggregatesFilter<"TemplateAssignment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TemplateAssignment"> | Date | string
    tenetId?: BytesWithAggregatesFilter<"TemplateAssignment"> | Uint8Array
  }

  export type ActivityWaypointTemplateWhereInput = {
    AND?: ActivityWaypointTemplateWhereInput | ActivityWaypointTemplateWhereInput[]
    OR?: ActivityWaypointTemplateWhereInput[]
    NOT?: ActivityWaypointTemplateWhereInput | ActivityWaypointTemplateWhereInput[]
    id?: BytesFilter<"ActivityWaypointTemplate"> | Uint8Array
    title?: StringFilter<"ActivityWaypointTemplate"> | string
    description?: StringNullableFilter<"ActivityWaypointTemplate"> | string | null
    defaultStatus?: EnumActivityStatusFilter<"ActivityWaypointTemplate"> | $Enums.ActivityStatus
    order?: IntFilter<"ActivityWaypointTemplate"> | number
    dateOffsetType?: EnumDateOffsetTypeFilter<"ActivityWaypointTemplate"> | $Enums.DateOffsetType
    dueDate?: IntFilter<"ActivityWaypointTemplate"> | number
    parentActivityId?: BytesFilter<"ActivityWaypointTemplate"> | Uint8Array
    createdAt?: DateTimeFilter<"ActivityWaypointTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"ActivityWaypointTemplate"> | Date | string
    tenetId?: BytesFilter<"ActivityWaypointTemplate"> | Uint8Array
    parentActivity?: XOR<ActivityTemplateScalarRelationFilter, ActivityTemplateWhereInput>
    activities?: ActivityTemplateListRelationFilter
    waypoints?: ActivityWaypointListRelationFilter
    assignments?: TemplateAssignmentListRelationFilter
    tenet?: XOR<TenetScalarRelationFilter, TenetWhereInput>
  }

  export type ActivityWaypointTemplateOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    defaultStatus?: SortOrder
    order?: SortOrder
    dateOffsetType?: SortOrder
    dueDate?: SortOrder
    parentActivityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenetId?: SortOrder
    parentActivity?: ActivityTemplateOrderByWithRelationInput
    activities?: ActivityTemplateOrderByRelationAggregateInput
    waypoints?: ActivityWaypointOrderByRelationAggregateInput
    assignments?: TemplateAssignmentOrderByRelationAggregateInput
    tenet?: TenetOrderByWithRelationInput
  }

  export type ActivityWaypointTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    AND?: ActivityWaypointTemplateWhereInput | ActivityWaypointTemplateWhereInput[]
    OR?: ActivityWaypointTemplateWhereInput[]
    NOT?: ActivityWaypointTemplateWhereInput | ActivityWaypointTemplateWhereInput[]
    title?: StringFilter<"ActivityWaypointTemplate"> | string
    description?: StringNullableFilter<"ActivityWaypointTemplate"> | string | null
    defaultStatus?: EnumActivityStatusFilter<"ActivityWaypointTemplate"> | $Enums.ActivityStatus
    order?: IntFilter<"ActivityWaypointTemplate"> | number
    dateOffsetType?: EnumDateOffsetTypeFilter<"ActivityWaypointTemplate"> | $Enums.DateOffsetType
    dueDate?: IntFilter<"ActivityWaypointTemplate"> | number
    parentActivityId?: BytesFilter<"ActivityWaypointTemplate"> | Uint8Array
    createdAt?: DateTimeFilter<"ActivityWaypointTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"ActivityWaypointTemplate"> | Date | string
    tenetId?: BytesFilter<"ActivityWaypointTemplate"> | Uint8Array
    parentActivity?: XOR<ActivityTemplateScalarRelationFilter, ActivityTemplateWhereInput>
    activities?: ActivityTemplateListRelationFilter
    waypoints?: ActivityWaypointListRelationFilter
    assignments?: TemplateAssignmentListRelationFilter
    tenet?: XOR<TenetScalarRelationFilter, TenetWhereInput>
  }, "id">

  export type ActivityWaypointTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    defaultStatus?: SortOrder
    order?: SortOrder
    dateOffsetType?: SortOrder
    dueDate?: SortOrder
    parentActivityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenetId?: SortOrder
    _count?: ActivityWaypointTemplateCountOrderByAggregateInput
    _avg?: ActivityWaypointTemplateAvgOrderByAggregateInput
    _max?: ActivityWaypointTemplateMaxOrderByAggregateInput
    _min?: ActivityWaypointTemplateMinOrderByAggregateInput
    _sum?: ActivityWaypointTemplateSumOrderByAggregateInput
  }

  export type ActivityWaypointTemplateScalarWhereWithAggregatesInput = {
    AND?: ActivityWaypointTemplateScalarWhereWithAggregatesInput | ActivityWaypointTemplateScalarWhereWithAggregatesInput[]
    OR?: ActivityWaypointTemplateScalarWhereWithAggregatesInput[]
    NOT?: ActivityWaypointTemplateScalarWhereWithAggregatesInput | ActivityWaypointTemplateScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"ActivityWaypointTemplate"> | Uint8Array
    title?: StringWithAggregatesFilter<"ActivityWaypointTemplate"> | string
    description?: StringNullableWithAggregatesFilter<"ActivityWaypointTemplate"> | string | null
    defaultStatus?: EnumActivityStatusWithAggregatesFilter<"ActivityWaypointTemplate"> | $Enums.ActivityStatus
    order?: IntWithAggregatesFilter<"ActivityWaypointTemplate"> | number
    dateOffsetType?: EnumDateOffsetTypeWithAggregatesFilter<"ActivityWaypointTemplate"> | $Enums.DateOffsetType
    dueDate?: IntWithAggregatesFilter<"ActivityWaypointTemplate"> | number
    parentActivityId?: BytesWithAggregatesFilter<"ActivityWaypointTemplate"> | Uint8Array
    createdAt?: DateTimeWithAggregatesFilter<"ActivityWaypointTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ActivityWaypointTemplate"> | Date | string
    tenetId?: BytesWithAggregatesFilter<"ActivityWaypointTemplate"> | Uint8Array
  }

  export type ActivityTemplateStepWhereInput = {
    AND?: ActivityTemplateStepWhereInput | ActivityTemplateStepWhereInput[]
    OR?: ActivityTemplateStepWhereInput[]
    NOT?: ActivityTemplateStepWhereInput | ActivityTemplateStepWhereInput[]
    id?: BytesFilter<"ActivityTemplateStep"> | Uint8Array
    order?: IntFilter<"ActivityTemplateStep"> | number
    title?: StringFilter<"ActivityTemplateStep"> | string
    type?: EnumActivityStepTypeFilter<"ActivityTemplateStep"> | $Enums.ActivityStepType
    activityTemplateId?: BytesFilter<"ActivityTemplateStep"> | Uint8Array
    tenetId?: BytesFilter<"ActivityTemplateStep"> | Uint8Array
    activityTemplate?: XOR<ActivityTemplateScalarRelationFilter, ActivityTemplateWhereInput>
    tenet?: XOR<TenetScalarRelationFilter, TenetWhereInput>
    assignedTo?: ActivityTemplateStepAssignmentListRelationFilter
  }

  export type ActivityTemplateStepOrderByWithRelationInput = {
    id?: SortOrder
    order?: SortOrder
    title?: SortOrder
    type?: SortOrder
    activityTemplateId?: SortOrder
    tenetId?: SortOrder
    activityTemplate?: ActivityTemplateOrderByWithRelationInput
    tenet?: TenetOrderByWithRelationInput
    assignedTo?: ActivityTemplateStepAssignmentOrderByRelationAggregateInput
  }

  export type ActivityTemplateStepWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    AND?: ActivityTemplateStepWhereInput | ActivityTemplateStepWhereInput[]
    OR?: ActivityTemplateStepWhereInput[]
    NOT?: ActivityTemplateStepWhereInput | ActivityTemplateStepWhereInput[]
    order?: IntFilter<"ActivityTemplateStep"> | number
    title?: StringFilter<"ActivityTemplateStep"> | string
    type?: EnumActivityStepTypeFilter<"ActivityTemplateStep"> | $Enums.ActivityStepType
    activityTemplateId?: BytesFilter<"ActivityTemplateStep"> | Uint8Array
    tenetId?: BytesFilter<"ActivityTemplateStep"> | Uint8Array
    activityTemplate?: XOR<ActivityTemplateScalarRelationFilter, ActivityTemplateWhereInput>
    tenet?: XOR<TenetScalarRelationFilter, TenetWhereInput>
    assignedTo?: ActivityTemplateStepAssignmentListRelationFilter
  }, "id">

  export type ActivityTemplateStepOrderByWithAggregationInput = {
    id?: SortOrder
    order?: SortOrder
    title?: SortOrder
    type?: SortOrder
    activityTemplateId?: SortOrder
    tenetId?: SortOrder
    _count?: ActivityTemplateStepCountOrderByAggregateInput
    _avg?: ActivityTemplateStepAvgOrderByAggregateInput
    _max?: ActivityTemplateStepMaxOrderByAggregateInput
    _min?: ActivityTemplateStepMinOrderByAggregateInput
    _sum?: ActivityTemplateStepSumOrderByAggregateInput
  }

  export type ActivityTemplateStepScalarWhereWithAggregatesInput = {
    AND?: ActivityTemplateStepScalarWhereWithAggregatesInput | ActivityTemplateStepScalarWhereWithAggregatesInput[]
    OR?: ActivityTemplateStepScalarWhereWithAggregatesInput[]
    NOT?: ActivityTemplateStepScalarWhereWithAggregatesInput | ActivityTemplateStepScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"ActivityTemplateStep"> | Uint8Array
    order?: IntWithAggregatesFilter<"ActivityTemplateStep"> | number
    title?: StringWithAggregatesFilter<"ActivityTemplateStep"> | string
    type?: EnumActivityStepTypeWithAggregatesFilter<"ActivityTemplateStep"> | $Enums.ActivityStepType
    activityTemplateId?: BytesWithAggregatesFilter<"ActivityTemplateStep"> | Uint8Array
    tenetId?: BytesWithAggregatesFilter<"ActivityTemplateStep"> | Uint8Array
  }

  export type ActivityTemplateStepAssignmentWhereInput = {
    AND?: ActivityTemplateStepAssignmentWhereInput | ActivityTemplateStepAssignmentWhereInput[]
    OR?: ActivityTemplateStepAssignmentWhereInput[]
    NOT?: ActivityTemplateStepAssignmentWhereInput | ActivityTemplateStepAssignmentWhereInput[]
    id?: BytesFilter<"ActivityTemplateStepAssignment"> | Uint8Array
    specificUserId?: BytesNullableFilter<"ActivityTemplateStepAssignment"> | Uint8Array | null
    specificRole?: EnumRoleNullableFilter<"ActivityTemplateStepAssignment"> | $Enums.Role | null
    activityTemplateStepId?: BytesFilter<"ActivityTemplateStepAssignment"> | Uint8Array
    tenetId?: BytesFilter<"ActivityTemplateStepAssignment"> | Uint8Array
    specificUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    activityTemplateStep?: XOR<ActivityTemplateStepScalarRelationFilter, ActivityTemplateStepWhereInput>
    tenet?: XOR<TenetScalarRelationFilter, TenetWhereInput>
  }

  export type ActivityTemplateStepAssignmentOrderByWithRelationInput = {
    id?: SortOrder
    specificUserId?: SortOrderInput | SortOrder
    specificRole?: SortOrderInput | SortOrder
    activityTemplateStepId?: SortOrder
    tenetId?: SortOrder
    specificUser?: UserOrderByWithRelationInput
    activityTemplateStep?: ActivityTemplateStepOrderByWithRelationInput
    tenet?: TenetOrderByWithRelationInput
  }

  export type ActivityTemplateStepAssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    AND?: ActivityTemplateStepAssignmentWhereInput | ActivityTemplateStepAssignmentWhereInput[]
    OR?: ActivityTemplateStepAssignmentWhereInput[]
    NOT?: ActivityTemplateStepAssignmentWhereInput | ActivityTemplateStepAssignmentWhereInput[]
    specificUserId?: BytesNullableFilter<"ActivityTemplateStepAssignment"> | Uint8Array | null
    specificRole?: EnumRoleNullableFilter<"ActivityTemplateStepAssignment"> | $Enums.Role | null
    activityTemplateStepId?: BytesFilter<"ActivityTemplateStepAssignment"> | Uint8Array
    tenetId?: BytesFilter<"ActivityTemplateStepAssignment"> | Uint8Array
    specificUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    activityTemplateStep?: XOR<ActivityTemplateStepScalarRelationFilter, ActivityTemplateStepWhereInput>
    tenet?: XOR<TenetScalarRelationFilter, TenetWhereInput>
  }, "id">

  export type ActivityTemplateStepAssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    specificUserId?: SortOrderInput | SortOrder
    specificRole?: SortOrderInput | SortOrder
    activityTemplateStepId?: SortOrder
    tenetId?: SortOrder
    _count?: ActivityTemplateStepAssignmentCountOrderByAggregateInput
    _max?: ActivityTemplateStepAssignmentMaxOrderByAggregateInput
    _min?: ActivityTemplateStepAssignmentMinOrderByAggregateInput
  }

  export type ActivityTemplateStepAssignmentScalarWhereWithAggregatesInput = {
    AND?: ActivityTemplateStepAssignmentScalarWhereWithAggregatesInput | ActivityTemplateStepAssignmentScalarWhereWithAggregatesInput[]
    OR?: ActivityTemplateStepAssignmentScalarWhereWithAggregatesInput[]
    NOT?: ActivityTemplateStepAssignmentScalarWhereWithAggregatesInput | ActivityTemplateStepAssignmentScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"ActivityTemplateStepAssignment"> | Uint8Array
    specificUserId?: BytesNullableWithAggregatesFilter<"ActivityTemplateStepAssignment"> | Uint8Array | null
    specificRole?: EnumRoleNullableWithAggregatesFilter<"ActivityTemplateStepAssignment"> | $Enums.Role | null
    activityTemplateStepId?: BytesWithAggregatesFilter<"ActivityTemplateStepAssignment"> | Uint8Array
    tenetId?: BytesWithAggregatesFilter<"ActivityTemplateStepAssignment"> | Uint8Array
  }

  export type ActivityTemplateWhereInput = {
    AND?: ActivityTemplateWhereInput | ActivityTemplateWhereInput[]
    OR?: ActivityTemplateWhereInput[]
    NOT?: ActivityTemplateWhereInput | ActivityTemplateWhereInput[]
    id?: BytesFilter<"ActivityTemplate"> | Uint8Array
    title?: StringFilter<"ActivityTemplate"> | string
    description?: StringNullableFilter<"ActivityTemplate"> | string | null
    type?: EnumActivityTypeFilter<"ActivityTemplate"> | $Enums.ActivityType
    defaultPriority?: EnumActivityPriorityFilter<"ActivityTemplate"> | $Enums.ActivityPriority
    defaultStatus?: EnumActivityStatusFilter<"ActivityTemplate"> | $Enums.ActivityStatus
    taskScheduleType?: EnumTaskScheduleTypeNullableFilter<"ActivityTemplate"> | $Enums.TaskScheduleType | null
    dateOffsetType?: EnumDateOffsetTypeFilter<"ActivityTemplate"> | $Enums.DateOffsetType
    startDate?: IntFilter<"ActivityTemplate"> | number
    endDate?: IntFilter<"ActivityTemplate"> | number
    startRelativeToId?: BytesNullableFilter<"ActivityTemplate"> | Uint8Array | null
    parentWaypointId?: BytesNullableFilter<"ActivityTemplate"> | Uint8Array | null
    parentActivityId?: BytesNullableFilter<"ActivityTemplate"> | Uint8Array | null
    createdAt?: DateTimeFilter<"ActivityTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"ActivityTemplate"> | Date | string
    tenetId?: BytesFilter<"ActivityTemplate"> | Uint8Array
    order?: IntNullableFilter<"ActivityTemplate"> | number | null
    steps?: ActivityTemplateStepListRelationFilter
    startRelativeTo?: XOR<ActivityTemplateNullableScalarRelationFilter, ActivityTemplateWhereInput> | null
    dependents?: ActivityTemplateListRelationFilter
    parentWaypoint?: XOR<ActivityWaypointTemplateNullableScalarRelationFilter, ActivityWaypointTemplateWhereInput> | null
    parentActivity?: XOR<ActivityTemplateNullableScalarRelationFilter, ActivityTemplateWhereInput> | null
    waypoints?: ActivityWaypointTemplateListRelationFilter
    childActivities?: ActivityTemplateListRelationFilter
    activities?: ActivityListRelationFilter
    assignments?: TemplateAssignmentListRelationFilter
    tenet?: XOR<TenetScalarRelationFilter, TenetWhereInput>
  }

  export type ActivityTemplateOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    defaultPriority?: SortOrder
    defaultStatus?: SortOrder
    taskScheduleType?: SortOrderInput | SortOrder
    dateOffsetType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    startRelativeToId?: SortOrderInput | SortOrder
    parentWaypointId?: SortOrderInput | SortOrder
    parentActivityId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenetId?: SortOrder
    order?: SortOrderInput | SortOrder
    steps?: ActivityTemplateStepOrderByRelationAggregateInput
    startRelativeTo?: ActivityTemplateOrderByWithRelationInput
    dependents?: ActivityTemplateOrderByRelationAggregateInput
    parentWaypoint?: ActivityWaypointTemplateOrderByWithRelationInput
    parentActivity?: ActivityTemplateOrderByWithRelationInput
    waypoints?: ActivityWaypointTemplateOrderByRelationAggregateInput
    childActivities?: ActivityTemplateOrderByRelationAggregateInput
    activities?: ActivityOrderByRelationAggregateInput
    assignments?: TemplateAssignmentOrderByRelationAggregateInput
    tenet?: TenetOrderByWithRelationInput
  }

  export type ActivityTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    AND?: ActivityTemplateWhereInput | ActivityTemplateWhereInput[]
    OR?: ActivityTemplateWhereInput[]
    NOT?: ActivityTemplateWhereInput | ActivityTemplateWhereInput[]
    title?: StringFilter<"ActivityTemplate"> | string
    description?: StringNullableFilter<"ActivityTemplate"> | string | null
    type?: EnumActivityTypeFilter<"ActivityTemplate"> | $Enums.ActivityType
    defaultPriority?: EnumActivityPriorityFilter<"ActivityTemplate"> | $Enums.ActivityPriority
    defaultStatus?: EnumActivityStatusFilter<"ActivityTemplate"> | $Enums.ActivityStatus
    taskScheduleType?: EnumTaskScheduleTypeNullableFilter<"ActivityTemplate"> | $Enums.TaskScheduleType | null
    dateOffsetType?: EnumDateOffsetTypeFilter<"ActivityTemplate"> | $Enums.DateOffsetType
    startDate?: IntFilter<"ActivityTemplate"> | number
    endDate?: IntFilter<"ActivityTemplate"> | number
    startRelativeToId?: BytesNullableFilter<"ActivityTemplate"> | Uint8Array | null
    parentWaypointId?: BytesNullableFilter<"ActivityTemplate"> | Uint8Array | null
    parentActivityId?: BytesNullableFilter<"ActivityTemplate"> | Uint8Array | null
    createdAt?: DateTimeFilter<"ActivityTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"ActivityTemplate"> | Date | string
    tenetId?: BytesFilter<"ActivityTemplate"> | Uint8Array
    order?: IntNullableFilter<"ActivityTemplate"> | number | null
    steps?: ActivityTemplateStepListRelationFilter
    startRelativeTo?: XOR<ActivityTemplateNullableScalarRelationFilter, ActivityTemplateWhereInput> | null
    dependents?: ActivityTemplateListRelationFilter
    parentWaypoint?: XOR<ActivityWaypointTemplateNullableScalarRelationFilter, ActivityWaypointTemplateWhereInput> | null
    parentActivity?: XOR<ActivityTemplateNullableScalarRelationFilter, ActivityTemplateWhereInput> | null
    waypoints?: ActivityWaypointTemplateListRelationFilter
    childActivities?: ActivityTemplateListRelationFilter
    activities?: ActivityListRelationFilter
    assignments?: TemplateAssignmentListRelationFilter
    tenet?: XOR<TenetScalarRelationFilter, TenetWhereInput>
  }, "id">

  export type ActivityTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    defaultPriority?: SortOrder
    defaultStatus?: SortOrder
    taskScheduleType?: SortOrderInput | SortOrder
    dateOffsetType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    startRelativeToId?: SortOrderInput | SortOrder
    parentWaypointId?: SortOrderInput | SortOrder
    parentActivityId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenetId?: SortOrder
    order?: SortOrderInput | SortOrder
    _count?: ActivityTemplateCountOrderByAggregateInput
    _avg?: ActivityTemplateAvgOrderByAggregateInput
    _max?: ActivityTemplateMaxOrderByAggregateInput
    _min?: ActivityTemplateMinOrderByAggregateInput
    _sum?: ActivityTemplateSumOrderByAggregateInput
  }

  export type ActivityTemplateScalarWhereWithAggregatesInput = {
    AND?: ActivityTemplateScalarWhereWithAggregatesInput | ActivityTemplateScalarWhereWithAggregatesInput[]
    OR?: ActivityTemplateScalarWhereWithAggregatesInput[]
    NOT?: ActivityTemplateScalarWhereWithAggregatesInput | ActivityTemplateScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"ActivityTemplate"> | Uint8Array
    title?: StringWithAggregatesFilter<"ActivityTemplate"> | string
    description?: StringNullableWithAggregatesFilter<"ActivityTemplate"> | string | null
    type?: EnumActivityTypeWithAggregatesFilter<"ActivityTemplate"> | $Enums.ActivityType
    defaultPriority?: EnumActivityPriorityWithAggregatesFilter<"ActivityTemplate"> | $Enums.ActivityPriority
    defaultStatus?: EnumActivityStatusWithAggregatesFilter<"ActivityTemplate"> | $Enums.ActivityStatus
    taskScheduleType?: EnumTaskScheduleTypeNullableWithAggregatesFilter<"ActivityTemplate"> | $Enums.TaskScheduleType | null
    dateOffsetType?: EnumDateOffsetTypeWithAggregatesFilter<"ActivityTemplate"> | $Enums.DateOffsetType
    startDate?: IntWithAggregatesFilter<"ActivityTemplate"> | number
    endDate?: IntWithAggregatesFilter<"ActivityTemplate"> | number
    startRelativeToId?: BytesNullableWithAggregatesFilter<"ActivityTemplate"> | Uint8Array | null
    parentWaypointId?: BytesNullableWithAggregatesFilter<"ActivityTemplate"> | Uint8Array | null
    parentActivityId?: BytesNullableWithAggregatesFilter<"ActivityTemplate"> | Uint8Array | null
    createdAt?: DateTimeWithAggregatesFilter<"ActivityTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ActivityTemplate"> | Date | string
    tenetId?: BytesWithAggregatesFilter<"ActivityTemplate"> | Uint8Array
    order?: IntNullableWithAggregatesFilter<"ActivityTemplate"> | number | null
  }

  export type ActivityWhereInput = {
    AND?: ActivityWhereInput | ActivityWhereInput[]
    OR?: ActivityWhereInput[]
    NOT?: ActivityWhereInput | ActivityWhereInput[]
    id?: BytesFilter<"Activity"> | Uint8Array
    title?: StringFilter<"Activity"> | string
    type?: EnumActivityTypeFilter<"Activity"> | $Enums.ActivityType
    parentActivityId?: BytesNullableFilter<"Activity"> | Uint8Array | null
    parentWaypointId?: BytesNullableFilter<"Activity"> | Uint8Array | null
    templateId?: BytesNullableFilter<"Activity"> | Uint8Array | null
    taskScheduleType?: EnumTaskScheduleTypeNullableFilter<"Activity"> | $Enums.TaskScheduleType | null
    startDate?: DateTimeFilter<"Activity"> | Date | string
    endDate?: DateTimeFilter<"Activity"> | Date | string
    completedAt?: DateTimeNullableFilter<"Activity"> | Date | string | null
    description?: StringNullableFilter<"Activity"> | string | null
    priority?: EnumActivityPriorityFilter<"Activity"> | $Enums.ActivityPriority
    status?: EnumActivityStatusFilter<"Activity"> | $Enums.ActivityStatus
    assignedById?: BytesFilter<"Activity"> | Uint8Array
    phoneNumber?: StringNullableFilter<"Activity"> | string | null
    location?: StringNullableFilter<"Activity"> | string | null
    holdReason?: StringNullableFilter<"Activity"> | string | null
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    updatedAt?: DateTimeFilter<"Activity"> | Date | string
    tenetId?: BytesFilter<"Activity"> | Uint8Array
    deleted?: BoolFilter<"Activity"> | boolean
    deletedAt?: DateTimeNullableFilter<"Activity"> | Date | string | null
    order?: IntNullableFilter<"Activity"> | number | null
    opportunityId?: BytesNullableFilter<"Activity"> | Uint8Array | null
    steps?: ActivityStepListRelationFilter
    waypoints?: ActivityWaypointListRelationFilter
    activities?: ActivityListRelationFilter
    parentActivity?: XOR<ActivityNullableScalarRelationFilter, ActivityWhereInput> | null
    parentWaypoint?: XOR<ActivityWaypointNullableScalarRelationFilter, ActivityWaypointWhereInput> | null
    template?: XOR<ActivityTemplateNullableScalarRelationFilter, ActivityTemplateWhereInput> | null
    assignedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    contacts?: ActivityContactJoinListRelationFilter
    users?: ActivityUserJoinListRelationFilter
    tenet?: XOR<TenetScalarRelationFilter, TenetWhereInput>
    attachments?: AttachmentListRelationFilter
    notes?: NoteListRelationFilter
    events?: ContactTimelineEventListRelationFilter
    opportunity?: XOR<OpportunityNullableScalarRelationFilter, OpportunityWhereInput> | null
  }

  export type ActivityOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    parentActivityId?: SortOrderInput | SortOrder
    parentWaypointId?: SortOrderInput | SortOrder
    templateId?: SortOrderInput | SortOrder
    taskScheduleType?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    priority?: SortOrder
    status?: SortOrder
    assignedById?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    holdReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenetId?: SortOrder
    deleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    order?: SortOrderInput | SortOrder
    opportunityId?: SortOrderInput | SortOrder
    steps?: ActivityStepOrderByRelationAggregateInput
    waypoints?: ActivityWaypointOrderByRelationAggregateInput
    activities?: ActivityOrderByRelationAggregateInput
    parentActivity?: ActivityOrderByWithRelationInput
    parentWaypoint?: ActivityWaypointOrderByWithRelationInput
    template?: ActivityTemplateOrderByWithRelationInput
    assignedBy?: UserOrderByWithRelationInput
    contacts?: ActivityContactJoinOrderByRelationAggregateInput
    users?: ActivityUserJoinOrderByRelationAggregateInput
    tenet?: TenetOrderByWithRelationInput
    attachments?: AttachmentOrderByRelationAggregateInput
    notes?: NoteOrderByRelationAggregateInput
    events?: ContactTimelineEventOrderByRelationAggregateInput
    opportunity?: OpportunityOrderByWithRelationInput
  }

  export type ActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    AND?: ActivityWhereInput | ActivityWhereInput[]
    OR?: ActivityWhereInput[]
    NOT?: ActivityWhereInput | ActivityWhereInput[]
    title?: StringFilter<"Activity"> | string
    type?: EnumActivityTypeFilter<"Activity"> | $Enums.ActivityType
    parentActivityId?: BytesNullableFilter<"Activity"> | Uint8Array | null
    parentWaypointId?: BytesNullableFilter<"Activity"> | Uint8Array | null
    templateId?: BytesNullableFilter<"Activity"> | Uint8Array | null
    taskScheduleType?: EnumTaskScheduleTypeNullableFilter<"Activity"> | $Enums.TaskScheduleType | null
    startDate?: DateTimeFilter<"Activity"> | Date | string
    endDate?: DateTimeFilter<"Activity"> | Date | string
    completedAt?: DateTimeNullableFilter<"Activity"> | Date | string | null
    description?: StringNullableFilter<"Activity"> | string | null
    priority?: EnumActivityPriorityFilter<"Activity"> | $Enums.ActivityPriority
    status?: EnumActivityStatusFilter<"Activity"> | $Enums.ActivityStatus
    assignedById?: BytesFilter<"Activity"> | Uint8Array
    phoneNumber?: StringNullableFilter<"Activity"> | string | null
    location?: StringNullableFilter<"Activity"> | string | null
    holdReason?: StringNullableFilter<"Activity"> | string | null
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    updatedAt?: DateTimeFilter<"Activity"> | Date | string
    tenetId?: BytesFilter<"Activity"> | Uint8Array
    deleted?: BoolFilter<"Activity"> | boolean
    deletedAt?: DateTimeNullableFilter<"Activity"> | Date | string | null
    order?: IntNullableFilter<"Activity"> | number | null
    opportunityId?: BytesNullableFilter<"Activity"> | Uint8Array | null
    steps?: ActivityStepListRelationFilter
    waypoints?: ActivityWaypointListRelationFilter
    activities?: ActivityListRelationFilter
    parentActivity?: XOR<ActivityNullableScalarRelationFilter, ActivityWhereInput> | null
    parentWaypoint?: XOR<ActivityWaypointNullableScalarRelationFilter, ActivityWaypointWhereInput> | null
    template?: XOR<ActivityTemplateNullableScalarRelationFilter, ActivityTemplateWhereInput> | null
    assignedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    contacts?: ActivityContactJoinListRelationFilter
    users?: ActivityUserJoinListRelationFilter
    tenet?: XOR<TenetScalarRelationFilter, TenetWhereInput>
    attachments?: AttachmentListRelationFilter
    notes?: NoteListRelationFilter
    events?: ContactTimelineEventListRelationFilter
    opportunity?: XOR<OpportunityNullableScalarRelationFilter, OpportunityWhereInput> | null
  }, "id">

  export type ActivityOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    parentActivityId?: SortOrderInput | SortOrder
    parentWaypointId?: SortOrderInput | SortOrder
    templateId?: SortOrderInput | SortOrder
    taskScheduleType?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    priority?: SortOrder
    status?: SortOrder
    assignedById?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    holdReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenetId?: SortOrder
    deleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    order?: SortOrderInput | SortOrder
    opportunityId?: SortOrderInput | SortOrder
    _count?: ActivityCountOrderByAggregateInput
    _avg?: ActivityAvgOrderByAggregateInput
    _max?: ActivityMaxOrderByAggregateInput
    _min?: ActivityMinOrderByAggregateInput
    _sum?: ActivitySumOrderByAggregateInput
  }

  export type ActivityScalarWhereWithAggregatesInput = {
    AND?: ActivityScalarWhereWithAggregatesInput | ActivityScalarWhereWithAggregatesInput[]
    OR?: ActivityScalarWhereWithAggregatesInput[]
    NOT?: ActivityScalarWhereWithAggregatesInput | ActivityScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"Activity"> | Uint8Array
    title?: StringWithAggregatesFilter<"Activity"> | string
    type?: EnumActivityTypeWithAggregatesFilter<"Activity"> | $Enums.ActivityType
    parentActivityId?: BytesNullableWithAggregatesFilter<"Activity"> | Uint8Array | null
    parentWaypointId?: BytesNullableWithAggregatesFilter<"Activity"> | Uint8Array | null
    templateId?: BytesNullableWithAggregatesFilter<"Activity"> | Uint8Array | null
    taskScheduleType?: EnumTaskScheduleTypeNullableWithAggregatesFilter<"Activity"> | $Enums.TaskScheduleType | null
    startDate?: DateTimeWithAggregatesFilter<"Activity"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Activity"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"Activity"> | Date | string | null
    description?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    priority?: EnumActivityPriorityWithAggregatesFilter<"Activity"> | $Enums.ActivityPriority
    status?: EnumActivityStatusWithAggregatesFilter<"Activity"> | $Enums.ActivityStatus
    assignedById?: BytesWithAggregatesFilter<"Activity"> | Uint8Array
    phoneNumber?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    location?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    holdReason?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Activity"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Activity"> | Date | string
    tenetId?: BytesWithAggregatesFilter<"Activity"> | Uint8Array
    deleted?: BoolWithAggregatesFilter<"Activity"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Activity"> | Date | string | null
    order?: IntNullableWithAggregatesFilter<"Activity"> | number | null
    opportunityId?: BytesNullableWithAggregatesFilter<"Activity"> | Uint8Array | null
  }

  export type ContactTimelineEventWhereInput = {
    AND?: ContactTimelineEventWhereInput | ContactTimelineEventWhereInput[]
    OR?: ContactTimelineEventWhereInput[]
    NOT?: ContactTimelineEventWhereInput | ContactTimelineEventWhereInput[]
    id?: BytesFilter<"ContactTimelineEvent"> | Uint8Array
    activityId?: BytesNullableFilter<"ContactTimelineEvent"> | Uint8Array | null
    waypointId?: BytesNullableFilter<"ContactTimelineEvent"> | Uint8Array | null
    opportunityId?: BytesNullableFilter<"ContactTimelineEvent"> | Uint8Array | null
    noteId?: BytesNullableFilter<"ContactTimelineEvent"> | Uint8Array | null
    extraInfo?: StringNullableFilter<"ContactTimelineEvent"> | string | null
    userId?: BytesFilter<"ContactTimelineEvent"> | Uint8Array
    tenetId?: BytesFilter<"ContactTimelineEvent"> | Uint8Array
    eventType?: EnumContactTimelineEventTypeFilter<"ContactTimelineEvent"> | $Enums.ContactTimelineEventType
    relationshipType?: StringNullableFilter<"ContactTimelineEvent"> | string | null
    createdAt?: DateTimeFilter<"ContactTimelineEvent"> | Date | string
    updatedAt?: DateTimeFilter<"ContactTimelineEvent"> | Date | string
    activity?: XOR<ActivityNullableScalarRelationFilter, ActivityWhereInput> | null
    waypoint?: XOR<ActivityWaypointNullableScalarRelationFilter, ActivityWaypointWhereInput> | null
    opportunity?: XOR<OpportunityNullableScalarRelationFilter, OpportunityWhereInput> | null
    note?: XOR<NoteNullableScalarRelationFilter, NoteWhereInput> | null
    contacts?: ContactTimelineEventContactJoinListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    tenet?: XOR<TenetScalarRelationFilter, TenetWhereInput>
  }

  export type ContactTimelineEventOrderByWithRelationInput = {
    id?: SortOrder
    activityId?: SortOrderInput | SortOrder
    waypointId?: SortOrderInput | SortOrder
    opportunityId?: SortOrderInput | SortOrder
    noteId?: SortOrderInput | SortOrder
    extraInfo?: SortOrderInput | SortOrder
    userId?: SortOrder
    tenetId?: SortOrder
    eventType?: SortOrder
    relationshipType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    activity?: ActivityOrderByWithRelationInput
    waypoint?: ActivityWaypointOrderByWithRelationInput
    opportunity?: OpportunityOrderByWithRelationInput
    note?: NoteOrderByWithRelationInput
    contacts?: ContactTimelineEventContactJoinOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
    tenet?: TenetOrderByWithRelationInput
  }

  export type ContactTimelineEventWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    AND?: ContactTimelineEventWhereInput | ContactTimelineEventWhereInput[]
    OR?: ContactTimelineEventWhereInput[]
    NOT?: ContactTimelineEventWhereInput | ContactTimelineEventWhereInput[]
    activityId?: BytesNullableFilter<"ContactTimelineEvent"> | Uint8Array | null
    waypointId?: BytesNullableFilter<"ContactTimelineEvent"> | Uint8Array | null
    opportunityId?: BytesNullableFilter<"ContactTimelineEvent"> | Uint8Array | null
    noteId?: BytesNullableFilter<"ContactTimelineEvent"> | Uint8Array | null
    extraInfo?: StringNullableFilter<"ContactTimelineEvent"> | string | null
    userId?: BytesFilter<"ContactTimelineEvent"> | Uint8Array
    tenetId?: BytesFilter<"ContactTimelineEvent"> | Uint8Array
    eventType?: EnumContactTimelineEventTypeFilter<"ContactTimelineEvent"> | $Enums.ContactTimelineEventType
    relationshipType?: StringNullableFilter<"ContactTimelineEvent"> | string | null
    createdAt?: DateTimeFilter<"ContactTimelineEvent"> | Date | string
    updatedAt?: DateTimeFilter<"ContactTimelineEvent"> | Date | string
    activity?: XOR<ActivityNullableScalarRelationFilter, ActivityWhereInput> | null
    waypoint?: XOR<ActivityWaypointNullableScalarRelationFilter, ActivityWaypointWhereInput> | null
    opportunity?: XOR<OpportunityNullableScalarRelationFilter, OpportunityWhereInput> | null
    note?: XOR<NoteNullableScalarRelationFilter, NoteWhereInput> | null
    contacts?: ContactTimelineEventContactJoinListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    tenet?: XOR<TenetScalarRelationFilter, TenetWhereInput>
  }, "id">

  export type ContactTimelineEventOrderByWithAggregationInput = {
    id?: SortOrder
    activityId?: SortOrderInput | SortOrder
    waypointId?: SortOrderInput | SortOrder
    opportunityId?: SortOrderInput | SortOrder
    noteId?: SortOrderInput | SortOrder
    extraInfo?: SortOrderInput | SortOrder
    userId?: SortOrder
    tenetId?: SortOrder
    eventType?: SortOrder
    relationshipType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContactTimelineEventCountOrderByAggregateInput
    _max?: ContactTimelineEventMaxOrderByAggregateInput
    _min?: ContactTimelineEventMinOrderByAggregateInput
  }

  export type ContactTimelineEventScalarWhereWithAggregatesInput = {
    AND?: ContactTimelineEventScalarWhereWithAggregatesInput | ContactTimelineEventScalarWhereWithAggregatesInput[]
    OR?: ContactTimelineEventScalarWhereWithAggregatesInput[]
    NOT?: ContactTimelineEventScalarWhereWithAggregatesInput | ContactTimelineEventScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"ContactTimelineEvent"> | Uint8Array
    activityId?: BytesNullableWithAggregatesFilter<"ContactTimelineEvent"> | Uint8Array | null
    waypointId?: BytesNullableWithAggregatesFilter<"ContactTimelineEvent"> | Uint8Array | null
    opportunityId?: BytesNullableWithAggregatesFilter<"ContactTimelineEvent"> | Uint8Array | null
    noteId?: BytesNullableWithAggregatesFilter<"ContactTimelineEvent"> | Uint8Array | null
    extraInfo?: StringNullableWithAggregatesFilter<"ContactTimelineEvent"> | string | null
    userId?: BytesWithAggregatesFilter<"ContactTimelineEvent"> | Uint8Array
    tenetId?: BytesWithAggregatesFilter<"ContactTimelineEvent"> | Uint8Array
    eventType?: EnumContactTimelineEventTypeWithAggregatesFilter<"ContactTimelineEvent"> | $Enums.ContactTimelineEventType
    relationshipType?: StringNullableWithAggregatesFilter<"ContactTimelineEvent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ContactTimelineEvent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContactTimelineEvent"> | Date | string
  }

  export type AuditEventWhereInput = {
    AND?: AuditEventWhereInput | AuditEventWhereInput[]
    OR?: AuditEventWhereInput[]
    NOT?: AuditEventWhereInput | AuditEventWhereInput[]
    id?: BytesFilter<"AuditEvent"> | Uint8Array
    userId?: BytesFilter<"AuditEvent"> | Uint8Array
    tenetId?: BytesFilter<"AuditEvent"> | Uint8Array
    type?: EnumAuditEventTypeFilter<"AuditEvent"> | $Enums.AuditEventType
    details?: StringNullableFilter<"AuditEvent"> | string | null
    referenceId?: BytesFilter<"AuditEvent"> | Uint8Array
    reference?: EnumAuditableFilter<"AuditEvent"> | $Enums.Auditable
    createdAt?: DateTimeFilter<"AuditEvent"> | Date | string
    updatedAt?: DateTimeFilter<"AuditEvent"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    tenet?: XOR<TenetScalarRelationFilter, TenetWhereInput>
  }

  export type AuditEventOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    tenetId?: SortOrder
    type?: SortOrder
    details?: SortOrderInput | SortOrder
    referenceId?: SortOrder
    reference?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    tenet?: TenetOrderByWithRelationInput
  }

  export type AuditEventWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    AND?: AuditEventWhereInput | AuditEventWhereInput[]
    OR?: AuditEventWhereInput[]
    NOT?: AuditEventWhereInput | AuditEventWhereInput[]
    userId?: BytesFilter<"AuditEvent"> | Uint8Array
    tenetId?: BytesFilter<"AuditEvent"> | Uint8Array
    type?: EnumAuditEventTypeFilter<"AuditEvent"> | $Enums.AuditEventType
    details?: StringNullableFilter<"AuditEvent"> | string | null
    referenceId?: BytesFilter<"AuditEvent"> | Uint8Array
    reference?: EnumAuditableFilter<"AuditEvent"> | $Enums.Auditable
    createdAt?: DateTimeFilter<"AuditEvent"> | Date | string
    updatedAt?: DateTimeFilter<"AuditEvent"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    tenet?: XOR<TenetScalarRelationFilter, TenetWhereInput>
  }, "id">

  export type AuditEventOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    tenetId?: SortOrder
    type?: SortOrder
    details?: SortOrderInput | SortOrder
    referenceId?: SortOrder
    reference?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AuditEventCountOrderByAggregateInput
    _max?: AuditEventMaxOrderByAggregateInput
    _min?: AuditEventMinOrderByAggregateInput
  }

  export type AuditEventScalarWhereWithAggregatesInput = {
    AND?: AuditEventScalarWhereWithAggregatesInput | AuditEventScalarWhereWithAggregatesInput[]
    OR?: AuditEventScalarWhereWithAggregatesInput[]
    NOT?: AuditEventScalarWhereWithAggregatesInput | AuditEventScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"AuditEvent"> | Uint8Array
    userId?: BytesWithAggregatesFilter<"AuditEvent"> | Uint8Array
    tenetId?: BytesWithAggregatesFilter<"AuditEvent"> | Uint8Array
    type?: EnumAuditEventTypeWithAggregatesFilter<"AuditEvent"> | $Enums.AuditEventType
    details?: StringNullableWithAggregatesFilter<"AuditEvent"> | string | null
    referenceId?: BytesWithAggregatesFilter<"AuditEvent"> | Uint8Array
    reference?: EnumAuditableWithAggregatesFilter<"AuditEvent"> | $Enums.Auditable
    createdAt?: DateTimeWithAggregatesFilter<"AuditEvent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AuditEvent"> | Date | string
  }

  export type ContactTimelineEventContactJoinWhereInput = {
    AND?: ContactTimelineEventContactJoinWhereInput | ContactTimelineEventContactJoinWhereInput[]
    OR?: ContactTimelineEventContactJoinWhereInput[]
    NOT?: ContactTimelineEventContactJoinWhereInput | ContactTimelineEventContactJoinWhereInput[]
    contactEventId?: BytesFilter<"ContactTimelineEventContactJoin"> | Uint8Array
    contactId?: BytesFilter<"ContactTimelineEventContactJoin"> | Uint8Array
    type?: EnumContactTimelineEventJoinTypeFilter<"ContactTimelineEventContactJoin"> | $Enums.ContactTimelineEventJoinType
    contactEventRelation?: XOR<ContactTimelineEventScalarRelationFilter, ContactTimelineEventWhereInput>
    contactRelation?: XOR<ContactScalarRelationFilter, ContactWhereInput>
  }

  export type ContactTimelineEventContactJoinOrderByWithRelationInput = {
    contactEventId?: SortOrder
    contactId?: SortOrder
    type?: SortOrder
    contactEventRelation?: ContactTimelineEventOrderByWithRelationInput
    contactRelation?: ContactOrderByWithRelationInput
  }

  export type ContactTimelineEventContactJoinWhereUniqueInput = Prisma.AtLeast<{
    contactEventId_contactId?: ContactTimelineEventContactJoinContactEventIdContactIdCompoundUniqueInput
    AND?: ContactTimelineEventContactJoinWhereInput | ContactTimelineEventContactJoinWhereInput[]
    OR?: ContactTimelineEventContactJoinWhereInput[]
    NOT?: ContactTimelineEventContactJoinWhereInput | ContactTimelineEventContactJoinWhereInput[]
    contactEventId?: BytesFilter<"ContactTimelineEventContactJoin"> | Uint8Array
    contactId?: BytesFilter<"ContactTimelineEventContactJoin"> | Uint8Array
    type?: EnumContactTimelineEventJoinTypeFilter<"ContactTimelineEventContactJoin"> | $Enums.ContactTimelineEventJoinType
    contactEventRelation?: XOR<ContactTimelineEventScalarRelationFilter, ContactTimelineEventWhereInput>
    contactRelation?: XOR<ContactScalarRelationFilter, ContactWhereInput>
  }, "contactEventId_contactId">

  export type ContactTimelineEventContactJoinOrderByWithAggregationInput = {
    contactEventId?: SortOrder
    contactId?: SortOrder
    type?: SortOrder
    _count?: ContactTimelineEventContactJoinCountOrderByAggregateInput
    _max?: ContactTimelineEventContactJoinMaxOrderByAggregateInput
    _min?: ContactTimelineEventContactJoinMinOrderByAggregateInput
  }

  export type ContactTimelineEventContactJoinScalarWhereWithAggregatesInput = {
    AND?: ContactTimelineEventContactJoinScalarWhereWithAggregatesInput | ContactTimelineEventContactJoinScalarWhereWithAggregatesInput[]
    OR?: ContactTimelineEventContactJoinScalarWhereWithAggregatesInput[]
    NOT?: ContactTimelineEventContactJoinScalarWhereWithAggregatesInput | ContactTimelineEventContactJoinScalarWhereWithAggregatesInput[]
    contactEventId?: BytesWithAggregatesFilter<"ContactTimelineEventContactJoin"> | Uint8Array
    contactId?: BytesWithAggregatesFilter<"ContactTimelineEventContactJoin"> | Uint8Array
    type?: EnumContactTimelineEventJoinTypeWithAggregatesFilter<"ContactTimelineEventContactJoin"> | $Enums.ContactTimelineEventJoinType
  }

  export type NoteWhereInput = {
    AND?: NoteWhereInput | NoteWhereInput[]
    OR?: NoteWhereInput[]
    NOT?: NoteWhereInput | NoteWhereInput[]
    id?: BytesFilter<"Note"> | Uint8Array
    content?: StringFilter<"Note"> | string
    waypointId?: BytesNullableFilter<"Note"> | Uint8Array | null
    activityId?: BytesNullableFilter<"Note"> | Uint8Array | null
    contactId?: BytesNullableFilter<"Note"> | Uint8Array | null
    opportunityId?: BytesNullableFilter<"Note"> | Uint8Array | null
    tenetId?: BytesFilter<"Note"> | Uint8Array
    authorId?: BytesFilter<"Note"> | Uint8Array
    createdAt?: DateTimeFilter<"Note"> | Date | string
    updatedAt?: DateTimeFilter<"Note"> | Date | string
    deleted?: BoolFilter<"Note"> | boolean
    deletedAt?: DateTimeNullableFilter<"Note"> | Date | string | null
    noteType?: EnumNoteTypeFilter<"Note"> | $Enums.NoteType
    waypoint?: XOR<ActivityWaypointNullableScalarRelationFilter, ActivityWaypointWhereInput> | null
    activity?: XOR<ActivityNullableScalarRelationFilter, ActivityWhereInput> | null
    contact?: XOR<ContactNullableScalarRelationFilter, ContactWhereInput> | null
    opportunity?: XOR<OpportunityNullableScalarRelationFilter, OpportunityWhereInput> | null
    tenet?: XOR<TenetScalarRelationFilter, TenetWhereInput>
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
    events?: ContactTimelineEventListRelationFilter
  }

  export type NoteOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    waypointId?: SortOrderInput | SortOrder
    activityId?: SortOrderInput | SortOrder
    contactId?: SortOrderInput | SortOrder
    opportunityId?: SortOrderInput | SortOrder
    tenetId?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    noteType?: SortOrder
    waypoint?: ActivityWaypointOrderByWithRelationInput
    activity?: ActivityOrderByWithRelationInput
    contact?: ContactOrderByWithRelationInput
    opportunity?: OpportunityOrderByWithRelationInput
    tenet?: TenetOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
    events?: ContactTimelineEventOrderByRelationAggregateInput
  }

  export type NoteWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    AND?: NoteWhereInput | NoteWhereInput[]
    OR?: NoteWhereInput[]
    NOT?: NoteWhereInput | NoteWhereInput[]
    content?: StringFilter<"Note"> | string
    waypointId?: BytesNullableFilter<"Note"> | Uint8Array | null
    activityId?: BytesNullableFilter<"Note"> | Uint8Array | null
    contactId?: BytesNullableFilter<"Note"> | Uint8Array | null
    opportunityId?: BytesNullableFilter<"Note"> | Uint8Array | null
    tenetId?: BytesFilter<"Note"> | Uint8Array
    authorId?: BytesFilter<"Note"> | Uint8Array
    createdAt?: DateTimeFilter<"Note"> | Date | string
    updatedAt?: DateTimeFilter<"Note"> | Date | string
    deleted?: BoolFilter<"Note"> | boolean
    deletedAt?: DateTimeNullableFilter<"Note"> | Date | string | null
    noteType?: EnumNoteTypeFilter<"Note"> | $Enums.NoteType
    waypoint?: XOR<ActivityWaypointNullableScalarRelationFilter, ActivityWaypointWhereInput> | null
    activity?: XOR<ActivityNullableScalarRelationFilter, ActivityWhereInput> | null
    contact?: XOR<ContactNullableScalarRelationFilter, ContactWhereInput> | null
    opportunity?: XOR<OpportunityNullableScalarRelationFilter, OpportunityWhereInput> | null
    tenet?: XOR<TenetScalarRelationFilter, TenetWhereInput>
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
    events?: ContactTimelineEventListRelationFilter
  }, "id">

  export type NoteOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    waypointId?: SortOrderInput | SortOrder
    activityId?: SortOrderInput | SortOrder
    contactId?: SortOrderInput | SortOrder
    opportunityId?: SortOrderInput | SortOrder
    tenetId?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    noteType?: SortOrder
    _count?: NoteCountOrderByAggregateInput
    _max?: NoteMaxOrderByAggregateInput
    _min?: NoteMinOrderByAggregateInput
  }

  export type NoteScalarWhereWithAggregatesInput = {
    AND?: NoteScalarWhereWithAggregatesInput | NoteScalarWhereWithAggregatesInput[]
    OR?: NoteScalarWhereWithAggregatesInput[]
    NOT?: NoteScalarWhereWithAggregatesInput | NoteScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"Note"> | Uint8Array
    content?: StringWithAggregatesFilter<"Note"> | string
    waypointId?: BytesNullableWithAggregatesFilter<"Note"> | Uint8Array | null
    activityId?: BytesNullableWithAggregatesFilter<"Note"> | Uint8Array | null
    contactId?: BytesNullableWithAggregatesFilter<"Note"> | Uint8Array | null
    opportunityId?: BytesNullableWithAggregatesFilter<"Note"> | Uint8Array | null
    tenetId?: BytesWithAggregatesFilter<"Note"> | Uint8Array
    authorId?: BytesWithAggregatesFilter<"Note"> | Uint8Array
    createdAt?: DateTimeWithAggregatesFilter<"Note"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Note"> | Date | string
    deleted?: BoolWithAggregatesFilter<"Note"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Note"> | Date | string | null
    noteType?: EnumNoteTypeWithAggregatesFilter<"Note"> | $Enums.NoteType
  }

  export type AttachmentWhereInput = {
    AND?: AttachmentWhereInput | AttachmentWhereInput[]
    OR?: AttachmentWhereInput[]
    NOT?: AttachmentWhereInput | AttachmentWhereInput[]
    id?: BytesFilter<"Attachment"> | Uint8Array
    name?: StringFilter<"Attachment"> | string
    location?: StringFilter<"Attachment"> | string
    activityId?: BytesNullableFilter<"Attachment"> | Uint8Array | null
    tenetId?: BytesFilter<"Attachment"> | Uint8Array
    activity?: XOR<ActivityNullableScalarRelationFilter, ActivityWhereInput> | null
    tenet?: XOR<TenetScalarRelationFilter, TenetWhereInput>
  }

  export type AttachmentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    activityId?: SortOrderInput | SortOrder
    tenetId?: SortOrder
    activity?: ActivityOrderByWithRelationInput
    tenet?: TenetOrderByWithRelationInput
  }

  export type AttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    AND?: AttachmentWhereInput | AttachmentWhereInput[]
    OR?: AttachmentWhereInput[]
    NOT?: AttachmentWhereInput | AttachmentWhereInput[]
    name?: StringFilter<"Attachment"> | string
    location?: StringFilter<"Attachment"> | string
    activityId?: BytesNullableFilter<"Attachment"> | Uint8Array | null
    tenetId?: BytesFilter<"Attachment"> | Uint8Array
    activity?: XOR<ActivityNullableScalarRelationFilter, ActivityWhereInput> | null
    tenet?: XOR<TenetScalarRelationFilter, TenetWhereInput>
  }, "id">

  export type AttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    activityId?: SortOrderInput | SortOrder
    tenetId?: SortOrder
    _count?: AttachmentCountOrderByAggregateInput
    _max?: AttachmentMaxOrderByAggregateInput
    _min?: AttachmentMinOrderByAggregateInput
  }

  export type AttachmentScalarWhereWithAggregatesInput = {
    AND?: AttachmentScalarWhereWithAggregatesInput | AttachmentScalarWhereWithAggregatesInput[]
    OR?: AttachmentScalarWhereWithAggregatesInput[]
    NOT?: AttachmentScalarWhereWithAggregatesInput | AttachmentScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"Attachment"> | Uint8Array
    name?: StringWithAggregatesFilter<"Attachment"> | string
    location?: StringWithAggregatesFilter<"Attachment"> | string
    activityId?: BytesNullableWithAggregatesFilter<"Attachment"> | Uint8Array | null
    tenetId?: BytesWithAggregatesFilter<"Attachment"> | Uint8Array
  }

  export type ActivityContactJoinWhereInput = {
    AND?: ActivityContactJoinWhereInput | ActivityContactJoinWhereInput[]
    OR?: ActivityContactJoinWhereInput[]
    NOT?: ActivityContactJoinWhereInput | ActivityContactJoinWhereInput[]
    activityId?: BytesFilter<"ActivityContactJoin"> | Uint8Array
    contactId?: BytesFilter<"ActivityContactJoin"> | Uint8Array
    activityRelation?: XOR<ActivityScalarRelationFilter, ActivityWhereInput>
    contactRelation?: XOR<ContactScalarRelationFilter, ContactWhereInput>
  }

  export type ActivityContactJoinOrderByWithRelationInput = {
    activityId?: SortOrder
    contactId?: SortOrder
    activityRelation?: ActivityOrderByWithRelationInput
    contactRelation?: ContactOrderByWithRelationInput
  }

  export type ActivityContactJoinWhereUniqueInput = Prisma.AtLeast<{
    activityId_contactId?: ActivityContactJoinActivityIdContactIdCompoundUniqueInput
    AND?: ActivityContactJoinWhereInput | ActivityContactJoinWhereInput[]
    OR?: ActivityContactJoinWhereInput[]
    NOT?: ActivityContactJoinWhereInput | ActivityContactJoinWhereInput[]
    activityId?: BytesFilter<"ActivityContactJoin"> | Uint8Array
    contactId?: BytesFilter<"ActivityContactJoin"> | Uint8Array
    activityRelation?: XOR<ActivityScalarRelationFilter, ActivityWhereInput>
    contactRelation?: XOR<ContactScalarRelationFilter, ContactWhereInput>
  }, "activityId_contactId">

  export type ActivityContactJoinOrderByWithAggregationInput = {
    activityId?: SortOrder
    contactId?: SortOrder
    _count?: ActivityContactJoinCountOrderByAggregateInput
    _max?: ActivityContactJoinMaxOrderByAggregateInput
    _min?: ActivityContactJoinMinOrderByAggregateInput
  }

  export type ActivityContactJoinScalarWhereWithAggregatesInput = {
    AND?: ActivityContactJoinScalarWhereWithAggregatesInput | ActivityContactJoinScalarWhereWithAggregatesInput[]
    OR?: ActivityContactJoinScalarWhereWithAggregatesInput[]
    NOT?: ActivityContactJoinScalarWhereWithAggregatesInput | ActivityContactJoinScalarWhereWithAggregatesInput[]
    activityId?: BytesWithAggregatesFilter<"ActivityContactJoin"> | Uint8Array
    contactId?: BytesWithAggregatesFilter<"ActivityContactJoin"> | Uint8Array
  }

  export type ActivityUserJoinWhereInput = {
    AND?: ActivityUserJoinWhereInput | ActivityUserJoinWhereInput[]
    OR?: ActivityUserJoinWhereInput[]
    NOT?: ActivityUserJoinWhereInput | ActivityUserJoinWhereInput[]
    activityId?: BytesFilter<"ActivityUserJoin"> | Uint8Array
    userId?: BytesFilter<"ActivityUserJoin"> | Uint8Array
    activityRelation?: XOR<ActivityScalarRelationFilter, ActivityWhereInput>
    userRelation?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ActivityUserJoinOrderByWithRelationInput = {
    activityId?: SortOrder
    userId?: SortOrder
    activityRelation?: ActivityOrderByWithRelationInput
    userRelation?: UserOrderByWithRelationInput
  }

  export type ActivityUserJoinWhereUniqueInput = Prisma.AtLeast<{
    activityId_userId?: ActivityUserJoinActivityIdUserIdCompoundUniqueInput
    AND?: ActivityUserJoinWhereInput | ActivityUserJoinWhereInput[]
    OR?: ActivityUserJoinWhereInput[]
    NOT?: ActivityUserJoinWhereInput | ActivityUserJoinWhereInput[]
    activityId?: BytesFilter<"ActivityUserJoin"> | Uint8Array
    userId?: BytesFilter<"ActivityUserJoin"> | Uint8Array
    activityRelation?: XOR<ActivityScalarRelationFilter, ActivityWhereInput>
    userRelation?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "activityId_userId">

  export type ActivityUserJoinOrderByWithAggregationInput = {
    activityId?: SortOrder
    userId?: SortOrder
    _count?: ActivityUserJoinCountOrderByAggregateInput
    _max?: ActivityUserJoinMaxOrderByAggregateInput
    _min?: ActivityUserJoinMinOrderByAggregateInput
  }

  export type ActivityUserJoinScalarWhereWithAggregatesInput = {
    AND?: ActivityUserJoinScalarWhereWithAggregatesInput | ActivityUserJoinScalarWhereWithAggregatesInput[]
    OR?: ActivityUserJoinScalarWhereWithAggregatesInput[]
    NOT?: ActivityUserJoinScalarWhereWithAggregatesInput | ActivityUserJoinScalarWhereWithAggregatesInput[]
    activityId?: BytesWithAggregatesFilter<"ActivityUserJoin"> | Uint8Array
    userId?: BytesWithAggregatesFilter<"ActivityUserJoin"> | Uint8Array
  }

  export type ContactEmailWhereInput = {
    AND?: ContactEmailWhereInput | ContactEmailWhereInput[]
    OR?: ContactEmailWhereInput[]
    NOT?: ContactEmailWhereInput | ContactEmailWhereInput[]
    id?: BytesFilter<"ContactEmail"> | Uint8Array
    email?: StringFilter<"ContactEmail"> | string
    isPrimary?: BoolFilter<"ContactEmail"> | boolean
    contactId?: BytesFilter<"ContactEmail"> | Uint8Array
    tenetId?: BytesFilter<"ContactEmail"> | Uint8Array
    createdAt?: DateTimeFilter<"ContactEmail"> | Date | string
    updatedAt?: DateTimeFilter<"ContactEmail"> | Date | string
    contact?: XOR<ContactScalarRelationFilter, ContactWhereInput>
    tenet?: XOR<TenetScalarRelationFilter, TenetWhereInput>
  }

  export type ContactEmailOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    isPrimary?: SortOrder
    contactId?: SortOrder
    tenetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contact?: ContactOrderByWithRelationInput
    tenet?: TenetOrderByWithRelationInput
  }

  export type ContactEmailWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    AND?: ContactEmailWhereInput | ContactEmailWhereInput[]
    OR?: ContactEmailWhereInput[]
    NOT?: ContactEmailWhereInput | ContactEmailWhereInput[]
    email?: StringFilter<"ContactEmail"> | string
    isPrimary?: BoolFilter<"ContactEmail"> | boolean
    contactId?: BytesFilter<"ContactEmail"> | Uint8Array
    tenetId?: BytesFilter<"ContactEmail"> | Uint8Array
    createdAt?: DateTimeFilter<"ContactEmail"> | Date | string
    updatedAt?: DateTimeFilter<"ContactEmail"> | Date | string
    contact?: XOR<ContactScalarRelationFilter, ContactWhereInput>
    tenet?: XOR<TenetScalarRelationFilter, TenetWhereInput>
  }, "id">

  export type ContactEmailOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    isPrimary?: SortOrder
    contactId?: SortOrder
    tenetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContactEmailCountOrderByAggregateInput
    _max?: ContactEmailMaxOrderByAggregateInput
    _min?: ContactEmailMinOrderByAggregateInput
  }

  export type ContactEmailScalarWhereWithAggregatesInput = {
    AND?: ContactEmailScalarWhereWithAggregatesInput | ContactEmailScalarWhereWithAggregatesInput[]
    OR?: ContactEmailScalarWhereWithAggregatesInput[]
    NOT?: ContactEmailScalarWhereWithAggregatesInput | ContactEmailScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"ContactEmail"> | Uint8Array
    email?: StringWithAggregatesFilter<"ContactEmail"> | string
    isPrimary?: BoolWithAggregatesFilter<"ContactEmail"> | boolean
    contactId?: BytesWithAggregatesFilter<"ContactEmail"> | Uint8Array
    tenetId?: BytesWithAggregatesFilter<"ContactEmail"> | Uint8Array
    createdAt?: DateTimeWithAggregatesFilter<"ContactEmail"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContactEmail"> | Date | string
  }

  export type ContactPhoneWhereInput = {
    AND?: ContactPhoneWhereInput | ContactPhoneWhereInput[]
    OR?: ContactPhoneWhereInput[]
    NOT?: ContactPhoneWhereInput | ContactPhoneWhereInput[]
    id?: BytesFilter<"ContactPhone"> | Uint8Array
    number?: StringFilter<"ContactPhone"> | string
    type?: EnumPhoneTypeFilter<"ContactPhone"> | $Enums.PhoneType
    isPrimary?: BoolFilter<"ContactPhone"> | boolean
    contactId?: BytesFilter<"ContactPhone"> | Uint8Array
    tenetId?: BytesFilter<"ContactPhone"> | Uint8Array
    createdAt?: DateTimeFilter<"ContactPhone"> | Date | string
    updatedAt?: DateTimeFilter<"ContactPhone"> | Date | string
    contact?: XOR<ContactScalarRelationFilter, ContactWhereInput>
    tenet?: XOR<TenetScalarRelationFilter, TenetWhereInput>
  }

  export type ContactPhoneOrderByWithRelationInput = {
    id?: SortOrder
    number?: SortOrder
    type?: SortOrder
    isPrimary?: SortOrder
    contactId?: SortOrder
    tenetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contact?: ContactOrderByWithRelationInput
    tenet?: TenetOrderByWithRelationInput
  }

  export type ContactPhoneWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    AND?: ContactPhoneWhereInput | ContactPhoneWhereInput[]
    OR?: ContactPhoneWhereInput[]
    NOT?: ContactPhoneWhereInput | ContactPhoneWhereInput[]
    number?: StringFilter<"ContactPhone"> | string
    type?: EnumPhoneTypeFilter<"ContactPhone"> | $Enums.PhoneType
    isPrimary?: BoolFilter<"ContactPhone"> | boolean
    contactId?: BytesFilter<"ContactPhone"> | Uint8Array
    tenetId?: BytesFilter<"ContactPhone"> | Uint8Array
    createdAt?: DateTimeFilter<"ContactPhone"> | Date | string
    updatedAt?: DateTimeFilter<"ContactPhone"> | Date | string
    contact?: XOR<ContactScalarRelationFilter, ContactWhereInput>
    tenet?: XOR<TenetScalarRelationFilter, TenetWhereInput>
  }, "id">

  export type ContactPhoneOrderByWithAggregationInput = {
    id?: SortOrder
    number?: SortOrder
    type?: SortOrder
    isPrimary?: SortOrder
    contactId?: SortOrder
    tenetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContactPhoneCountOrderByAggregateInput
    _max?: ContactPhoneMaxOrderByAggregateInput
    _min?: ContactPhoneMinOrderByAggregateInput
  }

  export type ContactPhoneScalarWhereWithAggregatesInput = {
    AND?: ContactPhoneScalarWhereWithAggregatesInput | ContactPhoneScalarWhereWithAggregatesInput[]
    OR?: ContactPhoneScalarWhereWithAggregatesInput[]
    NOT?: ContactPhoneScalarWhereWithAggregatesInput | ContactPhoneScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"ContactPhone"> | Uint8Array
    number?: StringWithAggregatesFilter<"ContactPhone"> | string
    type?: EnumPhoneTypeWithAggregatesFilter<"ContactPhone"> | $Enums.PhoneType
    isPrimary?: BoolWithAggregatesFilter<"ContactPhone"> | boolean
    contactId?: BytesWithAggregatesFilter<"ContactPhone"> | Uint8Array
    tenetId?: BytesWithAggregatesFilter<"ContactPhone"> | Uint8Array
    createdAt?: DateTimeWithAggregatesFilter<"ContactPhone"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContactPhone"> | Date | string
  }

  export type AddressWhereInput = {
    AND?: AddressWhereInput | AddressWhereInput[]
    OR?: AddressWhereInput[]
    NOT?: AddressWhereInput | AddressWhereInput[]
    id?: BytesFilter<"Address"> | Uint8Array
    street?: StringFilter<"Address"> | string
    city?: StringFilter<"Address"> | string
    state?: StringFilter<"Address"> | string
    zip?: StringFilter<"Address"> | string
    country?: StringFilter<"Address"> | string
    type?: EnumAddressTypeFilter<"Address"> | $Enums.AddressType
    primary?: BoolFilter<"Address"> | boolean
    contactId?: BytesFilter<"Address"> | Uint8Array
    tenetId?: BytesFilter<"Address"> | Uint8Array
    createdAt?: DateTimeFilter<"Address"> | Date | string
    updatedAt?: DateTimeFilter<"Address"> | Date | string
    timezone?: StringNullableFilter<"Address"> | string | null
    contact?: XOR<ContactScalarRelationFilter, ContactWhereInput>
    tenet?: XOR<TenetScalarRelationFilter, TenetWhereInput>
  }

  export type AddressOrderByWithRelationInput = {
    id?: SortOrder
    street?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    country?: SortOrder
    type?: SortOrder
    primary?: SortOrder
    contactId?: SortOrder
    tenetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    timezone?: SortOrderInput | SortOrder
    contact?: ContactOrderByWithRelationInput
    tenet?: TenetOrderByWithRelationInput
  }

  export type AddressWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    AND?: AddressWhereInput | AddressWhereInput[]
    OR?: AddressWhereInput[]
    NOT?: AddressWhereInput | AddressWhereInput[]
    street?: StringFilter<"Address"> | string
    city?: StringFilter<"Address"> | string
    state?: StringFilter<"Address"> | string
    zip?: StringFilter<"Address"> | string
    country?: StringFilter<"Address"> | string
    type?: EnumAddressTypeFilter<"Address"> | $Enums.AddressType
    primary?: BoolFilter<"Address"> | boolean
    contactId?: BytesFilter<"Address"> | Uint8Array
    tenetId?: BytesFilter<"Address"> | Uint8Array
    createdAt?: DateTimeFilter<"Address"> | Date | string
    updatedAt?: DateTimeFilter<"Address"> | Date | string
    timezone?: StringNullableFilter<"Address"> | string | null
    contact?: XOR<ContactScalarRelationFilter, ContactWhereInput>
    tenet?: XOR<TenetScalarRelationFilter, TenetWhereInput>
  }, "id">

  export type AddressOrderByWithAggregationInput = {
    id?: SortOrder
    street?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    country?: SortOrder
    type?: SortOrder
    primary?: SortOrder
    contactId?: SortOrder
    tenetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    timezone?: SortOrderInput | SortOrder
    _count?: AddressCountOrderByAggregateInput
    _max?: AddressMaxOrderByAggregateInput
    _min?: AddressMinOrderByAggregateInput
  }

  export type AddressScalarWhereWithAggregatesInput = {
    AND?: AddressScalarWhereWithAggregatesInput | AddressScalarWhereWithAggregatesInput[]
    OR?: AddressScalarWhereWithAggregatesInput[]
    NOT?: AddressScalarWhereWithAggregatesInput | AddressScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"Address"> | Uint8Array
    street?: StringWithAggregatesFilter<"Address"> | string
    city?: StringWithAggregatesFilter<"Address"> | string
    state?: StringWithAggregatesFilter<"Address"> | string
    zip?: StringWithAggregatesFilter<"Address"> | string
    country?: StringWithAggregatesFilter<"Address"> | string
    type?: EnumAddressTypeWithAggregatesFilter<"Address"> | $Enums.AddressType
    primary?: BoolWithAggregatesFilter<"Address"> | boolean
    contactId?: BytesWithAggregatesFilter<"Address"> | Uint8Array
    tenetId?: BytesWithAggregatesFilter<"Address"> | Uint8Array
    createdAt?: DateTimeWithAggregatesFilter<"Address"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Address"> | Date | string
    timezone?: StringNullableWithAggregatesFilter<"Address"> | string | null
  }

  export type ConfigOptionWhereInput = {
    AND?: ConfigOptionWhereInput | ConfigOptionWhereInput[]
    OR?: ConfigOptionWhereInput[]
    NOT?: ConfigOptionWhereInput | ConfigOptionWhereInput[]
    id?: BytesFilter<"ConfigOption"> | Uint8Array
    name?: StringFilter<"ConfigOption"> | string
    value?: StringFilter<"ConfigOption"> | string
  }

  export type ConfigOptionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
  }

  export type ConfigOptionWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    name?: string
    AND?: ConfigOptionWhereInput | ConfigOptionWhereInput[]
    OR?: ConfigOptionWhereInput[]
    NOT?: ConfigOptionWhereInput | ConfigOptionWhereInput[]
    value?: StringFilter<"ConfigOption"> | string
  }, "id" | "name">

  export type ConfigOptionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    _count?: ConfigOptionCountOrderByAggregateInput
    _max?: ConfigOptionMaxOrderByAggregateInput
    _min?: ConfigOptionMinOrderByAggregateInput
  }

  export type ConfigOptionScalarWhereWithAggregatesInput = {
    AND?: ConfigOptionScalarWhereWithAggregatesInput | ConfigOptionScalarWhereWithAggregatesInput[]
    OR?: ConfigOptionScalarWhereWithAggregatesInput[]
    NOT?: ConfigOptionScalarWhereWithAggregatesInput | ConfigOptionScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"ConfigOption"> | Uint8Array
    name?: StringWithAggregatesFilter<"ConfigOption"> | string
    value?: StringWithAggregatesFilter<"ConfigOption"> | string
  }

  export type ImportantDateWhereInput = {
    AND?: ImportantDateWhereInput | ImportantDateWhereInput[]
    OR?: ImportantDateWhereInput[]
    NOT?: ImportantDateWhereInput | ImportantDateWhereInput[]
    id?: BytesFilter<"ImportantDate"> | Uint8Array
    date?: DateTimeFilter<"ImportantDate"> | Date | string
    type?: EnumImportantDateTypeFilter<"ImportantDate"> | $Enums.ImportantDateType
    contactId?: BytesFilter<"ImportantDate"> | Uint8Array
    tenetId?: BytesFilter<"ImportantDate"> | Uint8Array
    createdAt?: DateTimeFilter<"ImportantDate"> | Date | string
    updatedAt?: DateTimeFilter<"ImportantDate"> | Date | string
    contact?: XOR<ContactScalarRelationFilter, ContactWhereInput>
    tenet?: XOR<TenetScalarRelationFilter, TenetWhereInput>
  }

  export type ImportantDateOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    contactId?: SortOrder
    tenetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contact?: ContactOrderByWithRelationInput
    tenet?: TenetOrderByWithRelationInput
  }

  export type ImportantDateWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    AND?: ImportantDateWhereInput | ImportantDateWhereInput[]
    OR?: ImportantDateWhereInput[]
    NOT?: ImportantDateWhereInput | ImportantDateWhereInput[]
    date?: DateTimeFilter<"ImportantDate"> | Date | string
    type?: EnumImportantDateTypeFilter<"ImportantDate"> | $Enums.ImportantDateType
    contactId?: BytesFilter<"ImportantDate"> | Uint8Array
    tenetId?: BytesFilter<"ImportantDate"> | Uint8Array
    createdAt?: DateTimeFilter<"ImportantDate"> | Date | string
    updatedAt?: DateTimeFilter<"ImportantDate"> | Date | string
    contact?: XOR<ContactScalarRelationFilter, ContactWhereInput>
    tenet?: XOR<TenetScalarRelationFilter, TenetWhereInput>
  }, "id">

  export type ImportantDateOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    contactId?: SortOrder
    tenetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ImportantDateCountOrderByAggregateInput
    _max?: ImportantDateMaxOrderByAggregateInput
    _min?: ImportantDateMinOrderByAggregateInput
  }

  export type ImportantDateScalarWhereWithAggregatesInput = {
    AND?: ImportantDateScalarWhereWithAggregatesInput | ImportantDateScalarWhereWithAggregatesInput[]
    OR?: ImportantDateScalarWhereWithAggregatesInput[]
    NOT?: ImportantDateScalarWhereWithAggregatesInput | ImportantDateScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"ImportantDate"> | Uint8Array
    date?: DateTimeWithAggregatesFilter<"ImportantDate"> | Date | string
    type?: EnumImportantDateTypeWithAggregatesFilter<"ImportantDate"> | $Enums.ImportantDateType
    contactId?: BytesWithAggregatesFilter<"ImportantDate"> | Uint8Array
    tenetId?: BytesWithAggregatesFilter<"ImportantDate"> | Uint8Array
    createdAt?: DateTimeWithAggregatesFilter<"ImportantDate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ImportantDate"> | Date | string
  }

  export type OpportunityWhereInput = {
    AND?: OpportunityWhereInput | OpportunityWhereInput[]
    OR?: OpportunityWhereInput[]
    NOT?: OpportunityWhereInput | OpportunityWhereInput[]
    id?: BytesFilter<"Opportunity"> | Uint8Array
    title?: StringFilter<"Opportunity"> | string
    description?: StringNullableFilter<"Opportunity"> | string | null
    createdAt?: DateTimeFilter<"Opportunity"> | Date | string
    updatedAt?: DateTimeFilter<"Opportunity"> | Date | string
    value?: FloatFilter<"Opportunity"> | number
    probability?: FloatFilter<"Opportunity"> | number
    expectedCloseDate?: DateTimeFilter<"Opportunity"> | Date | string
    actualCloseDate?: DateTimeNullableFilter<"Opportunity"> | Date | string | null
    status?: EnumOpportunityStatusFilter<"Opportunity"> | $Enums.OpportunityStatus
    statusHistory?: EnumOpportunityStatusNullableListFilter<"Opportunity">
    deleted?: BoolFilter<"Opportunity"> | boolean
    deletedAt?: DateTimeNullableFilter<"Opportunity"> | Date | string | null
    tenetId?: BytesFilter<"Opportunity"> | Uint8Array
    expectedValue?: FloatFilter<"Opportunity"> | number
    contacts?: ContactOpportunityJoinListRelationFilter
    teamMembers?: UserOpportunityJoinListRelationFilter
    activities?: ActivityListRelationFilter
    products?: OpportunityProductListRelationFilter
    tenet?: XOR<TenetScalarRelationFilter, TenetWhereInput>
    events?: ContactTimelineEventListRelationFilter
    notes?: NoteListRelationFilter
  }

  export type OpportunityOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    value?: SortOrder
    probability?: SortOrder
    expectedCloseDate?: SortOrder
    actualCloseDate?: SortOrderInput | SortOrder
    status?: SortOrder
    statusHistory?: SortOrder
    deleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    tenetId?: SortOrder
    expectedValue?: SortOrder
    contacts?: ContactOpportunityJoinOrderByRelationAggregateInput
    teamMembers?: UserOpportunityJoinOrderByRelationAggregateInput
    activities?: ActivityOrderByRelationAggregateInput
    products?: OpportunityProductOrderByRelationAggregateInput
    tenet?: TenetOrderByWithRelationInput
    events?: ContactTimelineEventOrderByRelationAggregateInput
    notes?: NoteOrderByRelationAggregateInput
  }

  export type OpportunityWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    AND?: OpportunityWhereInput | OpportunityWhereInput[]
    OR?: OpportunityWhereInput[]
    NOT?: OpportunityWhereInput | OpportunityWhereInput[]
    title?: StringFilter<"Opportunity"> | string
    description?: StringNullableFilter<"Opportunity"> | string | null
    createdAt?: DateTimeFilter<"Opportunity"> | Date | string
    updatedAt?: DateTimeFilter<"Opportunity"> | Date | string
    value?: FloatFilter<"Opportunity"> | number
    probability?: FloatFilter<"Opportunity"> | number
    expectedCloseDate?: DateTimeFilter<"Opportunity"> | Date | string
    actualCloseDate?: DateTimeNullableFilter<"Opportunity"> | Date | string | null
    status?: EnumOpportunityStatusFilter<"Opportunity"> | $Enums.OpportunityStatus
    statusHistory?: EnumOpportunityStatusNullableListFilter<"Opportunity">
    deleted?: BoolFilter<"Opportunity"> | boolean
    deletedAt?: DateTimeNullableFilter<"Opportunity"> | Date | string | null
    tenetId?: BytesFilter<"Opportunity"> | Uint8Array
    expectedValue?: FloatFilter<"Opportunity"> | number
    contacts?: ContactOpportunityJoinListRelationFilter
    teamMembers?: UserOpportunityJoinListRelationFilter
    activities?: ActivityListRelationFilter
    products?: OpportunityProductListRelationFilter
    tenet?: XOR<TenetScalarRelationFilter, TenetWhereInput>
    events?: ContactTimelineEventListRelationFilter
    notes?: NoteListRelationFilter
  }, "id">

  export type OpportunityOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    value?: SortOrder
    probability?: SortOrder
    expectedCloseDate?: SortOrder
    actualCloseDate?: SortOrderInput | SortOrder
    status?: SortOrder
    statusHistory?: SortOrder
    deleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    tenetId?: SortOrder
    expectedValue?: SortOrder
    _count?: OpportunityCountOrderByAggregateInput
    _avg?: OpportunityAvgOrderByAggregateInput
    _max?: OpportunityMaxOrderByAggregateInput
    _min?: OpportunityMinOrderByAggregateInput
    _sum?: OpportunitySumOrderByAggregateInput
  }

  export type OpportunityScalarWhereWithAggregatesInput = {
    AND?: OpportunityScalarWhereWithAggregatesInput | OpportunityScalarWhereWithAggregatesInput[]
    OR?: OpportunityScalarWhereWithAggregatesInput[]
    NOT?: OpportunityScalarWhereWithAggregatesInput | OpportunityScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"Opportunity"> | Uint8Array
    title?: StringWithAggregatesFilter<"Opportunity"> | string
    description?: StringNullableWithAggregatesFilter<"Opportunity"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Opportunity"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Opportunity"> | Date | string
    value?: FloatWithAggregatesFilter<"Opportunity"> | number
    probability?: FloatWithAggregatesFilter<"Opportunity"> | number
    expectedCloseDate?: DateTimeWithAggregatesFilter<"Opportunity"> | Date | string
    actualCloseDate?: DateTimeNullableWithAggregatesFilter<"Opportunity"> | Date | string | null
    status?: EnumOpportunityStatusWithAggregatesFilter<"Opportunity"> | $Enums.OpportunityStatus
    statusHistory?: EnumOpportunityStatusNullableListFilter<"Opportunity">
    deleted?: BoolWithAggregatesFilter<"Opportunity"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Opportunity"> | Date | string | null
    tenetId?: BytesWithAggregatesFilter<"Opportunity"> | Uint8Array
    expectedValue?: FloatWithAggregatesFilter<"Opportunity"> | number
  }

  export type ContactOpportunityJoinWhereInput = {
    AND?: ContactOpportunityJoinWhereInput | ContactOpportunityJoinWhereInput[]
    OR?: ContactOpportunityJoinWhereInput[]
    NOT?: ContactOpportunityJoinWhereInput | ContactOpportunityJoinWhereInput[]
    contactId?: BytesFilter<"ContactOpportunityJoin"> | Uint8Array
    opportunityId?: BytesFilter<"ContactOpportunityJoin"> | Uint8Array
    contactRelation?: XOR<ContactScalarRelationFilter, ContactWhereInput>
    opportunityRelation?: XOR<OpportunityScalarRelationFilter, OpportunityWhereInput>
  }

  export type ContactOpportunityJoinOrderByWithRelationInput = {
    contactId?: SortOrder
    opportunityId?: SortOrder
    contactRelation?: ContactOrderByWithRelationInput
    opportunityRelation?: OpportunityOrderByWithRelationInput
  }

  export type ContactOpportunityJoinWhereUniqueInput = Prisma.AtLeast<{
    contactId_opportunityId?: ContactOpportunityJoinContactIdOpportunityIdCompoundUniqueInput
    AND?: ContactOpportunityJoinWhereInput | ContactOpportunityJoinWhereInput[]
    OR?: ContactOpportunityJoinWhereInput[]
    NOT?: ContactOpportunityJoinWhereInput | ContactOpportunityJoinWhereInput[]
    contactId?: BytesFilter<"ContactOpportunityJoin"> | Uint8Array
    opportunityId?: BytesFilter<"ContactOpportunityJoin"> | Uint8Array
    contactRelation?: XOR<ContactScalarRelationFilter, ContactWhereInput>
    opportunityRelation?: XOR<OpportunityScalarRelationFilter, OpportunityWhereInput>
  }, "contactId_opportunityId">

  export type ContactOpportunityJoinOrderByWithAggregationInput = {
    contactId?: SortOrder
    opportunityId?: SortOrder
    _count?: ContactOpportunityJoinCountOrderByAggregateInput
    _max?: ContactOpportunityJoinMaxOrderByAggregateInput
    _min?: ContactOpportunityJoinMinOrderByAggregateInput
  }

  export type ContactOpportunityJoinScalarWhereWithAggregatesInput = {
    AND?: ContactOpportunityJoinScalarWhereWithAggregatesInput | ContactOpportunityJoinScalarWhereWithAggregatesInput[]
    OR?: ContactOpportunityJoinScalarWhereWithAggregatesInput[]
    NOT?: ContactOpportunityJoinScalarWhereWithAggregatesInput | ContactOpportunityJoinScalarWhereWithAggregatesInput[]
    contactId?: BytesWithAggregatesFilter<"ContactOpportunityJoin"> | Uint8Array
    opportunityId?: BytesWithAggregatesFilter<"ContactOpportunityJoin"> | Uint8Array
  }

  export type UserOpportunityJoinWhereInput = {
    AND?: UserOpportunityJoinWhereInput | UserOpportunityJoinWhereInput[]
    OR?: UserOpportunityJoinWhereInput[]
    NOT?: UserOpportunityJoinWhereInput | UserOpportunityJoinWhereInput[]
    userId?: BytesFilter<"UserOpportunityJoin"> | Uint8Array
    opportunityId?: BytesFilter<"UserOpportunityJoin"> | Uint8Array
    userRelation?: XOR<UserScalarRelationFilter, UserWhereInput>
    opportunityRelation?: XOR<OpportunityScalarRelationFilter, OpportunityWhereInput>
  }

  export type UserOpportunityJoinOrderByWithRelationInput = {
    userId?: SortOrder
    opportunityId?: SortOrder
    userRelation?: UserOrderByWithRelationInput
    opportunityRelation?: OpportunityOrderByWithRelationInput
  }

  export type UserOpportunityJoinWhereUniqueInput = Prisma.AtLeast<{
    userId_opportunityId?: UserOpportunityJoinUserIdOpportunityIdCompoundUniqueInput
    AND?: UserOpportunityJoinWhereInput | UserOpportunityJoinWhereInput[]
    OR?: UserOpportunityJoinWhereInput[]
    NOT?: UserOpportunityJoinWhereInput | UserOpportunityJoinWhereInput[]
    userId?: BytesFilter<"UserOpportunityJoin"> | Uint8Array
    opportunityId?: BytesFilter<"UserOpportunityJoin"> | Uint8Array
    userRelation?: XOR<UserScalarRelationFilter, UserWhereInput>
    opportunityRelation?: XOR<OpportunityScalarRelationFilter, OpportunityWhereInput>
  }, "userId_opportunityId">

  export type UserOpportunityJoinOrderByWithAggregationInput = {
    userId?: SortOrder
    opportunityId?: SortOrder
    _count?: UserOpportunityJoinCountOrderByAggregateInput
    _max?: UserOpportunityJoinMaxOrderByAggregateInput
    _min?: UserOpportunityJoinMinOrderByAggregateInput
  }

  export type UserOpportunityJoinScalarWhereWithAggregatesInput = {
    AND?: UserOpportunityJoinScalarWhereWithAggregatesInput | UserOpportunityJoinScalarWhereWithAggregatesInput[]
    OR?: UserOpportunityJoinScalarWhereWithAggregatesInput[]
    NOT?: UserOpportunityJoinScalarWhereWithAggregatesInput | UserOpportunityJoinScalarWhereWithAggregatesInput[]
    userId?: BytesWithAggregatesFilter<"UserOpportunityJoin"> | Uint8Array
    opportunityId?: BytesWithAggregatesFilter<"UserOpportunityJoin"> | Uint8Array
  }

  export type OpportunityProductWhereInput = {
    AND?: OpportunityProductWhereInput | OpportunityProductWhereInput[]
    OR?: OpportunityProductWhereInput[]
    NOT?: OpportunityProductWhereInput | OpportunityProductWhereInput[]
    id?: BytesFilter<"OpportunityProduct"> | Uint8Array
    price?: FloatFilter<"OpportunityProduct"> | number
    order?: IntFilter<"OpportunityProduct"> | number
    commission?: FloatFilter<"OpportunityProduct"> | number
    opportunityId?: BytesFilter<"OpportunityProduct"> | Uint8Array
    productTypeId?: BytesFilter<"OpportunityProduct"> | Uint8Array
    createdAt?: DateTimeFilter<"OpportunityProduct"> | Date | string
    updatedAt?: DateTimeFilter<"OpportunityProduct"> | Date | string
    opportunity?: XOR<OpportunityScalarRelationFilter, OpportunityWhereInput>
    productType?: XOR<ProductTypeScalarRelationFilter, ProductTypeWhereInput>
  }

  export type OpportunityProductOrderByWithRelationInput = {
    id?: SortOrder
    price?: SortOrder
    order?: SortOrder
    commission?: SortOrder
    opportunityId?: SortOrder
    productTypeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    opportunity?: OpportunityOrderByWithRelationInput
    productType?: ProductTypeOrderByWithRelationInput
  }

  export type OpportunityProductWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    AND?: OpportunityProductWhereInput | OpportunityProductWhereInput[]
    OR?: OpportunityProductWhereInput[]
    NOT?: OpportunityProductWhereInput | OpportunityProductWhereInput[]
    price?: FloatFilter<"OpportunityProduct"> | number
    order?: IntFilter<"OpportunityProduct"> | number
    commission?: FloatFilter<"OpportunityProduct"> | number
    opportunityId?: BytesFilter<"OpportunityProduct"> | Uint8Array
    productTypeId?: BytesFilter<"OpportunityProduct"> | Uint8Array
    createdAt?: DateTimeFilter<"OpportunityProduct"> | Date | string
    updatedAt?: DateTimeFilter<"OpportunityProduct"> | Date | string
    opportunity?: XOR<OpportunityScalarRelationFilter, OpportunityWhereInput>
    productType?: XOR<ProductTypeScalarRelationFilter, ProductTypeWhereInput>
  }, "id">

  export type OpportunityProductOrderByWithAggregationInput = {
    id?: SortOrder
    price?: SortOrder
    order?: SortOrder
    commission?: SortOrder
    opportunityId?: SortOrder
    productTypeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OpportunityProductCountOrderByAggregateInput
    _avg?: OpportunityProductAvgOrderByAggregateInput
    _max?: OpportunityProductMaxOrderByAggregateInput
    _min?: OpportunityProductMinOrderByAggregateInput
    _sum?: OpportunityProductSumOrderByAggregateInput
  }

  export type OpportunityProductScalarWhereWithAggregatesInput = {
    AND?: OpportunityProductScalarWhereWithAggregatesInput | OpportunityProductScalarWhereWithAggregatesInput[]
    OR?: OpportunityProductScalarWhereWithAggregatesInput[]
    NOT?: OpportunityProductScalarWhereWithAggregatesInput | OpportunityProductScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"OpportunityProduct"> | Uint8Array
    price?: FloatWithAggregatesFilter<"OpportunityProduct"> | number
    order?: IntWithAggregatesFilter<"OpportunityProduct"> | number
    commission?: FloatWithAggregatesFilter<"OpportunityProduct"> | number
    opportunityId?: BytesWithAggregatesFilter<"OpportunityProduct"> | Uint8Array
    productTypeId?: BytesWithAggregatesFilter<"OpportunityProduct"> | Uint8Array
    createdAt?: DateTimeWithAggregatesFilter<"OpportunityProduct"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OpportunityProduct"> | Date | string
  }

  export type ProductTypeWhereInput = {
    AND?: ProductTypeWhereInput | ProductTypeWhereInput[]
    OR?: ProductTypeWhereInput[]
    NOT?: ProductTypeWhereInput | ProductTypeWhereInput[]
    id?: BytesFilter<"ProductType"> | Uint8Array
    title?: StringFilter<"ProductType"> | string
    description?: StringNullableFilter<"ProductType"> | string | null
    defaultCommission?: FloatFilter<"ProductType"> | number
    createdAt?: DateTimeFilter<"ProductType"> | Date | string
    updatedAt?: DateTimeFilter<"ProductType"> | Date | string
    tenetId?: BytesFilter<"ProductType"> | Uint8Array
    opportunities?: OpportunityProductListRelationFilter
    tenet?: XOR<TenetScalarRelationFilter, TenetWhereInput>
  }

  export type ProductTypeOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    defaultCommission?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenetId?: SortOrder
    opportunities?: OpportunityProductOrderByRelationAggregateInput
    tenet?: TenetOrderByWithRelationInput
  }

  export type ProductTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    AND?: ProductTypeWhereInput | ProductTypeWhereInput[]
    OR?: ProductTypeWhereInput[]
    NOT?: ProductTypeWhereInput | ProductTypeWhereInput[]
    title?: StringFilter<"ProductType"> | string
    description?: StringNullableFilter<"ProductType"> | string | null
    defaultCommission?: FloatFilter<"ProductType"> | number
    createdAt?: DateTimeFilter<"ProductType"> | Date | string
    updatedAt?: DateTimeFilter<"ProductType"> | Date | string
    tenetId?: BytesFilter<"ProductType"> | Uint8Array
    opportunities?: OpportunityProductListRelationFilter
    tenet?: XOR<TenetScalarRelationFilter, TenetWhereInput>
  }, "id">

  export type ProductTypeOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    defaultCommission?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenetId?: SortOrder
    _count?: ProductTypeCountOrderByAggregateInput
    _avg?: ProductTypeAvgOrderByAggregateInput
    _max?: ProductTypeMaxOrderByAggregateInput
    _min?: ProductTypeMinOrderByAggregateInput
    _sum?: ProductTypeSumOrderByAggregateInput
  }

  export type ProductTypeScalarWhereWithAggregatesInput = {
    AND?: ProductTypeScalarWhereWithAggregatesInput | ProductTypeScalarWhereWithAggregatesInput[]
    OR?: ProductTypeScalarWhereWithAggregatesInput[]
    NOT?: ProductTypeScalarWhereWithAggregatesInput | ProductTypeScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"ProductType"> | Uint8Array
    title?: StringWithAggregatesFilter<"ProductType"> | string
    description?: StringNullableWithAggregatesFilter<"ProductType"> | string | null
    defaultCommission?: FloatWithAggregatesFilter<"ProductType"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ProductType"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductType"> | Date | string
    tenetId?: BytesWithAggregatesFilter<"ProductType"> | Uint8Array
  }

  export type LogWhereInput = {
    AND?: LogWhereInput | LogWhereInput[]
    OR?: LogWhereInput[]
    NOT?: LogWhereInput | LogWhereInput[]
    id?: BytesFilter<"Log"> | Uint8Array
    userEmail?: StringNullableFilter<"Log"> | string | null
    tenetId?: BytesNullableFilter<"Log"> | Uint8Array | null
    message?: StringFilter<"Log"> | string
    createdAt?: DateTimeFilter<"Log"> | Date | string
    updatedAt?: DateTimeFilter<"Log"> | Date | string
    severity?: EnumLogLevelFilter<"Log"> | $Enums.LogLevel
    stacktrace?: StringNullableFilter<"Log"> | string | null
    source?: StringNullableFilter<"Log"> | string | null
    secureDetails?: StringNullableFilter<"Log"> | string | null
    tenet?: XOR<TenetNullableScalarRelationFilter, TenetWhereInput> | null
  }

  export type LogOrderByWithRelationInput = {
    id?: SortOrder
    userEmail?: SortOrderInput | SortOrder
    tenetId?: SortOrderInput | SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    severity?: SortOrder
    stacktrace?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    secureDetails?: SortOrderInput | SortOrder
    tenet?: TenetOrderByWithRelationInput
  }

  export type LogWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    AND?: LogWhereInput | LogWhereInput[]
    OR?: LogWhereInput[]
    NOT?: LogWhereInput | LogWhereInput[]
    userEmail?: StringNullableFilter<"Log"> | string | null
    tenetId?: BytesNullableFilter<"Log"> | Uint8Array | null
    message?: StringFilter<"Log"> | string
    createdAt?: DateTimeFilter<"Log"> | Date | string
    updatedAt?: DateTimeFilter<"Log"> | Date | string
    severity?: EnumLogLevelFilter<"Log"> | $Enums.LogLevel
    stacktrace?: StringNullableFilter<"Log"> | string | null
    source?: StringNullableFilter<"Log"> | string | null
    secureDetails?: StringNullableFilter<"Log"> | string | null
    tenet?: XOR<TenetNullableScalarRelationFilter, TenetWhereInput> | null
  }, "id">

  export type LogOrderByWithAggregationInput = {
    id?: SortOrder
    userEmail?: SortOrderInput | SortOrder
    tenetId?: SortOrderInput | SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    severity?: SortOrder
    stacktrace?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    secureDetails?: SortOrderInput | SortOrder
    _count?: LogCountOrderByAggregateInput
    _max?: LogMaxOrderByAggregateInput
    _min?: LogMinOrderByAggregateInput
  }

  export type LogScalarWhereWithAggregatesInput = {
    AND?: LogScalarWhereWithAggregatesInput | LogScalarWhereWithAggregatesInput[]
    OR?: LogScalarWhereWithAggregatesInput[]
    NOT?: LogScalarWhereWithAggregatesInput | LogScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"Log"> | Uint8Array
    userEmail?: StringNullableWithAggregatesFilter<"Log"> | string | null
    tenetId?: BytesNullableWithAggregatesFilter<"Log"> | Uint8Array | null
    message?: StringWithAggregatesFilter<"Log"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Log"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Log"> | Date | string
    severity?: EnumLogLevelWithAggregatesFilter<"Log"> | $Enums.LogLevel
    stacktrace?: StringNullableWithAggregatesFilter<"Log"> | string | null
    source?: StringNullableWithAggregatesFilter<"Log"> | string | null
    secureDetails?: StringNullableWithAggregatesFilter<"Log"> | string | null
  }

  export type TokenWhereInput = {
    AND?: TokenWhereInput | TokenWhereInput[]
    OR?: TokenWhereInput[]
    NOT?: TokenWhereInput | TokenWhereInput[]
    id?: BytesFilter<"Token"> | Uint8Array
    userId?: BytesFilter<"Token"> | Uint8Array
    createdAt?: DateTimeFilter<"Token"> | Date | string
    refresh?: BoolFilter<"Token"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TokenOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    refresh?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type TokenWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    AND?: TokenWhereInput | TokenWhereInput[]
    OR?: TokenWhereInput[]
    NOT?: TokenWhereInput | TokenWhereInput[]
    userId?: BytesFilter<"Token"> | Uint8Array
    createdAt?: DateTimeFilter<"Token"> | Date | string
    refresh?: BoolFilter<"Token"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type TokenOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    refresh?: SortOrder
    _count?: TokenCountOrderByAggregateInput
    _max?: TokenMaxOrderByAggregateInput
    _min?: TokenMinOrderByAggregateInput
  }

  export type TokenScalarWhereWithAggregatesInput = {
    AND?: TokenScalarWhereWithAggregatesInput | TokenScalarWhereWithAggregatesInput[]
    OR?: TokenScalarWhereWithAggregatesInput[]
    NOT?: TokenScalarWhereWithAggregatesInput | TokenScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"Token"> | Uint8Array
    userId?: BytesWithAggregatesFilter<"Token"> | Uint8Array
    createdAt?: DateTimeWithAggregatesFilter<"Token"> | Date | string
    refresh?: BoolWithAggregatesFilter<"Token"> | boolean
  }

  export type TZDataWhereInput = {
    AND?: TZDataWhereInput | TZDataWhereInput[]
    OR?: TZDataWhereInput[]
    NOT?: TZDataWhereInput | TZDataWhereInput[]
    id?: IntFilter<"TZData"> | number
    name?: StringFilter<"TZData"> | string
    provinceName?: StringFilter<"TZData"> | string
    countryCode?: StringFilter<"TZData"> | string
    tz?: StringFilter<"TZData"> | string
  }

  export type TZDataOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    provinceName?: SortOrder
    countryCode?: SortOrder
    tz?: SortOrder
  }

  export type TZDataWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    tz_data_name_province_country_unique?: TZDataTz_data_name_province_country_uniqueCompoundUniqueInput
    AND?: TZDataWhereInput | TZDataWhereInput[]
    OR?: TZDataWhereInput[]
    NOT?: TZDataWhereInput | TZDataWhereInput[]
    name?: StringFilter<"TZData"> | string
    provinceName?: StringFilter<"TZData"> | string
    countryCode?: StringFilter<"TZData"> | string
    tz?: StringFilter<"TZData"> | string
  }, "id" | "tz_data_name_province_country_unique">

  export type TZDataOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    provinceName?: SortOrder
    countryCode?: SortOrder
    tz?: SortOrder
    _count?: TZDataCountOrderByAggregateInput
    _avg?: TZDataAvgOrderByAggregateInput
    _max?: TZDataMaxOrderByAggregateInput
    _min?: TZDataMinOrderByAggregateInput
    _sum?: TZDataSumOrderByAggregateInput
  }

  export type TZDataScalarWhereWithAggregatesInput = {
    AND?: TZDataScalarWhereWithAggregatesInput | TZDataScalarWhereWithAggregatesInput[]
    OR?: TZDataScalarWhereWithAggregatesInput[]
    NOT?: TZDataScalarWhereWithAggregatesInput | TZDataScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TZData"> | number
    name?: StringWithAggregatesFilter<"TZData"> | string
    provinceName?: StringWithAggregatesFilter<"TZData"> | string
    countryCode?: StringWithAggregatesFilter<"TZData"> | string
    tz?: StringWithAggregatesFilter<"TZData"> | string
  }

  export type TestObjectWhereInput = {
    AND?: TestObjectWhereInput | TestObjectWhereInput[]
    OR?: TestObjectWhereInput[]
    NOT?: TestObjectWhereInput | TestObjectWhereInput[]
    id?: BytesFilter<"TestObject"> | Uint8Array
    required?: StringFilter<"TestObject"> | string
    persisted?: StringNullableFilter<"TestObject"> | string | null
    wrapped?: WrappedObjectListRelationFilter
    join1?: JoinTestObjectListRelationFilter
    join2?: JoinTestObject2ListRelationFilter
  }

  export type TestObjectOrderByWithRelationInput = {
    id?: SortOrder
    required?: SortOrder
    persisted?: SortOrderInput | SortOrder
    wrapped?: WrappedObjectOrderByRelationAggregateInput
    join1?: JoinTestObjectOrderByRelationAggregateInput
    join2?: JoinTestObject2OrderByRelationAggregateInput
  }

  export type TestObjectWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    AND?: TestObjectWhereInput | TestObjectWhereInput[]
    OR?: TestObjectWhereInput[]
    NOT?: TestObjectWhereInput | TestObjectWhereInput[]
    required?: StringFilter<"TestObject"> | string
    persisted?: StringNullableFilter<"TestObject"> | string | null
    wrapped?: WrappedObjectListRelationFilter
    join1?: JoinTestObjectListRelationFilter
    join2?: JoinTestObject2ListRelationFilter
  }, "id">

  export type TestObjectOrderByWithAggregationInput = {
    id?: SortOrder
    required?: SortOrder
    persisted?: SortOrderInput | SortOrder
    _count?: TestObjectCountOrderByAggregateInput
    _max?: TestObjectMaxOrderByAggregateInput
    _min?: TestObjectMinOrderByAggregateInput
  }

  export type TestObjectScalarWhereWithAggregatesInput = {
    AND?: TestObjectScalarWhereWithAggregatesInput | TestObjectScalarWhereWithAggregatesInput[]
    OR?: TestObjectScalarWhereWithAggregatesInput[]
    NOT?: TestObjectScalarWhereWithAggregatesInput | TestObjectScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"TestObject"> | Uint8Array
    required?: StringWithAggregatesFilter<"TestObject"> | string
    persisted?: StringNullableWithAggregatesFilter<"TestObject"> | string | null
  }

  export type WrappedObjectWhereInput = {
    AND?: WrappedObjectWhereInput | WrappedObjectWhereInput[]
    OR?: WrappedObjectWhereInput[]
    NOT?: WrappedObjectWhereInput | WrappedObjectWhereInput[]
    id?: BytesFilter<"WrappedObject"> | Uint8Array
    persisted?: StringNullableFilter<"WrappedObject"> | string | null
    testObjectId?: BytesFilter<"WrappedObject"> | Uint8Array
    testObject?: XOR<TestObjectScalarRelationFilter, TestObjectWhereInput>
  }

  export type WrappedObjectOrderByWithRelationInput = {
    id?: SortOrder
    persisted?: SortOrderInput | SortOrder
    testObjectId?: SortOrder
    testObject?: TestObjectOrderByWithRelationInput
  }

  export type WrappedObjectWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    AND?: WrappedObjectWhereInput | WrappedObjectWhereInput[]
    OR?: WrappedObjectWhereInput[]
    NOT?: WrappedObjectWhereInput | WrappedObjectWhereInput[]
    persisted?: StringNullableFilter<"WrappedObject"> | string | null
    testObjectId?: BytesFilter<"WrappedObject"> | Uint8Array
    testObject?: XOR<TestObjectScalarRelationFilter, TestObjectWhereInput>
  }, "id">

  export type WrappedObjectOrderByWithAggregationInput = {
    id?: SortOrder
    persisted?: SortOrderInput | SortOrder
    testObjectId?: SortOrder
    _count?: WrappedObjectCountOrderByAggregateInput
    _max?: WrappedObjectMaxOrderByAggregateInput
    _min?: WrappedObjectMinOrderByAggregateInput
  }

  export type WrappedObjectScalarWhereWithAggregatesInput = {
    AND?: WrappedObjectScalarWhereWithAggregatesInput | WrappedObjectScalarWhereWithAggregatesInput[]
    OR?: WrappedObjectScalarWhereWithAggregatesInput[]
    NOT?: WrappedObjectScalarWhereWithAggregatesInput | WrappedObjectScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"WrappedObject"> | Uint8Array
    persisted?: StringNullableWithAggregatesFilter<"WrappedObject"> | string | null
    testObjectId?: BytesWithAggregatesFilter<"WrappedObject"> | Uint8Array
  }

  export type JoinTestObjectWhereInput = {
    AND?: JoinTestObjectWhereInput | JoinTestObjectWhereInput[]
    OR?: JoinTestObjectWhereInput[]
    NOT?: JoinTestObjectWhereInput | JoinTestObjectWhereInput[]
    testObjectId?: BytesFilter<"JoinTestObject"> | Uint8Array
    joinedObjectId?: BytesFilter<"JoinTestObject"> | Uint8Array
    joinProperty?: StringFilter<"JoinTestObject"> | string
    testObjectRelation?: XOR<TestObjectScalarRelationFilter, TestObjectWhereInput>
    joinedObjectRelation?: XOR<JoinedObject1ScalarRelationFilter, JoinedObject1WhereInput>
  }

  export type JoinTestObjectOrderByWithRelationInput = {
    testObjectId?: SortOrder
    joinedObjectId?: SortOrder
    joinProperty?: SortOrder
    testObjectRelation?: TestObjectOrderByWithRelationInput
    joinedObjectRelation?: JoinedObject1OrderByWithRelationInput
  }

  export type JoinTestObjectWhereUniqueInput = Prisma.AtLeast<{
    testObjectId_joinedObjectId?: JoinTestObjectTestObjectIdJoinedObjectIdCompoundUniqueInput
    AND?: JoinTestObjectWhereInput | JoinTestObjectWhereInput[]
    OR?: JoinTestObjectWhereInput[]
    NOT?: JoinTestObjectWhereInput | JoinTestObjectWhereInput[]
    testObjectId?: BytesFilter<"JoinTestObject"> | Uint8Array
    joinedObjectId?: BytesFilter<"JoinTestObject"> | Uint8Array
    joinProperty?: StringFilter<"JoinTestObject"> | string
    testObjectRelation?: XOR<TestObjectScalarRelationFilter, TestObjectWhereInput>
    joinedObjectRelation?: XOR<JoinedObject1ScalarRelationFilter, JoinedObject1WhereInput>
  }, "testObjectId_joinedObjectId">

  export type JoinTestObjectOrderByWithAggregationInput = {
    testObjectId?: SortOrder
    joinedObjectId?: SortOrder
    joinProperty?: SortOrder
    _count?: JoinTestObjectCountOrderByAggregateInput
    _max?: JoinTestObjectMaxOrderByAggregateInput
    _min?: JoinTestObjectMinOrderByAggregateInput
  }

  export type JoinTestObjectScalarWhereWithAggregatesInput = {
    AND?: JoinTestObjectScalarWhereWithAggregatesInput | JoinTestObjectScalarWhereWithAggregatesInput[]
    OR?: JoinTestObjectScalarWhereWithAggregatesInput[]
    NOT?: JoinTestObjectScalarWhereWithAggregatesInput | JoinTestObjectScalarWhereWithAggregatesInput[]
    testObjectId?: BytesWithAggregatesFilter<"JoinTestObject"> | Uint8Array
    joinedObjectId?: BytesWithAggregatesFilter<"JoinTestObject"> | Uint8Array
    joinProperty?: StringWithAggregatesFilter<"JoinTestObject"> | string
  }

  export type JoinTestObject2WhereInput = {
    AND?: JoinTestObject2WhereInput | JoinTestObject2WhereInput[]
    OR?: JoinTestObject2WhereInput[]
    NOT?: JoinTestObject2WhereInput | JoinTestObject2WhereInput[]
    id?: BytesFilter<"JoinTestObject2"> | Uint8Array
    testObjectId?: BytesFilter<"JoinTestObject2"> | Uint8Array
    joinedObjectId?: BytesFilter<"JoinTestObject2"> | Uint8Array
    joinProperty?: StringFilter<"JoinTestObject2"> | string
    testObjectRelation?: XOR<TestObjectScalarRelationFilter, TestObjectWhereInput>
    joinedObjectRelation?: XOR<JoinedObject2ScalarRelationFilter, JoinedObject2WhereInput>
  }

  export type JoinTestObject2OrderByWithRelationInput = {
    id?: SortOrder
    testObjectId?: SortOrder
    joinedObjectId?: SortOrder
    joinProperty?: SortOrder
    testObjectRelation?: TestObjectOrderByWithRelationInput
    joinedObjectRelation?: JoinedObject2OrderByWithRelationInput
  }

  export type JoinTestObject2WhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    AND?: JoinTestObject2WhereInput | JoinTestObject2WhereInput[]
    OR?: JoinTestObject2WhereInput[]
    NOT?: JoinTestObject2WhereInput | JoinTestObject2WhereInput[]
    testObjectId?: BytesFilter<"JoinTestObject2"> | Uint8Array
    joinedObjectId?: BytesFilter<"JoinTestObject2"> | Uint8Array
    joinProperty?: StringFilter<"JoinTestObject2"> | string
    testObjectRelation?: XOR<TestObjectScalarRelationFilter, TestObjectWhereInput>
    joinedObjectRelation?: XOR<JoinedObject2ScalarRelationFilter, JoinedObject2WhereInput>
  }, "id">

  export type JoinTestObject2OrderByWithAggregationInput = {
    id?: SortOrder
    testObjectId?: SortOrder
    joinedObjectId?: SortOrder
    joinProperty?: SortOrder
    _count?: JoinTestObject2CountOrderByAggregateInput
    _max?: JoinTestObject2MaxOrderByAggregateInput
    _min?: JoinTestObject2MinOrderByAggregateInput
  }

  export type JoinTestObject2ScalarWhereWithAggregatesInput = {
    AND?: JoinTestObject2ScalarWhereWithAggregatesInput | JoinTestObject2ScalarWhereWithAggregatesInput[]
    OR?: JoinTestObject2ScalarWhereWithAggregatesInput[]
    NOT?: JoinTestObject2ScalarWhereWithAggregatesInput | JoinTestObject2ScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"JoinTestObject2"> | Uint8Array
    testObjectId?: BytesWithAggregatesFilter<"JoinTestObject2"> | Uint8Array
    joinedObjectId?: BytesWithAggregatesFilter<"JoinTestObject2"> | Uint8Array
    joinProperty?: StringWithAggregatesFilter<"JoinTestObject2"> | string
  }

  export type JoinedObject1WhereInput = {
    AND?: JoinedObject1WhereInput | JoinedObject1WhereInput[]
    OR?: JoinedObject1WhereInput[]
    NOT?: JoinedObject1WhereInput | JoinedObject1WhereInput[]
    id?: BytesFilter<"JoinedObject1"> | Uint8Array
    persisted?: StringNullableFilter<"JoinedObject1"> | string | null
    testObjects?: JoinTestObjectListRelationFilter
  }

  export type JoinedObject1OrderByWithRelationInput = {
    id?: SortOrder
    persisted?: SortOrderInput | SortOrder
    testObjects?: JoinTestObjectOrderByRelationAggregateInput
  }

  export type JoinedObject1WhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    AND?: JoinedObject1WhereInput | JoinedObject1WhereInput[]
    OR?: JoinedObject1WhereInput[]
    NOT?: JoinedObject1WhereInput | JoinedObject1WhereInput[]
    persisted?: StringNullableFilter<"JoinedObject1"> | string | null
    testObjects?: JoinTestObjectListRelationFilter
  }, "id">

  export type JoinedObject1OrderByWithAggregationInput = {
    id?: SortOrder
    persisted?: SortOrderInput | SortOrder
    _count?: JoinedObject1CountOrderByAggregateInput
    _max?: JoinedObject1MaxOrderByAggregateInput
    _min?: JoinedObject1MinOrderByAggregateInput
  }

  export type JoinedObject1ScalarWhereWithAggregatesInput = {
    AND?: JoinedObject1ScalarWhereWithAggregatesInput | JoinedObject1ScalarWhereWithAggregatesInput[]
    OR?: JoinedObject1ScalarWhereWithAggregatesInput[]
    NOT?: JoinedObject1ScalarWhereWithAggregatesInput | JoinedObject1ScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"JoinedObject1"> | Uint8Array
    persisted?: StringNullableWithAggregatesFilter<"JoinedObject1"> | string | null
  }

  export type JoinedObject2WhereInput = {
    AND?: JoinedObject2WhereInput | JoinedObject2WhereInput[]
    OR?: JoinedObject2WhereInput[]
    NOT?: JoinedObject2WhereInput | JoinedObject2WhereInput[]
    id?: BytesFilter<"JoinedObject2"> | Uint8Array
    persisted?: StringNullableFilter<"JoinedObject2"> | string | null
    testObjects?: JoinTestObject2ListRelationFilter
  }

  export type JoinedObject2OrderByWithRelationInput = {
    id?: SortOrder
    persisted?: SortOrderInput | SortOrder
    testObjects?: JoinTestObject2OrderByRelationAggregateInput
  }

  export type JoinedObject2WhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    AND?: JoinedObject2WhereInput | JoinedObject2WhereInput[]
    OR?: JoinedObject2WhereInput[]
    NOT?: JoinedObject2WhereInput | JoinedObject2WhereInput[]
    persisted?: StringNullableFilter<"JoinedObject2"> | string | null
    testObjects?: JoinTestObject2ListRelationFilter
  }, "id">

  export type JoinedObject2OrderByWithAggregationInput = {
    id?: SortOrder
    persisted?: SortOrderInput | SortOrder
    _count?: JoinedObject2CountOrderByAggregateInput
    _max?: JoinedObject2MaxOrderByAggregateInput
    _min?: JoinedObject2MinOrderByAggregateInput
  }

  export type JoinedObject2ScalarWhereWithAggregatesInput = {
    AND?: JoinedObject2ScalarWhereWithAggregatesInput | JoinedObject2ScalarWhereWithAggregatesInput[]
    OR?: JoinedObject2ScalarWhereWithAggregatesInput[]
    NOT?: JoinedObject2ScalarWhereWithAggregatesInput | JoinedObject2ScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"JoinedObject2"> | Uint8Array
    persisted?: StringNullableWithAggregatesFilter<"JoinedObject2"> | string | null
  }

  export type JoinSelfReferenceWhereInput = {
    AND?: JoinSelfReferenceWhereInput | JoinSelfReferenceWhereInput[]
    OR?: JoinSelfReferenceWhereInput[]
    NOT?: JoinSelfReferenceWhereInput | JoinSelfReferenceWhereInput[]
    id?: BytesFilter<"JoinSelfReference"> | Uint8Array
    sourceId?: BytesFilter<"JoinSelfReference"> | Uint8Array
    targetId?: BytesFilter<"JoinSelfReference"> | Uint8Array
    joinProperty?: StringFilter<"JoinSelfReference"> | string
    source?: XOR<SelfReferencialJoinModelScalarRelationFilter, SelfReferencialJoinModelWhereInput>
    target?: XOR<SelfReferencialJoinModelScalarRelationFilter, SelfReferencialJoinModelWhereInput>
  }

  export type JoinSelfReferenceOrderByWithRelationInput = {
    id?: SortOrder
    sourceId?: SortOrder
    targetId?: SortOrder
    joinProperty?: SortOrder
    source?: SelfReferencialJoinModelOrderByWithRelationInput
    target?: SelfReferencialJoinModelOrderByWithRelationInput
  }

  export type JoinSelfReferenceWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    AND?: JoinSelfReferenceWhereInput | JoinSelfReferenceWhereInput[]
    OR?: JoinSelfReferenceWhereInput[]
    NOT?: JoinSelfReferenceWhereInput | JoinSelfReferenceWhereInput[]
    sourceId?: BytesFilter<"JoinSelfReference"> | Uint8Array
    targetId?: BytesFilter<"JoinSelfReference"> | Uint8Array
    joinProperty?: StringFilter<"JoinSelfReference"> | string
    source?: XOR<SelfReferencialJoinModelScalarRelationFilter, SelfReferencialJoinModelWhereInput>
    target?: XOR<SelfReferencialJoinModelScalarRelationFilter, SelfReferencialJoinModelWhereInput>
  }, "id">

  export type JoinSelfReferenceOrderByWithAggregationInput = {
    id?: SortOrder
    sourceId?: SortOrder
    targetId?: SortOrder
    joinProperty?: SortOrder
    _count?: JoinSelfReferenceCountOrderByAggregateInput
    _max?: JoinSelfReferenceMaxOrderByAggregateInput
    _min?: JoinSelfReferenceMinOrderByAggregateInput
  }

  export type JoinSelfReferenceScalarWhereWithAggregatesInput = {
    AND?: JoinSelfReferenceScalarWhereWithAggregatesInput | JoinSelfReferenceScalarWhereWithAggregatesInput[]
    OR?: JoinSelfReferenceScalarWhereWithAggregatesInput[]
    NOT?: JoinSelfReferenceScalarWhereWithAggregatesInput | JoinSelfReferenceScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"JoinSelfReference"> | Uint8Array
    sourceId?: BytesWithAggregatesFilter<"JoinSelfReference"> | Uint8Array
    targetId?: BytesWithAggregatesFilter<"JoinSelfReference"> | Uint8Array
    joinProperty?: StringWithAggregatesFilter<"JoinSelfReference"> | string
  }

  export type SelfReferencialJoinModelWhereInput = {
    AND?: SelfReferencialJoinModelWhereInput | SelfReferencialJoinModelWhereInput[]
    OR?: SelfReferencialJoinModelWhereInput[]
    NOT?: SelfReferencialJoinModelWhereInput | SelfReferencialJoinModelWhereInput[]
    id?: BytesFilter<"SelfReferencialJoinModel"> | Uint8Array
    joinsAsSource?: JoinSelfReferenceListRelationFilter
    joinsAsTarget?: JoinSelfReferenceListRelationFilter
  }

  export type SelfReferencialJoinModelOrderByWithRelationInput = {
    id?: SortOrder
    joinsAsSource?: JoinSelfReferenceOrderByRelationAggregateInput
    joinsAsTarget?: JoinSelfReferenceOrderByRelationAggregateInput
  }

  export type SelfReferencialJoinModelWhereUniqueInput = Prisma.AtLeast<{
    id?: Uint8Array
    AND?: SelfReferencialJoinModelWhereInput | SelfReferencialJoinModelWhereInput[]
    OR?: SelfReferencialJoinModelWhereInput[]
    NOT?: SelfReferencialJoinModelWhereInput | SelfReferencialJoinModelWhereInput[]
    joinsAsSource?: JoinSelfReferenceListRelationFilter
    joinsAsTarget?: JoinSelfReferenceListRelationFilter
  }, "id">

  export type SelfReferencialJoinModelOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: SelfReferencialJoinModelCountOrderByAggregateInput
    _max?: SelfReferencialJoinModelMaxOrderByAggregateInput
    _min?: SelfReferencialJoinModelMinOrderByAggregateInput
  }

  export type SelfReferencialJoinModelScalarWhereWithAggregatesInput = {
    AND?: SelfReferencialJoinModelScalarWhereWithAggregatesInput | SelfReferencialJoinModelScalarWhereWithAggregatesInput[]
    OR?: SelfReferencialJoinModelScalarWhereWithAggregatesInput[]
    NOT?: SelfReferencialJoinModelScalarWhereWithAggregatesInput | SelfReferencialJoinModelScalarWhereWithAggregatesInput[]
    id?: BytesWithAggregatesFilter<"SelfReferencialJoinModel"> | Uint8Array
  }

  export type TenetCreateInput = {
    id: Uint8Array
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenetInput
    logs?: LogCreateNestedManyWithoutTenetInput
    contacts?: ContactCreateNestedManyWithoutTenetInput
    activities?: ActivityCreateNestedManyWithoutTenetInput
    addresses?: AddressCreateNestedManyWithoutTenetInput
    contactEmails?: ContactEmailCreateNestedManyWithoutTenetInput
    contactPhones?: ContactPhoneCreateNestedManyWithoutTenetInput
    importantDates?: ImportantDateCreateNestedManyWithoutTenetInput
    attachments?: AttachmentCreateNestedManyWithoutTenetInput
    notes?: NoteCreateNestedManyWithoutTenetInput
    auditEvents?: AuditEventCreateNestedManyWithoutTenetInput
    contactTimelineEvents?: ContactTimelineEventCreateNestedManyWithoutTenetInput
    activitySteps?: ActivityStepCreateNestedManyWithoutTenetInput
    activityWaypoints?: ActivityWaypointCreateNestedManyWithoutTenetInput
    templateAssignments?: TemplateAssignmentCreateNestedManyWithoutTenetInput
    activityWaypointTemplates?: ActivityWaypointTemplateCreateNestedManyWithoutTenetInput
    activityTemplates?: ActivityTemplateCreateNestedManyWithoutTenetInput
    activityTemplateSteps?: ActivityTemplateStepCreateNestedManyWithoutTenetInput
    opportunities?: OpportunityCreateNestedManyWithoutTenetInput
    products?: ProductTypeCreateNestedManyWithoutTenetInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentCreateNestedManyWithoutTenetInput
  }

  export type TenetUncheckedCreateInput = {
    id: Uint8Array
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenetInput
    logs?: LogUncheckedCreateNestedManyWithoutTenetInput
    contacts?: ContactUncheckedCreateNestedManyWithoutTenetInput
    activities?: ActivityUncheckedCreateNestedManyWithoutTenetInput
    addresses?: AddressUncheckedCreateNestedManyWithoutTenetInput
    contactEmails?: ContactEmailUncheckedCreateNestedManyWithoutTenetInput
    contactPhones?: ContactPhoneUncheckedCreateNestedManyWithoutTenetInput
    importantDates?: ImportantDateUncheckedCreateNestedManyWithoutTenetInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTenetInput
    notes?: NoteUncheckedCreateNestedManyWithoutTenetInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutTenetInput
    contactTimelineEvents?: ContactTimelineEventUncheckedCreateNestedManyWithoutTenetInput
    activitySteps?: ActivityStepUncheckedCreateNestedManyWithoutTenetInput
    activityWaypoints?: ActivityWaypointUncheckedCreateNestedManyWithoutTenetInput
    templateAssignments?: TemplateAssignmentUncheckedCreateNestedManyWithoutTenetInput
    activityWaypointTemplates?: ActivityWaypointTemplateUncheckedCreateNestedManyWithoutTenetInput
    activityTemplates?: ActivityTemplateUncheckedCreateNestedManyWithoutTenetInput
    activityTemplateSteps?: ActivityTemplateStepUncheckedCreateNestedManyWithoutTenetInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutTenetInput
    products?: ProductTypeUncheckedCreateNestedManyWithoutTenetInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentUncheckedCreateNestedManyWithoutTenetInput
  }

  export type TenetUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenetNestedInput
    logs?: LogUpdateManyWithoutTenetNestedInput
    contacts?: ContactUpdateManyWithoutTenetNestedInput
    activities?: ActivityUpdateManyWithoutTenetNestedInput
    addresses?: AddressUpdateManyWithoutTenetNestedInput
    contactEmails?: ContactEmailUpdateManyWithoutTenetNestedInput
    contactPhones?: ContactPhoneUpdateManyWithoutTenetNestedInput
    importantDates?: ImportantDateUpdateManyWithoutTenetNestedInput
    attachments?: AttachmentUpdateManyWithoutTenetNestedInput
    notes?: NoteUpdateManyWithoutTenetNestedInput
    auditEvents?: AuditEventUpdateManyWithoutTenetNestedInput
    contactTimelineEvents?: ContactTimelineEventUpdateManyWithoutTenetNestedInput
    activitySteps?: ActivityStepUpdateManyWithoutTenetNestedInput
    activityWaypoints?: ActivityWaypointUpdateManyWithoutTenetNestedInput
    templateAssignments?: TemplateAssignmentUpdateManyWithoutTenetNestedInput
    activityWaypointTemplates?: ActivityWaypointTemplateUpdateManyWithoutTenetNestedInput
    activityTemplates?: ActivityTemplateUpdateManyWithoutTenetNestedInput
    activityTemplateSteps?: ActivityTemplateStepUpdateManyWithoutTenetNestedInput
    opportunities?: OpportunityUpdateManyWithoutTenetNestedInput
    products?: ProductTypeUpdateManyWithoutTenetNestedInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentUpdateManyWithoutTenetNestedInput
  }

  export type TenetUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenetNestedInput
    logs?: LogUncheckedUpdateManyWithoutTenetNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutTenetNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutTenetNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutTenetNestedInput
    contactEmails?: ContactEmailUncheckedUpdateManyWithoutTenetNestedInput
    contactPhones?: ContactPhoneUncheckedUpdateManyWithoutTenetNestedInput
    importantDates?: ImportantDateUncheckedUpdateManyWithoutTenetNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTenetNestedInput
    notes?: NoteUncheckedUpdateManyWithoutTenetNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutTenetNestedInput
    contactTimelineEvents?: ContactTimelineEventUncheckedUpdateManyWithoutTenetNestedInput
    activitySteps?: ActivityStepUncheckedUpdateManyWithoutTenetNestedInput
    activityWaypoints?: ActivityWaypointUncheckedUpdateManyWithoutTenetNestedInput
    templateAssignments?: TemplateAssignmentUncheckedUpdateManyWithoutTenetNestedInput
    activityWaypointTemplates?: ActivityWaypointTemplateUncheckedUpdateManyWithoutTenetNestedInput
    activityTemplates?: ActivityTemplateUncheckedUpdateManyWithoutTenetNestedInput
    activityTemplateSteps?: ActivityTemplateStepUncheckedUpdateManyWithoutTenetNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutTenetNestedInput
    products?: ProductTypeUncheckedUpdateManyWithoutTenetNestedInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentUncheckedUpdateManyWithoutTenetNestedInput
  }

  export type TenetCreateManyInput = {
    id: Uint8Array
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenetUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenetUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id: Uint8Array
    email: string
    firstName: string
    lastName: string
    fullName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password: string
    enabled?: boolean
    type?: $Enums.AccessGroup
    system?: boolean
    deleted?: boolean
    deletedAt?: Date | string | null
    tokens?: TokenCreateNestedManyWithoutUserInput
    tenet?: TenetCreateNestedOneWithoutUsersInput
    activities?: ActivityUserJoinCreateNestedManyWithoutUserRelationInput
    notes?: NoteCreateNestedManyWithoutAuthorInput
    waypoints?: UserWaypointJoinCreateNestedManyWithoutUserRelationInput
    events?: ContactTimelineEventCreateNestedManyWithoutUserInput
    auditEvents?: AuditEventCreateNestedManyWithoutUserInput
    templateAssignments?: TemplateAssignmentCreateNestedManyWithoutSpecificUserInput
    assignedActivities?: ActivityCreateNestedManyWithoutAssignedByInput
    opportunities?: UserOpportunityJoinCreateNestedManyWithoutUserRelationInput
    activitySteps?: ActivityStepUserJoinCreateNestedManyWithoutUserRelationInput
    templateStepAssignments?: ActivityTemplateStepAssignmentCreateNestedManyWithoutSpecificUserInput
  }

  export type UserUncheckedCreateInput = {
    id: Uint8Array
    email: string
    firstName: string
    lastName: string
    fullName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password: string
    enabled?: boolean
    type?: $Enums.AccessGroup
    tenetId?: Uint8Array | null
    system?: boolean
    deleted?: boolean
    deletedAt?: Date | string | null
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUserJoinUncheckedCreateNestedManyWithoutUserRelationInput
    notes?: NoteUncheckedCreateNestedManyWithoutAuthorInput
    waypoints?: UserWaypointJoinUncheckedCreateNestedManyWithoutUserRelationInput
    events?: ContactTimelineEventUncheckedCreateNestedManyWithoutUserInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutUserInput
    templateAssignments?: TemplateAssignmentUncheckedCreateNestedManyWithoutSpecificUserInput
    assignedActivities?: ActivityUncheckedCreateNestedManyWithoutAssignedByInput
    opportunities?: UserOpportunityJoinUncheckedCreateNestedManyWithoutUserRelationInput
    activitySteps?: ActivityStepUserJoinUncheckedCreateNestedManyWithoutUserRelationInput
    templateStepAssignments?: ActivityTemplateStepAssignmentUncheckedCreateNestedManyWithoutSpecificUserInput
  }

  export type UserUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumAccessGroupFieldUpdateOperationsInput | $Enums.AccessGroup
    system?: BoolFieldUpdateOperationsInput | boolean
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokens?: TokenUpdateManyWithoutUserNestedInput
    tenet?: TenetUpdateOneWithoutUsersNestedInput
    activities?: ActivityUserJoinUpdateManyWithoutUserRelationNestedInput
    notes?: NoteUpdateManyWithoutAuthorNestedInput
    waypoints?: UserWaypointJoinUpdateManyWithoutUserRelationNestedInput
    events?: ContactTimelineEventUpdateManyWithoutUserNestedInput
    auditEvents?: AuditEventUpdateManyWithoutUserNestedInput
    templateAssignments?: TemplateAssignmentUpdateManyWithoutSpecificUserNestedInput
    assignedActivities?: ActivityUpdateManyWithoutAssignedByNestedInput
    opportunities?: UserOpportunityJoinUpdateManyWithoutUserRelationNestedInput
    activitySteps?: ActivityStepUserJoinUpdateManyWithoutUserRelationNestedInput
    templateStepAssignments?: ActivityTemplateStepAssignmentUpdateManyWithoutSpecificUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumAccessGroupFieldUpdateOperationsInput | $Enums.AccessGroup
    tenetId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    system?: BoolFieldUpdateOperationsInput | boolean
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUserJoinUncheckedUpdateManyWithoutUserRelationNestedInput
    notes?: NoteUncheckedUpdateManyWithoutAuthorNestedInput
    waypoints?: UserWaypointJoinUncheckedUpdateManyWithoutUserRelationNestedInput
    events?: ContactTimelineEventUncheckedUpdateManyWithoutUserNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutUserNestedInput
    templateAssignments?: TemplateAssignmentUncheckedUpdateManyWithoutSpecificUserNestedInput
    assignedActivities?: ActivityUncheckedUpdateManyWithoutAssignedByNestedInput
    opportunities?: UserOpportunityJoinUncheckedUpdateManyWithoutUserRelationNestedInput
    activitySteps?: ActivityStepUserJoinUncheckedUpdateManyWithoutUserRelationNestedInput
    templateStepAssignments?: ActivityTemplateStepAssignmentUncheckedUpdateManyWithoutSpecificUserNestedInput
  }

  export type UserCreateManyInput = {
    id: Uint8Array
    email: string
    firstName: string
    lastName: string
    fullName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password: string
    enabled?: boolean
    type?: $Enums.AccessGroup
    tenetId?: Uint8Array | null
    system?: boolean
    deleted?: boolean
    deletedAt?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumAccessGroupFieldUpdateOperationsInput | $Enums.AccessGroup
    system?: BoolFieldUpdateOperationsInput | boolean
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumAccessGroupFieldUpdateOperationsInput | $Enums.AccessGroup
    tenetId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    system?: BoolFieldUpdateOperationsInput | boolean
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContactCreateInput = {
    id: Uint8Array
    firstName?: string | null
    lastName: string
    fullName: string
    importantNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.ContactType
    status: $Enums.ContactStatus
    lifecycleStage?: $Enums.LifecycleStage | null
    lastContactedDate?: Date | string | null
    followUpDate?: Date | string | null
    householdStatus?: $Enums.HouseholdRelationshipStatus | null
    position?: string | null
    companyStatus?: $Enums.CompanyRelationshipStatus | null
    industry?: string | null
    website?: string | null
    size?: number | null
    deleted?: boolean
    deletedAt?: Date | string | null
    tenet: TenetCreateNestedOneWithoutContactsInput
    notes?: NoteCreateNestedManyWithoutContactInput
    timelineEvents?: ContactTimelineEventContactJoinCreateNestedManyWithoutContactRelationInput
    addresses?: AddressCreateNestedManyWithoutContactInput
    emails?: ContactEmailCreateNestedManyWithoutContactInput
    phones?: ContactPhoneCreateNestedManyWithoutContactInput
    importantDates?: ImportantDateCreateNestedManyWithoutContactInput
    activities?: ActivityContactJoinCreateNestedManyWithoutContactRelationInput
    household?: ContactCreateNestedOneWithoutHouseholdMembersInput
    headOfHouseholdFor?: ContactCreateNestedOneWithoutHeadOfHouseholdInput
    company?: ContactCreateNestedOneWithoutEmployeesInput
    primaryContactFor?: ContactCreateNestedOneWithoutPrimaryContactInput
    headOfHousehold?: ContactCreateNestedOneWithoutHeadOfHouseholdForInput
    householdMembers?: ContactCreateNestedManyWithoutHouseholdInput
    employees?: ContactCreateNestedManyWithoutCompanyInput
    primaryContact?: ContactCreateNestedOneWithoutPrimaryContactForInput
    opportunities?: ContactOpportunityJoinCreateNestedManyWithoutContactRelationInput
    relationAsSource?: ContactRelationshipCreateNestedManyWithoutSourceInput
    relationAsTarget?: ContactRelationshipCreateNestedManyWithoutTargetInput
  }

  export type ContactUncheckedCreateInput = {
    id: Uint8Array
    firstName?: string | null
    lastName: string
    fullName: string
    tenetId: Uint8Array
    importantNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.ContactType
    status: $Enums.ContactStatus
    lifecycleStage?: $Enums.LifecycleStage | null
    lastContactedDate?: Date | string | null
    followUpDate?: Date | string | null
    householdId?: Uint8Array | null
    householdStatus?: $Enums.HouseholdRelationshipStatus | null
    companyId?: Uint8Array | null
    position?: string | null
    companyStatus?: $Enums.CompanyRelationshipStatus | null
    headOfHouseholdId?: Uint8Array | null
    industry?: string | null
    website?: string | null
    size?: number | null
    primaryContactId?: Uint8Array | null
    deleted?: boolean
    deletedAt?: Date | string | null
    notes?: NoteUncheckedCreateNestedManyWithoutContactInput
    timelineEvents?: ContactTimelineEventContactJoinUncheckedCreateNestedManyWithoutContactRelationInput
    addresses?: AddressUncheckedCreateNestedManyWithoutContactInput
    emails?: ContactEmailUncheckedCreateNestedManyWithoutContactInput
    phones?: ContactPhoneUncheckedCreateNestedManyWithoutContactInput
    importantDates?: ImportantDateUncheckedCreateNestedManyWithoutContactInput
    activities?: ActivityContactJoinUncheckedCreateNestedManyWithoutContactRelationInput
    headOfHouseholdFor?: ContactUncheckedCreateNestedOneWithoutHeadOfHouseholdInput
    primaryContactFor?: ContactUncheckedCreateNestedOneWithoutPrimaryContactInput
    householdMembers?: ContactUncheckedCreateNestedManyWithoutHouseholdInput
    employees?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    opportunities?: ContactOpportunityJoinUncheckedCreateNestedManyWithoutContactRelationInput
    relationAsSource?: ContactRelationshipUncheckedCreateNestedManyWithoutSourceInput
    relationAsTarget?: ContactRelationshipUncheckedCreateNestedManyWithoutTargetInput
  }

  export type ContactUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    importantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    lifecycleStage?: NullableEnumLifecycleStageFieldUpdateOperationsInput | $Enums.LifecycleStage | null
    lastContactedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    householdStatus?: NullableEnumHouseholdRelationshipStatusFieldUpdateOperationsInput | $Enums.HouseholdRelationshipStatus | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyStatus?: NullableEnumCompanyRelationshipStatusFieldUpdateOperationsInput | $Enums.CompanyRelationshipStatus | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenet?: TenetUpdateOneRequiredWithoutContactsNestedInput
    notes?: NoteUpdateManyWithoutContactNestedInput
    timelineEvents?: ContactTimelineEventContactJoinUpdateManyWithoutContactRelationNestedInput
    addresses?: AddressUpdateManyWithoutContactNestedInput
    emails?: ContactEmailUpdateManyWithoutContactNestedInput
    phones?: ContactPhoneUpdateManyWithoutContactNestedInput
    importantDates?: ImportantDateUpdateManyWithoutContactNestedInput
    activities?: ActivityContactJoinUpdateManyWithoutContactRelationNestedInput
    household?: ContactUpdateOneWithoutHouseholdMembersNestedInput
    headOfHouseholdFor?: ContactUpdateOneWithoutHeadOfHouseholdNestedInput
    company?: ContactUpdateOneWithoutEmployeesNestedInput
    primaryContactFor?: ContactUpdateOneWithoutPrimaryContactNestedInput
    headOfHousehold?: ContactUpdateOneWithoutHeadOfHouseholdForNestedInput
    householdMembers?: ContactUpdateManyWithoutHouseholdNestedInput
    employees?: ContactUpdateManyWithoutCompanyNestedInput
    primaryContact?: ContactUpdateOneWithoutPrimaryContactForNestedInput
    opportunities?: ContactOpportunityJoinUpdateManyWithoutContactRelationNestedInput
    relationAsSource?: ContactRelationshipUpdateManyWithoutSourceNestedInput
    relationAsTarget?: ContactRelationshipUpdateManyWithoutTargetNestedInput
  }

  export type ContactUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    importantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    lifecycleStage?: NullableEnumLifecycleStageFieldUpdateOperationsInput | $Enums.LifecycleStage | null
    lastContactedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    householdId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    householdStatus?: NullableEnumHouseholdRelationshipStatusFieldUpdateOperationsInput | $Enums.HouseholdRelationshipStatus | null
    companyId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyStatus?: NullableEnumCompanyRelationshipStatusFieldUpdateOperationsInput | $Enums.CompanyRelationshipStatus | null
    headOfHouseholdId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    primaryContactId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NoteUncheckedUpdateManyWithoutContactNestedInput
    timelineEvents?: ContactTimelineEventContactJoinUncheckedUpdateManyWithoutContactRelationNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutContactNestedInput
    emails?: ContactEmailUncheckedUpdateManyWithoutContactNestedInput
    phones?: ContactPhoneUncheckedUpdateManyWithoutContactNestedInput
    importantDates?: ImportantDateUncheckedUpdateManyWithoutContactNestedInput
    activities?: ActivityContactJoinUncheckedUpdateManyWithoutContactRelationNestedInput
    headOfHouseholdFor?: ContactUncheckedUpdateOneWithoutHeadOfHouseholdNestedInput
    primaryContactFor?: ContactUncheckedUpdateOneWithoutPrimaryContactNestedInput
    householdMembers?: ContactUncheckedUpdateManyWithoutHouseholdNestedInput
    employees?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    opportunities?: ContactOpportunityJoinUncheckedUpdateManyWithoutContactRelationNestedInput
    relationAsSource?: ContactRelationshipUncheckedUpdateManyWithoutSourceNestedInput
    relationAsTarget?: ContactRelationshipUncheckedUpdateManyWithoutTargetNestedInput
  }

  export type ContactCreateManyInput = {
    id: Uint8Array
    firstName?: string | null
    lastName: string
    fullName: string
    tenetId: Uint8Array
    importantNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.ContactType
    status: $Enums.ContactStatus
    lifecycleStage?: $Enums.LifecycleStage | null
    lastContactedDate?: Date | string | null
    followUpDate?: Date | string | null
    householdId?: Uint8Array | null
    householdStatus?: $Enums.HouseholdRelationshipStatus | null
    companyId?: Uint8Array | null
    position?: string | null
    companyStatus?: $Enums.CompanyRelationshipStatus | null
    headOfHouseholdId?: Uint8Array | null
    industry?: string | null
    website?: string | null
    size?: number | null
    primaryContactId?: Uint8Array | null
    deleted?: boolean
    deletedAt?: Date | string | null
  }

  export type ContactUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    importantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    lifecycleStage?: NullableEnumLifecycleStageFieldUpdateOperationsInput | $Enums.LifecycleStage | null
    lastContactedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    householdStatus?: NullableEnumHouseholdRelationshipStatusFieldUpdateOperationsInput | $Enums.HouseholdRelationshipStatus | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyStatus?: NullableEnumCompanyRelationshipStatusFieldUpdateOperationsInput | $Enums.CompanyRelationshipStatus | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContactUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    importantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    lifecycleStage?: NullableEnumLifecycleStageFieldUpdateOperationsInput | $Enums.LifecycleStage | null
    lastContactedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    householdId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    householdStatus?: NullableEnumHouseholdRelationshipStatusFieldUpdateOperationsInput | $Enums.HouseholdRelationshipStatus | null
    companyId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyStatus?: NullableEnumCompanyRelationshipStatusFieldUpdateOperationsInput | $Enums.CompanyRelationshipStatus | null
    headOfHouseholdId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    primaryContactId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContactRelationshipCreateInput = {
    id: Uint8Array
    type: string
    established?: Date | string | null
    notes?: string | null
    source: ContactCreateNestedOneWithoutRelationAsSourceInput
    target: ContactCreateNestedOneWithoutRelationAsTargetInput
  }

  export type ContactRelationshipUncheckedCreateInput = {
    id: Uint8Array
    sourceId: Uint8Array
    targetId: Uint8Array
    type: string
    established?: Date | string | null
    notes?: string | null
  }

  export type ContactRelationshipUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    type?: StringFieldUpdateOperationsInput | string
    established?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    source?: ContactUpdateOneRequiredWithoutRelationAsSourceNestedInput
    target?: ContactUpdateOneRequiredWithoutRelationAsTargetNestedInput
  }

  export type ContactRelationshipUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    sourceId?: BytesFieldUpdateOperationsInput | Uint8Array
    targetId?: BytesFieldUpdateOperationsInput | Uint8Array
    type?: StringFieldUpdateOperationsInput | string
    established?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContactRelationshipCreateManyInput = {
    id: Uint8Array
    sourceId: Uint8Array
    targetId: Uint8Array
    type: string
    established?: Date | string | null
    notes?: string | null
  }

  export type ContactRelationshipUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    type?: StringFieldUpdateOperationsInput | string
    established?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContactRelationshipUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    sourceId?: BytesFieldUpdateOperationsInput | Uint8Array
    targetId?: BytesFieldUpdateOperationsInput | Uint8Array
    type?: StringFieldUpdateOperationsInput | string
    established?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ActivityStepCreateInput = {
    id: Uint8Array
    title: string
    completed: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    type?: $Enums.ActivityStepType
    order: number
    activity: ActivityCreateNestedOneWithoutStepsInput
    assignedTo?: ActivityStepUserJoinCreateNestedManyWithoutStepRelationInput
    tenet: TenetCreateNestedOneWithoutActivityStepsInput
  }

  export type ActivityStepUncheckedCreateInput = {
    id: Uint8Array
    title: string
    completed: boolean
    activityId: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
    type?: $Enums.ActivityStepType
    order: number
    assignedTo?: ActivityStepUserJoinUncheckedCreateNestedManyWithoutStepRelationInput
  }

  export type ActivityStepUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumActivityStepTypeFieldUpdateOperationsInput | $Enums.ActivityStepType
    order?: IntFieldUpdateOperationsInput | number
    activity?: ActivityUpdateOneRequiredWithoutStepsNestedInput
    assignedTo?: ActivityStepUserJoinUpdateManyWithoutStepRelationNestedInput
    tenet?: TenetUpdateOneRequiredWithoutActivityStepsNestedInput
  }

  export type ActivityStepUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    activityId?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    type?: EnumActivityStepTypeFieldUpdateOperationsInput | $Enums.ActivityStepType
    order?: IntFieldUpdateOperationsInput | number
    assignedTo?: ActivityStepUserJoinUncheckedUpdateManyWithoutStepRelationNestedInput
  }

  export type ActivityStepCreateManyInput = {
    id: Uint8Array
    title: string
    completed: boolean
    activityId: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
    type?: $Enums.ActivityStepType
    order: number
  }

  export type ActivityStepUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumActivityStepTypeFieldUpdateOperationsInput | $Enums.ActivityStepType
    order?: IntFieldUpdateOperationsInput | number
  }

  export type ActivityStepUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    activityId?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    type?: EnumActivityStepTypeFieldUpdateOperationsInput | $Enums.ActivityStepType
    order?: IntFieldUpdateOperationsInput | number
  }

  export type ActivityStepUserJoinCreateInput = {
    stepRelation: ActivityStepCreateNestedOneWithoutAssignedToInput
    userRelation: UserCreateNestedOneWithoutActivityStepsInput
  }

  export type ActivityStepUserJoinUncheckedCreateInput = {
    activityStepId: Uint8Array
    userId: Uint8Array
  }

  export type ActivityStepUserJoinUpdateInput = {
    stepRelation?: ActivityStepUpdateOneRequiredWithoutAssignedToNestedInput
    userRelation?: UserUpdateOneRequiredWithoutActivityStepsNestedInput
  }

  export type ActivityStepUserJoinUncheckedUpdateInput = {
    activityStepId?: BytesFieldUpdateOperationsInput | Uint8Array
    userId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type ActivityStepUserJoinCreateManyInput = {
    activityStepId: Uint8Array
    userId: Uint8Array
  }

  export type ActivityStepUserJoinUpdateManyMutationInput = {

  }

  export type ActivityStepUserJoinUncheckedUpdateManyInput = {
    activityStepId?: BytesFieldUpdateOperationsInput | Uint8Array
    userId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type UserWaypointJoinCreateInput = {
    userRelation: UserCreateNestedOneWithoutWaypointsInput
    waypointRelation: ActivityWaypointCreateNestedOneWithoutUsersInput
  }

  export type UserWaypointJoinUncheckedCreateInput = {
    userId: Uint8Array
    waypointId: Uint8Array
  }

  export type UserWaypointJoinUpdateInput = {
    userRelation?: UserUpdateOneRequiredWithoutWaypointsNestedInput
    waypointRelation?: ActivityWaypointUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserWaypointJoinUncheckedUpdateInput = {
    userId?: BytesFieldUpdateOperationsInput | Uint8Array
    waypointId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type UserWaypointJoinCreateManyInput = {
    userId: Uint8Array
    waypointId: Uint8Array
  }

  export type UserWaypointJoinUpdateManyMutationInput = {

  }

  export type UserWaypointJoinUncheckedUpdateManyInput = {
    userId?: BytesFieldUpdateOperationsInput | Uint8Array
    waypointId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type ActivityWaypointCreateInput = {
    id: Uint8Array
    title: string
    description?: string | null
    summary?: string | null
    status: $Enums.ActivityStatus
    order: number
    actualStart: Date | string
    dueDate: Date | string
    actualEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserWaypointJoinCreateNestedManyWithoutWaypointRelationInput
    activity: ActivityCreateNestedOneWithoutWaypointsInput
    childActivities?: ActivityCreateNestedManyWithoutParentWaypointInput
    template?: ActivityWaypointTemplateCreateNestedOneWithoutWaypointsInput
    events?: ContactTimelineEventCreateNestedManyWithoutWaypointInput
    tenet: TenetCreateNestedOneWithoutActivityWaypointsInput
    Note?: NoteCreateNestedManyWithoutWaypointInput
  }

  export type ActivityWaypointUncheckedCreateInput = {
    id: Uint8Array
    title: string
    description?: string | null
    summary?: string | null
    status: $Enums.ActivityStatus
    order: number
    actualStart: Date | string
    dueDate: Date | string
    actualEnd?: Date | string | null
    activityId: Uint8Array
    templateId?: Uint8Array | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
    users?: UserWaypointJoinUncheckedCreateNestedManyWithoutWaypointRelationInput
    childActivities?: ActivityUncheckedCreateNestedManyWithoutParentWaypointInput
    events?: ContactTimelineEventUncheckedCreateNestedManyWithoutWaypointInput
    Note?: NoteUncheckedCreateNestedManyWithoutWaypointInput
  }

  export type ActivityWaypointUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    order?: IntFieldUpdateOperationsInput | number
    actualStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserWaypointJoinUpdateManyWithoutWaypointRelationNestedInput
    activity?: ActivityUpdateOneRequiredWithoutWaypointsNestedInput
    childActivities?: ActivityUpdateManyWithoutParentWaypointNestedInput
    template?: ActivityWaypointTemplateUpdateOneWithoutWaypointsNestedInput
    events?: ContactTimelineEventUpdateManyWithoutWaypointNestedInput
    tenet?: TenetUpdateOneRequiredWithoutActivityWaypointsNestedInput
    Note?: NoteUpdateManyWithoutWaypointNestedInput
  }

  export type ActivityWaypointUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    order?: IntFieldUpdateOperationsInput | number
    actualStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activityId?: BytesFieldUpdateOperationsInput | Uint8Array
    templateId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    users?: UserWaypointJoinUncheckedUpdateManyWithoutWaypointRelationNestedInput
    childActivities?: ActivityUncheckedUpdateManyWithoutParentWaypointNestedInput
    events?: ContactTimelineEventUncheckedUpdateManyWithoutWaypointNestedInput
    Note?: NoteUncheckedUpdateManyWithoutWaypointNestedInput
  }

  export type ActivityWaypointCreateManyInput = {
    id: Uint8Array
    title: string
    description?: string | null
    summary?: string | null
    status: $Enums.ActivityStatus
    order: number
    actualStart: Date | string
    dueDate: Date | string
    actualEnd?: Date | string | null
    activityId: Uint8Array
    templateId?: Uint8Array | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
  }

  export type ActivityWaypointUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    order?: IntFieldUpdateOperationsInput | number
    actualStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityWaypointUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    order?: IntFieldUpdateOperationsInput | number
    actualStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activityId?: BytesFieldUpdateOperationsInput | Uint8Array
    templateId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type TemplateAssignmentCreateInput = {
    id: Uint8Array
    specificRole?: $Enums.Role | null
    createdAt?: Date | string
    updatedAt?: Date | string
    specificUser?: UserCreateNestedOneWithoutTemplateAssignmentsInput
    activityTemplate?: ActivityTemplateCreateNestedOneWithoutAssignmentsInput
    waypointTemplate?: ActivityWaypointTemplateCreateNestedOneWithoutAssignmentsInput
    tenet: TenetCreateNestedOneWithoutTemplateAssignmentsInput
  }

  export type TemplateAssignmentUncheckedCreateInput = {
    id: Uint8Array
    specificUserId?: Uint8Array | null
    specificRole?: $Enums.Role | null
    activityTemplateId?: Uint8Array | null
    waypointTemplateId?: Uint8Array | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
  }

  export type TemplateAssignmentUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    specificRole?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    specificUser?: UserUpdateOneWithoutTemplateAssignmentsNestedInput
    activityTemplate?: ActivityTemplateUpdateOneWithoutAssignmentsNestedInput
    waypointTemplate?: ActivityWaypointTemplateUpdateOneWithoutAssignmentsNestedInput
    tenet?: TenetUpdateOneRequiredWithoutTemplateAssignmentsNestedInput
  }

  export type TemplateAssignmentUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    specificUserId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    specificRole?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    activityTemplateId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    waypointTemplateId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type TemplateAssignmentCreateManyInput = {
    id: Uint8Array
    specificUserId?: Uint8Array | null
    specificRole?: $Enums.Role | null
    activityTemplateId?: Uint8Array | null
    waypointTemplateId?: Uint8Array | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
  }

  export type TemplateAssignmentUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    specificRole?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateAssignmentUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    specificUserId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    specificRole?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    activityTemplateId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    waypointTemplateId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type ActivityWaypointTemplateCreateInput = {
    id: Uint8Array
    title: string
    description?: string | null
    defaultStatus: $Enums.ActivityStatus
    order: number
    dateOffsetType: $Enums.DateOffsetType
    dueDate: number
    createdAt?: Date | string
    updatedAt?: Date | string
    parentActivity: ActivityTemplateCreateNestedOneWithoutWaypointsInput
    activities?: ActivityTemplateCreateNestedManyWithoutParentWaypointInput
    waypoints?: ActivityWaypointCreateNestedManyWithoutTemplateInput
    assignments?: TemplateAssignmentCreateNestedManyWithoutWaypointTemplateInput
    tenet: TenetCreateNestedOneWithoutActivityWaypointTemplatesInput
  }

  export type ActivityWaypointTemplateUncheckedCreateInput = {
    id: Uint8Array
    title: string
    description?: string | null
    defaultStatus: $Enums.ActivityStatus
    order: number
    dateOffsetType: $Enums.DateOffsetType
    dueDate: number
    parentActivityId: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
    activities?: ActivityTemplateUncheckedCreateNestedManyWithoutParentWaypointInput
    waypoints?: ActivityWaypointUncheckedCreateNestedManyWithoutTemplateInput
    assignments?: TemplateAssignmentUncheckedCreateNestedManyWithoutWaypointTemplateInput
  }

  export type ActivityWaypointTemplateUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultStatus?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    order?: IntFieldUpdateOperationsInput | number
    dateOffsetType?: EnumDateOffsetTypeFieldUpdateOperationsInput | $Enums.DateOffsetType
    dueDate?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentActivity?: ActivityTemplateUpdateOneRequiredWithoutWaypointsNestedInput
    activities?: ActivityTemplateUpdateManyWithoutParentWaypointNestedInput
    waypoints?: ActivityWaypointUpdateManyWithoutTemplateNestedInput
    assignments?: TemplateAssignmentUpdateManyWithoutWaypointTemplateNestedInput
    tenet?: TenetUpdateOneRequiredWithoutActivityWaypointTemplatesNestedInput
  }

  export type ActivityWaypointTemplateUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultStatus?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    order?: IntFieldUpdateOperationsInput | number
    dateOffsetType?: EnumDateOffsetTypeFieldUpdateOperationsInput | $Enums.DateOffsetType
    dueDate?: IntFieldUpdateOperationsInput | number
    parentActivityId?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    activities?: ActivityTemplateUncheckedUpdateManyWithoutParentWaypointNestedInput
    waypoints?: ActivityWaypointUncheckedUpdateManyWithoutTemplateNestedInput
    assignments?: TemplateAssignmentUncheckedUpdateManyWithoutWaypointTemplateNestedInput
  }

  export type ActivityWaypointTemplateCreateManyInput = {
    id: Uint8Array
    title: string
    description?: string | null
    defaultStatus: $Enums.ActivityStatus
    order: number
    dateOffsetType: $Enums.DateOffsetType
    dueDate: number
    parentActivityId: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
  }

  export type ActivityWaypointTemplateUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultStatus?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    order?: IntFieldUpdateOperationsInput | number
    dateOffsetType?: EnumDateOffsetTypeFieldUpdateOperationsInput | $Enums.DateOffsetType
    dueDate?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityWaypointTemplateUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultStatus?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    order?: IntFieldUpdateOperationsInput | number
    dateOffsetType?: EnumDateOffsetTypeFieldUpdateOperationsInput | $Enums.DateOffsetType
    dueDate?: IntFieldUpdateOperationsInput | number
    parentActivityId?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type ActivityTemplateStepCreateInput = {
    id: Uint8Array
    order: number
    title: string
    type?: $Enums.ActivityStepType
    activityTemplate: ActivityTemplateCreateNestedOneWithoutStepsInput
    tenet: TenetCreateNestedOneWithoutActivityTemplateStepsInput
    assignedTo?: ActivityTemplateStepAssignmentCreateNestedManyWithoutActivityTemplateStepInput
  }

  export type ActivityTemplateStepUncheckedCreateInput = {
    id: Uint8Array
    order: number
    title: string
    type?: $Enums.ActivityStepType
    activityTemplateId: Uint8Array
    tenetId: Uint8Array
    assignedTo?: ActivityTemplateStepAssignmentUncheckedCreateNestedManyWithoutActivityTemplateStepInput
  }

  export type ActivityTemplateStepUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityStepTypeFieldUpdateOperationsInput | $Enums.ActivityStepType
    activityTemplate?: ActivityTemplateUpdateOneRequiredWithoutStepsNestedInput
    tenet?: TenetUpdateOneRequiredWithoutActivityTemplateStepsNestedInput
    assignedTo?: ActivityTemplateStepAssignmentUpdateManyWithoutActivityTemplateStepNestedInput
  }

  export type ActivityTemplateStepUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityStepTypeFieldUpdateOperationsInput | $Enums.ActivityStepType
    activityTemplateId?: BytesFieldUpdateOperationsInput | Uint8Array
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    assignedTo?: ActivityTemplateStepAssignmentUncheckedUpdateManyWithoutActivityTemplateStepNestedInput
  }

  export type ActivityTemplateStepCreateManyInput = {
    id: Uint8Array
    order: number
    title: string
    type?: $Enums.ActivityStepType
    activityTemplateId: Uint8Array
    tenetId: Uint8Array
  }

  export type ActivityTemplateStepUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityStepTypeFieldUpdateOperationsInput | $Enums.ActivityStepType
  }

  export type ActivityTemplateStepUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityStepTypeFieldUpdateOperationsInput | $Enums.ActivityStepType
    activityTemplateId?: BytesFieldUpdateOperationsInput | Uint8Array
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type ActivityTemplateStepAssignmentCreateInput = {
    id: Uint8Array
    specificRole?: $Enums.Role | null
    specificUser?: UserCreateNestedOneWithoutTemplateStepAssignmentsInput
    activityTemplateStep: ActivityTemplateStepCreateNestedOneWithoutAssignedToInput
    tenet: TenetCreateNestedOneWithoutActivityTemplateStepAssignmentInput
  }

  export type ActivityTemplateStepAssignmentUncheckedCreateInput = {
    id: Uint8Array
    specificUserId?: Uint8Array | null
    specificRole?: $Enums.Role | null
    activityTemplateStepId: Uint8Array
    tenetId: Uint8Array
  }

  export type ActivityTemplateStepAssignmentUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    specificRole?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    specificUser?: UserUpdateOneWithoutTemplateStepAssignmentsNestedInput
    activityTemplateStep?: ActivityTemplateStepUpdateOneRequiredWithoutAssignedToNestedInput
    tenet?: TenetUpdateOneRequiredWithoutActivityTemplateStepAssignmentNestedInput
  }

  export type ActivityTemplateStepAssignmentUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    specificUserId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    specificRole?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    activityTemplateStepId?: BytesFieldUpdateOperationsInput | Uint8Array
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type ActivityTemplateStepAssignmentCreateManyInput = {
    id: Uint8Array
    specificUserId?: Uint8Array | null
    specificRole?: $Enums.Role | null
    activityTemplateStepId: Uint8Array
    tenetId: Uint8Array
  }

  export type ActivityTemplateStepAssignmentUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    specificRole?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
  }

  export type ActivityTemplateStepAssignmentUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    specificUserId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    specificRole?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    activityTemplateStepId?: BytesFieldUpdateOperationsInput | Uint8Array
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type ActivityTemplateCreateInput = {
    id: Uint8Array
    title: string
    description?: string | null
    type: $Enums.ActivityType
    defaultPriority: $Enums.ActivityPriority
    defaultStatus: $Enums.ActivityStatus
    taskScheduleType?: $Enums.TaskScheduleType | null
    dateOffsetType: $Enums.DateOffsetType
    startDate: number
    endDate: number
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: number | null
    steps?: ActivityTemplateStepCreateNestedManyWithoutActivityTemplateInput
    startRelativeTo?: ActivityTemplateCreateNestedOneWithoutDependentsInput
    dependents?: ActivityTemplateCreateNestedManyWithoutStartRelativeToInput
    parentWaypoint?: ActivityWaypointTemplateCreateNestedOneWithoutActivitiesInput
    parentActivity?: ActivityTemplateCreateNestedOneWithoutChildActivitiesInput
    waypoints?: ActivityWaypointTemplateCreateNestedManyWithoutParentActivityInput
    childActivities?: ActivityTemplateCreateNestedManyWithoutParentActivityInput
    activities?: ActivityCreateNestedManyWithoutTemplateInput
    assignments?: TemplateAssignmentCreateNestedManyWithoutActivityTemplateInput
    tenet: TenetCreateNestedOneWithoutActivityTemplatesInput
  }

  export type ActivityTemplateUncheckedCreateInput = {
    id: Uint8Array
    title: string
    description?: string | null
    type: $Enums.ActivityType
    defaultPriority: $Enums.ActivityPriority
    defaultStatus: $Enums.ActivityStatus
    taskScheduleType?: $Enums.TaskScheduleType | null
    dateOffsetType: $Enums.DateOffsetType
    startDate: number
    endDate: number
    startRelativeToId?: Uint8Array | null
    parentWaypointId?: Uint8Array | null
    parentActivityId?: Uint8Array | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
    order?: number | null
    steps?: ActivityTemplateStepUncheckedCreateNestedManyWithoutActivityTemplateInput
    dependents?: ActivityTemplateUncheckedCreateNestedManyWithoutStartRelativeToInput
    waypoints?: ActivityWaypointTemplateUncheckedCreateNestedManyWithoutParentActivityInput
    childActivities?: ActivityTemplateUncheckedCreateNestedManyWithoutParentActivityInput
    activities?: ActivityUncheckedCreateNestedManyWithoutTemplateInput
    assignments?: TemplateAssignmentUncheckedCreateNestedManyWithoutActivityTemplateInput
  }

  export type ActivityTemplateUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    defaultPriority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    defaultStatus?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    dateOffsetType?: EnumDateOffsetTypeFieldUpdateOperationsInput | $Enums.DateOffsetType
    startDate?: IntFieldUpdateOperationsInput | number
    endDate?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    steps?: ActivityTemplateStepUpdateManyWithoutActivityTemplateNestedInput
    startRelativeTo?: ActivityTemplateUpdateOneWithoutDependentsNestedInput
    dependents?: ActivityTemplateUpdateManyWithoutStartRelativeToNestedInput
    parentWaypoint?: ActivityWaypointTemplateUpdateOneWithoutActivitiesNestedInput
    parentActivity?: ActivityTemplateUpdateOneWithoutChildActivitiesNestedInput
    waypoints?: ActivityWaypointTemplateUpdateManyWithoutParentActivityNestedInput
    childActivities?: ActivityTemplateUpdateManyWithoutParentActivityNestedInput
    activities?: ActivityUpdateManyWithoutTemplateNestedInput
    assignments?: TemplateAssignmentUpdateManyWithoutActivityTemplateNestedInput
    tenet?: TenetUpdateOneRequiredWithoutActivityTemplatesNestedInput
  }

  export type ActivityTemplateUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    defaultPriority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    defaultStatus?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    dateOffsetType?: EnumDateOffsetTypeFieldUpdateOperationsInput | $Enums.DateOffsetType
    startDate?: IntFieldUpdateOperationsInput | number
    endDate?: IntFieldUpdateOperationsInput | number
    startRelativeToId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    parentWaypointId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    parentActivityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    order?: NullableIntFieldUpdateOperationsInput | number | null
    steps?: ActivityTemplateStepUncheckedUpdateManyWithoutActivityTemplateNestedInput
    dependents?: ActivityTemplateUncheckedUpdateManyWithoutStartRelativeToNestedInput
    waypoints?: ActivityWaypointTemplateUncheckedUpdateManyWithoutParentActivityNestedInput
    childActivities?: ActivityTemplateUncheckedUpdateManyWithoutParentActivityNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutTemplateNestedInput
    assignments?: TemplateAssignmentUncheckedUpdateManyWithoutActivityTemplateNestedInput
  }

  export type ActivityTemplateCreateManyInput = {
    id: Uint8Array
    title: string
    description?: string | null
    type: $Enums.ActivityType
    defaultPriority: $Enums.ActivityPriority
    defaultStatus: $Enums.ActivityStatus
    taskScheduleType?: $Enums.TaskScheduleType | null
    dateOffsetType: $Enums.DateOffsetType
    startDate: number
    endDate: number
    startRelativeToId?: Uint8Array | null
    parentWaypointId?: Uint8Array | null
    parentActivityId?: Uint8Array | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
    order?: number | null
  }

  export type ActivityTemplateUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    defaultPriority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    defaultStatus?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    dateOffsetType?: EnumDateOffsetTypeFieldUpdateOperationsInput | $Enums.DateOffsetType
    startDate?: IntFieldUpdateOperationsInput | number
    endDate?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ActivityTemplateUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    defaultPriority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    defaultStatus?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    dateOffsetType?: EnumDateOffsetTypeFieldUpdateOperationsInput | $Enums.DateOffsetType
    startDate?: IntFieldUpdateOperationsInput | number
    endDate?: IntFieldUpdateOperationsInput | number
    startRelativeToId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    parentWaypointId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    parentActivityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    order?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ActivityCreateInput = {
    id: Uint8Array
    title: string
    type: $Enums.ActivityType
    taskScheduleType?: $Enums.TaskScheduleType | null
    startDate: Date | string
    endDate: Date | string
    completedAt?: Date | string | null
    description?: string | null
    priority?: $Enums.ActivityPriority
    status: $Enums.ActivityStatus
    phoneNumber?: string | null
    location?: string | null
    holdReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean
    deletedAt?: Date | string | null
    order?: number | null
    steps?: ActivityStepCreateNestedManyWithoutActivityInput
    waypoints?: ActivityWaypointCreateNestedManyWithoutActivityInput
    activities?: ActivityCreateNestedManyWithoutParentActivityInput
    parentActivity?: ActivityCreateNestedOneWithoutActivitiesInput
    parentWaypoint?: ActivityWaypointCreateNestedOneWithoutChildActivitiesInput
    template?: ActivityTemplateCreateNestedOneWithoutActivitiesInput
    assignedBy: UserCreateNestedOneWithoutAssignedActivitiesInput
    contacts?: ActivityContactJoinCreateNestedManyWithoutActivityRelationInput
    users?: ActivityUserJoinCreateNestedManyWithoutActivityRelationInput
    tenet: TenetCreateNestedOneWithoutActivitiesInput
    attachments?: AttachmentCreateNestedManyWithoutActivityInput
    notes?: NoteCreateNestedManyWithoutActivityInput
    events?: ContactTimelineEventCreateNestedManyWithoutActivityInput
    opportunity?: OpportunityCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateInput = {
    id: Uint8Array
    title: string
    type: $Enums.ActivityType
    parentActivityId?: Uint8Array | null
    parentWaypointId?: Uint8Array | null
    templateId?: Uint8Array | null
    taskScheduleType?: $Enums.TaskScheduleType | null
    startDate: Date | string
    endDate: Date | string
    completedAt?: Date | string | null
    description?: string | null
    priority?: $Enums.ActivityPriority
    status: $Enums.ActivityStatus
    assignedById: Uint8Array
    phoneNumber?: string | null
    location?: string | null
    holdReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
    deleted?: boolean
    deletedAt?: Date | string | null
    order?: number | null
    opportunityId?: Uint8Array | null
    steps?: ActivityStepUncheckedCreateNestedManyWithoutActivityInput
    waypoints?: ActivityWaypointUncheckedCreateNestedManyWithoutActivityInput
    activities?: ActivityUncheckedCreateNestedManyWithoutParentActivityInput
    contacts?: ActivityContactJoinUncheckedCreateNestedManyWithoutActivityRelationInput
    users?: ActivityUserJoinUncheckedCreateNestedManyWithoutActivityRelationInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutActivityInput
    notes?: NoteUncheckedCreateNestedManyWithoutActivityInput
    events?: ContactTimelineEventUncheckedCreateNestedManyWithoutActivityInput
  }

  export type ActivityUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    steps?: ActivityStepUpdateManyWithoutActivityNestedInput
    waypoints?: ActivityWaypointUpdateManyWithoutActivityNestedInput
    activities?: ActivityUpdateManyWithoutParentActivityNestedInput
    parentActivity?: ActivityUpdateOneWithoutActivitiesNestedInput
    parentWaypoint?: ActivityWaypointUpdateOneWithoutChildActivitiesNestedInput
    template?: ActivityTemplateUpdateOneWithoutActivitiesNestedInput
    assignedBy?: UserUpdateOneRequiredWithoutAssignedActivitiesNestedInput
    contacts?: ActivityContactJoinUpdateManyWithoutActivityRelationNestedInput
    users?: ActivityUserJoinUpdateManyWithoutActivityRelationNestedInput
    tenet?: TenetUpdateOneRequiredWithoutActivitiesNestedInput
    attachments?: AttachmentUpdateManyWithoutActivityNestedInput
    notes?: NoteUpdateManyWithoutActivityNestedInput
    events?: ContactTimelineEventUpdateManyWithoutActivityNestedInput
    opportunity?: OpportunityUpdateOneWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    parentActivityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    parentWaypointId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    templateId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    assignedById?: BytesFieldUpdateOperationsInput | Uint8Array
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    opportunityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    steps?: ActivityStepUncheckedUpdateManyWithoutActivityNestedInput
    waypoints?: ActivityWaypointUncheckedUpdateManyWithoutActivityNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutParentActivityNestedInput
    contacts?: ActivityContactJoinUncheckedUpdateManyWithoutActivityRelationNestedInput
    users?: ActivityUserJoinUncheckedUpdateManyWithoutActivityRelationNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutActivityNestedInput
    notes?: NoteUncheckedUpdateManyWithoutActivityNestedInput
    events?: ContactTimelineEventUncheckedUpdateManyWithoutActivityNestedInput
  }

  export type ActivityCreateManyInput = {
    id: Uint8Array
    title: string
    type: $Enums.ActivityType
    parentActivityId?: Uint8Array | null
    parentWaypointId?: Uint8Array | null
    templateId?: Uint8Array | null
    taskScheduleType?: $Enums.TaskScheduleType | null
    startDate: Date | string
    endDate: Date | string
    completedAt?: Date | string | null
    description?: string | null
    priority?: $Enums.ActivityPriority
    status: $Enums.ActivityStatus
    assignedById: Uint8Array
    phoneNumber?: string | null
    location?: string | null
    holdReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
    deleted?: boolean
    deletedAt?: Date | string | null
    order?: number | null
    opportunityId?: Uint8Array | null
  }

  export type ActivityUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ActivityUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    parentActivityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    parentWaypointId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    templateId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    assignedById?: BytesFieldUpdateOperationsInput | Uint8Array
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    opportunityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type ContactTimelineEventCreateInput = {
    id: Uint8Array
    extraInfo?: string | null
    eventType: $Enums.ContactTimelineEventType
    relationshipType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activity?: ActivityCreateNestedOneWithoutEventsInput
    waypoint?: ActivityWaypointCreateNestedOneWithoutEventsInput
    opportunity?: OpportunityCreateNestedOneWithoutEventsInput
    note?: NoteCreateNestedOneWithoutEventsInput
    contacts?: ContactTimelineEventContactJoinCreateNestedManyWithoutContactEventRelationInput
    user: UserCreateNestedOneWithoutEventsInput
    tenet: TenetCreateNestedOneWithoutContactTimelineEventsInput
  }

  export type ContactTimelineEventUncheckedCreateInput = {
    id: Uint8Array
    activityId?: Uint8Array | null
    waypointId?: Uint8Array | null
    opportunityId?: Uint8Array | null
    noteId?: Uint8Array | null
    extraInfo?: string | null
    userId: Uint8Array
    tenetId: Uint8Array
    eventType: $Enums.ContactTimelineEventType
    relationshipType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: ContactTimelineEventContactJoinUncheckedCreateNestedManyWithoutContactEventRelationInput
  }

  export type ContactTimelineEventUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    extraInfo?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: EnumContactTimelineEventTypeFieldUpdateOperationsInput | $Enums.ContactTimelineEventType
    relationshipType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activity?: ActivityUpdateOneWithoutEventsNestedInput
    waypoint?: ActivityWaypointUpdateOneWithoutEventsNestedInput
    opportunity?: OpportunityUpdateOneWithoutEventsNestedInput
    note?: NoteUpdateOneWithoutEventsNestedInput
    contacts?: ContactTimelineEventContactJoinUpdateManyWithoutContactEventRelationNestedInput
    user?: UserUpdateOneRequiredWithoutEventsNestedInput
    tenet?: TenetUpdateOneRequiredWithoutContactTimelineEventsNestedInput
  }

  export type ContactTimelineEventUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    activityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    waypointId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    opportunityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    noteId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    extraInfo?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: BytesFieldUpdateOperationsInput | Uint8Array
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    eventType?: EnumContactTimelineEventTypeFieldUpdateOperationsInput | $Enums.ContactTimelineEventType
    relationshipType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactTimelineEventContactJoinUncheckedUpdateManyWithoutContactEventRelationNestedInput
  }

  export type ContactTimelineEventCreateManyInput = {
    id: Uint8Array
    activityId?: Uint8Array | null
    waypointId?: Uint8Array | null
    opportunityId?: Uint8Array | null
    noteId?: Uint8Array | null
    extraInfo?: string | null
    userId: Uint8Array
    tenetId: Uint8Array
    eventType: $Enums.ContactTimelineEventType
    relationshipType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactTimelineEventUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    extraInfo?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: EnumContactTimelineEventTypeFieldUpdateOperationsInput | $Enums.ContactTimelineEventType
    relationshipType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactTimelineEventUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    activityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    waypointId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    opportunityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    noteId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    extraInfo?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: BytesFieldUpdateOperationsInput | Uint8Array
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    eventType?: EnumContactTimelineEventTypeFieldUpdateOperationsInput | $Enums.ContactTimelineEventType
    relationshipType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditEventCreateInput = {
    id: Uint8Array
    type: $Enums.AuditEventType
    details?: string | null
    referenceId: Uint8Array
    reference: $Enums.Auditable
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAuditEventsInput
    tenet: TenetCreateNestedOneWithoutAuditEventsInput
  }

  export type AuditEventUncheckedCreateInput = {
    id: Uint8Array
    userId: Uint8Array
    tenetId: Uint8Array
    type: $Enums.AuditEventType
    details?: string | null
    referenceId: Uint8Array
    reference: $Enums.Auditable
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditEventUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    type?: EnumAuditEventTypeFieldUpdateOperationsInput | $Enums.AuditEventType
    details?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: BytesFieldUpdateOperationsInput | Uint8Array
    reference?: EnumAuditableFieldUpdateOperationsInput | $Enums.Auditable
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAuditEventsNestedInput
    tenet?: TenetUpdateOneRequiredWithoutAuditEventsNestedInput
  }

  export type AuditEventUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    userId?: BytesFieldUpdateOperationsInput | Uint8Array
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    type?: EnumAuditEventTypeFieldUpdateOperationsInput | $Enums.AuditEventType
    details?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: BytesFieldUpdateOperationsInput | Uint8Array
    reference?: EnumAuditableFieldUpdateOperationsInput | $Enums.Auditable
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditEventCreateManyInput = {
    id: Uint8Array
    userId: Uint8Array
    tenetId: Uint8Array
    type: $Enums.AuditEventType
    details?: string | null
    referenceId: Uint8Array
    reference: $Enums.Auditable
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditEventUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    type?: EnumAuditEventTypeFieldUpdateOperationsInput | $Enums.AuditEventType
    details?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: BytesFieldUpdateOperationsInput | Uint8Array
    reference?: EnumAuditableFieldUpdateOperationsInput | $Enums.Auditable
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditEventUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    userId?: BytesFieldUpdateOperationsInput | Uint8Array
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    type?: EnumAuditEventTypeFieldUpdateOperationsInput | $Enums.AuditEventType
    details?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: BytesFieldUpdateOperationsInput | Uint8Array
    reference?: EnumAuditableFieldUpdateOperationsInput | $Enums.Auditable
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactTimelineEventContactJoinCreateInput = {
    type: $Enums.ContactTimelineEventJoinType
    contactEventRelation: ContactTimelineEventCreateNestedOneWithoutContactsInput
    contactRelation: ContactCreateNestedOneWithoutTimelineEventsInput
  }

  export type ContactTimelineEventContactJoinUncheckedCreateInput = {
    contactEventId: Uint8Array
    contactId: Uint8Array
    type: $Enums.ContactTimelineEventJoinType
  }

  export type ContactTimelineEventContactJoinUpdateInput = {
    type?: EnumContactTimelineEventJoinTypeFieldUpdateOperationsInput | $Enums.ContactTimelineEventJoinType
    contactEventRelation?: ContactTimelineEventUpdateOneRequiredWithoutContactsNestedInput
    contactRelation?: ContactUpdateOneRequiredWithoutTimelineEventsNestedInput
  }

  export type ContactTimelineEventContactJoinUncheckedUpdateInput = {
    contactEventId?: BytesFieldUpdateOperationsInput | Uint8Array
    contactId?: BytesFieldUpdateOperationsInput | Uint8Array
    type?: EnumContactTimelineEventJoinTypeFieldUpdateOperationsInput | $Enums.ContactTimelineEventJoinType
  }

  export type ContactTimelineEventContactJoinCreateManyInput = {
    contactEventId: Uint8Array
    contactId: Uint8Array
    type: $Enums.ContactTimelineEventJoinType
  }

  export type ContactTimelineEventContactJoinUpdateManyMutationInput = {
    type?: EnumContactTimelineEventJoinTypeFieldUpdateOperationsInput | $Enums.ContactTimelineEventJoinType
  }

  export type ContactTimelineEventContactJoinUncheckedUpdateManyInput = {
    contactEventId?: BytesFieldUpdateOperationsInput | Uint8Array
    contactId?: BytesFieldUpdateOperationsInput | Uint8Array
    type?: EnumContactTimelineEventJoinTypeFieldUpdateOperationsInput | $Enums.ContactTimelineEventJoinType
  }

  export type NoteCreateInput = {
    id: Uint8Array
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean
    deletedAt?: Date | string | null
    noteType?: $Enums.NoteType
    waypoint?: ActivityWaypointCreateNestedOneWithoutNoteInput
    activity?: ActivityCreateNestedOneWithoutNotesInput
    contact?: ContactCreateNestedOneWithoutNotesInput
    opportunity?: OpportunityCreateNestedOneWithoutNotesInput
    tenet: TenetCreateNestedOneWithoutNotesInput
    author: UserCreateNestedOneWithoutNotesInput
    events?: ContactTimelineEventCreateNestedManyWithoutNoteInput
  }

  export type NoteUncheckedCreateInput = {
    id: Uint8Array
    content: string
    waypointId?: Uint8Array | null
    activityId?: Uint8Array | null
    contactId?: Uint8Array | null
    opportunityId?: Uint8Array | null
    tenetId: Uint8Array
    authorId: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean
    deletedAt?: Date | string | null
    noteType?: $Enums.NoteType
    events?: ContactTimelineEventUncheckedCreateNestedManyWithoutNoteInput
  }

  export type NoteUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noteType?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    waypoint?: ActivityWaypointUpdateOneWithoutNoteNestedInput
    activity?: ActivityUpdateOneWithoutNotesNestedInput
    contact?: ContactUpdateOneWithoutNotesNestedInput
    opportunity?: OpportunityUpdateOneWithoutNotesNestedInput
    tenet?: TenetUpdateOneRequiredWithoutNotesNestedInput
    author?: UserUpdateOneRequiredWithoutNotesNestedInput
    events?: ContactTimelineEventUpdateManyWithoutNoteNestedInput
  }

  export type NoteUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    content?: StringFieldUpdateOperationsInput | string
    waypointId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    activityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    contactId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    opportunityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    authorId?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noteType?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    events?: ContactTimelineEventUncheckedUpdateManyWithoutNoteNestedInput
  }

  export type NoteCreateManyInput = {
    id: Uint8Array
    content: string
    waypointId?: Uint8Array | null
    activityId?: Uint8Array | null
    contactId?: Uint8Array | null
    opportunityId?: Uint8Array | null
    tenetId: Uint8Array
    authorId: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean
    deletedAt?: Date | string | null
    noteType?: $Enums.NoteType
  }

  export type NoteUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noteType?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
  }

  export type NoteUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    content?: StringFieldUpdateOperationsInput | string
    waypointId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    activityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    contactId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    opportunityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    authorId?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noteType?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
  }

  export type AttachmentCreateInput = {
    id: Uint8Array
    name: string
    location: string
    activity?: ActivityCreateNestedOneWithoutAttachmentsInput
    tenet: TenetCreateNestedOneWithoutAttachmentsInput
  }

  export type AttachmentUncheckedCreateInput = {
    id: Uint8Array
    name: string
    location: string
    activityId?: Uint8Array | null
    tenetId: Uint8Array
  }

  export type AttachmentUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    activity?: ActivityUpdateOneWithoutAttachmentsNestedInput
    tenet?: TenetUpdateOneRequiredWithoutAttachmentsNestedInput
  }

  export type AttachmentUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    activityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type AttachmentCreateManyInput = {
    id: Uint8Array
    name: string
    location: string
    activityId?: Uint8Array | null
    tenetId: Uint8Array
  }

  export type AttachmentUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
  }

  export type AttachmentUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    activityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type ActivityContactJoinCreateInput = {
    activityRelation: ActivityCreateNestedOneWithoutContactsInput
    contactRelation: ContactCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityContactJoinUncheckedCreateInput = {
    activityId: Uint8Array
    contactId: Uint8Array
  }

  export type ActivityContactJoinUpdateInput = {
    activityRelation?: ActivityUpdateOneRequiredWithoutContactsNestedInput
    contactRelation?: ContactUpdateOneRequiredWithoutActivitiesNestedInput
  }

  export type ActivityContactJoinUncheckedUpdateInput = {
    activityId?: BytesFieldUpdateOperationsInput | Uint8Array
    contactId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type ActivityContactJoinCreateManyInput = {
    activityId: Uint8Array
    contactId: Uint8Array
  }

  export type ActivityContactJoinUpdateManyMutationInput = {

  }

  export type ActivityContactJoinUncheckedUpdateManyInput = {
    activityId?: BytesFieldUpdateOperationsInput | Uint8Array
    contactId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type ActivityUserJoinCreateInput = {
    activityRelation: ActivityCreateNestedOneWithoutUsersInput
    userRelation: UserCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityUserJoinUncheckedCreateInput = {
    activityId: Uint8Array
    userId: Uint8Array
  }

  export type ActivityUserJoinUpdateInput = {
    activityRelation?: ActivityUpdateOneRequiredWithoutUsersNestedInput
    userRelation?: UserUpdateOneRequiredWithoutActivitiesNestedInput
  }

  export type ActivityUserJoinUncheckedUpdateInput = {
    activityId?: BytesFieldUpdateOperationsInput | Uint8Array
    userId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type ActivityUserJoinCreateManyInput = {
    activityId: Uint8Array
    userId: Uint8Array
  }

  export type ActivityUserJoinUpdateManyMutationInput = {

  }

  export type ActivityUserJoinUncheckedUpdateManyInput = {
    activityId?: BytesFieldUpdateOperationsInput | Uint8Array
    userId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type ContactEmailCreateInput = {
    id: Uint8Array
    email: string
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contact: ContactCreateNestedOneWithoutEmailsInput
    tenet: TenetCreateNestedOneWithoutContactEmailsInput
  }

  export type ContactEmailUncheckedCreateInput = {
    id: Uint8Array
    email: string
    isPrimary?: boolean
    contactId: Uint8Array
    tenetId: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactEmailUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    email?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: ContactUpdateOneRequiredWithoutEmailsNestedInput
    tenet?: TenetUpdateOneRequiredWithoutContactEmailsNestedInput
  }

  export type ContactEmailUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    email?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    contactId?: BytesFieldUpdateOperationsInput | Uint8Array
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactEmailCreateManyInput = {
    id: Uint8Array
    email: string
    isPrimary?: boolean
    contactId: Uint8Array
    tenetId: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactEmailUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    email?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactEmailUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    email?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    contactId?: BytesFieldUpdateOperationsInput | Uint8Array
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactPhoneCreateInput = {
    id: Uint8Array
    number: string
    type: $Enums.PhoneType
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contact: ContactCreateNestedOneWithoutPhonesInput
    tenet: TenetCreateNestedOneWithoutContactPhonesInput
  }

  export type ContactPhoneUncheckedCreateInput = {
    id: Uint8Array
    number: string
    type: $Enums.PhoneType
    isPrimary?: boolean
    contactId: Uint8Array
    tenetId: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactPhoneUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    number?: StringFieldUpdateOperationsInput | string
    type?: EnumPhoneTypeFieldUpdateOperationsInput | $Enums.PhoneType
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: ContactUpdateOneRequiredWithoutPhonesNestedInput
    tenet?: TenetUpdateOneRequiredWithoutContactPhonesNestedInput
  }

  export type ContactPhoneUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    number?: StringFieldUpdateOperationsInput | string
    type?: EnumPhoneTypeFieldUpdateOperationsInput | $Enums.PhoneType
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    contactId?: BytesFieldUpdateOperationsInput | Uint8Array
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactPhoneCreateManyInput = {
    id: Uint8Array
    number: string
    type: $Enums.PhoneType
    isPrimary?: boolean
    contactId: Uint8Array
    tenetId: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactPhoneUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    number?: StringFieldUpdateOperationsInput | string
    type?: EnumPhoneTypeFieldUpdateOperationsInput | $Enums.PhoneType
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactPhoneUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    number?: StringFieldUpdateOperationsInput | string
    type?: EnumPhoneTypeFieldUpdateOperationsInput | $Enums.PhoneType
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    contactId?: BytesFieldUpdateOperationsInput | Uint8Array
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressCreateInput = {
    id: Uint8Array
    street: string
    city: string
    state: string
    zip: string
    country: string
    type: $Enums.AddressType
    primary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    timezone?: string | null
    contact: ContactCreateNestedOneWithoutAddressesInput
    tenet: TenetCreateNestedOneWithoutAddressesInput
  }

  export type AddressUncheckedCreateInput = {
    id: Uint8Array
    street: string
    city: string
    state: string
    zip: string
    country: string
    type: $Enums.AddressType
    primary?: boolean
    contactId: Uint8Array
    tenetId: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
    timezone?: string | null
  }

  export type AddressUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    type?: EnumAddressTypeFieldUpdateOperationsInput | $Enums.AddressType
    primary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: ContactUpdateOneRequiredWithoutAddressesNestedInput
    tenet?: TenetUpdateOneRequiredWithoutAddressesNestedInput
  }

  export type AddressUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    type?: EnumAddressTypeFieldUpdateOperationsInput | $Enums.AddressType
    primary?: BoolFieldUpdateOperationsInput | boolean
    contactId?: BytesFieldUpdateOperationsInput | Uint8Array
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AddressCreateManyInput = {
    id: Uint8Array
    street: string
    city: string
    state: string
    zip: string
    country: string
    type: $Enums.AddressType
    primary?: boolean
    contactId: Uint8Array
    tenetId: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
    timezone?: string | null
  }

  export type AddressUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    type?: EnumAddressTypeFieldUpdateOperationsInput | $Enums.AddressType
    primary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AddressUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    type?: EnumAddressTypeFieldUpdateOperationsInput | $Enums.AddressType
    primary?: BoolFieldUpdateOperationsInput | boolean
    contactId?: BytesFieldUpdateOperationsInput | Uint8Array
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConfigOptionCreateInput = {
    id: Uint8Array
    name: string
    value: string
  }

  export type ConfigOptionUncheckedCreateInput = {
    id: Uint8Array
    name: string
    value: string
  }

  export type ConfigOptionUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type ConfigOptionUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type ConfigOptionCreateManyInput = {
    id: Uint8Array
    name: string
    value: string
  }

  export type ConfigOptionUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type ConfigOptionUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type ImportantDateCreateInput = {
    id: Uint8Array
    date: Date | string
    type: $Enums.ImportantDateType
    createdAt?: Date | string
    updatedAt?: Date | string
    contact: ContactCreateNestedOneWithoutImportantDatesInput
    tenet: TenetCreateNestedOneWithoutImportantDatesInput
  }

  export type ImportantDateUncheckedCreateInput = {
    id: Uint8Array
    date: Date | string
    type: $Enums.ImportantDateType
    contactId: Uint8Array
    tenetId: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImportantDateUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumImportantDateTypeFieldUpdateOperationsInput | $Enums.ImportantDateType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: ContactUpdateOneRequiredWithoutImportantDatesNestedInput
    tenet?: TenetUpdateOneRequiredWithoutImportantDatesNestedInput
  }

  export type ImportantDateUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumImportantDateTypeFieldUpdateOperationsInput | $Enums.ImportantDateType
    contactId?: BytesFieldUpdateOperationsInput | Uint8Array
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImportantDateCreateManyInput = {
    id: Uint8Array
    date: Date | string
    type: $Enums.ImportantDateType
    contactId: Uint8Array
    tenetId: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImportantDateUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumImportantDateTypeFieldUpdateOperationsInput | $Enums.ImportantDateType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImportantDateUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumImportantDateTypeFieldUpdateOperationsInput | $Enums.ImportantDateType
    contactId?: BytesFieldUpdateOperationsInput | Uint8Array
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OpportunityCreateInput = {
    id: Uint8Array
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    value: number
    probability: number
    expectedCloseDate: Date | string
    actualCloseDate?: Date | string | null
    status: $Enums.OpportunityStatus
    statusHistory?: OpportunityCreatestatusHistoryInput | $Enums.OpportunityStatus[]
    deleted?: boolean
    deletedAt?: Date | string | null
    expectedValue: number
    contacts?: ContactOpportunityJoinCreateNestedManyWithoutOpportunityRelationInput
    teamMembers?: UserOpportunityJoinCreateNestedManyWithoutOpportunityRelationInput
    activities?: ActivityCreateNestedManyWithoutOpportunityInput
    products?: OpportunityProductCreateNestedManyWithoutOpportunityInput
    tenet: TenetCreateNestedOneWithoutOpportunitiesInput
    events?: ContactTimelineEventCreateNestedManyWithoutOpportunityInput
    notes?: NoteCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityUncheckedCreateInput = {
    id: Uint8Array
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    value: number
    probability: number
    expectedCloseDate: Date | string
    actualCloseDate?: Date | string | null
    status: $Enums.OpportunityStatus
    statusHistory?: OpportunityCreatestatusHistoryInput | $Enums.OpportunityStatus[]
    deleted?: boolean
    deletedAt?: Date | string | null
    tenetId: Uint8Array
    expectedValue: number
    contacts?: ContactOpportunityJoinUncheckedCreateNestedManyWithoutOpportunityRelationInput
    teamMembers?: UserOpportunityJoinUncheckedCreateNestedManyWithoutOpportunityRelationInput
    activities?: ActivityUncheckedCreateNestedManyWithoutOpportunityInput
    products?: OpportunityProductUncheckedCreateNestedManyWithoutOpportunityInput
    events?: ContactTimelineEventUncheckedCreateNestedManyWithoutOpportunityInput
    notes?: NoteUncheckedCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    probability?: FloatFieldUpdateOperationsInput | number
    expectedCloseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumOpportunityStatusFieldUpdateOperationsInput | $Enums.OpportunityStatus
    statusHistory?: OpportunityUpdatestatusHistoryInput | $Enums.OpportunityStatus[]
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedValue?: FloatFieldUpdateOperationsInput | number
    contacts?: ContactOpportunityJoinUpdateManyWithoutOpportunityRelationNestedInput
    teamMembers?: UserOpportunityJoinUpdateManyWithoutOpportunityRelationNestedInput
    activities?: ActivityUpdateManyWithoutOpportunityNestedInput
    products?: OpportunityProductUpdateManyWithoutOpportunityNestedInput
    tenet?: TenetUpdateOneRequiredWithoutOpportunitiesNestedInput
    events?: ContactTimelineEventUpdateManyWithoutOpportunityNestedInput
    notes?: NoteUpdateManyWithoutOpportunityNestedInput
  }

  export type OpportunityUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    probability?: FloatFieldUpdateOperationsInput | number
    expectedCloseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumOpportunityStatusFieldUpdateOperationsInput | $Enums.OpportunityStatus
    statusHistory?: OpportunityUpdatestatusHistoryInput | $Enums.OpportunityStatus[]
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    expectedValue?: FloatFieldUpdateOperationsInput | number
    contacts?: ContactOpportunityJoinUncheckedUpdateManyWithoutOpportunityRelationNestedInput
    teamMembers?: UserOpportunityJoinUncheckedUpdateManyWithoutOpportunityRelationNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutOpportunityNestedInput
    products?: OpportunityProductUncheckedUpdateManyWithoutOpportunityNestedInput
    events?: ContactTimelineEventUncheckedUpdateManyWithoutOpportunityNestedInput
    notes?: NoteUncheckedUpdateManyWithoutOpportunityNestedInput
  }

  export type OpportunityCreateManyInput = {
    id: Uint8Array
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    value: number
    probability: number
    expectedCloseDate: Date | string
    actualCloseDate?: Date | string | null
    status: $Enums.OpportunityStatus
    statusHistory?: OpportunityCreatestatusHistoryInput | $Enums.OpportunityStatus[]
    deleted?: boolean
    deletedAt?: Date | string | null
    tenetId: Uint8Array
    expectedValue: number
  }

  export type OpportunityUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    probability?: FloatFieldUpdateOperationsInput | number
    expectedCloseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumOpportunityStatusFieldUpdateOperationsInput | $Enums.OpportunityStatus
    statusHistory?: OpportunityUpdatestatusHistoryInput | $Enums.OpportunityStatus[]
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedValue?: FloatFieldUpdateOperationsInput | number
  }

  export type OpportunityUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    probability?: FloatFieldUpdateOperationsInput | number
    expectedCloseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumOpportunityStatusFieldUpdateOperationsInput | $Enums.OpportunityStatus
    statusHistory?: OpportunityUpdatestatusHistoryInput | $Enums.OpportunityStatus[]
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    expectedValue?: FloatFieldUpdateOperationsInput | number
  }

  export type ContactOpportunityJoinCreateInput = {
    contactRelation: ContactCreateNestedOneWithoutOpportunitiesInput
    opportunityRelation: OpportunityCreateNestedOneWithoutContactsInput
  }

  export type ContactOpportunityJoinUncheckedCreateInput = {
    contactId: Uint8Array
    opportunityId: Uint8Array
  }

  export type ContactOpportunityJoinUpdateInput = {
    contactRelation?: ContactUpdateOneRequiredWithoutOpportunitiesNestedInput
    opportunityRelation?: OpportunityUpdateOneRequiredWithoutContactsNestedInput
  }

  export type ContactOpportunityJoinUncheckedUpdateInput = {
    contactId?: BytesFieldUpdateOperationsInput | Uint8Array
    opportunityId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type ContactOpportunityJoinCreateManyInput = {
    contactId: Uint8Array
    opportunityId: Uint8Array
  }

  export type ContactOpportunityJoinUpdateManyMutationInput = {

  }

  export type ContactOpportunityJoinUncheckedUpdateManyInput = {
    contactId?: BytesFieldUpdateOperationsInput | Uint8Array
    opportunityId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type UserOpportunityJoinCreateInput = {
    userRelation: UserCreateNestedOneWithoutOpportunitiesInput
    opportunityRelation: OpportunityCreateNestedOneWithoutTeamMembersInput
  }

  export type UserOpportunityJoinUncheckedCreateInput = {
    userId: Uint8Array
    opportunityId: Uint8Array
  }

  export type UserOpportunityJoinUpdateInput = {
    userRelation?: UserUpdateOneRequiredWithoutOpportunitiesNestedInput
    opportunityRelation?: OpportunityUpdateOneRequiredWithoutTeamMembersNestedInput
  }

  export type UserOpportunityJoinUncheckedUpdateInput = {
    userId?: BytesFieldUpdateOperationsInput | Uint8Array
    opportunityId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type UserOpportunityJoinCreateManyInput = {
    userId: Uint8Array
    opportunityId: Uint8Array
  }

  export type UserOpportunityJoinUpdateManyMutationInput = {

  }

  export type UserOpportunityJoinUncheckedUpdateManyInput = {
    userId?: BytesFieldUpdateOperationsInput | Uint8Array
    opportunityId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type OpportunityProductCreateInput = {
    id: Uint8Array
    price: number
    order: number
    commission: number
    createdAt?: Date | string
    updatedAt?: Date | string
    opportunity: OpportunityCreateNestedOneWithoutProductsInput
    productType: ProductTypeCreateNestedOneWithoutOpportunitiesInput
  }

  export type OpportunityProductUncheckedCreateInput = {
    id: Uint8Array
    price: number
    order: number
    commission: number
    opportunityId: Uint8Array
    productTypeId: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OpportunityProductUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    price?: FloatFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opportunity?: OpportunityUpdateOneRequiredWithoutProductsNestedInput
    productType?: ProductTypeUpdateOneRequiredWithoutOpportunitiesNestedInput
  }

  export type OpportunityProductUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    price?: FloatFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    opportunityId?: BytesFieldUpdateOperationsInput | Uint8Array
    productTypeId?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OpportunityProductCreateManyInput = {
    id: Uint8Array
    price: number
    order: number
    commission: number
    opportunityId: Uint8Array
    productTypeId: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OpportunityProductUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    price?: FloatFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OpportunityProductUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    price?: FloatFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    opportunityId?: BytesFieldUpdateOperationsInput | Uint8Array
    productTypeId?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductTypeCreateInput = {
    id: Uint8Array
    title: string
    description?: string | null
    defaultCommission: number
    createdAt?: Date | string
    updatedAt?: Date | string
    opportunities?: OpportunityProductCreateNestedManyWithoutProductTypeInput
    tenet: TenetCreateNestedOneWithoutProductsInput
  }

  export type ProductTypeUncheckedCreateInput = {
    id: Uint8Array
    title: string
    description?: string | null
    defaultCommission: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
    opportunities?: OpportunityProductUncheckedCreateNestedManyWithoutProductTypeInput
  }

  export type ProductTypeUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCommission?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opportunities?: OpportunityProductUpdateManyWithoutProductTypeNestedInput
    tenet?: TenetUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ProductTypeUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCommission?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    opportunities?: OpportunityProductUncheckedUpdateManyWithoutProductTypeNestedInput
  }

  export type ProductTypeCreateManyInput = {
    id: Uint8Array
    title: string
    description?: string | null
    defaultCommission: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
  }

  export type ProductTypeUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCommission?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductTypeUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCommission?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type LogCreateInput = {
    id: Uint8Array
    userEmail?: string | null
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    severity?: $Enums.LogLevel
    stacktrace?: string | null
    source?: string | null
    secureDetails?: string | null
    tenet?: TenetCreateNestedOneWithoutLogsInput
  }

  export type LogUncheckedCreateInput = {
    id: Uint8Array
    userEmail?: string | null
    tenetId?: Uint8Array | null
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    severity?: $Enums.LogLevel
    stacktrace?: string | null
    source?: string | null
    secureDetails?: string | null
  }

  export type LogUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    severity?: EnumLogLevelFieldUpdateOperationsInput | $Enums.LogLevel
    stacktrace?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    secureDetails?: NullableStringFieldUpdateOperationsInput | string | null
    tenet?: TenetUpdateOneWithoutLogsNestedInput
  }

  export type LogUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    tenetId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    severity?: EnumLogLevelFieldUpdateOperationsInput | $Enums.LogLevel
    stacktrace?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    secureDetails?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LogCreateManyInput = {
    id: Uint8Array
    userEmail?: string | null
    tenetId?: Uint8Array | null
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    severity?: $Enums.LogLevel
    stacktrace?: string | null
    source?: string | null
    secureDetails?: string | null
  }

  export type LogUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    severity?: EnumLogLevelFieldUpdateOperationsInput | $Enums.LogLevel
    stacktrace?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    secureDetails?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LogUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    tenetId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    severity?: EnumLogLevelFieldUpdateOperationsInput | $Enums.LogLevel
    stacktrace?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    secureDetails?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TokenCreateInput = {
    id: Uint8Array
    createdAt?: Date | string
    refresh?: boolean
    user: UserCreateNestedOneWithoutTokensInput
  }

  export type TokenUncheckedCreateInput = {
    id: Uint8Array
    userId: Uint8Array
    createdAt?: Date | string
    refresh?: boolean
  }

  export type TokenUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refresh?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutTokensNestedInput
  }

  export type TokenUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    userId?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refresh?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TokenCreateManyInput = {
    id: Uint8Array
    userId: Uint8Array
    createdAt?: Date | string
    refresh?: boolean
  }

  export type TokenUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refresh?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TokenUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    userId?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refresh?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TZDataCreateInput = {
    name: string
    provinceName: string
    countryCode: string
    tz: string
  }

  export type TZDataUncheckedCreateInput = {
    id?: number
    name: string
    provinceName: string
    countryCode: string
    tz: string
  }

  export type TZDataUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    provinceName?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    tz?: StringFieldUpdateOperationsInput | string
  }

  export type TZDataUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    provinceName?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    tz?: StringFieldUpdateOperationsInput | string
  }

  export type TZDataCreateManyInput = {
    id?: number
    name: string
    provinceName: string
    countryCode: string
    tz: string
  }

  export type TZDataUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    provinceName?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    tz?: StringFieldUpdateOperationsInput | string
  }

  export type TZDataUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    provinceName?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    tz?: StringFieldUpdateOperationsInput | string
  }

  export type TestObjectCreateInput = {
    id: Uint8Array
    required: string
    persisted?: string | null
    wrapped?: WrappedObjectCreateNestedManyWithoutTestObjectInput
    join1?: JoinTestObjectCreateNestedManyWithoutTestObjectRelationInput
    join2?: JoinTestObject2CreateNestedManyWithoutTestObjectRelationInput
  }

  export type TestObjectUncheckedCreateInput = {
    id: Uint8Array
    required: string
    persisted?: string | null
    wrapped?: WrappedObjectUncheckedCreateNestedManyWithoutTestObjectInput
    join1?: JoinTestObjectUncheckedCreateNestedManyWithoutTestObjectRelationInput
    join2?: JoinTestObject2UncheckedCreateNestedManyWithoutTestObjectRelationInput
  }

  export type TestObjectUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    required?: StringFieldUpdateOperationsInput | string
    persisted?: NullableStringFieldUpdateOperationsInput | string | null
    wrapped?: WrappedObjectUpdateManyWithoutTestObjectNestedInput
    join1?: JoinTestObjectUpdateManyWithoutTestObjectRelationNestedInput
    join2?: JoinTestObject2UpdateManyWithoutTestObjectRelationNestedInput
  }

  export type TestObjectUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    required?: StringFieldUpdateOperationsInput | string
    persisted?: NullableStringFieldUpdateOperationsInput | string | null
    wrapped?: WrappedObjectUncheckedUpdateManyWithoutTestObjectNestedInput
    join1?: JoinTestObjectUncheckedUpdateManyWithoutTestObjectRelationNestedInput
    join2?: JoinTestObject2UncheckedUpdateManyWithoutTestObjectRelationNestedInput
  }

  export type TestObjectCreateManyInput = {
    id: Uint8Array
    required: string
    persisted?: string | null
  }

  export type TestObjectUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    required?: StringFieldUpdateOperationsInput | string
    persisted?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TestObjectUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    required?: StringFieldUpdateOperationsInput | string
    persisted?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WrappedObjectCreateInput = {
    id: Uint8Array
    persisted?: string | null
    testObject: TestObjectCreateNestedOneWithoutWrappedInput
  }

  export type WrappedObjectUncheckedCreateInput = {
    id: Uint8Array
    persisted?: string | null
    testObjectId: Uint8Array
  }

  export type WrappedObjectUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    persisted?: NullableStringFieldUpdateOperationsInput | string | null
    testObject?: TestObjectUpdateOneRequiredWithoutWrappedNestedInput
  }

  export type WrappedObjectUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    persisted?: NullableStringFieldUpdateOperationsInput | string | null
    testObjectId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type WrappedObjectCreateManyInput = {
    id: Uint8Array
    persisted?: string | null
    testObjectId: Uint8Array
  }

  export type WrappedObjectUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    persisted?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WrappedObjectUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    persisted?: NullableStringFieldUpdateOperationsInput | string | null
    testObjectId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type JoinTestObjectCreateInput = {
    joinProperty: string
    testObjectRelation: TestObjectCreateNestedOneWithoutJoin1Input
    joinedObjectRelation: JoinedObject1CreateNestedOneWithoutTestObjectsInput
  }

  export type JoinTestObjectUncheckedCreateInput = {
    testObjectId: Uint8Array
    joinedObjectId: Uint8Array
    joinProperty: string
  }

  export type JoinTestObjectUpdateInput = {
    joinProperty?: StringFieldUpdateOperationsInput | string
    testObjectRelation?: TestObjectUpdateOneRequiredWithoutJoin1NestedInput
    joinedObjectRelation?: JoinedObject1UpdateOneRequiredWithoutTestObjectsNestedInput
  }

  export type JoinTestObjectUncheckedUpdateInput = {
    testObjectId?: BytesFieldUpdateOperationsInput | Uint8Array
    joinedObjectId?: BytesFieldUpdateOperationsInput | Uint8Array
    joinProperty?: StringFieldUpdateOperationsInput | string
  }

  export type JoinTestObjectCreateManyInput = {
    testObjectId: Uint8Array
    joinedObjectId: Uint8Array
    joinProperty: string
  }

  export type JoinTestObjectUpdateManyMutationInput = {
    joinProperty?: StringFieldUpdateOperationsInput | string
  }

  export type JoinTestObjectUncheckedUpdateManyInput = {
    testObjectId?: BytesFieldUpdateOperationsInput | Uint8Array
    joinedObjectId?: BytesFieldUpdateOperationsInput | Uint8Array
    joinProperty?: StringFieldUpdateOperationsInput | string
  }

  export type JoinTestObject2CreateInput = {
    id: Uint8Array
    joinProperty: string
    testObjectRelation: TestObjectCreateNestedOneWithoutJoin2Input
    joinedObjectRelation: JoinedObject2CreateNestedOneWithoutTestObjectsInput
  }

  export type JoinTestObject2UncheckedCreateInput = {
    id: Uint8Array
    testObjectId: Uint8Array
    joinedObjectId: Uint8Array
    joinProperty: string
  }

  export type JoinTestObject2UpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    joinProperty?: StringFieldUpdateOperationsInput | string
    testObjectRelation?: TestObjectUpdateOneRequiredWithoutJoin2NestedInput
    joinedObjectRelation?: JoinedObject2UpdateOneRequiredWithoutTestObjectsNestedInput
  }

  export type JoinTestObject2UncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    testObjectId?: BytesFieldUpdateOperationsInput | Uint8Array
    joinedObjectId?: BytesFieldUpdateOperationsInput | Uint8Array
    joinProperty?: StringFieldUpdateOperationsInput | string
  }

  export type JoinTestObject2CreateManyInput = {
    id: Uint8Array
    testObjectId: Uint8Array
    joinedObjectId: Uint8Array
    joinProperty: string
  }

  export type JoinTestObject2UpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    joinProperty?: StringFieldUpdateOperationsInput | string
  }

  export type JoinTestObject2UncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    testObjectId?: BytesFieldUpdateOperationsInput | Uint8Array
    joinedObjectId?: BytesFieldUpdateOperationsInput | Uint8Array
    joinProperty?: StringFieldUpdateOperationsInput | string
  }

  export type JoinedObject1CreateInput = {
    id: Uint8Array
    persisted?: string | null
    testObjects?: JoinTestObjectCreateNestedManyWithoutJoinedObjectRelationInput
  }

  export type JoinedObject1UncheckedCreateInput = {
    id: Uint8Array
    persisted?: string | null
    testObjects?: JoinTestObjectUncheckedCreateNestedManyWithoutJoinedObjectRelationInput
  }

  export type JoinedObject1UpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    persisted?: NullableStringFieldUpdateOperationsInput | string | null
    testObjects?: JoinTestObjectUpdateManyWithoutJoinedObjectRelationNestedInput
  }

  export type JoinedObject1UncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    persisted?: NullableStringFieldUpdateOperationsInput | string | null
    testObjects?: JoinTestObjectUncheckedUpdateManyWithoutJoinedObjectRelationNestedInput
  }

  export type JoinedObject1CreateManyInput = {
    id: Uint8Array
    persisted?: string | null
  }

  export type JoinedObject1UpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    persisted?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JoinedObject1UncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    persisted?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JoinedObject2CreateInput = {
    id: Uint8Array
    persisted?: string | null
    testObjects?: JoinTestObject2CreateNestedManyWithoutJoinedObjectRelationInput
  }

  export type JoinedObject2UncheckedCreateInput = {
    id: Uint8Array
    persisted?: string | null
    testObjects?: JoinTestObject2UncheckedCreateNestedManyWithoutJoinedObjectRelationInput
  }

  export type JoinedObject2UpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    persisted?: NullableStringFieldUpdateOperationsInput | string | null
    testObjects?: JoinTestObject2UpdateManyWithoutJoinedObjectRelationNestedInput
  }

  export type JoinedObject2UncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    persisted?: NullableStringFieldUpdateOperationsInput | string | null
    testObjects?: JoinTestObject2UncheckedUpdateManyWithoutJoinedObjectRelationNestedInput
  }

  export type JoinedObject2CreateManyInput = {
    id: Uint8Array
    persisted?: string | null
  }

  export type JoinedObject2UpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    persisted?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JoinedObject2UncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    persisted?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JoinSelfReferenceCreateInput = {
    id: Uint8Array
    joinProperty: string
    source: SelfReferencialJoinModelCreateNestedOneWithoutJoinsAsSourceInput
    target: SelfReferencialJoinModelCreateNestedOneWithoutJoinsAsTargetInput
  }

  export type JoinSelfReferenceUncheckedCreateInput = {
    id: Uint8Array
    sourceId: Uint8Array
    targetId: Uint8Array
    joinProperty: string
  }

  export type JoinSelfReferenceUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    joinProperty?: StringFieldUpdateOperationsInput | string
    source?: SelfReferencialJoinModelUpdateOneRequiredWithoutJoinsAsSourceNestedInput
    target?: SelfReferencialJoinModelUpdateOneRequiredWithoutJoinsAsTargetNestedInput
  }

  export type JoinSelfReferenceUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    sourceId?: BytesFieldUpdateOperationsInput | Uint8Array
    targetId?: BytesFieldUpdateOperationsInput | Uint8Array
    joinProperty?: StringFieldUpdateOperationsInput | string
  }

  export type JoinSelfReferenceCreateManyInput = {
    id: Uint8Array
    sourceId: Uint8Array
    targetId: Uint8Array
    joinProperty: string
  }

  export type JoinSelfReferenceUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    joinProperty?: StringFieldUpdateOperationsInput | string
  }

  export type JoinSelfReferenceUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    sourceId?: BytesFieldUpdateOperationsInput | Uint8Array
    targetId?: BytesFieldUpdateOperationsInput | Uint8Array
    joinProperty?: StringFieldUpdateOperationsInput | string
  }

  export type SelfReferencialJoinModelCreateInput = {
    id: Uint8Array
    joinsAsSource?: JoinSelfReferenceCreateNestedManyWithoutSourceInput
    joinsAsTarget?: JoinSelfReferenceCreateNestedManyWithoutTargetInput
  }

  export type SelfReferencialJoinModelUncheckedCreateInput = {
    id: Uint8Array
    joinsAsSource?: JoinSelfReferenceUncheckedCreateNestedManyWithoutSourceInput
    joinsAsTarget?: JoinSelfReferenceUncheckedCreateNestedManyWithoutTargetInput
  }

  export type SelfReferencialJoinModelUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    joinsAsSource?: JoinSelfReferenceUpdateManyWithoutSourceNestedInput
    joinsAsTarget?: JoinSelfReferenceUpdateManyWithoutTargetNestedInput
  }

  export type SelfReferencialJoinModelUncheckedUpdateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    joinsAsSource?: JoinSelfReferenceUncheckedUpdateManyWithoutSourceNestedInput
    joinsAsTarget?: JoinSelfReferenceUncheckedUpdateManyWithoutTargetNestedInput
  }

  export type SelfReferencialJoinModelCreateManyInput = {
    id: Uint8Array
  }

  export type SelfReferencialJoinModelUpdateManyMutationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type SelfReferencialJoinModelUncheckedUpdateManyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type BytesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel>
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesFilter<$PrismaModel> | Uint8Array
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type LogListRelationFilter = {
    every?: LogWhereInput
    some?: LogWhereInput
    none?: LogWhereInput
  }

  export type ContactListRelationFilter = {
    every?: ContactWhereInput
    some?: ContactWhereInput
    none?: ContactWhereInput
  }

  export type ActivityListRelationFilter = {
    every?: ActivityWhereInput
    some?: ActivityWhereInput
    none?: ActivityWhereInput
  }

  export type AddressListRelationFilter = {
    every?: AddressWhereInput
    some?: AddressWhereInput
    none?: AddressWhereInput
  }

  export type ContactEmailListRelationFilter = {
    every?: ContactEmailWhereInput
    some?: ContactEmailWhereInput
    none?: ContactEmailWhereInput
  }

  export type ContactPhoneListRelationFilter = {
    every?: ContactPhoneWhereInput
    some?: ContactPhoneWhereInput
    none?: ContactPhoneWhereInput
  }

  export type ImportantDateListRelationFilter = {
    every?: ImportantDateWhereInput
    some?: ImportantDateWhereInput
    none?: ImportantDateWhereInput
  }

  export type AttachmentListRelationFilter = {
    every?: AttachmentWhereInput
    some?: AttachmentWhereInput
    none?: AttachmentWhereInput
  }

  export type NoteListRelationFilter = {
    every?: NoteWhereInput
    some?: NoteWhereInput
    none?: NoteWhereInput
  }

  export type AuditEventListRelationFilter = {
    every?: AuditEventWhereInput
    some?: AuditEventWhereInput
    none?: AuditEventWhereInput
  }

  export type ContactTimelineEventListRelationFilter = {
    every?: ContactTimelineEventWhereInput
    some?: ContactTimelineEventWhereInput
    none?: ContactTimelineEventWhereInput
  }

  export type ActivityStepListRelationFilter = {
    every?: ActivityStepWhereInput
    some?: ActivityStepWhereInput
    none?: ActivityStepWhereInput
  }

  export type ActivityWaypointListRelationFilter = {
    every?: ActivityWaypointWhereInput
    some?: ActivityWaypointWhereInput
    none?: ActivityWaypointWhereInput
  }

  export type TemplateAssignmentListRelationFilter = {
    every?: TemplateAssignmentWhereInput
    some?: TemplateAssignmentWhereInput
    none?: TemplateAssignmentWhereInput
  }

  export type ActivityWaypointTemplateListRelationFilter = {
    every?: ActivityWaypointTemplateWhereInput
    some?: ActivityWaypointTemplateWhereInput
    none?: ActivityWaypointTemplateWhereInput
  }

  export type ActivityTemplateListRelationFilter = {
    every?: ActivityTemplateWhereInput
    some?: ActivityTemplateWhereInput
    none?: ActivityTemplateWhereInput
  }

  export type ActivityTemplateStepListRelationFilter = {
    every?: ActivityTemplateStepWhereInput
    some?: ActivityTemplateStepWhereInput
    none?: ActivityTemplateStepWhereInput
  }

  export type OpportunityListRelationFilter = {
    every?: OpportunityWhereInput
    some?: OpportunityWhereInput
    none?: OpportunityWhereInput
  }

  export type ProductTypeListRelationFilter = {
    every?: ProductTypeWhereInput
    some?: ProductTypeWhereInput
    none?: ProductTypeWhereInput
  }

  export type ActivityTemplateStepAssignmentListRelationFilter = {
    every?: ActivityTemplateStepAssignmentWhereInput
    some?: ActivityTemplateStepAssignmentWhereInput
    none?: ActivityTemplateStepAssignmentWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActivityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AddressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactEmailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactPhoneOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ImportantDateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactTimelineEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActivityStepOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActivityWaypointOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TemplateAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActivityWaypointTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActivityTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActivityTemplateStepOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OpportunityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductTypeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActivityTemplateStepAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenetCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenetMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenetMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel>
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Uint8Array
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumAccessGroupFilter<$PrismaModel = never> = {
    equals?: $Enums.AccessGroup | EnumAccessGroupFieldRefInput<$PrismaModel>
    in?: $Enums.AccessGroup[] | ListEnumAccessGroupFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccessGroup[] | ListEnumAccessGroupFieldRefInput<$PrismaModel>
    not?: NestedEnumAccessGroupFilter<$PrismaModel> | $Enums.AccessGroup
  }

  export type BytesNullableFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Uint8Array | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type TokenListRelationFilter = {
    every?: TokenWhereInput
    some?: TokenWhereInput
    none?: TokenWhereInput
  }

  export type TenetNullableScalarRelationFilter = {
    is?: TenetWhereInput | null
    isNot?: TenetWhereInput | null
  }

  export type ActivityUserJoinListRelationFilter = {
    every?: ActivityUserJoinWhereInput
    some?: ActivityUserJoinWhereInput
    none?: ActivityUserJoinWhereInput
  }

  export type UserWaypointJoinListRelationFilter = {
    every?: UserWaypointJoinWhereInput
    some?: UserWaypointJoinWhereInput
    none?: UserWaypointJoinWhereInput
  }

  export type UserOpportunityJoinListRelationFilter = {
    every?: UserOpportunityJoinWhereInput
    some?: UserOpportunityJoinWhereInput
    none?: UserOpportunityJoinWhereInput
  }

  export type ActivityStepUserJoinListRelationFilter = {
    every?: ActivityStepUserJoinWhereInput
    some?: ActivityStepUserJoinWhereInput
    none?: ActivityStepUserJoinWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type TokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActivityUserJoinOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserWaypointJoinOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOpportunityJoinOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActivityStepUserJoinOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    fullName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    password?: SortOrder
    enabled?: SortOrder
    type?: SortOrder
    tenetId?: SortOrder
    system?: SortOrder
    deleted?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    fullName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    password?: SortOrder
    enabled?: SortOrder
    type?: SortOrder
    tenetId?: SortOrder
    system?: SortOrder
    deleted?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    fullName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    password?: SortOrder
    enabled?: SortOrder
    type?: SortOrder
    tenetId?: SortOrder
    system?: SortOrder
    deleted?: SortOrder
    deletedAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumAccessGroupWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccessGroup | EnumAccessGroupFieldRefInput<$PrismaModel>
    in?: $Enums.AccessGroup[] | ListEnumAccessGroupFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccessGroup[] | ListEnumAccessGroupFieldRefInput<$PrismaModel>
    not?: NestedEnumAccessGroupWithAggregatesFilter<$PrismaModel> | $Enums.AccessGroup
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccessGroupFilter<$PrismaModel>
    _max?: NestedEnumAccessGroupFilter<$PrismaModel>
  }

  export type BytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Uint8Array | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumContactTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactType | EnumContactTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContactTypeFilter<$PrismaModel> | $Enums.ContactType
  }

  export type EnumContactStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactStatus | EnumContactStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContactStatus[] | ListEnumContactStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactStatus[] | ListEnumContactStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContactStatusFilter<$PrismaModel> | $Enums.ContactStatus
  }

  export type EnumLifecycleStageNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.LifecycleStage | EnumLifecycleStageFieldRefInput<$PrismaModel> | null
    in?: $Enums.LifecycleStage[] | ListEnumLifecycleStageFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.LifecycleStage[] | ListEnumLifecycleStageFieldRefInput<$PrismaModel> | null
    not?: NestedEnumLifecycleStageNullableFilter<$PrismaModel> | $Enums.LifecycleStage | null
  }

  export type EnumHouseholdRelationshipStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.HouseholdRelationshipStatus | EnumHouseholdRelationshipStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.HouseholdRelationshipStatus[] | ListEnumHouseholdRelationshipStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.HouseholdRelationshipStatus[] | ListEnumHouseholdRelationshipStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumHouseholdRelationshipStatusNullableFilter<$PrismaModel> | $Enums.HouseholdRelationshipStatus | null
  }

  export type EnumCompanyRelationshipStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanyRelationshipStatus | EnumCompanyRelationshipStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.CompanyRelationshipStatus[] | ListEnumCompanyRelationshipStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CompanyRelationshipStatus[] | ListEnumCompanyRelationshipStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCompanyRelationshipStatusNullableFilter<$PrismaModel> | $Enums.CompanyRelationshipStatus | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type TenetScalarRelationFilter = {
    is?: TenetWhereInput
    isNot?: TenetWhereInput
  }

  export type ContactTimelineEventContactJoinListRelationFilter = {
    every?: ContactTimelineEventContactJoinWhereInput
    some?: ContactTimelineEventContactJoinWhereInput
    none?: ContactTimelineEventContactJoinWhereInput
  }

  export type ActivityContactJoinListRelationFilter = {
    every?: ActivityContactJoinWhereInput
    some?: ActivityContactJoinWhereInput
    none?: ActivityContactJoinWhereInput
  }

  export type ContactNullableScalarRelationFilter = {
    is?: ContactWhereInput | null
    isNot?: ContactWhereInput | null
  }

  export type ContactOpportunityJoinListRelationFilter = {
    every?: ContactOpportunityJoinWhereInput
    some?: ContactOpportunityJoinWhereInput
    none?: ContactOpportunityJoinWhereInput
  }

  export type ContactRelationshipListRelationFilter = {
    every?: ContactRelationshipWhereInput
    some?: ContactRelationshipWhereInput
    none?: ContactRelationshipWhereInput
  }

  export type ContactTimelineEventContactJoinOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActivityContactJoinOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactOpportunityJoinOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactRelationshipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    fullName?: SortOrder
    tenetId?: SortOrder
    importantNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    type?: SortOrder
    status?: SortOrder
    lifecycleStage?: SortOrder
    lastContactedDate?: SortOrder
    followUpDate?: SortOrder
    householdId?: SortOrder
    householdStatus?: SortOrder
    companyId?: SortOrder
    position?: SortOrder
    companyStatus?: SortOrder
    headOfHouseholdId?: SortOrder
    industry?: SortOrder
    website?: SortOrder
    size?: SortOrder
    primaryContactId?: SortOrder
    deleted?: SortOrder
    deletedAt?: SortOrder
  }

  export type ContactAvgOrderByAggregateInput = {
    size?: SortOrder
  }

  export type ContactMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    fullName?: SortOrder
    tenetId?: SortOrder
    importantNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    type?: SortOrder
    status?: SortOrder
    lifecycleStage?: SortOrder
    lastContactedDate?: SortOrder
    followUpDate?: SortOrder
    householdId?: SortOrder
    householdStatus?: SortOrder
    companyId?: SortOrder
    position?: SortOrder
    companyStatus?: SortOrder
    headOfHouseholdId?: SortOrder
    industry?: SortOrder
    website?: SortOrder
    size?: SortOrder
    primaryContactId?: SortOrder
    deleted?: SortOrder
    deletedAt?: SortOrder
  }

  export type ContactMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    fullName?: SortOrder
    tenetId?: SortOrder
    importantNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    type?: SortOrder
    status?: SortOrder
    lifecycleStage?: SortOrder
    lastContactedDate?: SortOrder
    followUpDate?: SortOrder
    householdId?: SortOrder
    householdStatus?: SortOrder
    companyId?: SortOrder
    position?: SortOrder
    companyStatus?: SortOrder
    headOfHouseholdId?: SortOrder
    industry?: SortOrder
    website?: SortOrder
    size?: SortOrder
    primaryContactId?: SortOrder
    deleted?: SortOrder
    deletedAt?: SortOrder
  }

  export type ContactSumOrderByAggregateInput = {
    size?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumContactTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactType | EnumContactTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContactTypeWithAggregatesFilter<$PrismaModel> | $Enums.ContactType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContactTypeFilter<$PrismaModel>
    _max?: NestedEnumContactTypeFilter<$PrismaModel>
  }

  export type EnumContactStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactStatus | EnumContactStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContactStatus[] | ListEnumContactStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactStatus[] | ListEnumContactStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContactStatusWithAggregatesFilter<$PrismaModel> | $Enums.ContactStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContactStatusFilter<$PrismaModel>
    _max?: NestedEnumContactStatusFilter<$PrismaModel>
  }

  export type EnumLifecycleStageNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LifecycleStage | EnumLifecycleStageFieldRefInput<$PrismaModel> | null
    in?: $Enums.LifecycleStage[] | ListEnumLifecycleStageFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.LifecycleStage[] | ListEnumLifecycleStageFieldRefInput<$PrismaModel> | null
    not?: NestedEnumLifecycleStageNullableWithAggregatesFilter<$PrismaModel> | $Enums.LifecycleStage | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumLifecycleStageNullableFilter<$PrismaModel>
    _max?: NestedEnumLifecycleStageNullableFilter<$PrismaModel>
  }

  export type EnumHouseholdRelationshipStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HouseholdRelationshipStatus | EnumHouseholdRelationshipStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.HouseholdRelationshipStatus[] | ListEnumHouseholdRelationshipStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.HouseholdRelationshipStatus[] | ListEnumHouseholdRelationshipStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumHouseholdRelationshipStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.HouseholdRelationshipStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumHouseholdRelationshipStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumHouseholdRelationshipStatusNullableFilter<$PrismaModel>
  }

  export type EnumCompanyRelationshipStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanyRelationshipStatus | EnumCompanyRelationshipStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.CompanyRelationshipStatus[] | ListEnumCompanyRelationshipStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CompanyRelationshipStatus[] | ListEnumCompanyRelationshipStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCompanyRelationshipStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.CompanyRelationshipStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumCompanyRelationshipStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumCompanyRelationshipStatusNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type ContactScalarRelationFilter = {
    is?: ContactWhereInput
    isNot?: ContactWhereInput
  }

  export type ContactRelationshipSourceIdTargetIdTypeCompoundUniqueInput = {
    sourceId: Uint8Array
    targetId: Uint8Array
    type: string
  }

  export type ContactRelationshipCountOrderByAggregateInput = {
    id?: SortOrder
    sourceId?: SortOrder
    targetId?: SortOrder
    type?: SortOrder
    established?: SortOrder
    notes?: SortOrder
  }

  export type ContactRelationshipMaxOrderByAggregateInput = {
    id?: SortOrder
    sourceId?: SortOrder
    targetId?: SortOrder
    type?: SortOrder
    established?: SortOrder
    notes?: SortOrder
  }

  export type ContactRelationshipMinOrderByAggregateInput = {
    id?: SortOrder
    sourceId?: SortOrder
    targetId?: SortOrder
    type?: SortOrder
    established?: SortOrder
    notes?: SortOrder
  }

  export type EnumActivityStepTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityStepType | EnumActivityStepTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityStepType[] | ListEnumActivityStepTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityStepType[] | ListEnumActivityStepTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityStepTypeFilter<$PrismaModel> | $Enums.ActivityStepType
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type ActivityScalarRelationFilter = {
    is?: ActivityWhereInput
    isNot?: ActivityWhereInput
  }

  export type ActivityStepCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    completed?: SortOrder
    activityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenetId?: SortOrder
    type?: SortOrder
    order?: SortOrder
  }

  export type ActivityStepAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type ActivityStepMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    completed?: SortOrder
    activityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenetId?: SortOrder
    type?: SortOrder
    order?: SortOrder
  }

  export type ActivityStepMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    completed?: SortOrder
    activityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenetId?: SortOrder
    type?: SortOrder
    order?: SortOrder
  }

  export type ActivityStepSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type EnumActivityStepTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityStepType | EnumActivityStepTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityStepType[] | ListEnumActivityStepTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityStepType[] | ListEnumActivityStepTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityStepTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActivityStepType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActivityStepTypeFilter<$PrismaModel>
    _max?: NestedEnumActivityStepTypeFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type ActivityStepScalarRelationFilter = {
    is?: ActivityStepWhereInput
    isNot?: ActivityStepWhereInput
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ActivityStepUserJoinActivityStepIdUserIdCompoundUniqueInput = {
    activityStepId: Uint8Array
    userId: Uint8Array
  }

  export type ActivityStepUserJoinCountOrderByAggregateInput = {
    activityStepId?: SortOrder
    userId?: SortOrder
  }

  export type ActivityStepUserJoinMaxOrderByAggregateInput = {
    activityStepId?: SortOrder
    userId?: SortOrder
  }

  export type ActivityStepUserJoinMinOrderByAggregateInput = {
    activityStepId?: SortOrder
    userId?: SortOrder
  }

  export type ActivityWaypointScalarRelationFilter = {
    is?: ActivityWaypointWhereInput
    isNot?: ActivityWaypointWhereInput
  }

  export type UserWaypointJoinUserIdWaypointIdCompoundUniqueInput = {
    userId: Uint8Array
    waypointId: Uint8Array
  }

  export type UserWaypointJoinCountOrderByAggregateInput = {
    userId?: SortOrder
    waypointId?: SortOrder
  }

  export type UserWaypointJoinMaxOrderByAggregateInput = {
    userId?: SortOrder
    waypointId?: SortOrder
  }

  export type UserWaypointJoinMinOrderByAggregateInput = {
    userId?: SortOrder
    waypointId?: SortOrder
  }

  export type EnumActivityStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityStatus | EnumActivityStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityStatus[] | ListEnumActivityStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityStatus[] | ListEnumActivityStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityStatusFilter<$PrismaModel> | $Enums.ActivityStatus
  }

  export type ActivityWaypointTemplateNullableScalarRelationFilter = {
    is?: ActivityWaypointTemplateWhereInput | null
    isNot?: ActivityWaypointTemplateWhereInput | null
  }

  export type ActivityWaypointCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    summary?: SortOrder
    status?: SortOrder
    order?: SortOrder
    actualStart?: SortOrder
    dueDate?: SortOrder
    actualEnd?: SortOrder
    activityId?: SortOrder
    templateId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenetId?: SortOrder
  }

  export type ActivityWaypointAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type ActivityWaypointMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    summary?: SortOrder
    status?: SortOrder
    order?: SortOrder
    actualStart?: SortOrder
    dueDate?: SortOrder
    actualEnd?: SortOrder
    activityId?: SortOrder
    templateId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenetId?: SortOrder
  }

  export type ActivityWaypointMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    summary?: SortOrder
    status?: SortOrder
    order?: SortOrder
    actualStart?: SortOrder
    dueDate?: SortOrder
    actualEnd?: SortOrder
    activityId?: SortOrder
    templateId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenetId?: SortOrder
  }

  export type ActivityWaypointSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type EnumActivityStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityStatus | EnumActivityStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityStatus[] | ListEnumActivityStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityStatus[] | ListEnumActivityStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityStatusWithAggregatesFilter<$PrismaModel> | $Enums.ActivityStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActivityStatusFilter<$PrismaModel>
    _max?: NestedEnumActivityStatusFilter<$PrismaModel>
  }

  export type EnumRoleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRoleNullableFilter<$PrismaModel> | $Enums.Role | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ActivityTemplateNullableScalarRelationFilter = {
    is?: ActivityTemplateWhereInput | null
    isNot?: ActivityTemplateWhereInput | null
  }

  export type TemplateAssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    specificUserId?: SortOrder
    specificRole?: SortOrder
    activityTemplateId?: SortOrder
    waypointTemplateId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenetId?: SortOrder
  }

  export type TemplateAssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    specificUserId?: SortOrder
    specificRole?: SortOrder
    activityTemplateId?: SortOrder
    waypointTemplateId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenetId?: SortOrder
  }

  export type TemplateAssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    specificUserId?: SortOrder
    specificRole?: SortOrder
    activityTemplateId?: SortOrder
    waypointTemplateId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenetId?: SortOrder
  }

  export type EnumRoleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRoleNullableWithAggregatesFilter<$PrismaModel> | $Enums.Role | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRoleNullableFilter<$PrismaModel>
    _max?: NestedEnumRoleNullableFilter<$PrismaModel>
  }

  export type EnumDateOffsetTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DateOffsetType | EnumDateOffsetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DateOffsetType[] | ListEnumDateOffsetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DateOffsetType[] | ListEnumDateOffsetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDateOffsetTypeFilter<$PrismaModel> | $Enums.DateOffsetType
  }

  export type ActivityTemplateScalarRelationFilter = {
    is?: ActivityTemplateWhereInput
    isNot?: ActivityTemplateWhereInput
  }

  export type ActivityWaypointTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    defaultStatus?: SortOrder
    order?: SortOrder
    dateOffsetType?: SortOrder
    dueDate?: SortOrder
    parentActivityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenetId?: SortOrder
  }

  export type ActivityWaypointTemplateAvgOrderByAggregateInput = {
    order?: SortOrder
    dueDate?: SortOrder
  }

  export type ActivityWaypointTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    defaultStatus?: SortOrder
    order?: SortOrder
    dateOffsetType?: SortOrder
    dueDate?: SortOrder
    parentActivityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenetId?: SortOrder
  }

  export type ActivityWaypointTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    defaultStatus?: SortOrder
    order?: SortOrder
    dateOffsetType?: SortOrder
    dueDate?: SortOrder
    parentActivityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenetId?: SortOrder
  }

  export type ActivityWaypointTemplateSumOrderByAggregateInput = {
    order?: SortOrder
    dueDate?: SortOrder
  }

  export type EnumDateOffsetTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DateOffsetType | EnumDateOffsetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DateOffsetType[] | ListEnumDateOffsetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DateOffsetType[] | ListEnumDateOffsetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDateOffsetTypeWithAggregatesFilter<$PrismaModel> | $Enums.DateOffsetType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDateOffsetTypeFilter<$PrismaModel>
    _max?: NestedEnumDateOffsetTypeFilter<$PrismaModel>
  }

  export type ActivityTemplateStepCountOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
    title?: SortOrder
    type?: SortOrder
    activityTemplateId?: SortOrder
    tenetId?: SortOrder
  }

  export type ActivityTemplateStepAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type ActivityTemplateStepMaxOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
    title?: SortOrder
    type?: SortOrder
    activityTemplateId?: SortOrder
    tenetId?: SortOrder
  }

  export type ActivityTemplateStepMinOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
    title?: SortOrder
    type?: SortOrder
    activityTemplateId?: SortOrder
    tenetId?: SortOrder
  }

  export type ActivityTemplateStepSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type ActivityTemplateStepScalarRelationFilter = {
    is?: ActivityTemplateStepWhereInput
    isNot?: ActivityTemplateStepWhereInput
  }

  export type ActivityTemplateStepAssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    specificUserId?: SortOrder
    specificRole?: SortOrder
    activityTemplateStepId?: SortOrder
    tenetId?: SortOrder
  }

  export type ActivityTemplateStepAssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    specificUserId?: SortOrder
    specificRole?: SortOrder
    activityTemplateStepId?: SortOrder
    tenetId?: SortOrder
  }

  export type ActivityTemplateStepAssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    specificUserId?: SortOrder
    specificRole?: SortOrder
    activityTemplateStepId?: SortOrder
    tenetId?: SortOrder
  }

  export type EnumActivityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTypeFilter<$PrismaModel> | $Enums.ActivityType
  }

  export type EnumActivityPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityPriority | EnumActivityPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityPriority[] | ListEnumActivityPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityPriority[] | ListEnumActivityPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityPriorityFilter<$PrismaModel> | $Enums.ActivityPriority
  }

  export type EnumTaskScheduleTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskScheduleType | EnumTaskScheduleTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.TaskScheduleType[] | ListEnumTaskScheduleTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TaskScheduleType[] | ListEnumTaskScheduleTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTaskScheduleTypeNullableFilter<$PrismaModel> | $Enums.TaskScheduleType | null
  }

  export type ActivityTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    defaultPriority?: SortOrder
    defaultStatus?: SortOrder
    taskScheduleType?: SortOrder
    dateOffsetType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    startRelativeToId?: SortOrder
    parentWaypointId?: SortOrder
    parentActivityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenetId?: SortOrder
    order?: SortOrder
  }

  export type ActivityTemplateAvgOrderByAggregateInput = {
    startDate?: SortOrder
    endDate?: SortOrder
    order?: SortOrder
  }

  export type ActivityTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    defaultPriority?: SortOrder
    defaultStatus?: SortOrder
    taskScheduleType?: SortOrder
    dateOffsetType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    startRelativeToId?: SortOrder
    parentWaypointId?: SortOrder
    parentActivityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenetId?: SortOrder
    order?: SortOrder
  }

  export type ActivityTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    defaultPriority?: SortOrder
    defaultStatus?: SortOrder
    taskScheduleType?: SortOrder
    dateOffsetType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    startRelativeToId?: SortOrder
    parentWaypointId?: SortOrder
    parentActivityId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenetId?: SortOrder
    order?: SortOrder
  }

  export type ActivityTemplateSumOrderByAggregateInput = {
    startDate?: SortOrder
    endDate?: SortOrder
    order?: SortOrder
  }

  export type EnumActivityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActivityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActivityTypeFilter<$PrismaModel>
    _max?: NestedEnumActivityTypeFilter<$PrismaModel>
  }

  export type EnumActivityPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityPriority | EnumActivityPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityPriority[] | ListEnumActivityPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityPriority[] | ListEnumActivityPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityPriorityWithAggregatesFilter<$PrismaModel> | $Enums.ActivityPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActivityPriorityFilter<$PrismaModel>
    _max?: NestedEnumActivityPriorityFilter<$PrismaModel>
  }

  export type EnumTaskScheduleTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskScheduleType | EnumTaskScheduleTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.TaskScheduleType[] | ListEnumTaskScheduleTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TaskScheduleType[] | ListEnumTaskScheduleTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTaskScheduleTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.TaskScheduleType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTaskScheduleTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumTaskScheduleTypeNullableFilter<$PrismaModel>
  }

  export type ActivityNullableScalarRelationFilter = {
    is?: ActivityWhereInput | null
    isNot?: ActivityWhereInput | null
  }

  export type ActivityWaypointNullableScalarRelationFilter = {
    is?: ActivityWaypointWhereInput | null
    isNot?: ActivityWaypointWhereInput | null
  }

  export type OpportunityNullableScalarRelationFilter = {
    is?: OpportunityWhereInput | null
    isNot?: OpportunityWhereInput | null
  }

  export type ActivityCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    parentActivityId?: SortOrder
    parentWaypointId?: SortOrder
    templateId?: SortOrder
    taskScheduleType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    completedAt?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    assignedById?: SortOrder
    phoneNumber?: SortOrder
    location?: SortOrder
    holdReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenetId?: SortOrder
    deleted?: SortOrder
    deletedAt?: SortOrder
    order?: SortOrder
    opportunityId?: SortOrder
  }

  export type ActivityAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type ActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    parentActivityId?: SortOrder
    parentWaypointId?: SortOrder
    templateId?: SortOrder
    taskScheduleType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    completedAt?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    assignedById?: SortOrder
    phoneNumber?: SortOrder
    location?: SortOrder
    holdReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenetId?: SortOrder
    deleted?: SortOrder
    deletedAt?: SortOrder
    order?: SortOrder
    opportunityId?: SortOrder
  }

  export type ActivityMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    type?: SortOrder
    parentActivityId?: SortOrder
    parentWaypointId?: SortOrder
    templateId?: SortOrder
    taskScheduleType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    completedAt?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    assignedById?: SortOrder
    phoneNumber?: SortOrder
    location?: SortOrder
    holdReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenetId?: SortOrder
    deleted?: SortOrder
    deletedAt?: SortOrder
    order?: SortOrder
    opportunityId?: SortOrder
  }

  export type ActivitySumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type EnumContactTimelineEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactTimelineEventType | EnumContactTimelineEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContactTimelineEventType[] | ListEnumContactTimelineEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactTimelineEventType[] | ListEnumContactTimelineEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContactTimelineEventTypeFilter<$PrismaModel> | $Enums.ContactTimelineEventType
  }

  export type NoteNullableScalarRelationFilter = {
    is?: NoteWhereInput | null
    isNot?: NoteWhereInput | null
  }

  export type ContactTimelineEventCountOrderByAggregateInput = {
    id?: SortOrder
    activityId?: SortOrder
    waypointId?: SortOrder
    opportunityId?: SortOrder
    noteId?: SortOrder
    extraInfo?: SortOrder
    userId?: SortOrder
    tenetId?: SortOrder
    eventType?: SortOrder
    relationshipType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactTimelineEventMaxOrderByAggregateInput = {
    id?: SortOrder
    activityId?: SortOrder
    waypointId?: SortOrder
    opportunityId?: SortOrder
    noteId?: SortOrder
    extraInfo?: SortOrder
    userId?: SortOrder
    tenetId?: SortOrder
    eventType?: SortOrder
    relationshipType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactTimelineEventMinOrderByAggregateInput = {
    id?: SortOrder
    activityId?: SortOrder
    waypointId?: SortOrder
    opportunityId?: SortOrder
    noteId?: SortOrder
    extraInfo?: SortOrder
    userId?: SortOrder
    tenetId?: SortOrder
    eventType?: SortOrder
    relationshipType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumContactTimelineEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactTimelineEventType | EnumContactTimelineEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContactTimelineEventType[] | ListEnumContactTimelineEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactTimelineEventType[] | ListEnumContactTimelineEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContactTimelineEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.ContactTimelineEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContactTimelineEventTypeFilter<$PrismaModel>
    _max?: NestedEnumContactTimelineEventTypeFilter<$PrismaModel>
  }

  export type EnumAuditEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditEventType | EnumAuditEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AuditEventType[] | ListEnumAuditEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditEventType[] | ListEnumAuditEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditEventTypeFilter<$PrismaModel> | $Enums.AuditEventType
  }

  export type EnumAuditableFilter<$PrismaModel = never> = {
    equals?: $Enums.Auditable | EnumAuditableFieldRefInput<$PrismaModel>
    in?: $Enums.Auditable[] | ListEnumAuditableFieldRefInput<$PrismaModel>
    notIn?: $Enums.Auditable[] | ListEnumAuditableFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditableFilter<$PrismaModel> | $Enums.Auditable
  }

  export type AuditEventCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tenetId?: SortOrder
    type?: SortOrder
    details?: SortOrder
    referenceId?: SortOrder
    reference?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuditEventMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tenetId?: SortOrder
    type?: SortOrder
    details?: SortOrder
    referenceId?: SortOrder
    reference?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuditEventMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tenetId?: SortOrder
    type?: SortOrder
    details?: SortOrder
    referenceId?: SortOrder
    reference?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAuditEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditEventType | EnumAuditEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AuditEventType[] | ListEnumAuditEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditEventType[] | ListEnumAuditEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.AuditEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditEventTypeFilter<$PrismaModel>
    _max?: NestedEnumAuditEventTypeFilter<$PrismaModel>
  }

  export type EnumAuditableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Auditable | EnumAuditableFieldRefInput<$PrismaModel>
    in?: $Enums.Auditable[] | ListEnumAuditableFieldRefInput<$PrismaModel>
    notIn?: $Enums.Auditable[] | ListEnumAuditableFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditableWithAggregatesFilter<$PrismaModel> | $Enums.Auditable
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditableFilter<$PrismaModel>
    _max?: NestedEnumAuditableFilter<$PrismaModel>
  }

  export type EnumContactTimelineEventJoinTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactTimelineEventJoinType | EnumContactTimelineEventJoinTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContactTimelineEventJoinType[] | ListEnumContactTimelineEventJoinTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactTimelineEventJoinType[] | ListEnumContactTimelineEventJoinTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContactTimelineEventJoinTypeFilter<$PrismaModel> | $Enums.ContactTimelineEventJoinType
  }

  export type ContactTimelineEventScalarRelationFilter = {
    is?: ContactTimelineEventWhereInput
    isNot?: ContactTimelineEventWhereInput
  }

  export type ContactTimelineEventContactJoinContactEventIdContactIdCompoundUniqueInput = {
    contactEventId: Uint8Array
    contactId: Uint8Array
  }

  export type ContactTimelineEventContactJoinCountOrderByAggregateInput = {
    contactEventId?: SortOrder
    contactId?: SortOrder
    type?: SortOrder
  }

  export type ContactTimelineEventContactJoinMaxOrderByAggregateInput = {
    contactEventId?: SortOrder
    contactId?: SortOrder
    type?: SortOrder
  }

  export type ContactTimelineEventContactJoinMinOrderByAggregateInput = {
    contactEventId?: SortOrder
    contactId?: SortOrder
    type?: SortOrder
  }

  export type EnumContactTimelineEventJoinTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactTimelineEventJoinType | EnumContactTimelineEventJoinTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContactTimelineEventJoinType[] | ListEnumContactTimelineEventJoinTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactTimelineEventJoinType[] | ListEnumContactTimelineEventJoinTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContactTimelineEventJoinTypeWithAggregatesFilter<$PrismaModel> | $Enums.ContactTimelineEventJoinType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContactTimelineEventJoinTypeFilter<$PrismaModel>
    _max?: NestedEnumContactTimelineEventJoinTypeFilter<$PrismaModel>
  }

  export type EnumNoteTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NoteType | EnumNoteTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NoteType[] | ListEnumNoteTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NoteType[] | ListEnumNoteTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNoteTypeFilter<$PrismaModel> | $Enums.NoteType
  }

  export type NoteCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    waypointId?: SortOrder
    activityId?: SortOrder
    contactId?: SortOrder
    opportunityId?: SortOrder
    tenetId?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleted?: SortOrder
    deletedAt?: SortOrder
    noteType?: SortOrder
  }

  export type NoteMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    waypointId?: SortOrder
    activityId?: SortOrder
    contactId?: SortOrder
    opportunityId?: SortOrder
    tenetId?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleted?: SortOrder
    deletedAt?: SortOrder
    noteType?: SortOrder
  }

  export type NoteMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    waypointId?: SortOrder
    activityId?: SortOrder
    contactId?: SortOrder
    opportunityId?: SortOrder
    tenetId?: SortOrder
    authorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deleted?: SortOrder
    deletedAt?: SortOrder
    noteType?: SortOrder
  }

  export type EnumNoteTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NoteType | EnumNoteTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NoteType[] | ListEnumNoteTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NoteType[] | ListEnumNoteTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNoteTypeWithAggregatesFilter<$PrismaModel> | $Enums.NoteType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNoteTypeFilter<$PrismaModel>
    _max?: NestedEnumNoteTypeFilter<$PrismaModel>
  }

  export type AttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    activityId?: SortOrder
    tenetId?: SortOrder
  }

  export type AttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    activityId?: SortOrder
    tenetId?: SortOrder
  }

  export type AttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    activityId?: SortOrder
    tenetId?: SortOrder
  }

  export type ActivityContactJoinActivityIdContactIdCompoundUniqueInput = {
    activityId: Uint8Array
    contactId: Uint8Array
  }

  export type ActivityContactJoinCountOrderByAggregateInput = {
    activityId?: SortOrder
    contactId?: SortOrder
  }

  export type ActivityContactJoinMaxOrderByAggregateInput = {
    activityId?: SortOrder
    contactId?: SortOrder
  }

  export type ActivityContactJoinMinOrderByAggregateInput = {
    activityId?: SortOrder
    contactId?: SortOrder
  }

  export type ActivityUserJoinActivityIdUserIdCompoundUniqueInput = {
    activityId: Uint8Array
    userId: Uint8Array
  }

  export type ActivityUserJoinCountOrderByAggregateInput = {
    activityId?: SortOrder
    userId?: SortOrder
  }

  export type ActivityUserJoinMaxOrderByAggregateInput = {
    activityId?: SortOrder
    userId?: SortOrder
  }

  export type ActivityUserJoinMinOrderByAggregateInput = {
    activityId?: SortOrder
    userId?: SortOrder
  }

  export type ContactEmailCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    isPrimary?: SortOrder
    contactId?: SortOrder
    tenetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactEmailMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    isPrimary?: SortOrder
    contactId?: SortOrder
    tenetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactEmailMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    isPrimary?: SortOrder
    contactId?: SortOrder
    tenetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumPhoneTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PhoneType | EnumPhoneTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PhoneType[] | ListEnumPhoneTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PhoneType[] | ListEnumPhoneTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPhoneTypeFilter<$PrismaModel> | $Enums.PhoneType
  }

  export type ContactPhoneCountOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    type?: SortOrder
    isPrimary?: SortOrder
    contactId?: SortOrder
    tenetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactPhoneMaxOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    type?: SortOrder
    isPrimary?: SortOrder
    contactId?: SortOrder
    tenetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactPhoneMinOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    type?: SortOrder
    isPrimary?: SortOrder
    contactId?: SortOrder
    tenetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumPhoneTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PhoneType | EnumPhoneTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PhoneType[] | ListEnumPhoneTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PhoneType[] | ListEnumPhoneTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPhoneTypeWithAggregatesFilter<$PrismaModel> | $Enums.PhoneType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPhoneTypeFilter<$PrismaModel>
    _max?: NestedEnumPhoneTypeFilter<$PrismaModel>
  }

  export type EnumAddressTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AddressType | EnumAddressTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AddressType[] | ListEnumAddressTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AddressType[] | ListEnumAddressTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAddressTypeFilter<$PrismaModel> | $Enums.AddressType
  }

  export type AddressCountOrderByAggregateInput = {
    id?: SortOrder
    street?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    country?: SortOrder
    type?: SortOrder
    primary?: SortOrder
    contactId?: SortOrder
    tenetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    timezone?: SortOrder
  }

  export type AddressMaxOrderByAggregateInput = {
    id?: SortOrder
    street?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    country?: SortOrder
    type?: SortOrder
    primary?: SortOrder
    contactId?: SortOrder
    tenetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    timezone?: SortOrder
  }

  export type AddressMinOrderByAggregateInput = {
    id?: SortOrder
    street?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    country?: SortOrder
    type?: SortOrder
    primary?: SortOrder
    contactId?: SortOrder
    tenetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    timezone?: SortOrder
  }

  export type EnumAddressTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AddressType | EnumAddressTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AddressType[] | ListEnumAddressTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AddressType[] | ListEnumAddressTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAddressTypeWithAggregatesFilter<$PrismaModel> | $Enums.AddressType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAddressTypeFilter<$PrismaModel>
    _max?: NestedEnumAddressTypeFilter<$PrismaModel>
  }

  export type ConfigOptionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
  }

  export type ConfigOptionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
  }

  export type ConfigOptionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
  }

  export type EnumImportantDateTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ImportantDateType | EnumImportantDateTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ImportantDateType[] | ListEnumImportantDateTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImportantDateType[] | ListEnumImportantDateTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumImportantDateTypeFilter<$PrismaModel> | $Enums.ImportantDateType
  }

  export type ImportantDateCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    contactId?: SortOrder
    tenetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImportantDateMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    contactId?: SortOrder
    tenetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImportantDateMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    contactId?: SortOrder
    tenetId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumImportantDateTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ImportantDateType | EnumImportantDateTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ImportantDateType[] | ListEnumImportantDateTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImportantDateType[] | ListEnumImportantDateTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumImportantDateTypeWithAggregatesFilter<$PrismaModel> | $Enums.ImportantDateType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumImportantDateTypeFilter<$PrismaModel>
    _max?: NestedEnumImportantDateTypeFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumOpportunityStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OpportunityStatus | EnumOpportunityStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OpportunityStatus[] | ListEnumOpportunityStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OpportunityStatus[] | ListEnumOpportunityStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOpportunityStatusFilter<$PrismaModel> | $Enums.OpportunityStatus
  }

  export type EnumOpportunityStatusNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.OpportunityStatus[] | ListEnumOpportunityStatusFieldRefInput<$PrismaModel> | null
    has?: $Enums.OpportunityStatus | EnumOpportunityStatusFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.OpportunityStatus[] | ListEnumOpportunityStatusFieldRefInput<$PrismaModel>
    hasSome?: $Enums.OpportunityStatus[] | ListEnumOpportunityStatusFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type OpportunityProductListRelationFilter = {
    every?: OpportunityProductWhereInput
    some?: OpportunityProductWhereInput
    none?: OpportunityProductWhereInput
  }

  export type OpportunityProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OpportunityCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    value?: SortOrder
    probability?: SortOrder
    expectedCloseDate?: SortOrder
    actualCloseDate?: SortOrder
    status?: SortOrder
    statusHistory?: SortOrder
    deleted?: SortOrder
    deletedAt?: SortOrder
    tenetId?: SortOrder
    expectedValue?: SortOrder
  }

  export type OpportunityAvgOrderByAggregateInput = {
    value?: SortOrder
    probability?: SortOrder
    expectedValue?: SortOrder
  }

  export type OpportunityMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    value?: SortOrder
    probability?: SortOrder
    expectedCloseDate?: SortOrder
    actualCloseDate?: SortOrder
    status?: SortOrder
    deleted?: SortOrder
    deletedAt?: SortOrder
    tenetId?: SortOrder
    expectedValue?: SortOrder
  }

  export type OpportunityMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    value?: SortOrder
    probability?: SortOrder
    expectedCloseDate?: SortOrder
    actualCloseDate?: SortOrder
    status?: SortOrder
    deleted?: SortOrder
    deletedAt?: SortOrder
    tenetId?: SortOrder
    expectedValue?: SortOrder
  }

  export type OpportunitySumOrderByAggregateInput = {
    value?: SortOrder
    probability?: SortOrder
    expectedValue?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumOpportunityStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OpportunityStatus | EnumOpportunityStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OpportunityStatus[] | ListEnumOpportunityStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OpportunityStatus[] | ListEnumOpportunityStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOpportunityStatusWithAggregatesFilter<$PrismaModel> | $Enums.OpportunityStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOpportunityStatusFilter<$PrismaModel>
    _max?: NestedEnumOpportunityStatusFilter<$PrismaModel>
  }

  export type OpportunityScalarRelationFilter = {
    is?: OpportunityWhereInput
    isNot?: OpportunityWhereInput
  }

  export type ContactOpportunityJoinContactIdOpportunityIdCompoundUniqueInput = {
    contactId: Uint8Array
    opportunityId: Uint8Array
  }

  export type ContactOpportunityJoinCountOrderByAggregateInput = {
    contactId?: SortOrder
    opportunityId?: SortOrder
  }

  export type ContactOpportunityJoinMaxOrderByAggregateInput = {
    contactId?: SortOrder
    opportunityId?: SortOrder
  }

  export type ContactOpportunityJoinMinOrderByAggregateInput = {
    contactId?: SortOrder
    opportunityId?: SortOrder
  }

  export type UserOpportunityJoinUserIdOpportunityIdCompoundUniqueInput = {
    userId: Uint8Array
    opportunityId: Uint8Array
  }

  export type UserOpportunityJoinCountOrderByAggregateInput = {
    userId?: SortOrder
    opportunityId?: SortOrder
  }

  export type UserOpportunityJoinMaxOrderByAggregateInput = {
    userId?: SortOrder
    opportunityId?: SortOrder
  }

  export type UserOpportunityJoinMinOrderByAggregateInput = {
    userId?: SortOrder
    opportunityId?: SortOrder
  }

  export type ProductTypeScalarRelationFilter = {
    is?: ProductTypeWhereInput
    isNot?: ProductTypeWhereInput
  }

  export type OpportunityProductCountOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    order?: SortOrder
    commission?: SortOrder
    opportunityId?: SortOrder
    productTypeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OpportunityProductAvgOrderByAggregateInput = {
    price?: SortOrder
    order?: SortOrder
    commission?: SortOrder
  }

  export type OpportunityProductMaxOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    order?: SortOrder
    commission?: SortOrder
    opportunityId?: SortOrder
    productTypeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OpportunityProductMinOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    order?: SortOrder
    commission?: SortOrder
    opportunityId?: SortOrder
    productTypeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OpportunityProductSumOrderByAggregateInput = {
    price?: SortOrder
    order?: SortOrder
    commission?: SortOrder
  }

  export type ProductTypeCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    defaultCommission?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenetId?: SortOrder
  }

  export type ProductTypeAvgOrderByAggregateInput = {
    defaultCommission?: SortOrder
  }

  export type ProductTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    defaultCommission?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenetId?: SortOrder
  }

  export type ProductTypeMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    defaultCommission?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenetId?: SortOrder
  }

  export type ProductTypeSumOrderByAggregateInput = {
    defaultCommission?: SortOrder
  }

  export type EnumLogLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.LogLevel | EnumLogLevelFieldRefInput<$PrismaModel>
    in?: $Enums.LogLevel[] | ListEnumLogLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.LogLevel[] | ListEnumLogLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumLogLevelFilter<$PrismaModel> | $Enums.LogLevel
  }

  export type LogCountOrderByAggregateInput = {
    id?: SortOrder
    userEmail?: SortOrder
    tenetId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    severity?: SortOrder
    stacktrace?: SortOrder
    source?: SortOrder
    secureDetails?: SortOrder
  }

  export type LogMaxOrderByAggregateInput = {
    id?: SortOrder
    userEmail?: SortOrder
    tenetId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    severity?: SortOrder
    stacktrace?: SortOrder
    source?: SortOrder
    secureDetails?: SortOrder
  }

  export type LogMinOrderByAggregateInput = {
    id?: SortOrder
    userEmail?: SortOrder
    tenetId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    severity?: SortOrder
    stacktrace?: SortOrder
    source?: SortOrder
    secureDetails?: SortOrder
  }

  export type EnumLogLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LogLevel | EnumLogLevelFieldRefInput<$PrismaModel>
    in?: $Enums.LogLevel[] | ListEnumLogLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.LogLevel[] | ListEnumLogLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumLogLevelWithAggregatesFilter<$PrismaModel> | $Enums.LogLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLogLevelFilter<$PrismaModel>
    _max?: NestedEnumLogLevelFilter<$PrismaModel>
  }

  export type TokenCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    refresh?: SortOrder
  }

  export type TokenMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    refresh?: SortOrder
  }

  export type TokenMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    refresh?: SortOrder
  }

  export type TZDataTz_data_name_province_country_uniqueCompoundUniqueInput = {
    name: string
    provinceName: string
    countryCode: string
  }

  export type TZDataCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    provinceName?: SortOrder
    countryCode?: SortOrder
    tz?: SortOrder
  }

  export type TZDataAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TZDataMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    provinceName?: SortOrder
    countryCode?: SortOrder
    tz?: SortOrder
  }

  export type TZDataMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    provinceName?: SortOrder
    countryCode?: SortOrder
    tz?: SortOrder
  }

  export type TZDataSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type WrappedObjectListRelationFilter = {
    every?: WrappedObjectWhereInput
    some?: WrappedObjectWhereInput
    none?: WrappedObjectWhereInput
  }

  export type JoinTestObjectListRelationFilter = {
    every?: JoinTestObjectWhereInput
    some?: JoinTestObjectWhereInput
    none?: JoinTestObjectWhereInput
  }

  export type JoinTestObject2ListRelationFilter = {
    every?: JoinTestObject2WhereInput
    some?: JoinTestObject2WhereInput
    none?: JoinTestObject2WhereInput
  }

  export type WrappedObjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JoinTestObjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JoinTestObject2OrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TestObjectCountOrderByAggregateInput = {
    id?: SortOrder
    required?: SortOrder
    persisted?: SortOrder
  }

  export type TestObjectMaxOrderByAggregateInput = {
    id?: SortOrder
    required?: SortOrder
    persisted?: SortOrder
  }

  export type TestObjectMinOrderByAggregateInput = {
    id?: SortOrder
    required?: SortOrder
    persisted?: SortOrder
  }

  export type TestObjectScalarRelationFilter = {
    is?: TestObjectWhereInput
    isNot?: TestObjectWhereInput
  }

  export type WrappedObjectCountOrderByAggregateInput = {
    id?: SortOrder
    persisted?: SortOrder
    testObjectId?: SortOrder
  }

  export type WrappedObjectMaxOrderByAggregateInput = {
    id?: SortOrder
    persisted?: SortOrder
    testObjectId?: SortOrder
  }

  export type WrappedObjectMinOrderByAggregateInput = {
    id?: SortOrder
    persisted?: SortOrder
    testObjectId?: SortOrder
  }

  export type JoinedObject1ScalarRelationFilter = {
    is?: JoinedObject1WhereInput
    isNot?: JoinedObject1WhereInput
  }

  export type JoinTestObjectTestObjectIdJoinedObjectIdCompoundUniqueInput = {
    testObjectId: Uint8Array
    joinedObjectId: Uint8Array
  }

  export type JoinTestObjectCountOrderByAggregateInput = {
    testObjectId?: SortOrder
    joinedObjectId?: SortOrder
    joinProperty?: SortOrder
  }

  export type JoinTestObjectMaxOrderByAggregateInput = {
    testObjectId?: SortOrder
    joinedObjectId?: SortOrder
    joinProperty?: SortOrder
  }

  export type JoinTestObjectMinOrderByAggregateInput = {
    testObjectId?: SortOrder
    joinedObjectId?: SortOrder
    joinProperty?: SortOrder
  }

  export type JoinedObject2ScalarRelationFilter = {
    is?: JoinedObject2WhereInput
    isNot?: JoinedObject2WhereInput
  }

  export type JoinTestObject2CountOrderByAggregateInput = {
    id?: SortOrder
    testObjectId?: SortOrder
    joinedObjectId?: SortOrder
    joinProperty?: SortOrder
  }

  export type JoinTestObject2MaxOrderByAggregateInput = {
    id?: SortOrder
    testObjectId?: SortOrder
    joinedObjectId?: SortOrder
    joinProperty?: SortOrder
  }

  export type JoinTestObject2MinOrderByAggregateInput = {
    id?: SortOrder
    testObjectId?: SortOrder
    joinedObjectId?: SortOrder
    joinProperty?: SortOrder
  }

  export type JoinedObject1CountOrderByAggregateInput = {
    id?: SortOrder
    persisted?: SortOrder
  }

  export type JoinedObject1MaxOrderByAggregateInput = {
    id?: SortOrder
    persisted?: SortOrder
  }

  export type JoinedObject1MinOrderByAggregateInput = {
    id?: SortOrder
    persisted?: SortOrder
  }

  export type JoinedObject2CountOrderByAggregateInput = {
    id?: SortOrder
    persisted?: SortOrder
  }

  export type JoinedObject2MaxOrderByAggregateInput = {
    id?: SortOrder
    persisted?: SortOrder
  }

  export type JoinedObject2MinOrderByAggregateInput = {
    id?: SortOrder
    persisted?: SortOrder
  }

  export type SelfReferencialJoinModelScalarRelationFilter = {
    is?: SelfReferencialJoinModelWhereInput
    isNot?: SelfReferencialJoinModelWhereInput
  }

  export type JoinSelfReferenceCountOrderByAggregateInput = {
    id?: SortOrder
    sourceId?: SortOrder
    targetId?: SortOrder
    joinProperty?: SortOrder
  }

  export type JoinSelfReferenceMaxOrderByAggregateInput = {
    id?: SortOrder
    sourceId?: SortOrder
    targetId?: SortOrder
    joinProperty?: SortOrder
  }

  export type JoinSelfReferenceMinOrderByAggregateInput = {
    id?: SortOrder
    sourceId?: SortOrder
    targetId?: SortOrder
    joinProperty?: SortOrder
  }

  export type JoinSelfReferenceListRelationFilter = {
    every?: JoinSelfReferenceWhereInput
    some?: JoinSelfReferenceWhereInput
    none?: JoinSelfReferenceWhereInput
  }

  export type JoinSelfReferenceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SelfReferencialJoinModelCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SelfReferencialJoinModelMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SelfReferencialJoinModelMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserCreateNestedManyWithoutTenetInput = {
    create?: XOR<UserCreateWithoutTenetInput, UserUncheckedCreateWithoutTenetInput> | UserCreateWithoutTenetInput[] | UserUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenetInput | UserCreateOrConnectWithoutTenetInput[]
    createMany?: UserCreateManyTenetInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type LogCreateNestedManyWithoutTenetInput = {
    create?: XOR<LogCreateWithoutTenetInput, LogUncheckedCreateWithoutTenetInput> | LogCreateWithoutTenetInput[] | LogUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: LogCreateOrConnectWithoutTenetInput | LogCreateOrConnectWithoutTenetInput[]
    createMany?: LogCreateManyTenetInputEnvelope
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
  }

  export type ContactCreateNestedManyWithoutTenetInput = {
    create?: XOR<ContactCreateWithoutTenetInput, ContactUncheckedCreateWithoutTenetInput> | ContactCreateWithoutTenetInput[] | ContactUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutTenetInput | ContactCreateOrConnectWithoutTenetInput[]
    createMany?: ContactCreateManyTenetInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type ActivityCreateNestedManyWithoutTenetInput = {
    create?: XOR<ActivityCreateWithoutTenetInput, ActivityUncheckedCreateWithoutTenetInput> | ActivityCreateWithoutTenetInput[] | ActivityUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutTenetInput | ActivityCreateOrConnectWithoutTenetInput[]
    createMany?: ActivityCreateManyTenetInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type AddressCreateNestedManyWithoutTenetInput = {
    create?: XOR<AddressCreateWithoutTenetInput, AddressUncheckedCreateWithoutTenetInput> | AddressCreateWithoutTenetInput[] | AddressUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutTenetInput | AddressCreateOrConnectWithoutTenetInput[]
    createMany?: AddressCreateManyTenetInputEnvelope
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
  }

  export type ContactEmailCreateNestedManyWithoutTenetInput = {
    create?: XOR<ContactEmailCreateWithoutTenetInput, ContactEmailUncheckedCreateWithoutTenetInput> | ContactEmailCreateWithoutTenetInput[] | ContactEmailUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: ContactEmailCreateOrConnectWithoutTenetInput | ContactEmailCreateOrConnectWithoutTenetInput[]
    createMany?: ContactEmailCreateManyTenetInputEnvelope
    connect?: ContactEmailWhereUniqueInput | ContactEmailWhereUniqueInput[]
  }

  export type ContactPhoneCreateNestedManyWithoutTenetInput = {
    create?: XOR<ContactPhoneCreateWithoutTenetInput, ContactPhoneUncheckedCreateWithoutTenetInput> | ContactPhoneCreateWithoutTenetInput[] | ContactPhoneUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: ContactPhoneCreateOrConnectWithoutTenetInput | ContactPhoneCreateOrConnectWithoutTenetInput[]
    createMany?: ContactPhoneCreateManyTenetInputEnvelope
    connect?: ContactPhoneWhereUniqueInput | ContactPhoneWhereUniqueInput[]
  }

  export type ImportantDateCreateNestedManyWithoutTenetInput = {
    create?: XOR<ImportantDateCreateWithoutTenetInput, ImportantDateUncheckedCreateWithoutTenetInput> | ImportantDateCreateWithoutTenetInput[] | ImportantDateUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: ImportantDateCreateOrConnectWithoutTenetInput | ImportantDateCreateOrConnectWithoutTenetInput[]
    createMany?: ImportantDateCreateManyTenetInputEnvelope
    connect?: ImportantDateWhereUniqueInput | ImportantDateWhereUniqueInput[]
  }

  export type AttachmentCreateNestedManyWithoutTenetInput = {
    create?: XOR<AttachmentCreateWithoutTenetInput, AttachmentUncheckedCreateWithoutTenetInput> | AttachmentCreateWithoutTenetInput[] | AttachmentUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutTenetInput | AttachmentCreateOrConnectWithoutTenetInput[]
    createMany?: AttachmentCreateManyTenetInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type NoteCreateNestedManyWithoutTenetInput = {
    create?: XOR<NoteCreateWithoutTenetInput, NoteUncheckedCreateWithoutTenetInput> | NoteCreateWithoutTenetInput[] | NoteUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutTenetInput | NoteCreateOrConnectWithoutTenetInput[]
    createMany?: NoteCreateManyTenetInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type AuditEventCreateNestedManyWithoutTenetInput = {
    create?: XOR<AuditEventCreateWithoutTenetInput, AuditEventUncheckedCreateWithoutTenetInput> | AuditEventCreateWithoutTenetInput[] | AuditEventUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: AuditEventCreateOrConnectWithoutTenetInput | AuditEventCreateOrConnectWithoutTenetInput[]
    createMany?: AuditEventCreateManyTenetInputEnvelope
    connect?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
  }

  export type ContactTimelineEventCreateNestedManyWithoutTenetInput = {
    create?: XOR<ContactTimelineEventCreateWithoutTenetInput, ContactTimelineEventUncheckedCreateWithoutTenetInput> | ContactTimelineEventCreateWithoutTenetInput[] | ContactTimelineEventUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: ContactTimelineEventCreateOrConnectWithoutTenetInput | ContactTimelineEventCreateOrConnectWithoutTenetInput[]
    createMany?: ContactTimelineEventCreateManyTenetInputEnvelope
    connect?: ContactTimelineEventWhereUniqueInput | ContactTimelineEventWhereUniqueInput[]
  }

  export type ActivityStepCreateNestedManyWithoutTenetInput = {
    create?: XOR<ActivityStepCreateWithoutTenetInput, ActivityStepUncheckedCreateWithoutTenetInput> | ActivityStepCreateWithoutTenetInput[] | ActivityStepUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: ActivityStepCreateOrConnectWithoutTenetInput | ActivityStepCreateOrConnectWithoutTenetInput[]
    createMany?: ActivityStepCreateManyTenetInputEnvelope
    connect?: ActivityStepWhereUniqueInput | ActivityStepWhereUniqueInput[]
  }

  export type ActivityWaypointCreateNestedManyWithoutTenetInput = {
    create?: XOR<ActivityWaypointCreateWithoutTenetInput, ActivityWaypointUncheckedCreateWithoutTenetInput> | ActivityWaypointCreateWithoutTenetInput[] | ActivityWaypointUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: ActivityWaypointCreateOrConnectWithoutTenetInput | ActivityWaypointCreateOrConnectWithoutTenetInput[]
    createMany?: ActivityWaypointCreateManyTenetInputEnvelope
    connect?: ActivityWaypointWhereUniqueInput | ActivityWaypointWhereUniqueInput[]
  }

  export type TemplateAssignmentCreateNestedManyWithoutTenetInput = {
    create?: XOR<TemplateAssignmentCreateWithoutTenetInput, TemplateAssignmentUncheckedCreateWithoutTenetInput> | TemplateAssignmentCreateWithoutTenetInput[] | TemplateAssignmentUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: TemplateAssignmentCreateOrConnectWithoutTenetInput | TemplateAssignmentCreateOrConnectWithoutTenetInput[]
    createMany?: TemplateAssignmentCreateManyTenetInputEnvelope
    connect?: TemplateAssignmentWhereUniqueInput | TemplateAssignmentWhereUniqueInput[]
  }

  export type ActivityWaypointTemplateCreateNestedManyWithoutTenetInput = {
    create?: XOR<ActivityWaypointTemplateCreateWithoutTenetInput, ActivityWaypointTemplateUncheckedCreateWithoutTenetInput> | ActivityWaypointTemplateCreateWithoutTenetInput[] | ActivityWaypointTemplateUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: ActivityWaypointTemplateCreateOrConnectWithoutTenetInput | ActivityWaypointTemplateCreateOrConnectWithoutTenetInput[]
    createMany?: ActivityWaypointTemplateCreateManyTenetInputEnvelope
    connect?: ActivityWaypointTemplateWhereUniqueInput | ActivityWaypointTemplateWhereUniqueInput[]
  }

  export type ActivityTemplateCreateNestedManyWithoutTenetInput = {
    create?: XOR<ActivityTemplateCreateWithoutTenetInput, ActivityTemplateUncheckedCreateWithoutTenetInput> | ActivityTemplateCreateWithoutTenetInput[] | ActivityTemplateUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: ActivityTemplateCreateOrConnectWithoutTenetInput | ActivityTemplateCreateOrConnectWithoutTenetInput[]
    createMany?: ActivityTemplateCreateManyTenetInputEnvelope
    connect?: ActivityTemplateWhereUniqueInput | ActivityTemplateWhereUniqueInput[]
  }

  export type ActivityTemplateStepCreateNestedManyWithoutTenetInput = {
    create?: XOR<ActivityTemplateStepCreateWithoutTenetInput, ActivityTemplateStepUncheckedCreateWithoutTenetInput> | ActivityTemplateStepCreateWithoutTenetInput[] | ActivityTemplateStepUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: ActivityTemplateStepCreateOrConnectWithoutTenetInput | ActivityTemplateStepCreateOrConnectWithoutTenetInput[]
    createMany?: ActivityTemplateStepCreateManyTenetInputEnvelope
    connect?: ActivityTemplateStepWhereUniqueInput | ActivityTemplateStepWhereUniqueInput[]
  }

  export type OpportunityCreateNestedManyWithoutTenetInput = {
    create?: XOR<OpportunityCreateWithoutTenetInput, OpportunityUncheckedCreateWithoutTenetInput> | OpportunityCreateWithoutTenetInput[] | OpportunityUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: OpportunityCreateOrConnectWithoutTenetInput | OpportunityCreateOrConnectWithoutTenetInput[]
    createMany?: OpportunityCreateManyTenetInputEnvelope
    connect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
  }

  export type ProductTypeCreateNestedManyWithoutTenetInput = {
    create?: XOR<ProductTypeCreateWithoutTenetInput, ProductTypeUncheckedCreateWithoutTenetInput> | ProductTypeCreateWithoutTenetInput[] | ProductTypeUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: ProductTypeCreateOrConnectWithoutTenetInput | ProductTypeCreateOrConnectWithoutTenetInput[]
    createMany?: ProductTypeCreateManyTenetInputEnvelope
    connect?: ProductTypeWhereUniqueInput | ProductTypeWhereUniqueInput[]
  }

  export type ActivityTemplateStepAssignmentCreateNestedManyWithoutTenetInput = {
    create?: XOR<ActivityTemplateStepAssignmentCreateWithoutTenetInput, ActivityTemplateStepAssignmentUncheckedCreateWithoutTenetInput> | ActivityTemplateStepAssignmentCreateWithoutTenetInput[] | ActivityTemplateStepAssignmentUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: ActivityTemplateStepAssignmentCreateOrConnectWithoutTenetInput | ActivityTemplateStepAssignmentCreateOrConnectWithoutTenetInput[]
    createMany?: ActivityTemplateStepAssignmentCreateManyTenetInputEnvelope
    connect?: ActivityTemplateStepAssignmentWhereUniqueInput | ActivityTemplateStepAssignmentWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutTenetInput = {
    create?: XOR<UserCreateWithoutTenetInput, UserUncheckedCreateWithoutTenetInput> | UserCreateWithoutTenetInput[] | UserUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenetInput | UserCreateOrConnectWithoutTenetInput[]
    createMany?: UserCreateManyTenetInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type LogUncheckedCreateNestedManyWithoutTenetInput = {
    create?: XOR<LogCreateWithoutTenetInput, LogUncheckedCreateWithoutTenetInput> | LogCreateWithoutTenetInput[] | LogUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: LogCreateOrConnectWithoutTenetInput | LogCreateOrConnectWithoutTenetInput[]
    createMany?: LogCreateManyTenetInputEnvelope
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
  }

  export type ContactUncheckedCreateNestedManyWithoutTenetInput = {
    create?: XOR<ContactCreateWithoutTenetInput, ContactUncheckedCreateWithoutTenetInput> | ContactCreateWithoutTenetInput[] | ContactUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutTenetInput | ContactCreateOrConnectWithoutTenetInput[]
    createMany?: ContactCreateManyTenetInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type ActivityUncheckedCreateNestedManyWithoutTenetInput = {
    create?: XOR<ActivityCreateWithoutTenetInput, ActivityUncheckedCreateWithoutTenetInput> | ActivityCreateWithoutTenetInput[] | ActivityUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutTenetInput | ActivityCreateOrConnectWithoutTenetInput[]
    createMany?: ActivityCreateManyTenetInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type AddressUncheckedCreateNestedManyWithoutTenetInput = {
    create?: XOR<AddressCreateWithoutTenetInput, AddressUncheckedCreateWithoutTenetInput> | AddressCreateWithoutTenetInput[] | AddressUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutTenetInput | AddressCreateOrConnectWithoutTenetInput[]
    createMany?: AddressCreateManyTenetInputEnvelope
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
  }

  export type ContactEmailUncheckedCreateNestedManyWithoutTenetInput = {
    create?: XOR<ContactEmailCreateWithoutTenetInput, ContactEmailUncheckedCreateWithoutTenetInput> | ContactEmailCreateWithoutTenetInput[] | ContactEmailUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: ContactEmailCreateOrConnectWithoutTenetInput | ContactEmailCreateOrConnectWithoutTenetInput[]
    createMany?: ContactEmailCreateManyTenetInputEnvelope
    connect?: ContactEmailWhereUniqueInput | ContactEmailWhereUniqueInput[]
  }

  export type ContactPhoneUncheckedCreateNestedManyWithoutTenetInput = {
    create?: XOR<ContactPhoneCreateWithoutTenetInput, ContactPhoneUncheckedCreateWithoutTenetInput> | ContactPhoneCreateWithoutTenetInput[] | ContactPhoneUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: ContactPhoneCreateOrConnectWithoutTenetInput | ContactPhoneCreateOrConnectWithoutTenetInput[]
    createMany?: ContactPhoneCreateManyTenetInputEnvelope
    connect?: ContactPhoneWhereUniqueInput | ContactPhoneWhereUniqueInput[]
  }

  export type ImportantDateUncheckedCreateNestedManyWithoutTenetInput = {
    create?: XOR<ImportantDateCreateWithoutTenetInput, ImportantDateUncheckedCreateWithoutTenetInput> | ImportantDateCreateWithoutTenetInput[] | ImportantDateUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: ImportantDateCreateOrConnectWithoutTenetInput | ImportantDateCreateOrConnectWithoutTenetInput[]
    createMany?: ImportantDateCreateManyTenetInputEnvelope
    connect?: ImportantDateWhereUniqueInput | ImportantDateWhereUniqueInput[]
  }

  export type AttachmentUncheckedCreateNestedManyWithoutTenetInput = {
    create?: XOR<AttachmentCreateWithoutTenetInput, AttachmentUncheckedCreateWithoutTenetInput> | AttachmentCreateWithoutTenetInput[] | AttachmentUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutTenetInput | AttachmentCreateOrConnectWithoutTenetInput[]
    createMany?: AttachmentCreateManyTenetInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type NoteUncheckedCreateNestedManyWithoutTenetInput = {
    create?: XOR<NoteCreateWithoutTenetInput, NoteUncheckedCreateWithoutTenetInput> | NoteCreateWithoutTenetInput[] | NoteUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutTenetInput | NoteCreateOrConnectWithoutTenetInput[]
    createMany?: NoteCreateManyTenetInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type AuditEventUncheckedCreateNestedManyWithoutTenetInput = {
    create?: XOR<AuditEventCreateWithoutTenetInput, AuditEventUncheckedCreateWithoutTenetInput> | AuditEventCreateWithoutTenetInput[] | AuditEventUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: AuditEventCreateOrConnectWithoutTenetInput | AuditEventCreateOrConnectWithoutTenetInput[]
    createMany?: AuditEventCreateManyTenetInputEnvelope
    connect?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
  }

  export type ContactTimelineEventUncheckedCreateNestedManyWithoutTenetInput = {
    create?: XOR<ContactTimelineEventCreateWithoutTenetInput, ContactTimelineEventUncheckedCreateWithoutTenetInput> | ContactTimelineEventCreateWithoutTenetInput[] | ContactTimelineEventUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: ContactTimelineEventCreateOrConnectWithoutTenetInput | ContactTimelineEventCreateOrConnectWithoutTenetInput[]
    createMany?: ContactTimelineEventCreateManyTenetInputEnvelope
    connect?: ContactTimelineEventWhereUniqueInput | ContactTimelineEventWhereUniqueInput[]
  }

  export type ActivityStepUncheckedCreateNestedManyWithoutTenetInput = {
    create?: XOR<ActivityStepCreateWithoutTenetInput, ActivityStepUncheckedCreateWithoutTenetInput> | ActivityStepCreateWithoutTenetInput[] | ActivityStepUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: ActivityStepCreateOrConnectWithoutTenetInput | ActivityStepCreateOrConnectWithoutTenetInput[]
    createMany?: ActivityStepCreateManyTenetInputEnvelope
    connect?: ActivityStepWhereUniqueInput | ActivityStepWhereUniqueInput[]
  }

  export type ActivityWaypointUncheckedCreateNestedManyWithoutTenetInput = {
    create?: XOR<ActivityWaypointCreateWithoutTenetInput, ActivityWaypointUncheckedCreateWithoutTenetInput> | ActivityWaypointCreateWithoutTenetInput[] | ActivityWaypointUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: ActivityWaypointCreateOrConnectWithoutTenetInput | ActivityWaypointCreateOrConnectWithoutTenetInput[]
    createMany?: ActivityWaypointCreateManyTenetInputEnvelope
    connect?: ActivityWaypointWhereUniqueInput | ActivityWaypointWhereUniqueInput[]
  }

  export type TemplateAssignmentUncheckedCreateNestedManyWithoutTenetInput = {
    create?: XOR<TemplateAssignmentCreateWithoutTenetInput, TemplateAssignmentUncheckedCreateWithoutTenetInput> | TemplateAssignmentCreateWithoutTenetInput[] | TemplateAssignmentUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: TemplateAssignmentCreateOrConnectWithoutTenetInput | TemplateAssignmentCreateOrConnectWithoutTenetInput[]
    createMany?: TemplateAssignmentCreateManyTenetInputEnvelope
    connect?: TemplateAssignmentWhereUniqueInput | TemplateAssignmentWhereUniqueInput[]
  }

  export type ActivityWaypointTemplateUncheckedCreateNestedManyWithoutTenetInput = {
    create?: XOR<ActivityWaypointTemplateCreateWithoutTenetInput, ActivityWaypointTemplateUncheckedCreateWithoutTenetInput> | ActivityWaypointTemplateCreateWithoutTenetInput[] | ActivityWaypointTemplateUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: ActivityWaypointTemplateCreateOrConnectWithoutTenetInput | ActivityWaypointTemplateCreateOrConnectWithoutTenetInput[]
    createMany?: ActivityWaypointTemplateCreateManyTenetInputEnvelope
    connect?: ActivityWaypointTemplateWhereUniqueInput | ActivityWaypointTemplateWhereUniqueInput[]
  }

  export type ActivityTemplateUncheckedCreateNestedManyWithoutTenetInput = {
    create?: XOR<ActivityTemplateCreateWithoutTenetInput, ActivityTemplateUncheckedCreateWithoutTenetInput> | ActivityTemplateCreateWithoutTenetInput[] | ActivityTemplateUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: ActivityTemplateCreateOrConnectWithoutTenetInput | ActivityTemplateCreateOrConnectWithoutTenetInput[]
    createMany?: ActivityTemplateCreateManyTenetInputEnvelope
    connect?: ActivityTemplateWhereUniqueInput | ActivityTemplateWhereUniqueInput[]
  }

  export type ActivityTemplateStepUncheckedCreateNestedManyWithoutTenetInput = {
    create?: XOR<ActivityTemplateStepCreateWithoutTenetInput, ActivityTemplateStepUncheckedCreateWithoutTenetInput> | ActivityTemplateStepCreateWithoutTenetInput[] | ActivityTemplateStepUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: ActivityTemplateStepCreateOrConnectWithoutTenetInput | ActivityTemplateStepCreateOrConnectWithoutTenetInput[]
    createMany?: ActivityTemplateStepCreateManyTenetInputEnvelope
    connect?: ActivityTemplateStepWhereUniqueInput | ActivityTemplateStepWhereUniqueInput[]
  }

  export type OpportunityUncheckedCreateNestedManyWithoutTenetInput = {
    create?: XOR<OpportunityCreateWithoutTenetInput, OpportunityUncheckedCreateWithoutTenetInput> | OpportunityCreateWithoutTenetInput[] | OpportunityUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: OpportunityCreateOrConnectWithoutTenetInput | OpportunityCreateOrConnectWithoutTenetInput[]
    createMany?: OpportunityCreateManyTenetInputEnvelope
    connect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
  }

  export type ProductTypeUncheckedCreateNestedManyWithoutTenetInput = {
    create?: XOR<ProductTypeCreateWithoutTenetInput, ProductTypeUncheckedCreateWithoutTenetInput> | ProductTypeCreateWithoutTenetInput[] | ProductTypeUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: ProductTypeCreateOrConnectWithoutTenetInput | ProductTypeCreateOrConnectWithoutTenetInput[]
    createMany?: ProductTypeCreateManyTenetInputEnvelope
    connect?: ProductTypeWhereUniqueInput | ProductTypeWhereUniqueInput[]
  }

  export type ActivityTemplateStepAssignmentUncheckedCreateNestedManyWithoutTenetInput = {
    create?: XOR<ActivityTemplateStepAssignmentCreateWithoutTenetInput, ActivityTemplateStepAssignmentUncheckedCreateWithoutTenetInput> | ActivityTemplateStepAssignmentCreateWithoutTenetInput[] | ActivityTemplateStepAssignmentUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: ActivityTemplateStepAssignmentCreateOrConnectWithoutTenetInput | ActivityTemplateStepAssignmentCreateOrConnectWithoutTenetInput[]
    createMany?: ActivityTemplateStepAssignmentCreateManyTenetInputEnvelope
    connect?: ActivityTemplateStepAssignmentWhereUniqueInput | ActivityTemplateStepAssignmentWhereUniqueInput[]
  }

  export type BytesFieldUpdateOperationsInput = {
    set?: Uint8Array
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateManyWithoutTenetNestedInput = {
    create?: XOR<UserCreateWithoutTenetInput, UserUncheckedCreateWithoutTenetInput> | UserCreateWithoutTenetInput[] | UserUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenetInput | UserCreateOrConnectWithoutTenetInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTenetInput | UserUpsertWithWhereUniqueWithoutTenetInput[]
    createMany?: UserCreateManyTenetInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTenetInput | UserUpdateWithWhereUniqueWithoutTenetInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTenetInput | UserUpdateManyWithWhereWithoutTenetInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type LogUpdateManyWithoutTenetNestedInput = {
    create?: XOR<LogCreateWithoutTenetInput, LogUncheckedCreateWithoutTenetInput> | LogCreateWithoutTenetInput[] | LogUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: LogCreateOrConnectWithoutTenetInput | LogCreateOrConnectWithoutTenetInput[]
    upsert?: LogUpsertWithWhereUniqueWithoutTenetInput | LogUpsertWithWhereUniqueWithoutTenetInput[]
    createMany?: LogCreateManyTenetInputEnvelope
    set?: LogWhereUniqueInput | LogWhereUniqueInput[]
    disconnect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    delete?: LogWhereUniqueInput | LogWhereUniqueInput[]
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    update?: LogUpdateWithWhereUniqueWithoutTenetInput | LogUpdateWithWhereUniqueWithoutTenetInput[]
    updateMany?: LogUpdateManyWithWhereWithoutTenetInput | LogUpdateManyWithWhereWithoutTenetInput[]
    deleteMany?: LogScalarWhereInput | LogScalarWhereInput[]
  }

  export type ContactUpdateManyWithoutTenetNestedInput = {
    create?: XOR<ContactCreateWithoutTenetInput, ContactUncheckedCreateWithoutTenetInput> | ContactCreateWithoutTenetInput[] | ContactUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutTenetInput | ContactCreateOrConnectWithoutTenetInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutTenetInput | ContactUpsertWithWhereUniqueWithoutTenetInput[]
    createMany?: ContactCreateManyTenetInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutTenetInput | ContactUpdateWithWhereUniqueWithoutTenetInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutTenetInput | ContactUpdateManyWithWhereWithoutTenetInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type ActivityUpdateManyWithoutTenetNestedInput = {
    create?: XOR<ActivityCreateWithoutTenetInput, ActivityUncheckedCreateWithoutTenetInput> | ActivityCreateWithoutTenetInput[] | ActivityUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutTenetInput | ActivityCreateOrConnectWithoutTenetInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutTenetInput | ActivityUpsertWithWhereUniqueWithoutTenetInput[]
    createMany?: ActivityCreateManyTenetInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutTenetInput | ActivityUpdateWithWhereUniqueWithoutTenetInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutTenetInput | ActivityUpdateManyWithWhereWithoutTenetInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type AddressUpdateManyWithoutTenetNestedInput = {
    create?: XOR<AddressCreateWithoutTenetInput, AddressUncheckedCreateWithoutTenetInput> | AddressCreateWithoutTenetInput[] | AddressUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutTenetInput | AddressCreateOrConnectWithoutTenetInput[]
    upsert?: AddressUpsertWithWhereUniqueWithoutTenetInput | AddressUpsertWithWhereUniqueWithoutTenetInput[]
    createMany?: AddressCreateManyTenetInputEnvelope
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    update?: AddressUpdateWithWhereUniqueWithoutTenetInput | AddressUpdateWithWhereUniqueWithoutTenetInput[]
    updateMany?: AddressUpdateManyWithWhereWithoutTenetInput | AddressUpdateManyWithWhereWithoutTenetInput[]
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[]
  }

  export type ContactEmailUpdateManyWithoutTenetNestedInput = {
    create?: XOR<ContactEmailCreateWithoutTenetInput, ContactEmailUncheckedCreateWithoutTenetInput> | ContactEmailCreateWithoutTenetInput[] | ContactEmailUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: ContactEmailCreateOrConnectWithoutTenetInput | ContactEmailCreateOrConnectWithoutTenetInput[]
    upsert?: ContactEmailUpsertWithWhereUniqueWithoutTenetInput | ContactEmailUpsertWithWhereUniqueWithoutTenetInput[]
    createMany?: ContactEmailCreateManyTenetInputEnvelope
    set?: ContactEmailWhereUniqueInput | ContactEmailWhereUniqueInput[]
    disconnect?: ContactEmailWhereUniqueInput | ContactEmailWhereUniqueInput[]
    delete?: ContactEmailWhereUniqueInput | ContactEmailWhereUniqueInput[]
    connect?: ContactEmailWhereUniqueInput | ContactEmailWhereUniqueInput[]
    update?: ContactEmailUpdateWithWhereUniqueWithoutTenetInput | ContactEmailUpdateWithWhereUniqueWithoutTenetInput[]
    updateMany?: ContactEmailUpdateManyWithWhereWithoutTenetInput | ContactEmailUpdateManyWithWhereWithoutTenetInput[]
    deleteMany?: ContactEmailScalarWhereInput | ContactEmailScalarWhereInput[]
  }

  export type ContactPhoneUpdateManyWithoutTenetNestedInput = {
    create?: XOR<ContactPhoneCreateWithoutTenetInput, ContactPhoneUncheckedCreateWithoutTenetInput> | ContactPhoneCreateWithoutTenetInput[] | ContactPhoneUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: ContactPhoneCreateOrConnectWithoutTenetInput | ContactPhoneCreateOrConnectWithoutTenetInput[]
    upsert?: ContactPhoneUpsertWithWhereUniqueWithoutTenetInput | ContactPhoneUpsertWithWhereUniqueWithoutTenetInput[]
    createMany?: ContactPhoneCreateManyTenetInputEnvelope
    set?: ContactPhoneWhereUniqueInput | ContactPhoneWhereUniqueInput[]
    disconnect?: ContactPhoneWhereUniqueInput | ContactPhoneWhereUniqueInput[]
    delete?: ContactPhoneWhereUniqueInput | ContactPhoneWhereUniqueInput[]
    connect?: ContactPhoneWhereUniqueInput | ContactPhoneWhereUniqueInput[]
    update?: ContactPhoneUpdateWithWhereUniqueWithoutTenetInput | ContactPhoneUpdateWithWhereUniqueWithoutTenetInput[]
    updateMany?: ContactPhoneUpdateManyWithWhereWithoutTenetInput | ContactPhoneUpdateManyWithWhereWithoutTenetInput[]
    deleteMany?: ContactPhoneScalarWhereInput | ContactPhoneScalarWhereInput[]
  }

  export type ImportantDateUpdateManyWithoutTenetNestedInput = {
    create?: XOR<ImportantDateCreateWithoutTenetInput, ImportantDateUncheckedCreateWithoutTenetInput> | ImportantDateCreateWithoutTenetInput[] | ImportantDateUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: ImportantDateCreateOrConnectWithoutTenetInput | ImportantDateCreateOrConnectWithoutTenetInput[]
    upsert?: ImportantDateUpsertWithWhereUniqueWithoutTenetInput | ImportantDateUpsertWithWhereUniqueWithoutTenetInput[]
    createMany?: ImportantDateCreateManyTenetInputEnvelope
    set?: ImportantDateWhereUniqueInput | ImportantDateWhereUniqueInput[]
    disconnect?: ImportantDateWhereUniqueInput | ImportantDateWhereUniqueInput[]
    delete?: ImportantDateWhereUniqueInput | ImportantDateWhereUniqueInput[]
    connect?: ImportantDateWhereUniqueInput | ImportantDateWhereUniqueInput[]
    update?: ImportantDateUpdateWithWhereUniqueWithoutTenetInput | ImportantDateUpdateWithWhereUniqueWithoutTenetInput[]
    updateMany?: ImportantDateUpdateManyWithWhereWithoutTenetInput | ImportantDateUpdateManyWithWhereWithoutTenetInput[]
    deleteMany?: ImportantDateScalarWhereInput | ImportantDateScalarWhereInput[]
  }

  export type AttachmentUpdateManyWithoutTenetNestedInput = {
    create?: XOR<AttachmentCreateWithoutTenetInput, AttachmentUncheckedCreateWithoutTenetInput> | AttachmentCreateWithoutTenetInput[] | AttachmentUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutTenetInput | AttachmentCreateOrConnectWithoutTenetInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutTenetInput | AttachmentUpsertWithWhereUniqueWithoutTenetInput[]
    createMany?: AttachmentCreateManyTenetInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutTenetInput | AttachmentUpdateWithWhereUniqueWithoutTenetInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutTenetInput | AttachmentUpdateManyWithWhereWithoutTenetInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type NoteUpdateManyWithoutTenetNestedInput = {
    create?: XOR<NoteCreateWithoutTenetInput, NoteUncheckedCreateWithoutTenetInput> | NoteCreateWithoutTenetInput[] | NoteUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutTenetInput | NoteCreateOrConnectWithoutTenetInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutTenetInput | NoteUpsertWithWhereUniqueWithoutTenetInput[]
    createMany?: NoteCreateManyTenetInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutTenetInput | NoteUpdateWithWhereUniqueWithoutTenetInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutTenetInput | NoteUpdateManyWithWhereWithoutTenetInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type AuditEventUpdateManyWithoutTenetNestedInput = {
    create?: XOR<AuditEventCreateWithoutTenetInput, AuditEventUncheckedCreateWithoutTenetInput> | AuditEventCreateWithoutTenetInput[] | AuditEventUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: AuditEventCreateOrConnectWithoutTenetInput | AuditEventCreateOrConnectWithoutTenetInput[]
    upsert?: AuditEventUpsertWithWhereUniqueWithoutTenetInput | AuditEventUpsertWithWhereUniqueWithoutTenetInput[]
    createMany?: AuditEventCreateManyTenetInputEnvelope
    set?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    disconnect?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    delete?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    connect?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    update?: AuditEventUpdateWithWhereUniqueWithoutTenetInput | AuditEventUpdateWithWhereUniqueWithoutTenetInput[]
    updateMany?: AuditEventUpdateManyWithWhereWithoutTenetInput | AuditEventUpdateManyWithWhereWithoutTenetInput[]
    deleteMany?: AuditEventScalarWhereInput | AuditEventScalarWhereInput[]
  }

  export type ContactTimelineEventUpdateManyWithoutTenetNestedInput = {
    create?: XOR<ContactTimelineEventCreateWithoutTenetInput, ContactTimelineEventUncheckedCreateWithoutTenetInput> | ContactTimelineEventCreateWithoutTenetInput[] | ContactTimelineEventUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: ContactTimelineEventCreateOrConnectWithoutTenetInput | ContactTimelineEventCreateOrConnectWithoutTenetInput[]
    upsert?: ContactTimelineEventUpsertWithWhereUniqueWithoutTenetInput | ContactTimelineEventUpsertWithWhereUniqueWithoutTenetInput[]
    createMany?: ContactTimelineEventCreateManyTenetInputEnvelope
    set?: ContactTimelineEventWhereUniqueInput | ContactTimelineEventWhereUniqueInput[]
    disconnect?: ContactTimelineEventWhereUniqueInput | ContactTimelineEventWhereUniqueInput[]
    delete?: ContactTimelineEventWhereUniqueInput | ContactTimelineEventWhereUniqueInput[]
    connect?: ContactTimelineEventWhereUniqueInput | ContactTimelineEventWhereUniqueInput[]
    update?: ContactTimelineEventUpdateWithWhereUniqueWithoutTenetInput | ContactTimelineEventUpdateWithWhereUniqueWithoutTenetInput[]
    updateMany?: ContactTimelineEventUpdateManyWithWhereWithoutTenetInput | ContactTimelineEventUpdateManyWithWhereWithoutTenetInput[]
    deleteMany?: ContactTimelineEventScalarWhereInput | ContactTimelineEventScalarWhereInput[]
  }

  export type ActivityStepUpdateManyWithoutTenetNestedInput = {
    create?: XOR<ActivityStepCreateWithoutTenetInput, ActivityStepUncheckedCreateWithoutTenetInput> | ActivityStepCreateWithoutTenetInput[] | ActivityStepUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: ActivityStepCreateOrConnectWithoutTenetInput | ActivityStepCreateOrConnectWithoutTenetInput[]
    upsert?: ActivityStepUpsertWithWhereUniqueWithoutTenetInput | ActivityStepUpsertWithWhereUniqueWithoutTenetInput[]
    createMany?: ActivityStepCreateManyTenetInputEnvelope
    set?: ActivityStepWhereUniqueInput | ActivityStepWhereUniqueInput[]
    disconnect?: ActivityStepWhereUniqueInput | ActivityStepWhereUniqueInput[]
    delete?: ActivityStepWhereUniqueInput | ActivityStepWhereUniqueInput[]
    connect?: ActivityStepWhereUniqueInput | ActivityStepWhereUniqueInput[]
    update?: ActivityStepUpdateWithWhereUniqueWithoutTenetInput | ActivityStepUpdateWithWhereUniqueWithoutTenetInput[]
    updateMany?: ActivityStepUpdateManyWithWhereWithoutTenetInput | ActivityStepUpdateManyWithWhereWithoutTenetInput[]
    deleteMany?: ActivityStepScalarWhereInput | ActivityStepScalarWhereInput[]
  }

  export type ActivityWaypointUpdateManyWithoutTenetNestedInput = {
    create?: XOR<ActivityWaypointCreateWithoutTenetInput, ActivityWaypointUncheckedCreateWithoutTenetInput> | ActivityWaypointCreateWithoutTenetInput[] | ActivityWaypointUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: ActivityWaypointCreateOrConnectWithoutTenetInput | ActivityWaypointCreateOrConnectWithoutTenetInput[]
    upsert?: ActivityWaypointUpsertWithWhereUniqueWithoutTenetInput | ActivityWaypointUpsertWithWhereUniqueWithoutTenetInput[]
    createMany?: ActivityWaypointCreateManyTenetInputEnvelope
    set?: ActivityWaypointWhereUniqueInput | ActivityWaypointWhereUniqueInput[]
    disconnect?: ActivityWaypointWhereUniqueInput | ActivityWaypointWhereUniqueInput[]
    delete?: ActivityWaypointWhereUniqueInput | ActivityWaypointWhereUniqueInput[]
    connect?: ActivityWaypointWhereUniqueInput | ActivityWaypointWhereUniqueInput[]
    update?: ActivityWaypointUpdateWithWhereUniqueWithoutTenetInput | ActivityWaypointUpdateWithWhereUniqueWithoutTenetInput[]
    updateMany?: ActivityWaypointUpdateManyWithWhereWithoutTenetInput | ActivityWaypointUpdateManyWithWhereWithoutTenetInput[]
    deleteMany?: ActivityWaypointScalarWhereInput | ActivityWaypointScalarWhereInput[]
  }

  export type TemplateAssignmentUpdateManyWithoutTenetNestedInput = {
    create?: XOR<TemplateAssignmentCreateWithoutTenetInput, TemplateAssignmentUncheckedCreateWithoutTenetInput> | TemplateAssignmentCreateWithoutTenetInput[] | TemplateAssignmentUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: TemplateAssignmentCreateOrConnectWithoutTenetInput | TemplateAssignmentCreateOrConnectWithoutTenetInput[]
    upsert?: TemplateAssignmentUpsertWithWhereUniqueWithoutTenetInput | TemplateAssignmentUpsertWithWhereUniqueWithoutTenetInput[]
    createMany?: TemplateAssignmentCreateManyTenetInputEnvelope
    set?: TemplateAssignmentWhereUniqueInput | TemplateAssignmentWhereUniqueInput[]
    disconnect?: TemplateAssignmentWhereUniqueInput | TemplateAssignmentWhereUniqueInput[]
    delete?: TemplateAssignmentWhereUniqueInput | TemplateAssignmentWhereUniqueInput[]
    connect?: TemplateAssignmentWhereUniqueInput | TemplateAssignmentWhereUniqueInput[]
    update?: TemplateAssignmentUpdateWithWhereUniqueWithoutTenetInput | TemplateAssignmentUpdateWithWhereUniqueWithoutTenetInput[]
    updateMany?: TemplateAssignmentUpdateManyWithWhereWithoutTenetInput | TemplateAssignmentUpdateManyWithWhereWithoutTenetInput[]
    deleteMany?: TemplateAssignmentScalarWhereInput | TemplateAssignmentScalarWhereInput[]
  }

  export type ActivityWaypointTemplateUpdateManyWithoutTenetNestedInput = {
    create?: XOR<ActivityWaypointTemplateCreateWithoutTenetInput, ActivityWaypointTemplateUncheckedCreateWithoutTenetInput> | ActivityWaypointTemplateCreateWithoutTenetInput[] | ActivityWaypointTemplateUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: ActivityWaypointTemplateCreateOrConnectWithoutTenetInput | ActivityWaypointTemplateCreateOrConnectWithoutTenetInput[]
    upsert?: ActivityWaypointTemplateUpsertWithWhereUniqueWithoutTenetInput | ActivityWaypointTemplateUpsertWithWhereUniqueWithoutTenetInput[]
    createMany?: ActivityWaypointTemplateCreateManyTenetInputEnvelope
    set?: ActivityWaypointTemplateWhereUniqueInput | ActivityWaypointTemplateWhereUniqueInput[]
    disconnect?: ActivityWaypointTemplateWhereUniqueInput | ActivityWaypointTemplateWhereUniqueInput[]
    delete?: ActivityWaypointTemplateWhereUniqueInput | ActivityWaypointTemplateWhereUniqueInput[]
    connect?: ActivityWaypointTemplateWhereUniqueInput | ActivityWaypointTemplateWhereUniqueInput[]
    update?: ActivityWaypointTemplateUpdateWithWhereUniqueWithoutTenetInput | ActivityWaypointTemplateUpdateWithWhereUniqueWithoutTenetInput[]
    updateMany?: ActivityWaypointTemplateUpdateManyWithWhereWithoutTenetInput | ActivityWaypointTemplateUpdateManyWithWhereWithoutTenetInput[]
    deleteMany?: ActivityWaypointTemplateScalarWhereInput | ActivityWaypointTemplateScalarWhereInput[]
  }

  export type ActivityTemplateUpdateManyWithoutTenetNestedInput = {
    create?: XOR<ActivityTemplateCreateWithoutTenetInput, ActivityTemplateUncheckedCreateWithoutTenetInput> | ActivityTemplateCreateWithoutTenetInput[] | ActivityTemplateUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: ActivityTemplateCreateOrConnectWithoutTenetInput | ActivityTemplateCreateOrConnectWithoutTenetInput[]
    upsert?: ActivityTemplateUpsertWithWhereUniqueWithoutTenetInput | ActivityTemplateUpsertWithWhereUniqueWithoutTenetInput[]
    createMany?: ActivityTemplateCreateManyTenetInputEnvelope
    set?: ActivityTemplateWhereUniqueInput | ActivityTemplateWhereUniqueInput[]
    disconnect?: ActivityTemplateWhereUniqueInput | ActivityTemplateWhereUniqueInput[]
    delete?: ActivityTemplateWhereUniqueInput | ActivityTemplateWhereUniqueInput[]
    connect?: ActivityTemplateWhereUniqueInput | ActivityTemplateWhereUniqueInput[]
    update?: ActivityTemplateUpdateWithWhereUniqueWithoutTenetInput | ActivityTemplateUpdateWithWhereUniqueWithoutTenetInput[]
    updateMany?: ActivityTemplateUpdateManyWithWhereWithoutTenetInput | ActivityTemplateUpdateManyWithWhereWithoutTenetInput[]
    deleteMany?: ActivityTemplateScalarWhereInput | ActivityTemplateScalarWhereInput[]
  }

  export type ActivityTemplateStepUpdateManyWithoutTenetNestedInput = {
    create?: XOR<ActivityTemplateStepCreateWithoutTenetInput, ActivityTemplateStepUncheckedCreateWithoutTenetInput> | ActivityTemplateStepCreateWithoutTenetInput[] | ActivityTemplateStepUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: ActivityTemplateStepCreateOrConnectWithoutTenetInput | ActivityTemplateStepCreateOrConnectWithoutTenetInput[]
    upsert?: ActivityTemplateStepUpsertWithWhereUniqueWithoutTenetInput | ActivityTemplateStepUpsertWithWhereUniqueWithoutTenetInput[]
    createMany?: ActivityTemplateStepCreateManyTenetInputEnvelope
    set?: ActivityTemplateStepWhereUniqueInput | ActivityTemplateStepWhereUniqueInput[]
    disconnect?: ActivityTemplateStepWhereUniqueInput | ActivityTemplateStepWhereUniqueInput[]
    delete?: ActivityTemplateStepWhereUniqueInput | ActivityTemplateStepWhereUniqueInput[]
    connect?: ActivityTemplateStepWhereUniqueInput | ActivityTemplateStepWhereUniqueInput[]
    update?: ActivityTemplateStepUpdateWithWhereUniqueWithoutTenetInput | ActivityTemplateStepUpdateWithWhereUniqueWithoutTenetInput[]
    updateMany?: ActivityTemplateStepUpdateManyWithWhereWithoutTenetInput | ActivityTemplateStepUpdateManyWithWhereWithoutTenetInput[]
    deleteMany?: ActivityTemplateStepScalarWhereInput | ActivityTemplateStepScalarWhereInput[]
  }

  export type OpportunityUpdateManyWithoutTenetNestedInput = {
    create?: XOR<OpportunityCreateWithoutTenetInput, OpportunityUncheckedCreateWithoutTenetInput> | OpportunityCreateWithoutTenetInput[] | OpportunityUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: OpportunityCreateOrConnectWithoutTenetInput | OpportunityCreateOrConnectWithoutTenetInput[]
    upsert?: OpportunityUpsertWithWhereUniqueWithoutTenetInput | OpportunityUpsertWithWhereUniqueWithoutTenetInput[]
    createMany?: OpportunityCreateManyTenetInputEnvelope
    set?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    disconnect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    delete?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    connect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    update?: OpportunityUpdateWithWhereUniqueWithoutTenetInput | OpportunityUpdateWithWhereUniqueWithoutTenetInput[]
    updateMany?: OpportunityUpdateManyWithWhereWithoutTenetInput | OpportunityUpdateManyWithWhereWithoutTenetInput[]
    deleteMany?: OpportunityScalarWhereInput | OpportunityScalarWhereInput[]
  }

  export type ProductTypeUpdateManyWithoutTenetNestedInput = {
    create?: XOR<ProductTypeCreateWithoutTenetInput, ProductTypeUncheckedCreateWithoutTenetInput> | ProductTypeCreateWithoutTenetInput[] | ProductTypeUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: ProductTypeCreateOrConnectWithoutTenetInput | ProductTypeCreateOrConnectWithoutTenetInput[]
    upsert?: ProductTypeUpsertWithWhereUniqueWithoutTenetInput | ProductTypeUpsertWithWhereUniqueWithoutTenetInput[]
    createMany?: ProductTypeCreateManyTenetInputEnvelope
    set?: ProductTypeWhereUniqueInput | ProductTypeWhereUniqueInput[]
    disconnect?: ProductTypeWhereUniqueInput | ProductTypeWhereUniqueInput[]
    delete?: ProductTypeWhereUniqueInput | ProductTypeWhereUniqueInput[]
    connect?: ProductTypeWhereUniqueInput | ProductTypeWhereUniqueInput[]
    update?: ProductTypeUpdateWithWhereUniqueWithoutTenetInput | ProductTypeUpdateWithWhereUniqueWithoutTenetInput[]
    updateMany?: ProductTypeUpdateManyWithWhereWithoutTenetInput | ProductTypeUpdateManyWithWhereWithoutTenetInput[]
    deleteMany?: ProductTypeScalarWhereInput | ProductTypeScalarWhereInput[]
  }

  export type ActivityTemplateStepAssignmentUpdateManyWithoutTenetNestedInput = {
    create?: XOR<ActivityTemplateStepAssignmentCreateWithoutTenetInput, ActivityTemplateStepAssignmentUncheckedCreateWithoutTenetInput> | ActivityTemplateStepAssignmentCreateWithoutTenetInput[] | ActivityTemplateStepAssignmentUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: ActivityTemplateStepAssignmentCreateOrConnectWithoutTenetInput | ActivityTemplateStepAssignmentCreateOrConnectWithoutTenetInput[]
    upsert?: ActivityTemplateStepAssignmentUpsertWithWhereUniqueWithoutTenetInput | ActivityTemplateStepAssignmentUpsertWithWhereUniqueWithoutTenetInput[]
    createMany?: ActivityTemplateStepAssignmentCreateManyTenetInputEnvelope
    set?: ActivityTemplateStepAssignmentWhereUniqueInput | ActivityTemplateStepAssignmentWhereUniqueInput[]
    disconnect?: ActivityTemplateStepAssignmentWhereUniqueInput | ActivityTemplateStepAssignmentWhereUniqueInput[]
    delete?: ActivityTemplateStepAssignmentWhereUniqueInput | ActivityTemplateStepAssignmentWhereUniqueInput[]
    connect?: ActivityTemplateStepAssignmentWhereUniqueInput | ActivityTemplateStepAssignmentWhereUniqueInput[]
    update?: ActivityTemplateStepAssignmentUpdateWithWhereUniqueWithoutTenetInput | ActivityTemplateStepAssignmentUpdateWithWhereUniqueWithoutTenetInput[]
    updateMany?: ActivityTemplateStepAssignmentUpdateManyWithWhereWithoutTenetInput | ActivityTemplateStepAssignmentUpdateManyWithWhereWithoutTenetInput[]
    deleteMany?: ActivityTemplateStepAssignmentScalarWhereInput | ActivityTemplateStepAssignmentScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutTenetNestedInput = {
    create?: XOR<UserCreateWithoutTenetInput, UserUncheckedCreateWithoutTenetInput> | UserCreateWithoutTenetInput[] | UserUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenetInput | UserCreateOrConnectWithoutTenetInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTenetInput | UserUpsertWithWhereUniqueWithoutTenetInput[]
    createMany?: UserCreateManyTenetInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTenetInput | UserUpdateWithWhereUniqueWithoutTenetInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTenetInput | UserUpdateManyWithWhereWithoutTenetInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type LogUncheckedUpdateManyWithoutTenetNestedInput = {
    create?: XOR<LogCreateWithoutTenetInput, LogUncheckedCreateWithoutTenetInput> | LogCreateWithoutTenetInput[] | LogUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: LogCreateOrConnectWithoutTenetInput | LogCreateOrConnectWithoutTenetInput[]
    upsert?: LogUpsertWithWhereUniqueWithoutTenetInput | LogUpsertWithWhereUniqueWithoutTenetInput[]
    createMany?: LogCreateManyTenetInputEnvelope
    set?: LogWhereUniqueInput | LogWhereUniqueInput[]
    disconnect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    delete?: LogWhereUniqueInput | LogWhereUniqueInput[]
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    update?: LogUpdateWithWhereUniqueWithoutTenetInput | LogUpdateWithWhereUniqueWithoutTenetInput[]
    updateMany?: LogUpdateManyWithWhereWithoutTenetInput | LogUpdateManyWithWhereWithoutTenetInput[]
    deleteMany?: LogScalarWhereInput | LogScalarWhereInput[]
  }

  export type ContactUncheckedUpdateManyWithoutTenetNestedInput = {
    create?: XOR<ContactCreateWithoutTenetInput, ContactUncheckedCreateWithoutTenetInput> | ContactCreateWithoutTenetInput[] | ContactUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutTenetInput | ContactCreateOrConnectWithoutTenetInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutTenetInput | ContactUpsertWithWhereUniqueWithoutTenetInput[]
    createMany?: ContactCreateManyTenetInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutTenetInput | ContactUpdateWithWhereUniqueWithoutTenetInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutTenetInput | ContactUpdateManyWithWhereWithoutTenetInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type ActivityUncheckedUpdateManyWithoutTenetNestedInput = {
    create?: XOR<ActivityCreateWithoutTenetInput, ActivityUncheckedCreateWithoutTenetInput> | ActivityCreateWithoutTenetInput[] | ActivityUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutTenetInput | ActivityCreateOrConnectWithoutTenetInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutTenetInput | ActivityUpsertWithWhereUniqueWithoutTenetInput[]
    createMany?: ActivityCreateManyTenetInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutTenetInput | ActivityUpdateWithWhereUniqueWithoutTenetInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutTenetInput | ActivityUpdateManyWithWhereWithoutTenetInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type AddressUncheckedUpdateManyWithoutTenetNestedInput = {
    create?: XOR<AddressCreateWithoutTenetInput, AddressUncheckedCreateWithoutTenetInput> | AddressCreateWithoutTenetInput[] | AddressUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutTenetInput | AddressCreateOrConnectWithoutTenetInput[]
    upsert?: AddressUpsertWithWhereUniqueWithoutTenetInput | AddressUpsertWithWhereUniqueWithoutTenetInput[]
    createMany?: AddressCreateManyTenetInputEnvelope
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    update?: AddressUpdateWithWhereUniqueWithoutTenetInput | AddressUpdateWithWhereUniqueWithoutTenetInput[]
    updateMany?: AddressUpdateManyWithWhereWithoutTenetInput | AddressUpdateManyWithWhereWithoutTenetInput[]
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[]
  }

  export type ContactEmailUncheckedUpdateManyWithoutTenetNestedInput = {
    create?: XOR<ContactEmailCreateWithoutTenetInput, ContactEmailUncheckedCreateWithoutTenetInput> | ContactEmailCreateWithoutTenetInput[] | ContactEmailUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: ContactEmailCreateOrConnectWithoutTenetInput | ContactEmailCreateOrConnectWithoutTenetInput[]
    upsert?: ContactEmailUpsertWithWhereUniqueWithoutTenetInput | ContactEmailUpsertWithWhereUniqueWithoutTenetInput[]
    createMany?: ContactEmailCreateManyTenetInputEnvelope
    set?: ContactEmailWhereUniqueInput | ContactEmailWhereUniqueInput[]
    disconnect?: ContactEmailWhereUniqueInput | ContactEmailWhereUniqueInput[]
    delete?: ContactEmailWhereUniqueInput | ContactEmailWhereUniqueInput[]
    connect?: ContactEmailWhereUniqueInput | ContactEmailWhereUniqueInput[]
    update?: ContactEmailUpdateWithWhereUniqueWithoutTenetInput | ContactEmailUpdateWithWhereUniqueWithoutTenetInput[]
    updateMany?: ContactEmailUpdateManyWithWhereWithoutTenetInput | ContactEmailUpdateManyWithWhereWithoutTenetInput[]
    deleteMany?: ContactEmailScalarWhereInput | ContactEmailScalarWhereInput[]
  }

  export type ContactPhoneUncheckedUpdateManyWithoutTenetNestedInput = {
    create?: XOR<ContactPhoneCreateWithoutTenetInput, ContactPhoneUncheckedCreateWithoutTenetInput> | ContactPhoneCreateWithoutTenetInput[] | ContactPhoneUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: ContactPhoneCreateOrConnectWithoutTenetInput | ContactPhoneCreateOrConnectWithoutTenetInput[]
    upsert?: ContactPhoneUpsertWithWhereUniqueWithoutTenetInput | ContactPhoneUpsertWithWhereUniqueWithoutTenetInput[]
    createMany?: ContactPhoneCreateManyTenetInputEnvelope
    set?: ContactPhoneWhereUniqueInput | ContactPhoneWhereUniqueInput[]
    disconnect?: ContactPhoneWhereUniqueInput | ContactPhoneWhereUniqueInput[]
    delete?: ContactPhoneWhereUniqueInput | ContactPhoneWhereUniqueInput[]
    connect?: ContactPhoneWhereUniqueInput | ContactPhoneWhereUniqueInput[]
    update?: ContactPhoneUpdateWithWhereUniqueWithoutTenetInput | ContactPhoneUpdateWithWhereUniqueWithoutTenetInput[]
    updateMany?: ContactPhoneUpdateManyWithWhereWithoutTenetInput | ContactPhoneUpdateManyWithWhereWithoutTenetInput[]
    deleteMany?: ContactPhoneScalarWhereInput | ContactPhoneScalarWhereInput[]
  }

  export type ImportantDateUncheckedUpdateManyWithoutTenetNestedInput = {
    create?: XOR<ImportantDateCreateWithoutTenetInput, ImportantDateUncheckedCreateWithoutTenetInput> | ImportantDateCreateWithoutTenetInput[] | ImportantDateUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: ImportantDateCreateOrConnectWithoutTenetInput | ImportantDateCreateOrConnectWithoutTenetInput[]
    upsert?: ImportantDateUpsertWithWhereUniqueWithoutTenetInput | ImportantDateUpsertWithWhereUniqueWithoutTenetInput[]
    createMany?: ImportantDateCreateManyTenetInputEnvelope
    set?: ImportantDateWhereUniqueInput | ImportantDateWhereUniqueInput[]
    disconnect?: ImportantDateWhereUniqueInput | ImportantDateWhereUniqueInput[]
    delete?: ImportantDateWhereUniqueInput | ImportantDateWhereUniqueInput[]
    connect?: ImportantDateWhereUniqueInput | ImportantDateWhereUniqueInput[]
    update?: ImportantDateUpdateWithWhereUniqueWithoutTenetInput | ImportantDateUpdateWithWhereUniqueWithoutTenetInput[]
    updateMany?: ImportantDateUpdateManyWithWhereWithoutTenetInput | ImportantDateUpdateManyWithWhereWithoutTenetInput[]
    deleteMany?: ImportantDateScalarWhereInput | ImportantDateScalarWhereInput[]
  }

  export type AttachmentUncheckedUpdateManyWithoutTenetNestedInput = {
    create?: XOR<AttachmentCreateWithoutTenetInput, AttachmentUncheckedCreateWithoutTenetInput> | AttachmentCreateWithoutTenetInput[] | AttachmentUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutTenetInput | AttachmentCreateOrConnectWithoutTenetInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutTenetInput | AttachmentUpsertWithWhereUniqueWithoutTenetInput[]
    createMany?: AttachmentCreateManyTenetInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutTenetInput | AttachmentUpdateWithWhereUniqueWithoutTenetInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutTenetInput | AttachmentUpdateManyWithWhereWithoutTenetInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type NoteUncheckedUpdateManyWithoutTenetNestedInput = {
    create?: XOR<NoteCreateWithoutTenetInput, NoteUncheckedCreateWithoutTenetInput> | NoteCreateWithoutTenetInput[] | NoteUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutTenetInput | NoteCreateOrConnectWithoutTenetInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutTenetInput | NoteUpsertWithWhereUniqueWithoutTenetInput[]
    createMany?: NoteCreateManyTenetInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutTenetInput | NoteUpdateWithWhereUniqueWithoutTenetInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutTenetInput | NoteUpdateManyWithWhereWithoutTenetInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type AuditEventUncheckedUpdateManyWithoutTenetNestedInput = {
    create?: XOR<AuditEventCreateWithoutTenetInput, AuditEventUncheckedCreateWithoutTenetInput> | AuditEventCreateWithoutTenetInput[] | AuditEventUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: AuditEventCreateOrConnectWithoutTenetInput | AuditEventCreateOrConnectWithoutTenetInput[]
    upsert?: AuditEventUpsertWithWhereUniqueWithoutTenetInput | AuditEventUpsertWithWhereUniqueWithoutTenetInput[]
    createMany?: AuditEventCreateManyTenetInputEnvelope
    set?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    disconnect?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    delete?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    connect?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    update?: AuditEventUpdateWithWhereUniqueWithoutTenetInput | AuditEventUpdateWithWhereUniqueWithoutTenetInput[]
    updateMany?: AuditEventUpdateManyWithWhereWithoutTenetInput | AuditEventUpdateManyWithWhereWithoutTenetInput[]
    deleteMany?: AuditEventScalarWhereInput | AuditEventScalarWhereInput[]
  }

  export type ContactTimelineEventUncheckedUpdateManyWithoutTenetNestedInput = {
    create?: XOR<ContactTimelineEventCreateWithoutTenetInput, ContactTimelineEventUncheckedCreateWithoutTenetInput> | ContactTimelineEventCreateWithoutTenetInput[] | ContactTimelineEventUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: ContactTimelineEventCreateOrConnectWithoutTenetInput | ContactTimelineEventCreateOrConnectWithoutTenetInput[]
    upsert?: ContactTimelineEventUpsertWithWhereUniqueWithoutTenetInput | ContactTimelineEventUpsertWithWhereUniqueWithoutTenetInput[]
    createMany?: ContactTimelineEventCreateManyTenetInputEnvelope
    set?: ContactTimelineEventWhereUniqueInput | ContactTimelineEventWhereUniqueInput[]
    disconnect?: ContactTimelineEventWhereUniqueInput | ContactTimelineEventWhereUniqueInput[]
    delete?: ContactTimelineEventWhereUniqueInput | ContactTimelineEventWhereUniqueInput[]
    connect?: ContactTimelineEventWhereUniqueInput | ContactTimelineEventWhereUniqueInput[]
    update?: ContactTimelineEventUpdateWithWhereUniqueWithoutTenetInput | ContactTimelineEventUpdateWithWhereUniqueWithoutTenetInput[]
    updateMany?: ContactTimelineEventUpdateManyWithWhereWithoutTenetInput | ContactTimelineEventUpdateManyWithWhereWithoutTenetInput[]
    deleteMany?: ContactTimelineEventScalarWhereInput | ContactTimelineEventScalarWhereInput[]
  }

  export type ActivityStepUncheckedUpdateManyWithoutTenetNestedInput = {
    create?: XOR<ActivityStepCreateWithoutTenetInput, ActivityStepUncheckedCreateWithoutTenetInput> | ActivityStepCreateWithoutTenetInput[] | ActivityStepUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: ActivityStepCreateOrConnectWithoutTenetInput | ActivityStepCreateOrConnectWithoutTenetInput[]
    upsert?: ActivityStepUpsertWithWhereUniqueWithoutTenetInput | ActivityStepUpsertWithWhereUniqueWithoutTenetInput[]
    createMany?: ActivityStepCreateManyTenetInputEnvelope
    set?: ActivityStepWhereUniqueInput | ActivityStepWhereUniqueInput[]
    disconnect?: ActivityStepWhereUniqueInput | ActivityStepWhereUniqueInput[]
    delete?: ActivityStepWhereUniqueInput | ActivityStepWhereUniqueInput[]
    connect?: ActivityStepWhereUniqueInput | ActivityStepWhereUniqueInput[]
    update?: ActivityStepUpdateWithWhereUniqueWithoutTenetInput | ActivityStepUpdateWithWhereUniqueWithoutTenetInput[]
    updateMany?: ActivityStepUpdateManyWithWhereWithoutTenetInput | ActivityStepUpdateManyWithWhereWithoutTenetInput[]
    deleteMany?: ActivityStepScalarWhereInput | ActivityStepScalarWhereInput[]
  }

  export type ActivityWaypointUncheckedUpdateManyWithoutTenetNestedInput = {
    create?: XOR<ActivityWaypointCreateWithoutTenetInput, ActivityWaypointUncheckedCreateWithoutTenetInput> | ActivityWaypointCreateWithoutTenetInput[] | ActivityWaypointUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: ActivityWaypointCreateOrConnectWithoutTenetInput | ActivityWaypointCreateOrConnectWithoutTenetInput[]
    upsert?: ActivityWaypointUpsertWithWhereUniqueWithoutTenetInput | ActivityWaypointUpsertWithWhereUniqueWithoutTenetInput[]
    createMany?: ActivityWaypointCreateManyTenetInputEnvelope
    set?: ActivityWaypointWhereUniqueInput | ActivityWaypointWhereUniqueInput[]
    disconnect?: ActivityWaypointWhereUniqueInput | ActivityWaypointWhereUniqueInput[]
    delete?: ActivityWaypointWhereUniqueInput | ActivityWaypointWhereUniqueInput[]
    connect?: ActivityWaypointWhereUniqueInput | ActivityWaypointWhereUniqueInput[]
    update?: ActivityWaypointUpdateWithWhereUniqueWithoutTenetInput | ActivityWaypointUpdateWithWhereUniqueWithoutTenetInput[]
    updateMany?: ActivityWaypointUpdateManyWithWhereWithoutTenetInput | ActivityWaypointUpdateManyWithWhereWithoutTenetInput[]
    deleteMany?: ActivityWaypointScalarWhereInput | ActivityWaypointScalarWhereInput[]
  }

  export type TemplateAssignmentUncheckedUpdateManyWithoutTenetNestedInput = {
    create?: XOR<TemplateAssignmentCreateWithoutTenetInput, TemplateAssignmentUncheckedCreateWithoutTenetInput> | TemplateAssignmentCreateWithoutTenetInput[] | TemplateAssignmentUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: TemplateAssignmentCreateOrConnectWithoutTenetInput | TemplateAssignmentCreateOrConnectWithoutTenetInput[]
    upsert?: TemplateAssignmentUpsertWithWhereUniqueWithoutTenetInput | TemplateAssignmentUpsertWithWhereUniqueWithoutTenetInput[]
    createMany?: TemplateAssignmentCreateManyTenetInputEnvelope
    set?: TemplateAssignmentWhereUniqueInput | TemplateAssignmentWhereUniqueInput[]
    disconnect?: TemplateAssignmentWhereUniqueInput | TemplateAssignmentWhereUniqueInput[]
    delete?: TemplateAssignmentWhereUniqueInput | TemplateAssignmentWhereUniqueInput[]
    connect?: TemplateAssignmentWhereUniqueInput | TemplateAssignmentWhereUniqueInput[]
    update?: TemplateAssignmentUpdateWithWhereUniqueWithoutTenetInput | TemplateAssignmentUpdateWithWhereUniqueWithoutTenetInput[]
    updateMany?: TemplateAssignmentUpdateManyWithWhereWithoutTenetInput | TemplateAssignmentUpdateManyWithWhereWithoutTenetInput[]
    deleteMany?: TemplateAssignmentScalarWhereInput | TemplateAssignmentScalarWhereInput[]
  }

  export type ActivityWaypointTemplateUncheckedUpdateManyWithoutTenetNestedInput = {
    create?: XOR<ActivityWaypointTemplateCreateWithoutTenetInput, ActivityWaypointTemplateUncheckedCreateWithoutTenetInput> | ActivityWaypointTemplateCreateWithoutTenetInput[] | ActivityWaypointTemplateUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: ActivityWaypointTemplateCreateOrConnectWithoutTenetInput | ActivityWaypointTemplateCreateOrConnectWithoutTenetInput[]
    upsert?: ActivityWaypointTemplateUpsertWithWhereUniqueWithoutTenetInput | ActivityWaypointTemplateUpsertWithWhereUniqueWithoutTenetInput[]
    createMany?: ActivityWaypointTemplateCreateManyTenetInputEnvelope
    set?: ActivityWaypointTemplateWhereUniqueInput | ActivityWaypointTemplateWhereUniqueInput[]
    disconnect?: ActivityWaypointTemplateWhereUniqueInput | ActivityWaypointTemplateWhereUniqueInput[]
    delete?: ActivityWaypointTemplateWhereUniqueInput | ActivityWaypointTemplateWhereUniqueInput[]
    connect?: ActivityWaypointTemplateWhereUniqueInput | ActivityWaypointTemplateWhereUniqueInput[]
    update?: ActivityWaypointTemplateUpdateWithWhereUniqueWithoutTenetInput | ActivityWaypointTemplateUpdateWithWhereUniqueWithoutTenetInput[]
    updateMany?: ActivityWaypointTemplateUpdateManyWithWhereWithoutTenetInput | ActivityWaypointTemplateUpdateManyWithWhereWithoutTenetInput[]
    deleteMany?: ActivityWaypointTemplateScalarWhereInput | ActivityWaypointTemplateScalarWhereInput[]
  }

  export type ActivityTemplateUncheckedUpdateManyWithoutTenetNestedInput = {
    create?: XOR<ActivityTemplateCreateWithoutTenetInput, ActivityTemplateUncheckedCreateWithoutTenetInput> | ActivityTemplateCreateWithoutTenetInput[] | ActivityTemplateUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: ActivityTemplateCreateOrConnectWithoutTenetInput | ActivityTemplateCreateOrConnectWithoutTenetInput[]
    upsert?: ActivityTemplateUpsertWithWhereUniqueWithoutTenetInput | ActivityTemplateUpsertWithWhereUniqueWithoutTenetInput[]
    createMany?: ActivityTemplateCreateManyTenetInputEnvelope
    set?: ActivityTemplateWhereUniqueInput | ActivityTemplateWhereUniqueInput[]
    disconnect?: ActivityTemplateWhereUniqueInput | ActivityTemplateWhereUniqueInput[]
    delete?: ActivityTemplateWhereUniqueInput | ActivityTemplateWhereUniqueInput[]
    connect?: ActivityTemplateWhereUniqueInput | ActivityTemplateWhereUniqueInput[]
    update?: ActivityTemplateUpdateWithWhereUniqueWithoutTenetInput | ActivityTemplateUpdateWithWhereUniqueWithoutTenetInput[]
    updateMany?: ActivityTemplateUpdateManyWithWhereWithoutTenetInput | ActivityTemplateUpdateManyWithWhereWithoutTenetInput[]
    deleteMany?: ActivityTemplateScalarWhereInput | ActivityTemplateScalarWhereInput[]
  }

  export type ActivityTemplateStepUncheckedUpdateManyWithoutTenetNestedInput = {
    create?: XOR<ActivityTemplateStepCreateWithoutTenetInput, ActivityTemplateStepUncheckedCreateWithoutTenetInput> | ActivityTemplateStepCreateWithoutTenetInput[] | ActivityTemplateStepUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: ActivityTemplateStepCreateOrConnectWithoutTenetInput | ActivityTemplateStepCreateOrConnectWithoutTenetInput[]
    upsert?: ActivityTemplateStepUpsertWithWhereUniqueWithoutTenetInput | ActivityTemplateStepUpsertWithWhereUniqueWithoutTenetInput[]
    createMany?: ActivityTemplateStepCreateManyTenetInputEnvelope
    set?: ActivityTemplateStepWhereUniqueInput | ActivityTemplateStepWhereUniqueInput[]
    disconnect?: ActivityTemplateStepWhereUniqueInput | ActivityTemplateStepWhereUniqueInput[]
    delete?: ActivityTemplateStepWhereUniqueInput | ActivityTemplateStepWhereUniqueInput[]
    connect?: ActivityTemplateStepWhereUniqueInput | ActivityTemplateStepWhereUniqueInput[]
    update?: ActivityTemplateStepUpdateWithWhereUniqueWithoutTenetInput | ActivityTemplateStepUpdateWithWhereUniqueWithoutTenetInput[]
    updateMany?: ActivityTemplateStepUpdateManyWithWhereWithoutTenetInput | ActivityTemplateStepUpdateManyWithWhereWithoutTenetInput[]
    deleteMany?: ActivityTemplateStepScalarWhereInput | ActivityTemplateStepScalarWhereInput[]
  }

  export type OpportunityUncheckedUpdateManyWithoutTenetNestedInput = {
    create?: XOR<OpportunityCreateWithoutTenetInput, OpportunityUncheckedCreateWithoutTenetInput> | OpportunityCreateWithoutTenetInput[] | OpportunityUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: OpportunityCreateOrConnectWithoutTenetInput | OpportunityCreateOrConnectWithoutTenetInput[]
    upsert?: OpportunityUpsertWithWhereUniqueWithoutTenetInput | OpportunityUpsertWithWhereUniqueWithoutTenetInput[]
    createMany?: OpportunityCreateManyTenetInputEnvelope
    set?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    disconnect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    delete?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    connect?: OpportunityWhereUniqueInput | OpportunityWhereUniqueInput[]
    update?: OpportunityUpdateWithWhereUniqueWithoutTenetInput | OpportunityUpdateWithWhereUniqueWithoutTenetInput[]
    updateMany?: OpportunityUpdateManyWithWhereWithoutTenetInput | OpportunityUpdateManyWithWhereWithoutTenetInput[]
    deleteMany?: OpportunityScalarWhereInput | OpportunityScalarWhereInput[]
  }

  export type ProductTypeUncheckedUpdateManyWithoutTenetNestedInput = {
    create?: XOR<ProductTypeCreateWithoutTenetInput, ProductTypeUncheckedCreateWithoutTenetInput> | ProductTypeCreateWithoutTenetInput[] | ProductTypeUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: ProductTypeCreateOrConnectWithoutTenetInput | ProductTypeCreateOrConnectWithoutTenetInput[]
    upsert?: ProductTypeUpsertWithWhereUniqueWithoutTenetInput | ProductTypeUpsertWithWhereUniqueWithoutTenetInput[]
    createMany?: ProductTypeCreateManyTenetInputEnvelope
    set?: ProductTypeWhereUniqueInput | ProductTypeWhereUniqueInput[]
    disconnect?: ProductTypeWhereUniqueInput | ProductTypeWhereUniqueInput[]
    delete?: ProductTypeWhereUniqueInput | ProductTypeWhereUniqueInput[]
    connect?: ProductTypeWhereUniqueInput | ProductTypeWhereUniqueInput[]
    update?: ProductTypeUpdateWithWhereUniqueWithoutTenetInput | ProductTypeUpdateWithWhereUniqueWithoutTenetInput[]
    updateMany?: ProductTypeUpdateManyWithWhereWithoutTenetInput | ProductTypeUpdateManyWithWhereWithoutTenetInput[]
    deleteMany?: ProductTypeScalarWhereInput | ProductTypeScalarWhereInput[]
  }

  export type ActivityTemplateStepAssignmentUncheckedUpdateManyWithoutTenetNestedInput = {
    create?: XOR<ActivityTemplateStepAssignmentCreateWithoutTenetInput, ActivityTemplateStepAssignmentUncheckedCreateWithoutTenetInput> | ActivityTemplateStepAssignmentCreateWithoutTenetInput[] | ActivityTemplateStepAssignmentUncheckedCreateWithoutTenetInput[]
    connectOrCreate?: ActivityTemplateStepAssignmentCreateOrConnectWithoutTenetInput | ActivityTemplateStepAssignmentCreateOrConnectWithoutTenetInput[]
    upsert?: ActivityTemplateStepAssignmentUpsertWithWhereUniqueWithoutTenetInput | ActivityTemplateStepAssignmentUpsertWithWhereUniqueWithoutTenetInput[]
    createMany?: ActivityTemplateStepAssignmentCreateManyTenetInputEnvelope
    set?: ActivityTemplateStepAssignmentWhereUniqueInput | ActivityTemplateStepAssignmentWhereUniqueInput[]
    disconnect?: ActivityTemplateStepAssignmentWhereUniqueInput | ActivityTemplateStepAssignmentWhereUniqueInput[]
    delete?: ActivityTemplateStepAssignmentWhereUniqueInput | ActivityTemplateStepAssignmentWhereUniqueInput[]
    connect?: ActivityTemplateStepAssignmentWhereUniqueInput | ActivityTemplateStepAssignmentWhereUniqueInput[]
    update?: ActivityTemplateStepAssignmentUpdateWithWhereUniqueWithoutTenetInput | ActivityTemplateStepAssignmentUpdateWithWhereUniqueWithoutTenetInput[]
    updateMany?: ActivityTemplateStepAssignmentUpdateManyWithWhereWithoutTenetInput | ActivityTemplateStepAssignmentUpdateManyWithWhereWithoutTenetInput[]
    deleteMany?: ActivityTemplateStepAssignmentScalarWhereInput | ActivityTemplateStepAssignmentScalarWhereInput[]
  }

  export type TokenCreateNestedManyWithoutUserInput = {
    create?: XOR<TokenCreateWithoutUserInput, TokenUncheckedCreateWithoutUserInput> | TokenCreateWithoutUserInput[] | TokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TokenCreateOrConnectWithoutUserInput | TokenCreateOrConnectWithoutUserInput[]
    createMany?: TokenCreateManyUserInputEnvelope
    connect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
  }

  export type TenetCreateNestedOneWithoutUsersInput = {
    create?: XOR<TenetCreateWithoutUsersInput, TenetUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TenetCreateOrConnectWithoutUsersInput
    connect?: TenetWhereUniqueInput
  }

  export type ActivityUserJoinCreateNestedManyWithoutUserRelationInput = {
    create?: XOR<ActivityUserJoinCreateWithoutUserRelationInput, ActivityUserJoinUncheckedCreateWithoutUserRelationInput> | ActivityUserJoinCreateWithoutUserRelationInput[] | ActivityUserJoinUncheckedCreateWithoutUserRelationInput[]
    connectOrCreate?: ActivityUserJoinCreateOrConnectWithoutUserRelationInput | ActivityUserJoinCreateOrConnectWithoutUserRelationInput[]
    createMany?: ActivityUserJoinCreateManyUserRelationInputEnvelope
    connect?: ActivityUserJoinWhereUniqueInput | ActivityUserJoinWhereUniqueInput[]
  }

  export type NoteCreateNestedManyWithoutAuthorInput = {
    create?: XOR<NoteCreateWithoutAuthorInput, NoteUncheckedCreateWithoutAuthorInput> | NoteCreateWithoutAuthorInput[] | NoteUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutAuthorInput | NoteCreateOrConnectWithoutAuthorInput[]
    createMany?: NoteCreateManyAuthorInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type UserWaypointJoinCreateNestedManyWithoutUserRelationInput = {
    create?: XOR<UserWaypointJoinCreateWithoutUserRelationInput, UserWaypointJoinUncheckedCreateWithoutUserRelationInput> | UserWaypointJoinCreateWithoutUserRelationInput[] | UserWaypointJoinUncheckedCreateWithoutUserRelationInput[]
    connectOrCreate?: UserWaypointJoinCreateOrConnectWithoutUserRelationInput | UserWaypointJoinCreateOrConnectWithoutUserRelationInput[]
    createMany?: UserWaypointJoinCreateManyUserRelationInputEnvelope
    connect?: UserWaypointJoinWhereUniqueInput | UserWaypointJoinWhereUniqueInput[]
  }

  export type ContactTimelineEventCreateNestedManyWithoutUserInput = {
    create?: XOR<ContactTimelineEventCreateWithoutUserInput, ContactTimelineEventUncheckedCreateWithoutUserInput> | ContactTimelineEventCreateWithoutUserInput[] | ContactTimelineEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContactTimelineEventCreateOrConnectWithoutUserInput | ContactTimelineEventCreateOrConnectWithoutUserInput[]
    createMany?: ContactTimelineEventCreateManyUserInputEnvelope
    connect?: ContactTimelineEventWhereUniqueInput | ContactTimelineEventWhereUniqueInput[]
  }

  export type AuditEventCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditEventCreateWithoutUserInput, AuditEventUncheckedCreateWithoutUserInput> | AuditEventCreateWithoutUserInput[] | AuditEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditEventCreateOrConnectWithoutUserInput | AuditEventCreateOrConnectWithoutUserInput[]
    createMany?: AuditEventCreateManyUserInputEnvelope
    connect?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
  }

  export type TemplateAssignmentCreateNestedManyWithoutSpecificUserInput = {
    create?: XOR<TemplateAssignmentCreateWithoutSpecificUserInput, TemplateAssignmentUncheckedCreateWithoutSpecificUserInput> | TemplateAssignmentCreateWithoutSpecificUserInput[] | TemplateAssignmentUncheckedCreateWithoutSpecificUserInput[]
    connectOrCreate?: TemplateAssignmentCreateOrConnectWithoutSpecificUserInput | TemplateAssignmentCreateOrConnectWithoutSpecificUserInput[]
    createMany?: TemplateAssignmentCreateManySpecificUserInputEnvelope
    connect?: TemplateAssignmentWhereUniqueInput | TemplateAssignmentWhereUniqueInput[]
  }

  export type ActivityCreateNestedManyWithoutAssignedByInput = {
    create?: XOR<ActivityCreateWithoutAssignedByInput, ActivityUncheckedCreateWithoutAssignedByInput> | ActivityCreateWithoutAssignedByInput[] | ActivityUncheckedCreateWithoutAssignedByInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutAssignedByInput | ActivityCreateOrConnectWithoutAssignedByInput[]
    createMany?: ActivityCreateManyAssignedByInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type UserOpportunityJoinCreateNestedManyWithoutUserRelationInput = {
    create?: XOR<UserOpportunityJoinCreateWithoutUserRelationInput, UserOpportunityJoinUncheckedCreateWithoutUserRelationInput> | UserOpportunityJoinCreateWithoutUserRelationInput[] | UserOpportunityJoinUncheckedCreateWithoutUserRelationInput[]
    connectOrCreate?: UserOpportunityJoinCreateOrConnectWithoutUserRelationInput | UserOpportunityJoinCreateOrConnectWithoutUserRelationInput[]
    createMany?: UserOpportunityJoinCreateManyUserRelationInputEnvelope
    connect?: UserOpportunityJoinWhereUniqueInput | UserOpportunityJoinWhereUniqueInput[]
  }

  export type ActivityStepUserJoinCreateNestedManyWithoutUserRelationInput = {
    create?: XOR<ActivityStepUserJoinCreateWithoutUserRelationInput, ActivityStepUserJoinUncheckedCreateWithoutUserRelationInput> | ActivityStepUserJoinCreateWithoutUserRelationInput[] | ActivityStepUserJoinUncheckedCreateWithoutUserRelationInput[]
    connectOrCreate?: ActivityStepUserJoinCreateOrConnectWithoutUserRelationInput | ActivityStepUserJoinCreateOrConnectWithoutUserRelationInput[]
    createMany?: ActivityStepUserJoinCreateManyUserRelationInputEnvelope
    connect?: ActivityStepUserJoinWhereUniqueInput | ActivityStepUserJoinWhereUniqueInput[]
  }

  export type ActivityTemplateStepAssignmentCreateNestedManyWithoutSpecificUserInput = {
    create?: XOR<ActivityTemplateStepAssignmentCreateWithoutSpecificUserInput, ActivityTemplateStepAssignmentUncheckedCreateWithoutSpecificUserInput> | ActivityTemplateStepAssignmentCreateWithoutSpecificUserInput[] | ActivityTemplateStepAssignmentUncheckedCreateWithoutSpecificUserInput[]
    connectOrCreate?: ActivityTemplateStepAssignmentCreateOrConnectWithoutSpecificUserInput | ActivityTemplateStepAssignmentCreateOrConnectWithoutSpecificUserInput[]
    createMany?: ActivityTemplateStepAssignmentCreateManySpecificUserInputEnvelope
    connect?: ActivityTemplateStepAssignmentWhereUniqueInput | ActivityTemplateStepAssignmentWhereUniqueInput[]
  }

  export type TokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TokenCreateWithoutUserInput, TokenUncheckedCreateWithoutUserInput> | TokenCreateWithoutUserInput[] | TokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TokenCreateOrConnectWithoutUserInput | TokenCreateOrConnectWithoutUserInput[]
    createMany?: TokenCreateManyUserInputEnvelope
    connect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
  }

  export type ActivityUserJoinUncheckedCreateNestedManyWithoutUserRelationInput = {
    create?: XOR<ActivityUserJoinCreateWithoutUserRelationInput, ActivityUserJoinUncheckedCreateWithoutUserRelationInput> | ActivityUserJoinCreateWithoutUserRelationInput[] | ActivityUserJoinUncheckedCreateWithoutUserRelationInput[]
    connectOrCreate?: ActivityUserJoinCreateOrConnectWithoutUserRelationInput | ActivityUserJoinCreateOrConnectWithoutUserRelationInput[]
    createMany?: ActivityUserJoinCreateManyUserRelationInputEnvelope
    connect?: ActivityUserJoinWhereUniqueInput | ActivityUserJoinWhereUniqueInput[]
  }

  export type NoteUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<NoteCreateWithoutAuthorInput, NoteUncheckedCreateWithoutAuthorInput> | NoteCreateWithoutAuthorInput[] | NoteUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutAuthorInput | NoteCreateOrConnectWithoutAuthorInput[]
    createMany?: NoteCreateManyAuthorInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type UserWaypointJoinUncheckedCreateNestedManyWithoutUserRelationInput = {
    create?: XOR<UserWaypointJoinCreateWithoutUserRelationInput, UserWaypointJoinUncheckedCreateWithoutUserRelationInput> | UserWaypointJoinCreateWithoutUserRelationInput[] | UserWaypointJoinUncheckedCreateWithoutUserRelationInput[]
    connectOrCreate?: UserWaypointJoinCreateOrConnectWithoutUserRelationInput | UserWaypointJoinCreateOrConnectWithoutUserRelationInput[]
    createMany?: UserWaypointJoinCreateManyUserRelationInputEnvelope
    connect?: UserWaypointJoinWhereUniqueInput | UserWaypointJoinWhereUniqueInput[]
  }

  export type ContactTimelineEventUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ContactTimelineEventCreateWithoutUserInput, ContactTimelineEventUncheckedCreateWithoutUserInput> | ContactTimelineEventCreateWithoutUserInput[] | ContactTimelineEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContactTimelineEventCreateOrConnectWithoutUserInput | ContactTimelineEventCreateOrConnectWithoutUserInput[]
    createMany?: ContactTimelineEventCreateManyUserInputEnvelope
    connect?: ContactTimelineEventWhereUniqueInput | ContactTimelineEventWhereUniqueInput[]
  }

  export type AuditEventUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditEventCreateWithoutUserInput, AuditEventUncheckedCreateWithoutUserInput> | AuditEventCreateWithoutUserInput[] | AuditEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditEventCreateOrConnectWithoutUserInput | AuditEventCreateOrConnectWithoutUserInput[]
    createMany?: AuditEventCreateManyUserInputEnvelope
    connect?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
  }

  export type TemplateAssignmentUncheckedCreateNestedManyWithoutSpecificUserInput = {
    create?: XOR<TemplateAssignmentCreateWithoutSpecificUserInput, TemplateAssignmentUncheckedCreateWithoutSpecificUserInput> | TemplateAssignmentCreateWithoutSpecificUserInput[] | TemplateAssignmentUncheckedCreateWithoutSpecificUserInput[]
    connectOrCreate?: TemplateAssignmentCreateOrConnectWithoutSpecificUserInput | TemplateAssignmentCreateOrConnectWithoutSpecificUserInput[]
    createMany?: TemplateAssignmentCreateManySpecificUserInputEnvelope
    connect?: TemplateAssignmentWhereUniqueInput | TemplateAssignmentWhereUniqueInput[]
  }

  export type ActivityUncheckedCreateNestedManyWithoutAssignedByInput = {
    create?: XOR<ActivityCreateWithoutAssignedByInput, ActivityUncheckedCreateWithoutAssignedByInput> | ActivityCreateWithoutAssignedByInput[] | ActivityUncheckedCreateWithoutAssignedByInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutAssignedByInput | ActivityCreateOrConnectWithoutAssignedByInput[]
    createMany?: ActivityCreateManyAssignedByInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type UserOpportunityJoinUncheckedCreateNestedManyWithoutUserRelationInput = {
    create?: XOR<UserOpportunityJoinCreateWithoutUserRelationInput, UserOpportunityJoinUncheckedCreateWithoutUserRelationInput> | UserOpportunityJoinCreateWithoutUserRelationInput[] | UserOpportunityJoinUncheckedCreateWithoutUserRelationInput[]
    connectOrCreate?: UserOpportunityJoinCreateOrConnectWithoutUserRelationInput | UserOpportunityJoinCreateOrConnectWithoutUserRelationInput[]
    createMany?: UserOpportunityJoinCreateManyUserRelationInputEnvelope
    connect?: UserOpportunityJoinWhereUniqueInput | UserOpportunityJoinWhereUniqueInput[]
  }

  export type ActivityStepUserJoinUncheckedCreateNestedManyWithoutUserRelationInput = {
    create?: XOR<ActivityStepUserJoinCreateWithoutUserRelationInput, ActivityStepUserJoinUncheckedCreateWithoutUserRelationInput> | ActivityStepUserJoinCreateWithoutUserRelationInput[] | ActivityStepUserJoinUncheckedCreateWithoutUserRelationInput[]
    connectOrCreate?: ActivityStepUserJoinCreateOrConnectWithoutUserRelationInput | ActivityStepUserJoinCreateOrConnectWithoutUserRelationInput[]
    createMany?: ActivityStepUserJoinCreateManyUserRelationInputEnvelope
    connect?: ActivityStepUserJoinWhereUniqueInput | ActivityStepUserJoinWhereUniqueInput[]
  }

  export type ActivityTemplateStepAssignmentUncheckedCreateNestedManyWithoutSpecificUserInput = {
    create?: XOR<ActivityTemplateStepAssignmentCreateWithoutSpecificUserInput, ActivityTemplateStepAssignmentUncheckedCreateWithoutSpecificUserInput> | ActivityTemplateStepAssignmentCreateWithoutSpecificUserInput[] | ActivityTemplateStepAssignmentUncheckedCreateWithoutSpecificUserInput[]
    connectOrCreate?: ActivityTemplateStepAssignmentCreateOrConnectWithoutSpecificUserInput | ActivityTemplateStepAssignmentCreateOrConnectWithoutSpecificUserInput[]
    createMany?: ActivityTemplateStepAssignmentCreateManySpecificUserInputEnvelope
    connect?: ActivityTemplateStepAssignmentWhereUniqueInput | ActivityTemplateStepAssignmentWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumAccessGroupFieldUpdateOperationsInput = {
    set?: $Enums.AccessGroup
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type TokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<TokenCreateWithoutUserInput, TokenUncheckedCreateWithoutUserInput> | TokenCreateWithoutUserInput[] | TokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TokenCreateOrConnectWithoutUserInput | TokenCreateOrConnectWithoutUserInput[]
    upsert?: TokenUpsertWithWhereUniqueWithoutUserInput | TokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TokenCreateManyUserInputEnvelope
    set?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    disconnect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    delete?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    connect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    update?: TokenUpdateWithWhereUniqueWithoutUserInput | TokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TokenUpdateManyWithWhereWithoutUserInput | TokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TokenScalarWhereInput | TokenScalarWhereInput[]
  }

  export type TenetUpdateOneWithoutUsersNestedInput = {
    create?: XOR<TenetCreateWithoutUsersInput, TenetUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TenetCreateOrConnectWithoutUsersInput
    upsert?: TenetUpsertWithoutUsersInput
    disconnect?: TenetWhereInput | boolean
    delete?: TenetWhereInput | boolean
    connect?: TenetWhereUniqueInput
    update?: XOR<XOR<TenetUpdateToOneWithWhereWithoutUsersInput, TenetUpdateWithoutUsersInput>, TenetUncheckedUpdateWithoutUsersInput>
  }

  export type ActivityUserJoinUpdateManyWithoutUserRelationNestedInput = {
    create?: XOR<ActivityUserJoinCreateWithoutUserRelationInput, ActivityUserJoinUncheckedCreateWithoutUserRelationInput> | ActivityUserJoinCreateWithoutUserRelationInput[] | ActivityUserJoinUncheckedCreateWithoutUserRelationInput[]
    connectOrCreate?: ActivityUserJoinCreateOrConnectWithoutUserRelationInput | ActivityUserJoinCreateOrConnectWithoutUserRelationInput[]
    upsert?: ActivityUserJoinUpsertWithWhereUniqueWithoutUserRelationInput | ActivityUserJoinUpsertWithWhereUniqueWithoutUserRelationInput[]
    createMany?: ActivityUserJoinCreateManyUserRelationInputEnvelope
    set?: ActivityUserJoinWhereUniqueInput | ActivityUserJoinWhereUniqueInput[]
    disconnect?: ActivityUserJoinWhereUniqueInput | ActivityUserJoinWhereUniqueInput[]
    delete?: ActivityUserJoinWhereUniqueInput | ActivityUserJoinWhereUniqueInput[]
    connect?: ActivityUserJoinWhereUniqueInput | ActivityUserJoinWhereUniqueInput[]
    update?: ActivityUserJoinUpdateWithWhereUniqueWithoutUserRelationInput | ActivityUserJoinUpdateWithWhereUniqueWithoutUserRelationInput[]
    updateMany?: ActivityUserJoinUpdateManyWithWhereWithoutUserRelationInput | ActivityUserJoinUpdateManyWithWhereWithoutUserRelationInput[]
    deleteMany?: ActivityUserJoinScalarWhereInput | ActivityUserJoinScalarWhereInput[]
  }

  export type NoteUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<NoteCreateWithoutAuthorInput, NoteUncheckedCreateWithoutAuthorInput> | NoteCreateWithoutAuthorInput[] | NoteUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutAuthorInput | NoteCreateOrConnectWithoutAuthorInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutAuthorInput | NoteUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: NoteCreateManyAuthorInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutAuthorInput | NoteUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutAuthorInput | NoteUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type UserWaypointJoinUpdateManyWithoutUserRelationNestedInput = {
    create?: XOR<UserWaypointJoinCreateWithoutUserRelationInput, UserWaypointJoinUncheckedCreateWithoutUserRelationInput> | UserWaypointJoinCreateWithoutUserRelationInput[] | UserWaypointJoinUncheckedCreateWithoutUserRelationInput[]
    connectOrCreate?: UserWaypointJoinCreateOrConnectWithoutUserRelationInput | UserWaypointJoinCreateOrConnectWithoutUserRelationInput[]
    upsert?: UserWaypointJoinUpsertWithWhereUniqueWithoutUserRelationInput | UserWaypointJoinUpsertWithWhereUniqueWithoutUserRelationInput[]
    createMany?: UserWaypointJoinCreateManyUserRelationInputEnvelope
    set?: UserWaypointJoinWhereUniqueInput | UserWaypointJoinWhereUniqueInput[]
    disconnect?: UserWaypointJoinWhereUniqueInput | UserWaypointJoinWhereUniqueInput[]
    delete?: UserWaypointJoinWhereUniqueInput | UserWaypointJoinWhereUniqueInput[]
    connect?: UserWaypointJoinWhereUniqueInput | UserWaypointJoinWhereUniqueInput[]
    update?: UserWaypointJoinUpdateWithWhereUniqueWithoutUserRelationInput | UserWaypointJoinUpdateWithWhereUniqueWithoutUserRelationInput[]
    updateMany?: UserWaypointJoinUpdateManyWithWhereWithoutUserRelationInput | UserWaypointJoinUpdateManyWithWhereWithoutUserRelationInput[]
    deleteMany?: UserWaypointJoinScalarWhereInput | UserWaypointJoinScalarWhereInput[]
  }

  export type ContactTimelineEventUpdateManyWithoutUserNestedInput = {
    create?: XOR<ContactTimelineEventCreateWithoutUserInput, ContactTimelineEventUncheckedCreateWithoutUserInput> | ContactTimelineEventCreateWithoutUserInput[] | ContactTimelineEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContactTimelineEventCreateOrConnectWithoutUserInput | ContactTimelineEventCreateOrConnectWithoutUserInput[]
    upsert?: ContactTimelineEventUpsertWithWhereUniqueWithoutUserInput | ContactTimelineEventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ContactTimelineEventCreateManyUserInputEnvelope
    set?: ContactTimelineEventWhereUniqueInput | ContactTimelineEventWhereUniqueInput[]
    disconnect?: ContactTimelineEventWhereUniqueInput | ContactTimelineEventWhereUniqueInput[]
    delete?: ContactTimelineEventWhereUniqueInput | ContactTimelineEventWhereUniqueInput[]
    connect?: ContactTimelineEventWhereUniqueInput | ContactTimelineEventWhereUniqueInput[]
    update?: ContactTimelineEventUpdateWithWhereUniqueWithoutUserInput | ContactTimelineEventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ContactTimelineEventUpdateManyWithWhereWithoutUserInput | ContactTimelineEventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ContactTimelineEventScalarWhereInput | ContactTimelineEventScalarWhereInput[]
  }

  export type AuditEventUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditEventCreateWithoutUserInput, AuditEventUncheckedCreateWithoutUserInput> | AuditEventCreateWithoutUserInput[] | AuditEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditEventCreateOrConnectWithoutUserInput | AuditEventCreateOrConnectWithoutUserInput[]
    upsert?: AuditEventUpsertWithWhereUniqueWithoutUserInput | AuditEventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditEventCreateManyUserInputEnvelope
    set?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    disconnect?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    delete?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    connect?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    update?: AuditEventUpdateWithWhereUniqueWithoutUserInput | AuditEventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditEventUpdateManyWithWhereWithoutUserInput | AuditEventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditEventScalarWhereInput | AuditEventScalarWhereInput[]
  }

  export type TemplateAssignmentUpdateManyWithoutSpecificUserNestedInput = {
    create?: XOR<TemplateAssignmentCreateWithoutSpecificUserInput, TemplateAssignmentUncheckedCreateWithoutSpecificUserInput> | TemplateAssignmentCreateWithoutSpecificUserInput[] | TemplateAssignmentUncheckedCreateWithoutSpecificUserInput[]
    connectOrCreate?: TemplateAssignmentCreateOrConnectWithoutSpecificUserInput | TemplateAssignmentCreateOrConnectWithoutSpecificUserInput[]
    upsert?: TemplateAssignmentUpsertWithWhereUniqueWithoutSpecificUserInput | TemplateAssignmentUpsertWithWhereUniqueWithoutSpecificUserInput[]
    createMany?: TemplateAssignmentCreateManySpecificUserInputEnvelope
    set?: TemplateAssignmentWhereUniqueInput | TemplateAssignmentWhereUniqueInput[]
    disconnect?: TemplateAssignmentWhereUniqueInput | TemplateAssignmentWhereUniqueInput[]
    delete?: TemplateAssignmentWhereUniqueInput | TemplateAssignmentWhereUniqueInput[]
    connect?: TemplateAssignmentWhereUniqueInput | TemplateAssignmentWhereUniqueInput[]
    update?: TemplateAssignmentUpdateWithWhereUniqueWithoutSpecificUserInput | TemplateAssignmentUpdateWithWhereUniqueWithoutSpecificUserInput[]
    updateMany?: TemplateAssignmentUpdateManyWithWhereWithoutSpecificUserInput | TemplateAssignmentUpdateManyWithWhereWithoutSpecificUserInput[]
    deleteMany?: TemplateAssignmentScalarWhereInput | TemplateAssignmentScalarWhereInput[]
  }

  export type ActivityUpdateManyWithoutAssignedByNestedInput = {
    create?: XOR<ActivityCreateWithoutAssignedByInput, ActivityUncheckedCreateWithoutAssignedByInput> | ActivityCreateWithoutAssignedByInput[] | ActivityUncheckedCreateWithoutAssignedByInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutAssignedByInput | ActivityCreateOrConnectWithoutAssignedByInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutAssignedByInput | ActivityUpsertWithWhereUniqueWithoutAssignedByInput[]
    createMany?: ActivityCreateManyAssignedByInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutAssignedByInput | ActivityUpdateWithWhereUniqueWithoutAssignedByInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutAssignedByInput | ActivityUpdateManyWithWhereWithoutAssignedByInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type UserOpportunityJoinUpdateManyWithoutUserRelationNestedInput = {
    create?: XOR<UserOpportunityJoinCreateWithoutUserRelationInput, UserOpportunityJoinUncheckedCreateWithoutUserRelationInput> | UserOpportunityJoinCreateWithoutUserRelationInput[] | UserOpportunityJoinUncheckedCreateWithoutUserRelationInput[]
    connectOrCreate?: UserOpportunityJoinCreateOrConnectWithoutUserRelationInput | UserOpportunityJoinCreateOrConnectWithoutUserRelationInput[]
    upsert?: UserOpportunityJoinUpsertWithWhereUniqueWithoutUserRelationInput | UserOpportunityJoinUpsertWithWhereUniqueWithoutUserRelationInput[]
    createMany?: UserOpportunityJoinCreateManyUserRelationInputEnvelope
    set?: UserOpportunityJoinWhereUniqueInput | UserOpportunityJoinWhereUniqueInput[]
    disconnect?: UserOpportunityJoinWhereUniqueInput | UserOpportunityJoinWhereUniqueInput[]
    delete?: UserOpportunityJoinWhereUniqueInput | UserOpportunityJoinWhereUniqueInput[]
    connect?: UserOpportunityJoinWhereUniqueInput | UserOpportunityJoinWhereUniqueInput[]
    update?: UserOpportunityJoinUpdateWithWhereUniqueWithoutUserRelationInput | UserOpportunityJoinUpdateWithWhereUniqueWithoutUserRelationInput[]
    updateMany?: UserOpportunityJoinUpdateManyWithWhereWithoutUserRelationInput | UserOpportunityJoinUpdateManyWithWhereWithoutUserRelationInput[]
    deleteMany?: UserOpportunityJoinScalarWhereInput | UserOpportunityJoinScalarWhereInput[]
  }

  export type ActivityStepUserJoinUpdateManyWithoutUserRelationNestedInput = {
    create?: XOR<ActivityStepUserJoinCreateWithoutUserRelationInput, ActivityStepUserJoinUncheckedCreateWithoutUserRelationInput> | ActivityStepUserJoinCreateWithoutUserRelationInput[] | ActivityStepUserJoinUncheckedCreateWithoutUserRelationInput[]
    connectOrCreate?: ActivityStepUserJoinCreateOrConnectWithoutUserRelationInput | ActivityStepUserJoinCreateOrConnectWithoutUserRelationInput[]
    upsert?: ActivityStepUserJoinUpsertWithWhereUniqueWithoutUserRelationInput | ActivityStepUserJoinUpsertWithWhereUniqueWithoutUserRelationInput[]
    createMany?: ActivityStepUserJoinCreateManyUserRelationInputEnvelope
    set?: ActivityStepUserJoinWhereUniqueInput | ActivityStepUserJoinWhereUniqueInput[]
    disconnect?: ActivityStepUserJoinWhereUniqueInput | ActivityStepUserJoinWhereUniqueInput[]
    delete?: ActivityStepUserJoinWhereUniqueInput | ActivityStepUserJoinWhereUniqueInput[]
    connect?: ActivityStepUserJoinWhereUniqueInput | ActivityStepUserJoinWhereUniqueInput[]
    update?: ActivityStepUserJoinUpdateWithWhereUniqueWithoutUserRelationInput | ActivityStepUserJoinUpdateWithWhereUniqueWithoutUserRelationInput[]
    updateMany?: ActivityStepUserJoinUpdateManyWithWhereWithoutUserRelationInput | ActivityStepUserJoinUpdateManyWithWhereWithoutUserRelationInput[]
    deleteMany?: ActivityStepUserJoinScalarWhereInput | ActivityStepUserJoinScalarWhereInput[]
  }

  export type ActivityTemplateStepAssignmentUpdateManyWithoutSpecificUserNestedInput = {
    create?: XOR<ActivityTemplateStepAssignmentCreateWithoutSpecificUserInput, ActivityTemplateStepAssignmentUncheckedCreateWithoutSpecificUserInput> | ActivityTemplateStepAssignmentCreateWithoutSpecificUserInput[] | ActivityTemplateStepAssignmentUncheckedCreateWithoutSpecificUserInput[]
    connectOrCreate?: ActivityTemplateStepAssignmentCreateOrConnectWithoutSpecificUserInput | ActivityTemplateStepAssignmentCreateOrConnectWithoutSpecificUserInput[]
    upsert?: ActivityTemplateStepAssignmentUpsertWithWhereUniqueWithoutSpecificUserInput | ActivityTemplateStepAssignmentUpsertWithWhereUniqueWithoutSpecificUserInput[]
    createMany?: ActivityTemplateStepAssignmentCreateManySpecificUserInputEnvelope
    set?: ActivityTemplateStepAssignmentWhereUniqueInput | ActivityTemplateStepAssignmentWhereUniqueInput[]
    disconnect?: ActivityTemplateStepAssignmentWhereUniqueInput | ActivityTemplateStepAssignmentWhereUniqueInput[]
    delete?: ActivityTemplateStepAssignmentWhereUniqueInput | ActivityTemplateStepAssignmentWhereUniqueInput[]
    connect?: ActivityTemplateStepAssignmentWhereUniqueInput | ActivityTemplateStepAssignmentWhereUniqueInput[]
    update?: ActivityTemplateStepAssignmentUpdateWithWhereUniqueWithoutSpecificUserInput | ActivityTemplateStepAssignmentUpdateWithWhereUniqueWithoutSpecificUserInput[]
    updateMany?: ActivityTemplateStepAssignmentUpdateManyWithWhereWithoutSpecificUserInput | ActivityTemplateStepAssignmentUpdateManyWithWhereWithoutSpecificUserInput[]
    deleteMany?: ActivityTemplateStepAssignmentScalarWhereInput | ActivityTemplateStepAssignmentScalarWhereInput[]
  }

  export type NullableBytesFieldUpdateOperationsInput = {
    set?: Uint8Array | null
  }

  export type TokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TokenCreateWithoutUserInput, TokenUncheckedCreateWithoutUserInput> | TokenCreateWithoutUserInput[] | TokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TokenCreateOrConnectWithoutUserInput | TokenCreateOrConnectWithoutUserInput[]
    upsert?: TokenUpsertWithWhereUniqueWithoutUserInput | TokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TokenCreateManyUserInputEnvelope
    set?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    disconnect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    delete?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    connect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    update?: TokenUpdateWithWhereUniqueWithoutUserInput | TokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TokenUpdateManyWithWhereWithoutUserInput | TokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TokenScalarWhereInput | TokenScalarWhereInput[]
  }

  export type ActivityUserJoinUncheckedUpdateManyWithoutUserRelationNestedInput = {
    create?: XOR<ActivityUserJoinCreateWithoutUserRelationInput, ActivityUserJoinUncheckedCreateWithoutUserRelationInput> | ActivityUserJoinCreateWithoutUserRelationInput[] | ActivityUserJoinUncheckedCreateWithoutUserRelationInput[]
    connectOrCreate?: ActivityUserJoinCreateOrConnectWithoutUserRelationInput | ActivityUserJoinCreateOrConnectWithoutUserRelationInput[]
    upsert?: ActivityUserJoinUpsertWithWhereUniqueWithoutUserRelationInput | ActivityUserJoinUpsertWithWhereUniqueWithoutUserRelationInput[]
    createMany?: ActivityUserJoinCreateManyUserRelationInputEnvelope
    set?: ActivityUserJoinWhereUniqueInput | ActivityUserJoinWhereUniqueInput[]
    disconnect?: ActivityUserJoinWhereUniqueInput | ActivityUserJoinWhereUniqueInput[]
    delete?: ActivityUserJoinWhereUniqueInput | ActivityUserJoinWhereUniqueInput[]
    connect?: ActivityUserJoinWhereUniqueInput | ActivityUserJoinWhereUniqueInput[]
    update?: ActivityUserJoinUpdateWithWhereUniqueWithoutUserRelationInput | ActivityUserJoinUpdateWithWhereUniqueWithoutUserRelationInput[]
    updateMany?: ActivityUserJoinUpdateManyWithWhereWithoutUserRelationInput | ActivityUserJoinUpdateManyWithWhereWithoutUserRelationInput[]
    deleteMany?: ActivityUserJoinScalarWhereInput | ActivityUserJoinScalarWhereInput[]
  }

  export type NoteUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<NoteCreateWithoutAuthorInput, NoteUncheckedCreateWithoutAuthorInput> | NoteCreateWithoutAuthorInput[] | NoteUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutAuthorInput | NoteCreateOrConnectWithoutAuthorInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutAuthorInput | NoteUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: NoteCreateManyAuthorInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutAuthorInput | NoteUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutAuthorInput | NoteUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type UserWaypointJoinUncheckedUpdateManyWithoutUserRelationNestedInput = {
    create?: XOR<UserWaypointJoinCreateWithoutUserRelationInput, UserWaypointJoinUncheckedCreateWithoutUserRelationInput> | UserWaypointJoinCreateWithoutUserRelationInput[] | UserWaypointJoinUncheckedCreateWithoutUserRelationInput[]
    connectOrCreate?: UserWaypointJoinCreateOrConnectWithoutUserRelationInput | UserWaypointJoinCreateOrConnectWithoutUserRelationInput[]
    upsert?: UserWaypointJoinUpsertWithWhereUniqueWithoutUserRelationInput | UserWaypointJoinUpsertWithWhereUniqueWithoutUserRelationInput[]
    createMany?: UserWaypointJoinCreateManyUserRelationInputEnvelope
    set?: UserWaypointJoinWhereUniqueInput | UserWaypointJoinWhereUniqueInput[]
    disconnect?: UserWaypointJoinWhereUniqueInput | UserWaypointJoinWhereUniqueInput[]
    delete?: UserWaypointJoinWhereUniqueInput | UserWaypointJoinWhereUniqueInput[]
    connect?: UserWaypointJoinWhereUniqueInput | UserWaypointJoinWhereUniqueInput[]
    update?: UserWaypointJoinUpdateWithWhereUniqueWithoutUserRelationInput | UserWaypointJoinUpdateWithWhereUniqueWithoutUserRelationInput[]
    updateMany?: UserWaypointJoinUpdateManyWithWhereWithoutUserRelationInput | UserWaypointJoinUpdateManyWithWhereWithoutUserRelationInput[]
    deleteMany?: UserWaypointJoinScalarWhereInput | UserWaypointJoinScalarWhereInput[]
  }

  export type ContactTimelineEventUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ContactTimelineEventCreateWithoutUserInput, ContactTimelineEventUncheckedCreateWithoutUserInput> | ContactTimelineEventCreateWithoutUserInput[] | ContactTimelineEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContactTimelineEventCreateOrConnectWithoutUserInput | ContactTimelineEventCreateOrConnectWithoutUserInput[]
    upsert?: ContactTimelineEventUpsertWithWhereUniqueWithoutUserInput | ContactTimelineEventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ContactTimelineEventCreateManyUserInputEnvelope
    set?: ContactTimelineEventWhereUniqueInput | ContactTimelineEventWhereUniqueInput[]
    disconnect?: ContactTimelineEventWhereUniqueInput | ContactTimelineEventWhereUniqueInput[]
    delete?: ContactTimelineEventWhereUniqueInput | ContactTimelineEventWhereUniqueInput[]
    connect?: ContactTimelineEventWhereUniqueInput | ContactTimelineEventWhereUniqueInput[]
    update?: ContactTimelineEventUpdateWithWhereUniqueWithoutUserInput | ContactTimelineEventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ContactTimelineEventUpdateManyWithWhereWithoutUserInput | ContactTimelineEventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ContactTimelineEventScalarWhereInput | ContactTimelineEventScalarWhereInput[]
  }

  export type AuditEventUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditEventCreateWithoutUserInput, AuditEventUncheckedCreateWithoutUserInput> | AuditEventCreateWithoutUserInput[] | AuditEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditEventCreateOrConnectWithoutUserInput | AuditEventCreateOrConnectWithoutUserInput[]
    upsert?: AuditEventUpsertWithWhereUniqueWithoutUserInput | AuditEventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditEventCreateManyUserInputEnvelope
    set?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    disconnect?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    delete?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    connect?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    update?: AuditEventUpdateWithWhereUniqueWithoutUserInput | AuditEventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditEventUpdateManyWithWhereWithoutUserInput | AuditEventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditEventScalarWhereInput | AuditEventScalarWhereInput[]
  }

  export type TemplateAssignmentUncheckedUpdateManyWithoutSpecificUserNestedInput = {
    create?: XOR<TemplateAssignmentCreateWithoutSpecificUserInput, TemplateAssignmentUncheckedCreateWithoutSpecificUserInput> | TemplateAssignmentCreateWithoutSpecificUserInput[] | TemplateAssignmentUncheckedCreateWithoutSpecificUserInput[]
    connectOrCreate?: TemplateAssignmentCreateOrConnectWithoutSpecificUserInput | TemplateAssignmentCreateOrConnectWithoutSpecificUserInput[]
    upsert?: TemplateAssignmentUpsertWithWhereUniqueWithoutSpecificUserInput | TemplateAssignmentUpsertWithWhereUniqueWithoutSpecificUserInput[]
    createMany?: TemplateAssignmentCreateManySpecificUserInputEnvelope
    set?: TemplateAssignmentWhereUniqueInput | TemplateAssignmentWhereUniqueInput[]
    disconnect?: TemplateAssignmentWhereUniqueInput | TemplateAssignmentWhereUniqueInput[]
    delete?: TemplateAssignmentWhereUniqueInput | TemplateAssignmentWhereUniqueInput[]
    connect?: TemplateAssignmentWhereUniqueInput | TemplateAssignmentWhereUniqueInput[]
    update?: TemplateAssignmentUpdateWithWhereUniqueWithoutSpecificUserInput | TemplateAssignmentUpdateWithWhereUniqueWithoutSpecificUserInput[]
    updateMany?: TemplateAssignmentUpdateManyWithWhereWithoutSpecificUserInput | TemplateAssignmentUpdateManyWithWhereWithoutSpecificUserInput[]
    deleteMany?: TemplateAssignmentScalarWhereInput | TemplateAssignmentScalarWhereInput[]
  }

  export type ActivityUncheckedUpdateManyWithoutAssignedByNestedInput = {
    create?: XOR<ActivityCreateWithoutAssignedByInput, ActivityUncheckedCreateWithoutAssignedByInput> | ActivityCreateWithoutAssignedByInput[] | ActivityUncheckedCreateWithoutAssignedByInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutAssignedByInput | ActivityCreateOrConnectWithoutAssignedByInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutAssignedByInput | ActivityUpsertWithWhereUniqueWithoutAssignedByInput[]
    createMany?: ActivityCreateManyAssignedByInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutAssignedByInput | ActivityUpdateWithWhereUniqueWithoutAssignedByInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutAssignedByInput | ActivityUpdateManyWithWhereWithoutAssignedByInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type UserOpportunityJoinUncheckedUpdateManyWithoutUserRelationNestedInput = {
    create?: XOR<UserOpportunityJoinCreateWithoutUserRelationInput, UserOpportunityJoinUncheckedCreateWithoutUserRelationInput> | UserOpportunityJoinCreateWithoutUserRelationInput[] | UserOpportunityJoinUncheckedCreateWithoutUserRelationInput[]
    connectOrCreate?: UserOpportunityJoinCreateOrConnectWithoutUserRelationInput | UserOpportunityJoinCreateOrConnectWithoutUserRelationInput[]
    upsert?: UserOpportunityJoinUpsertWithWhereUniqueWithoutUserRelationInput | UserOpportunityJoinUpsertWithWhereUniqueWithoutUserRelationInput[]
    createMany?: UserOpportunityJoinCreateManyUserRelationInputEnvelope
    set?: UserOpportunityJoinWhereUniqueInput | UserOpportunityJoinWhereUniqueInput[]
    disconnect?: UserOpportunityJoinWhereUniqueInput | UserOpportunityJoinWhereUniqueInput[]
    delete?: UserOpportunityJoinWhereUniqueInput | UserOpportunityJoinWhereUniqueInput[]
    connect?: UserOpportunityJoinWhereUniqueInput | UserOpportunityJoinWhereUniqueInput[]
    update?: UserOpportunityJoinUpdateWithWhereUniqueWithoutUserRelationInput | UserOpportunityJoinUpdateWithWhereUniqueWithoutUserRelationInput[]
    updateMany?: UserOpportunityJoinUpdateManyWithWhereWithoutUserRelationInput | UserOpportunityJoinUpdateManyWithWhereWithoutUserRelationInput[]
    deleteMany?: UserOpportunityJoinScalarWhereInput | UserOpportunityJoinScalarWhereInput[]
  }

  export type ActivityStepUserJoinUncheckedUpdateManyWithoutUserRelationNestedInput = {
    create?: XOR<ActivityStepUserJoinCreateWithoutUserRelationInput, ActivityStepUserJoinUncheckedCreateWithoutUserRelationInput> | ActivityStepUserJoinCreateWithoutUserRelationInput[] | ActivityStepUserJoinUncheckedCreateWithoutUserRelationInput[]
    connectOrCreate?: ActivityStepUserJoinCreateOrConnectWithoutUserRelationInput | ActivityStepUserJoinCreateOrConnectWithoutUserRelationInput[]
    upsert?: ActivityStepUserJoinUpsertWithWhereUniqueWithoutUserRelationInput | ActivityStepUserJoinUpsertWithWhereUniqueWithoutUserRelationInput[]
    createMany?: ActivityStepUserJoinCreateManyUserRelationInputEnvelope
    set?: ActivityStepUserJoinWhereUniqueInput | ActivityStepUserJoinWhereUniqueInput[]
    disconnect?: ActivityStepUserJoinWhereUniqueInput | ActivityStepUserJoinWhereUniqueInput[]
    delete?: ActivityStepUserJoinWhereUniqueInput | ActivityStepUserJoinWhereUniqueInput[]
    connect?: ActivityStepUserJoinWhereUniqueInput | ActivityStepUserJoinWhereUniqueInput[]
    update?: ActivityStepUserJoinUpdateWithWhereUniqueWithoutUserRelationInput | ActivityStepUserJoinUpdateWithWhereUniqueWithoutUserRelationInput[]
    updateMany?: ActivityStepUserJoinUpdateManyWithWhereWithoutUserRelationInput | ActivityStepUserJoinUpdateManyWithWhereWithoutUserRelationInput[]
    deleteMany?: ActivityStepUserJoinScalarWhereInput | ActivityStepUserJoinScalarWhereInput[]
  }

  export type ActivityTemplateStepAssignmentUncheckedUpdateManyWithoutSpecificUserNestedInput = {
    create?: XOR<ActivityTemplateStepAssignmentCreateWithoutSpecificUserInput, ActivityTemplateStepAssignmentUncheckedCreateWithoutSpecificUserInput> | ActivityTemplateStepAssignmentCreateWithoutSpecificUserInput[] | ActivityTemplateStepAssignmentUncheckedCreateWithoutSpecificUserInput[]
    connectOrCreate?: ActivityTemplateStepAssignmentCreateOrConnectWithoutSpecificUserInput | ActivityTemplateStepAssignmentCreateOrConnectWithoutSpecificUserInput[]
    upsert?: ActivityTemplateStepAssignmentUpsertWithWhereUniqueWithoutSpecificUserInput | ActivityTemplateStepAssignmentUpsertWithWhereUniqueWithoutSpecificUserInput[]
    createMany?: ActivityTemplateStepAssignmentCreateManySpecificUserInputEnvelope
    set?: ActivityTemplateStepAssignmentWhereUniqueInput | ActivityTemplateStepAssignmentWhereUniqueInput[]
    disconnect?: ActivityTemplateStepAssignmentWhereUniqueInput | ActivityTemplateStepAssignmentWhereUniqueInput[]
    delete?: ActivityTemplateStepAssignmentWhereUniqueInput | ActivityTemplateStepAssignmentWhereUniqueInput[]
    connect?: ActivityTemplateStepAssignmentWhereUniqueInput | ActivityTemplateStepAssignmentWhereUniqueInput[]
    update?: ActivityTemplateStepAssignmentUpdateWithWhereUniqueWithoutSpecificUserInput | ActivityTemplateStepAssignmentUpdateWithWhereUniqueWithoutSpecificUserInput[]
    updateMany?: ActivityTemplateStepAssignmentUpdateManyWithWhereWithoutSpecificUserInput | ActivityTemplateStepAssignmentUpdateManyWithWhereWithoutSpecificUserInput[]
    deleteMany?: ActivityTemplateStepAssignmentScalarWhereInput | ActivityTemplateStepAssignmentScalarWhereInput[]
  }

  export type TenetCreateNestedOneWithoutContactsInput = {
    create?: XOR<TenetCreateWithoutContactsInput, TenetUncheckedCreateWithoutContactsInput>
    connectOrCreate?: TenetCreateOrConnectWithoutContactsInput
    connect?: TenetWhereUniqueInput
  }

  export type NoteCreateNestedManyWithoutContactInput = {
    create?: XOR<NoteCreateWithoutContactInput, NoteUncheckedCreateWithoutContactInput> | NoteCreateWithoutContactInput[] | NoteUncheckedCreateWithoutContactInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutContactInput | NoteCreateOrConnectWithoutContactInput[]
    createMany?: NoteCreateManyContactInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type ContactTimelineEventContactJoinCreateNestedManyWithoutContactRelationInput = {
    create?: XOR<ContactTimelineEventContactJoinCreateWithoutContactRelationInput, ContactTimelineEventContactJoinUncheckedCreateWithoutContactRelationInput> | ContactTimelineEventContactJoinCreateWithoutContactRelationInput[] | ContactTimelineEventContactJoinUncheckedCreateWithoutContactRelationInput[]
    connectOrCreate?: ContactTimelineEventContactJoinCreateOrConnectWithoutContactRelationInput | ContactTimelineEventContactJoinCreateOrConnectWithoutContactRelationInput[]
    createMany?: ContactTimelineEventContactJoinCreateManyContactRelationInputEnvelope
    connect?: ContactTimelineEventContactJoinWhereUniqueInput | ContactTimelineEventContactJoinWhereUniqueInput[]
  }

  export type AddressCreateNestedManyWithoutContactInput = {
    create?: XOR<AddressCreateWithoutContactInput, AddressUncheckedCreateWithoutContactInput> | AddressCreateWithoutContactInput[] | AddressUncheckedCreateWithoutContactInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutContactInput | AddressCreateOrConnectWithoutContactInput[]
    createMany?: AddressCreateManyContactInputEnvelope
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
  }

  export type ContactEmailCreateNestedManyWithoutContactInput = {
    create?: XOR<ContactEmailCreateWithoutContactInput, ContactEmailUncheckedCreateWithoutContactInput> | ContactEmailCreateWithoutContactInput[] | ContactEmailUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ContactEmailCreateOrConnectWithoutContactInput | ContactEmailCreateOrConnectWithoutContactInput[]
    createMany?: ContactEmailCreateManyContactInputEnvelope
    connect?: ContactEmailWhereUniqueInput | ContactEmailWhereUniqueInput[]
  }

  export type ContactPhoneCreateNestedManyWithoutContactInput = {
    create?: XOR<ContactPhoneCreateWithoutContactInput, ContactPhoneUncheckedCreateWithoutContactInput> | ContactPhoneCreateWithoutContactInput[] | ContactPhoneUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ContactPhoneCreateOrConnectWithoutContactInput | ContactPhoneCreateOrConnectWithoutContactInput[]
    createMany?: ContactPhoneCreateManyContactInputEnvelope
    connect?: ContactPhoneWhereUniqueInput | ContactPhoneWhereUniqueInput[]
  }

  export type ImportantDateCreateNestedManyWithoutContactInput = {
    create?: XOR<ImportantDateCreateWithoutContactInput, ImportantDateUncheckedCreateWithoutContactInput> | ImportantDateCreateWithoutContactInput[] | ImportantDateUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ImportantDateCreateOrConnectWithoutContactInput | ImportantDateCreateOrConnectWithoutContactInput[]
    createMany?: ImportantDateCreateManyContactInputEnvelope
    connect?: ImportantDateWhereUniqueInput | ImportantDateWhereUniqueInput[]
  }

  export type ActivityContactJoinCreateNestedManyWithoutContactRelationInput = {
    create?: XOR<ActivityContactJoinCreateWithoutContactRelationInput, ActivityContactJoinUncheckedCreateWithoutContactRelationInput> | ActivityContactJoinCreateWithoutContactRelationInput[] | ActivityContactJoinUncheckedCreateWithoutContactRelationInput[]
    connectOrCreate?: ActivityContactJoinCreateOrConnectWithoutContactRelationInput | ActivityContactJoinCreateOrConnectWithoutContactRelationInput[]
    createMany?: ActivityContactJoinCreateManyContactRelationInputEnvelope
    connect?: ActivityContactJoinWhereUniqueInput | ActivityContactJoinWhereUniqueInput[]
  }

  export type ContactCreateNestedOneWithoutHouseholdMembersInput = {
    create?: XOR<ContactCreateWithoutHouseholdMembersInput, ContactUncheckedCreateWithoutHouseholdMembersInput>
    connectOrCreate?: ContactCreateOrConnectWithoutHouseholdMembersInput
    connect?: ContactWhereUniqueInput
  }

  export type ContactCreateNestedOneWithoutHeadOfHouseholdInput = {
    create?: XOR<ContactCreateWithoutHeadOfHouseholdInput, ContactUncheckedCreateWithoutHeadOfHouseholdInput>
    connectOrCreate?: ContactCreateOrConnectWithoutHeadOfHouseholdInput
    connect?: ContactWhereUniqueInput
  }

  export type ContactCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<ContactCreateWithoutEmployeesInput, ContactUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: ContactCreateOrConnectWithoutEmployeesInput
    connect?: ContactWhereUniqueInput
  }

  export type ContactCreateNestedOneWithoutPrimaryContactInput = {
    create?: XOR<ContactCreateWithoutPrimaryContactInput, ContactUncheckedCreateWithoutPrimaryContactInput>
    connectOrCreate?: ContactCreateOrConnectWithoutPrimaryContactInput
    connect?: ContactWhereUniqueInput
  }

  export type ContactCreateNestedOneWithoutHeadOfHouseholdForInput = {
    create?: XOR<ContactCreateWithoutHeadOfHouseholdForInput, ContactUncheckedCreateWithoutHeadOfHouseholdForInput>
    connectOrCreate?: ContactCreateOrConnectWithoutHeadOfHouseholdForInput
    connect?: ContactWhereUniqueInput
  }

  export type ContactCreateNestedManyWithoutHouseholdInput = {
    create?: XOR<ContactCreateWithoutHouseholdInput, ContactUncheckedCreateWithoutHouseholdInput> | ContactCreateWithoutHouseholdInput[] | ContactUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutHouseholdInput | ContactCreateOrConnectWithoutHouseholdInput[]
    createMany?: ContactCreateManyHouseholdInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type ContactCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ContactCreateWithoutCompanyInput, ContactUncheckedCreateWithoutCompanyInput> | ContactCreateWithoutCompanyInput[] | ContactUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutCompanyInput | ContactCreateOrConnectWithoutCompanyInput[]
    createMany?: ContactCreateManyCompanyInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type ContactCreateNestedOneWithoutPrimaryContactForInput = {
    create?: XOR<ContactCreateWithoutPrimaryContactForInput, ContactUncheckedCreateWithoutPrimaryContactForInput>
    connectOrCreate?: ContactCreateOrConnectWithoutPrimaryContactForInput
    connect?: ContactWhereUniqueInput
  }

  export type ContactOpportunityJoinCreateNestedManyWithoutContactRelationInput = {
    create?: XOR<ContactOpportunityJoinCreateWithoutContactRelationInput, ContactOpportunityJoinUncheckedCreateWithoutContactRelationInput> | ContactOpportunityJoinCreateWithoutContactRelationInput[] | ContactOpportunityJoinUncheckedCreateWithoutContactRelationInput[]
    connectOrCreate?: ContactOpportunityJoinCreateOrConnectWithoutContactRelationInput | ContactOpportunityJoinCreateOrConnectWithoutContactRelationInput[]
    createMany?: ContactOpportunityJoinCreateManyContactRelationInputEnvelope
    connect?: ContactOpportunityJoinWhereUniqueInput | ContactOpportunityJoinWhereUniqueInput[]
  }

  export type ContactRelationshipCreateNestedManyWithoutSourceInput = {
    create?: XOR<ContactRelationshipCreateWithoutSourceInput, ContactRelationshipUncheckedCreateWithoutSourceInput> | ContactRelationshipCreateWithoutSourceInput[] | ContactRelationshipUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: ContactRelationshipCreateOrConnectWithoutSourceInput | ContactRelationshipCreateOrConnectWithoutSourceInput[]
    createMany?: ContactRelationshipCreateManySourceInputEnvelope
    connect?: ContactRelationshipWhereUniqueInput | ContactRelationshipWhereUniqueInput[]
  }

  export type ContactRelationshipCreateNestedManyWithoutTargetInput = {
    create?: XOR<ContactRelationshipCreateWithoutTargetInput, ContactRelationshipUncheckedCreateWithoutTargetInput> | ContactRelationshipCreateWithoutTargetInput[] | ContactRelationshipUncheckedCreateWithoutTargetInput[]
    connectOrCreate?: ContactRelationshipCreateOrConnectWithoutTargetInput | ContactRelationshipCreateOrConnectWithoutTargetInput[]
    createMany?: ContactRelationshipCreateManyTargetInputEnvelope
    connect?: ContactRelationshipWhereUniqueInput | ContactRelationshipWhereUniqueInput[]
  }

  export type NoteUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<NoteCreateWithoutContactInput, NoteUncheckedCreateWithoutContactInput> | NoteCreateWithoutContactInput[] | NoteUncheckedCreateWithoutContactInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutContactInput | NoteCreateOrConnectWithoutContactInput[]
    createMany?: NoteCreateManyContactInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type ContactTimelineEventContactJoinUncheckedCreateNestedManyWithoutContactRelationInput = {
    create?: XOR<ContactTimelineEventContactJoinCreateWithoutContactRelationInput, ContactTimelineEventContactJoinUncheckedCreateWithoutContactRelationInput> | ContactTimelineEventContactJoinCreateWithoutContactRelationInput[] | ContactTimelineEventContactJoinUncheckedCreateWithoutContactRelationInput[]
    connectOrCreate?: ContactTimelineEventContactJoinCreateOrConnectWithoutContactRelationInput | ContactTimelineEventContactJoinCreateOrConnectWithoutContactRelationInput[]
    createMany?: ContactTimelineEventContactJoinCreateManyContactRelationInputEnvelope
    connect?: ContactTimelineEventContactJoinWhereUniqueInput | ContactTimelineEventContactJoinWhereUniqueInput[]
  }

  export type AddressUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<AddressCreateWithoutContactInput, AddressUncheckedCreateWithoutContactInput> | AddressCreateWithoutContactInput[] | AddressUncheckedCreateWithoutContactInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutContactInput | AddressCreateOrConnectWithoutContactInput[]
    createMany?: AddressCreateManyContactInputEnvelope
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
  }

  export type ContactEmailUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<ContactEmailCreateWithoutContactInput, ContactEmailUncheckedCreateWithoutContactInput> | ContactEmailCreateWithoutContactInput[] | ContactEmailUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ContactEmailCreateOrConnectWithoutContactInput | ContactEmailCreateOrConnectWithoutContactInput[]
    createMany?: ContactEmailCreateManyContactInputEnvelope
    connect?: ContactEmailWhereUniqueInput | ContactEmailWhereUniqueInput[]
  }

  export type ContactPhoneUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<ContactPhoneCreateWithoutContactInput, ContactPhoneUncheckedCreateWithoutContactInput> | ContactPhoneCreateWithoutContactInput[] | ContactPhoneUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ContactPhoneCreateOrConnectWithoutContactInput | ContactPhoneCreateOrConnectWithoutContactInput[]
    createMany?: ContactPhoneCreateManyContactInputEnvelope
    connect?: ContactPhoneWhereUniqueInput | ContactPhoneWhereUniqueInput[]
  }

  export type ImportantDateUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<ImportantDateCreateWithoutContactInput, ImportantDateUncheckedCreateWithoutContactInput> | ImportantDateCreateWithoutContactInput[] | ImportantDateUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ImportantDateCreateOrConnectWithoutContactInput | ImportantDateCreateOrConnectWithoutContactInput[]
    createMany?: ImportantDateCreateManyContactInputEnvelope
    connect?: ImportantDateWhereUniqueInput | ImportantDateWhereUniqueInput[]
  }

  export type ActivityContactJoinUncheckedCreateNestedManyWithoutContactRelationInput = {
    create?: XOR<ActivityContactJoinCreateWithoutContactRelationInput, ActivityContactJoinUncheckedCreateWithoutContactRelationInput> | ActivityContactJoinCreateWithoutContactRelationInput[] | ActivityContactJoinUncheckedCreateWithoutContactRelationInput[]
    connectOrCreate?: ActivityContactJoinCreateOrConnectWithoutContactRelationInput | ActivityContactJoinCreateOrConnectWithoutContactRelationInput[]
    createMany?: ActivityContactJoinCreateManyContactRelationInputEnvelope
    connect?: ActivityContactJoinWhereUniqueInput | ActivityContactJoinWhereUniqueInput[]
  }

  export type ContactUncheckedCreateNestedOneWithoutHeadOfHouseholdInput = {
    create?: XOR<ContactCreateWithoutHeadOfHouseholdInput, ContactUncheckedCreateWithoutHeadOfHouseholdInput>
    connectOrCreate?: ContactCreateOrConnectWithoutHeadOfHouseholdInput
    connect?: ContactWhereUniqueInput
  }

  export type ContactUncheckedCreateNestedOneWithoutPrimaryContactInput = {
    create?: XOR<ContactCreateWithoutPrimaryContactInput, ContactUncheckedCreateWithoutPrimaryContactInput>
    connectOrCreate?: ContactCreateOrConnectWithoutPrimaryContactInput
    connect?: ContactWhereUniqueInput
  }

  export type ContactUncheckedCreateNestedManyWithoutHouseholdInput = {
    create?: XOR<ContactCreateWithoutHouseholdInput, ContactUncheckedCreateWithoutHouseholdInput> | ContactCreateWithoutHouseholdInput[] | ContactUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutHouseholdInput | ContactCreateOrConnectWithoutHouseholdInput[]
    createMany?: ContactCreateManyHouseholdInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type ContactUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ContactCreateWithoutCompanyInput, ContactUncheckedCreateWithoutCompanyInput> | ContactCreateWithoutCompanyInput[] | ContactUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutCompanyInput | ContactCreateOrConnectWithoutCompanyInput[]
    createMany?: ContactCreateManyCompanyInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type ContactOpportunityJoinUncheckedCreateNestedManyWithoutContactRelationInput = {
    create?: XOR<ContactOpportunityJoinCreateWithoutContactRelationInput, ContactOpportunityJoinUncheckedCreateWithoutContactRelationInput> | ContactOpportunityJoinCreateWithoutContactRelationInput[] | ContactOpportunityJoinUncheckedCreateWithoutContactRelationInput[]
    connectOrCreate?: ContactOpportunityJoinCreateOrConnectWithoutContactRelationInput | ContactOpportunityJoinCreateOrConnectWithoutContactRelationInput[]
    createMany?: ContactOpportunityJoinCreateManyContactRelationInputEnvelope
    connect?: ContactOpportunityJoinWhereUniqueInput | ContactOpportunityJoinWhereUniqueInput[]
  }

  export type ContactRelationshipUncheckedCreateNestedManyWithoutSourceInput = {
    create?: XOR<ContactRelationshipCreateWithoutSourceInput, ContactRelationshipUncheckedCreateWithoutSourceInput> | ContactRelationshipCreateWithoutSourceInput[] | ContactRelationshipUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: ContactRelationshipCreateOrConnectWithoutSourceInput | ContactRelationshipCreateOrConnectWithoutSourceInput[]
    createMany?: ContactRelationshipCreateManySourceInputEnvelope
    connect?: ContactRelationshipWhereUniqueInput | ContactRelationshipWhereUniqueInput[]
  }

  export type ContactRelationshipUncheckedCreateNestedManyWithoutTargetInput = {
    create?: XOR<ContactRelationshipCreateWithoutTargetInput, ContactRelationshipUncheckedCreateWithoutTargetInput> | ContactRelationshipCreateWithoutTargetInput[] | ContactRelationshipUncheckedCreateWithoutTargetInput[]
    connectOrCreate?: ContactRelationshipCreateOrConnectWithoutTargetInput | ContactRelationshipCreateOrConnectWithoutTargetInput[]
    createMany?: ContactRelationshipCreateManyTargetInputEnvelope
    connect?: ContactRelationshipWhereUniqueInput | ContactRelationshipWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumContactTypeFieldUpdateOperationsInput = {
    set?: $Enums.ContactType
  }

  export type EnumContactStatusFieldUpdateOperationsInput = {
    set?: $Enums.ContactStatus
  }

  export type NullableEnumLifecycleStageFieldUpdateOperationsInput = {
    set?: $Enums.LifecycleStage | null
  }

  export type NullableEnumHouseholdRelationshipStatusFieldUpdateOperationsInput = {
    set?: $Enums.HouseholdRelationshipStatus | null
  }

  export type NullableEnumCompanyRelationshipStatusFieldUpdateOperationsInput = {
    set?: $Enums.CompanyRelationshipStatus | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TenetUpdateOneRequiredWithoutContactsNestedInput = {
    create?: XOR<TenetCreateWithoutContactsInput, TenetUncheckedCreateWithoutContactsInput>
    connectOrCreate?: TenetCreateOrConnectWithoutContactsInput
    upsert?: TenetUpsertWithoutContactsInput
    connect?: TenetWhereUniqueInput
    update?: XOR<XOR<TenetUpdateToOneWithWhereWithoutContactsInput, TenetUpdateWithoutContactsInput>, TenetUncheckedUpdateWithoutContactsInput>
  }

  export type NoteUpdateManyWithoutContactNestedInput = {
    create?: XOR<NoteCreateWithoutContactInput, NoteUncheckedCreateWithoutContactInput> | NoteCreateWithoutContactInput[] | NoteUncheckedCreateWithoutContactInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutContactInput | NoteCreateOrConnectWithoutContactInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutContactInput | NoteUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: NoteCreateManyContactInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutContactInput | NoteUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutContactInput | NoteUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type ContactTimelineEventContactJoinUpdateManyWithoutContactRelationNestedInput = {
    create?: XOR<ContactTimelineEventContactJoinCreateWithoutContactRelationInput, ContactTimelineEventContactJoinUncheckedCreateWithoutContactRelationInput> | ContactTimelineEventContactJoinCreateWithoutContactRelationInput[] | ContactTimelineEventContactJoinUncheckedCreateWithoutContactRelationInput[]
    connectOrCreate?: ContactTimelineEventContactJoinCreateOrConnectWithoutContactRelationInput | ContactTimelineEventContactJoinCreateOrConnectWithoutContactRelationInput[]
    upsert?: ContactTimelineEventContactJoinUpsertWithWhereUniqueWithoutContactRelationInput | ContactTimelineEventContactJoinUpsertWithWhereUniqueWithoutContactRelationInput[]
    createMany?: ContactTimelineEventContactJoinCreateManyContactRelationInputEnvelope
    set?: ContactTimelineEventContactJoinWhereUniqueInput | ContactTimelineEventContactJoinWhereUniqueInput[]
    disconnect?: ContactTimelineEventContactJoinWhereUniqueInput | ContactTimelineEventContactJoinWhereUniqueInput[]
    delete?: ContactTimelineEventContactJoinWhereUniqueInput | ContactTimelineEventContactJoinWhereUniqueInput[]
    connect?: ContactTimelineEventContactJoinWhereUniqueInput | ContactTimelineEventContactJoinWhereUniqueInput[]
    update?: ContactTimelineEventContactJoinUpdateWithWhereUniqueWithoutContactRelationInput | ContactTimelineEventContactJoinUpdateWithWhereUniqueWithoutContactRelationInput[]
    updateMany?: ContactTimelineEventContactJoinUpdateManyWithWhereWithoutContactRelationInput | ContactTimelineEventContactJoinUpdateManyWithWhereWithoutContactRelationInput[]
    deleteMany?: ContactTimelineEventContactJoinScalarWhereInput | ContactTimelineEventContactJoinScalarWhereInput[]
  }

  export type AddressUpdateManyWithoutContactNestedInput = {
    create?: XOR<AddressCreateWithoutContactInput, AddressUncheckedCreateWithoutContactInput> | AddressCreateWithoutContactInput[] | AddressUncheckedCreateWithoutContactInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutContactInput | AddressCreateOrConnectWithoutContactInput[]
    upsert?: AddressUpsertWithWhereUniqueWithoutContactInput | AddressUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: AddressCreateManyContactInputEnvelope
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    update?: AddressUpdateWithWhereUniqueWithoutContactInput | AddressUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: AddressUpdateManyWithWhereWithoutContactInput | AddressUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[]
  }

  export type ContactEmailUpdateManyWithoutContactNestedInput = {
    create?: XOR<ContactEmailCreateWithoutContactInput, ContactEmailUncheckedCreateWithoutContactInput> | ContactEmailCreateWithoutContactInput[] | ContactEmailUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ContactEmailCreateOrConnectWithoutContactInput | ContactEmailCreateOrConnectWithoutContactInput[]
    upsert?: ContactEmailUpsertWithWhereUniqueWithoutContactInput | ContactEmailUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: ContactEmailCreateManyContactInputEnvelope
    set?: ContactEmailWhereUniqueInput | ContactEmailWhereUniqueInput[]
    disconnect?: ContactEmailWhereUniqueInput | ContactEmailWhereUniqueInput[]
    delete?: ContactEmailWhereUniqueInput | ContactEmailWhereUniqueInput[]
    connect?: ContactEmailWhereUniqueInput | ContactEmailWhereUniqueInput[]
    update?: ContactEmailUpdateWithWhereUniqueWithoutContactInput | ContactEmailUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: ContactEmailUpdateManyWithWhereWithoutContactInput | ContactEmailUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: ContactEmailScalarWhereInput | ContactEmailScalarWhereInput[]
  }

  export type ContactPhoneUpdateManyWithoutContactNestedInput = {
    create?: XOR<ContactPhoneCreateWithoutContactInput, ContactPhoneUncheckedCreateWithoutContactInput> | ContactPhoneCreateWithoutContactInput[] | ContactPhoneUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ContactPhoneCreateOrConnectWithoutContactInput | ContactPhoneCreateOrConnectWithoutContactInput[]
    upsert?: ContactPhoneUpsertWithWhereUniqueWithoutContactInput | ContactPhoneUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: ContactPhoneCreateManyContactInputEnvelope
    set?: ContactPhoneWhereUniqueInput | ContactPhoneWhereUniqueInput[]
    disconnect?: ContactPhoneWhereUniqueInput | ContactPhoneWhereUniqueInput[]
    delete?: ContactPhoneWhereUniqueInput | ContactPhoneWhereUniqueInput[]
    connect?: ContactPhoneWhereUniqueInput | ContactPhoneWhereUniqueInput[]
    update?: ContactPhoneUpdateWithWhereUniqueWithoutContactInput | ContactPhoneUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: ContactPhoneUpdateManyWithWhereWithoutContactInput | ContactPhoneUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: ContactPhoneScalarWhereInput | ContactPhoneScalarWhereInput[]
  }

  export type ImportantDateUpdateManyWithoutContactNestedInput = {
    create?: XOR<ImportantDateCreateWithoutContactInput, ImportantDateUncheckedCreateWithoutContactInput> | ImportantDateCreateWithoutContactInput[] | ImportantDateUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ImportantDateCreateOrConnectWithoutContactInput | ImportantDateCreateOrConnectWithoutContactInput[]
    upsert?: ImportantDateUpsertWithWhereUniqueWithoutContactInput | ImportantDateUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: ImportantDateCreateManyContactInputEnvelope
    set?: ImportantDateWhereUniqueInput | ImportantDateWhereUniqueInput[]
    disconnect?: ImportantDateWhereUniqueInput | ImportantDateWhereUniqueInput[]
    delete?: ImportantDateWhereUniqueInput | ImportantDateWhereUniqueInput[]
    connect?: ImportantDateWhereUniqueInput | ImportantDateWhereUniqueInput[]
    update?: ImportantDateUpdateWithWhereUniqueWithoutContactInput | ImportantDateUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: ImportantDateUpdateManyWithWhereWithoutContactInput | ImportantDateUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: ImportantDateScalarWhereInput | ImportantDateScalarWhereInput[]
  }

  export type ActivityContactJoinUpdateManyWithoutContactRelationNestedInput = {
    create?: XOR<ActivityContactJoinCreateWithoutContactRelationInput, ActivityContactJoinUncheckedCreateWithoutContactRelationInput> | ActivityContactJoinCreateWithoutContactRelationInput[] | ActivityContactJoinUncheckedCreateWithoutContactRelationInput[]
    connectOrCreate?: ActivityContactJoinCreateOrConnectWithoutContactRelationInput | ActivityContactJoinCreateOrConnectWithoutContactRelationInput[]
    upsert?: ActivityContactJoinUpsertWithWhereUniqueWithoutContactRelationInput | ActivityContactJoinUpsertWithWhereUniqueWithoutContactRelationInput[]
    createMany?: ActivityContactJoinCreateManyContactRelationInputEnvelope
    set?: ActivityContactJoinWhereUniqueInput | ActivityContactJoinWhereUniqueInput[]
    disconnect?: ActivityContactJoinWhereUniqueInput | ActivityContactJoinWhereUniqueInput[]
    delete?: ActivityContactJoinWhereUniqueInput | ActivityContactJoinWhereUniqueInput[]
    connect?: ActivityContactJoinWhereUniqueInput | ActivityContactJoinWhereUniqueInput[]
    update?: ActivityContactJoinUpdateWithWhereUniqueWithoutContactRelationInput | ActivityContactJoinUpdateWithWhereUniqueWithoutContactRelationInput[]
    updateMany?: ActivityContactJoinUpdateManyWithWhereWithoutContactRelationInput | ActivityContactJoinUpdateManyWithWhereWithoutContactRelationInput[]
    deleteMany?: ActivityContactJoinScalarWhereInput | ActivityContactJoinScalarWhereInput[]
  }

  export type ContactUpdateOneWithoutHouseholdMembersNestedInput = {
    create?: XOR<ContactCreateWithoutHouseholdMembersInput, ContactUncheckedCreateWithoutHouseholdMembersInput>
    connectOrCreate?: ContactCreateOrConnectWithoutHouseholdMembersInput
    upsert?: ContactUpsertWithoutHouseholdMembersInput
    disconnect?: ContactWhereInput | boolean
    delete?: ContactWhereInput | boolean
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutHouseholdMembersInput, ContactUpdateWithoutHouseholdMembersInput>, ContactUncheckedUpdateWithoutHouseholdMembersInput>
  }

  export type ContactUpdateOneWithoutHeadOfHouseholdNestedInput = {
    create?: XOR<ContactCreateWithoutHeadOfHouseholdInput, ContactUncheckedCreateWithoutHeadOfHouseholdInput>
    connectOrCreate?: ContactCreateOrConnectWithoutHeadOfHouseholdInput
    upsert?: ContactUpsertWithoutHeadOfHouseholdInput
    disconnect?: ContactWhereInput | boolean
    delete?: ContactWhereInput | boolean
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutHeadOfHouseholdInput, ContactUpdateWithoutHeadOfHouseholdInput>, ContactUncheckedUpdateWithoutHeadOfHouseholdInput>
  }

  export type ContactUpdateOneWithoutEmployeesNestedInput = {
    create?: XOR<ContactCreateWithoutEmployeesInput, ContactUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: ContactCreateOrConnectWithoutEmployeesInput
    upsert?: ContactUpsertWithoutEmployeesInput
    disconnect?: ContactWhereInput | boolean
    delete?: ContactWhereInput | boolean
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutEmployeesInput, ContactUpdateWithoutEmployeesInput>, ContactUncheckedUpdateWithoutEmployeesInput>
  }

  export type ContactUpdateOneWithoutPrimaryContactNestedInput = {
    create?: XOR<ContactCreateWithoutPrimaryContactInput, ContactUncheckedCreateWithoutPrimaryContactInput>
    connectOrCreate?: ContactCreateOrConnectWithoutPrimaryContactInput
    upsert?: ContactUpsertWithoutPrimaryContactInput
    disconnect?: ContactWhereInput | boolean
    delete?: ContactWhereInput | boolean
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutPrimaryContactInput, ContactUpdateWithoutPrimaryContactInput>, ContactUncheckedUpdateWithoutPrimaryContactInput>
  }

  export type ContactUpdateOneWithoutHeadOfHouseholdForNestedInput = {
    create?: XOR<ContactCreateWithoutHeadOfHouseholdForInput, ContactUncheckedCreateWithoutHeadOfHouseholdForInput>
    connectOrCreate?: ContactCreateOrConnectWithoutHeadOfHouseholdForInput
    upsert?: ContactUpsertWithoutHeadOfHouseholdForInput
    disconnect?: ContactWhereInput | boolean
    delete?: ContactWhereInput | boolean
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutHeadOfHouseholdForInput, ContactUpdateWithoutHeadOfHouseholdForInput>, ContactUncheckedUpdateWithoutHeadOfHouseholdForInput>
  }

  export type ContactUpdateManyWithoutHouseholdNestedInput = {
    create?: XOR<ContactCreateWithoutHouseholdInput, ContactUncheckedCreateWithoutHouseholdInput> | ContactCreateWithoutHouseholdInput[] | ContactUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutHouseholdInput | ContactCreateOrConnectWithoutHouseholdInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutHouseholdInput | ContactUpsertWithWhereUniqueWithoutHouseholdInput[]
    createMany?: ContactCreateManyHouseholdInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutHouseholdInput | ContactUpdateWithWhereUniqueWithoutHouseholdInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutHouseholdInput | ContactUpdateManyWithWhereWithoutHouseholdInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type ContactUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ContactCreateWithoutCompanyInput, ContactUncheckedCreateWithoutCompanyInput> | ContactCreateWithoutCompanyInput[] | ContactUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutCompanyInput | ContactCreateOrConnectWithoutCompanyInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutCompanyInput | ContactUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ContactCreateManyCompanyInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutCompanyInput | ContactUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutCompanyInput | ContactUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type ContactUpdateOneWithoutPrimaryContactForNestedInput = {
    create?: XOR<ContactCreateWithoutPrimaryContactForInput, ContactUncheckedCreateWithoutPrimaryContactForInput>
    connectOrCreate?: ContactCreateOrConnectWithoutPrimaryContactForInput
    upsert?: ContactUpsertWithoutPrimaryContactForInput
    disconnect?: ContactWhereInput | boolean
    delete?: ContactWhereInput | boolean
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutPrimaryContactForInput, ContactUpdateWithoutPrimaryContactForInput>, ContactUncheckedUpdateWithoutPrimaryContactForInput>
  }

  export type ContactOpportunityJoinUpdateManyWithoutContactRelationNestedInput = {
    create?: XOR<ContactOpportunityJoinCreateWithoutContactRelationInput, ContactOpportunityJoinUncheckedCreateWithoutContactRelationInput> | ContactOpportunityJoinCreateWithoutContactRelationInput[] | ContactOpportunityJoinUncheckedCreateWithoutContactRelationInput[]
    connectOrCreate?: ContactOpportunityJoinCreateOrConnectWithoutContactRelationInput | ContactOpportunityJoinCreateOrConnectWithoutContactRelationInput[]
    upsert?: ContactOpportunityJoinUpsertWithWhereUniqueWithoutContactRelationInput | ContactOpportunityJoinUpsertWithWhereUniqueWithoutContactRelationInput[]
    createMany?: ContactOpportunityJoinCreateManyContactRelationInputEnvelope
    set?: ContactOpportunityJoinWhereUniqueInput | ContactOpportunityJoinWhereUniqueInput[]
    disconnect?: ContactOpportunityJoinWhereUniqueInput | ContactOpportunityJoinWhereUniqueInput[]
    delete?: ContactOpportunityJoinWhereUniqueInput | ContactOpportunityJoinWhereUniqueInput[]
    connect?: ContactOpportunityJoinWhereUniqueInput | ContactOpportunityJoinWhereUniqueInput[]
    update?: ContactOpportunityJoinUpdateWithWhereUniqueWithoutContactRelationInput | ContactOpportunityJoinUpdateWithWhereUniqueWithoutContactRelationInput[]
    updateMany?: ContactOpportunityJoinUpdateManyWithWhereWithoutContactRelationInput | ContactOpportunityJoinUpdateManyWithWhereWithoutContactRelationInput[]
    deleteMany?: ContactOpportunityJoinScalarWhereInput | ContactOpportunityJoinScalarWhereInput[]
  }

  export type ContactRelationshipUpdateManyWithoutSourceNestedInput = {
    create?: XOR<ContactRelationshipCreateWithoutSourceInput, ContactRelationshipUncheckedCreateWithoutSourceInput> | ContactRelationshipCreateWithoutSourceInput[] | ContactRelationshipUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: ContactRelationshipCreateOrConnectWithoutSourceInput | ContactRelationshipCreateOrConnectWithoutSourceInput[]
    upsert?: ContactRelationshipUpsertWithWhereUniqueWithoutSourceInput | ContactRelationshipUpsertWithWhereUniqueWithoutSourceInput[]
    createMany?: ContactRelationshipCreateManySourceInputEnvelope
    set?: ContactRelationshipWhereUniqueInput | ContactRelationshipWhereUniqueInput[]
    disconnect?: ContactRelationshipWhereUniqueInput | ContactRelationshipWhereUniqueInput[]
    delete?: ContactRelationshipWhereUniqueInput | ContactRelationshipWhereUniqueInput[]
    connect?: ContactRelationshipWhereUniqueInput | ContactRelationshipWhereUniqueInput[]
    update?: ContactRelationshipUpdateWithWhereUniqueWithoutSourceInput | ContactRelationshipUpdateWithWhereUniqueWithoutSourceInput[]
    updateMany?: ContactRelationshipUpdateManyWithWhereWithoutSourceInput | ContactRelationshipUpdateManyWithWhereWithoutSourceInput[]
    deleteMany?: ContactRelationshipScalarWhereInput | ContactRelationshipScalarWhereInput[]
  }

  export type ContactRelationshipUpdateManyWithoutTargetNestedInput = {
    create?: XOR<ContactRelationshipCreateWithoutTargetInput, ContactRelationshipUncheckedCreateWithoutTargetInput> | ContactRelationshipCreateWithoutTargetInput[] | ContactRelationshipUncheckedCreateWithoutTargetInput[]
    connectOrCreate?: ContactRelationshipCreateOrConnectWithoutTargetInput | ContactRelationshipCreateOrConnectWithoutTargetInput[]
    upsert?: ContactRelationshipUpsertWithWhereUniqueWithoutTargetInput | ContactRelationshipUpsertWithWhereUniqueWithoutTargetInput[]
    createMany?: ContactRelationshipCreateManyTargetInputEnvelope
    set?: ContactRelationshipWhereUniqueInput | ContactRelationshipWhereUniqueInput[]
    disconnect?: ContactRelationshipWhereUniqueInput | ContactRelationshipWhereUniqueInput[]
    delete?: ContactRelationshipWhereUniqueInput | ContactRelationshipWhereUniqueInput[]
    connect?: ContactRelationshipWhereUniqueInput | ContactRelationshipWhereUniqueInput[]
    update?: ContactRelationshipUpdateWithWhereUniqueWithoutTargetInput | ContactRelationshipUpdateWithWhereUniqueWithoutTargetInput[]
    updateMany?: ContactRelationshipUpdateManyWithWhereWithoutTargetInput | ContactRelationshipUpdateManyWithWhereWithoutTargetInput[]
    deleteMany?: ContactRelationshipScalarWhereInput | ContactRelationshipScalarWhereInput[]
  }

  export type NoteUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<NoteCreateWithoutContactInput, NoteUncheckedCreateWithoutContactInput> | NoteCreateWithoutContactInput[] | NoteUncheckedCreateWithoutContactInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutContactInput | NoteCreateOrConnectWithoutContactInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutContactInput | NoteUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: NoteCreateManyContactInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutContactInput | NoteUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutContactInput | NoteUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type ContactTimelineEventContactJoinUncheckedUpdateManyWithoutContactRelationNestedInput = {
    create?: XOR<ContactTimelineEventContactJoinCreateWithoutContactRelationInput, ContactTimelineEventContactJoinUncheckedCreateWithoutContactRelationInput> | ContactTimelineEventContactJoinCreateWithoutContactRelationInput[] | ContactTimelineEventContactJoinUncheckedCreateWithoutContactRelationInput[]
    connectOrCreate?: ContactTimelineEventContactJoinCreateOrConnectWithoutContactRelationInput | ContactTimelineEventContactJoinCreateOrConnectWithoutContactRelationInput[]
    upsert?: ContactTimelineEventContactJoinUpsertWithWhereUniqueWithoutContactRelationInput | ContactTimelineEventContactJoinUpsertWithWhereUniqueWithoutContactRelationInput[]
    createMany?: ContactTimelineEventContactJoinCreateManyContactRelationInputEnvelope
    set?: ContactTimelineEventContactJoinWhereUniqueInput | ContactTimelineEventContactJoinWhereUniqueInput[]
    disconnect?: ContactTimelineEventContactJoinWhereUniqueInput | ContactTimelineEventContactJoinWhereUniqueInput[]
    delete?: ContactTimelineEventContactJoinWhereUniqueInput | ContactTimelineEventContactJoinWhereUniqueInput[]
    connect?: ContactTimelineEventContactJoinWhereUniqueInput | ContactTimelineEventContactJoinWhereUniqueInput[]
    update?: ContactTimelineEventContactJoinUpdateWithWhereUniqueWithoutContactRelationInput | ContactTimelineEventContactJoinUpdateWithWhereUniqueWithoutContactRelationInput[]
    updateMany?: ContactTimelineEventContactJoinUpdateManyWithWhereWithoutContactRelationInput | ContactTimelineEventContactJoinUpdateManyWithWhereWithoutContactRelationInput[]
    deleteMany?: ContactTimelineEventContactJoinScalarWhereInput | ContactTimelineEventContactJoinScalarWhereInput[]
  }

  export type AddressUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<AddressCreateWithoutContactInput, AddressUncheckedCreateWithoutContactInput> | AddressCreateWithoutContactInput[] | AddressUncheckedCreateWithoutContactInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutContactInput | AddressCreateOrConnectWithoutContactInput[]
    upsert?: AddressUpsertWithWhereUniqueWithoutContactInput | AddressUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: AddressCreateManyContactInputEnvelope
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    update?: AddressUpdateWithWhereUniqueWithoutContactInput | AddressUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: AddressUpdateManyWithWhereWithoutContactInput | AddressUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[]
  }

  export type ContactEmailUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<ContactEmailCreateWithoutContactInput, ContactEmailUncheckedCreateWithoutContactInput> | ContactEmailCreateWithoutContactInput[] | ContactEmailUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ContactEmailCreateOrConnectWithoutContactInput | ContactEmailCreateOrConnectWithoutContactInput[]
    upsert?: ContactEmailUpsertWithWhereUniqueWithoutContactInput | ContactEmailUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: ContactEmailCreateManyContactInputEnvelope
    set?: ContactEmailWhereUniqueInput | ContactEmailWhereUniqueInput[]
    disconnect?: ContactEmailWhereUniqueInput | ContactEmailWhereUniqueInput[]
    delete?: ContactEmailWhereUniqueInput | ContactEmailWhereUniqueInput[]
    connect?: ContactEmailWhereUniqueInput | ContactEmailWhereUniqueInput[]
    update?: ContactEmailUpdateWithWhereUniqueWithoutContactInput | ContactEmailUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: ContactEmailUpdateManyWithWhereWithoutContactInput | ContactEmailUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: ContactEmailScalarWhereInput | ContactEmailScalarWhereInput[]
  }

  export type ContactPhoneUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<ContactPhoneCreateWithoutContactInput, ContactPhoneUncheckedCreateWithoutContactInput> | ContactPhoneCreateWithoutContactInput[] | ContactPhoneUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ContactPhoneCreateOrConnectWithoutContactInput | ContactPhoneCreateOrConnectWithoutContactInput[]
    upsert?: ContactPhoneUpsertWithWhereUniqueWithoutContactInput | ContactPhoneUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: ContactPhoneCreateManyContactInputEnvelope
    set?: ContactPhoneWhereUniqueInput | ContactPhoneWhereUniqueInput[]
    disconnect?: ContactPhoneWhereUniqueInput | ContactPhoneWhereUniqueInput[]
    delete?: ContactPhoneWhereUniqueInput | ContactPhoneWhereUniqueInput[]
    connect?: ContactPhoneWhereUniqueInput | ContactPhoneWhereUniqueInput[]
    update?: ContactPhoneUpdateWithWhereUniqueWithoutContactInput | ContactPhoneUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: ContactPhoneUpdateManyWithWhereWithoutContactInput | ContactPhoneUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: ContactPhoneScalarWhereInput | ContactPhoneScalarWhereInput[]
  }

  export type ImportantDateUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<ImportantDateCreateWithoutContactInput, ImportantDateUncheckedCreateWithoutContactInput> | ImportantDateCreateWithoutContactInput[] | ImportantDateUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ImportantDateCreateOrConnectWithoutContactInput | ImportantDateCreateOrConnectWithoutContactInput[]
    upsert?: ImportantDateUpsertWithWhereUniqueWithoutContactInput | ImportantDateUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: ImportantDateCreateManyContactInputEnvelope
    set?: ImportantDateWhereUniqueInput | ImportantDateWhereUniqueInput[]
    disconnect?: ImportantDateWhereUniqueInput | ImportantDateWhereUniqueInput[]
    delete?: ImportantDateWhereUniqueInput | ImportantDateWhereUniqueInput[]
    connect?: ImportantDateWhereUniqueInput | ImportantDateWhereUniqueInput[]
    update?: ImportantDateUpdateWithWhereUniqueWithoutContactInput | ImportantDateUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: ImportantDateUpdateManyWithWhereWithoutContactInput | ImportantDateUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: ImportantDateScalarWhereInput | ImportantDateScalarWhereInput[]
  }

  export type ActivityContactJoinUncheckedUpdateManyWithoutContactRelationNestedInput = {
    create?: XOR<ActivityContactJoinCreateWithoutContactRelationInput, ActivityContactJoinUncheckedCreateWithoutContactRelationInput> | ActivityContactJoinCreateWithoutContactRelationInput[] | ActivityContactJoinUncheckedCreateWithoutContactRelationInput[]
    connectOrCreate?: ActivityContactJoinCreateOrConnectWithoutContactRelationInput | ActivityContactJoinCreateOrConnectWithoutContactRelationInput[]
    upsert?: ActivityContactJoinUpsertWithWhereUniqueWithoutContactRelationInput | ActivityContactJoinUpsertWithWhereUniqueWithoutContactRelationInput[]
    createMany?: ActivityContactJoinCreateManyContactRelationInputEnvelope
    set?: ActivityContactJoinWhereUniqueInput | ActivityContactJoinWhereUniqueInput[]
    disconnect?: ActivityContactJoinWhereUniqueInput | ActivityContactJoinWhereUniqueInput[]
    delete?: ActivityContactJoinWhereUniqueInput | ActivityContactJoinWhereUniqueInput[]
    connect?: ActivityContactJoinWhereUniqueInput | ActivityContactJoinWhereUniqueInput[]
    update?: ActivityContactJoinUpdateWithWhereUniqueWithoutContactRelationInput | ActivityContactJoinUpdateWithWhereUniqueWithoutContactRelationInput[]
    updateMany?: ActivityContactJoinUpdateManyWithWhereWithoutContactRelationInput | ActivityContactJoinUpdateManyWithWhereWithoutContactRelationInput[]
    deleteMany?: ActivityContactJoinScalarWhereInput | ActivityContactJoinScalarWhereInput[]
  }

  export type ContactUncheckedUpdateOneWithoutHeadOfHouseholdNestedInput = {
    create?: XOR<ContactCreateWithoutHeadOfHouseholdInput, ContactUncheckedCreateWithoutHeadOfHouseholdInput>
    connectOrCreate?: ContactCreateOrConnectWithoutHeadOfHouseholdInput
    upsert?: ContactUpsertWithoutHeadOfHouseholdInput
    disconnect?: ContactWhereInput | boolean
    delete?: ContactWhereInput | boolean
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutHeadOfHouseholdInput, ContactUpdateWithoutHeadOfHouseholdInput>, ContactUncheckedUpdateWithoutHeadOfHouseholdInput>
  }

  export type ContactUncheckedUpdateOneWithoutPrimaryContactNestedInput = {
    create?: XOR<ContactCreateWithoutPrimaryContactInput, ContactUncheckedCreateWithoutPrimaryContactInput>
    connectOrCreate?: ContactCreateOrConnectWithoutPrimaryContactInput
    upsert?: ContactUpsertWithoutPrimaryContactInput
    disconnect?: ContactWhereInput | boolean
    delete?: ContactWhereInput | boolean
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutPrimaryContactInput, ContactUpdateWithoutPrimaryContactInput>, ContactUncheckedUpdateWithoutPrimaryContactInput>
  }

  export type ContactUncheckedUpdateManyWithoutHouseholdNestedInput = {
    create?: XOR<ContactCreateWithoutHouseholdInput, ContactUncheckedCreateWithoutHouseholdInput> | ContactCreateWithoutHouseholdInput[] | ContactUncheckedCreateWithoutHouseholdInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutHouseholdInput | ContactCreateOrConnectWithoutHouseholdInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutHouseholdInput | ContactUpsertWithWhereUniqueWithoutHouseholdInput[]
    createMany?: ContactCreateManyHouseholdInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutHouseholdInput | ContactUpdateWithWhereUniqueWithoutHouseholdInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutHouseholdInput | ContactUpdateManyWithWhereWithoutHouseholdInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type ContactUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ContactCreateWithoutCompanyInput, ContactUncheckedCreateWithoutCompanyInput> | ContactCreateWithoutCompanyInput[] | ContactUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutCompanyInput | ContactCreateOrConnectWithoutCompanyInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutCompanyInput | ContactUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ContactCreateManyCompanyInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutCompanyInput | ContactUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutCompanyInput | ContactUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type ContactOpportunityJoinUncheckedUpdateManyWithoutContactRelationNestedInput = {
    create?: XOR<ContactOpportunityJoinCreateWithoutContactRelationInput, ContactOpportunityJoinUncheckedCreateWithoutContactRelationInput> | ContactOpportunityJoinCreateWithoutContactRelationInput[] | ContactOpportunityJoinUncheckedCreateWithoutContactRelationInput[]
    connectOrCreate?: ContactOpportunityJoinCreateOrConnectWithoutContactRelationInput | ContactOpportunityJoinCreateOrConnectWithoutContactRelationInput[]
    upsert?: ContactOpportunityJoinUpsertWithWhereUniqueWithoutContactRelationInput | ContactOpportunityJoinUpsertWithWhereUniqueWithoutContactRelationInput[]
    createMany?: ContactOpportunityJoinCreateManyContactRelationInputEnvelope
    set?: ContactOpportunityJoinWhereUniqueInput | ContactOpportunityJoinWhereUniqueInput[]
    disconnect?: ContactOpportunityJoinWhereUniqueInput | ContactOpportunityJoinWhereUniqueInput[]
    delete?: ContactOpportunityJoinWhereUniqueInput | ContactOpportunityJoinWhereUniqueInput[]
    connect?: ContactOpportunityJoinWhereUniqueInput | ContactOpportunityJoinWhereUniqueInput[]
    update?: ContactOpportunityJoinUpdateWithWhereUniqueWithoutContactRelationInput | ContactOpportunityJoinUpdateWithWhereUniqueWithoutContactRelationInput[]
    updateMany?: ContactOpportunityJoinUpdateManyWithWhereWithoutContactRelationInput | ContactOpportunityJoinUpdateManyWithWhereWithoutContactRelationInput[]
    deleteMany?: ContactOpportunityJoinScalarWhereInput | ContactOpportunityJoinScalarWhereInput[]
  }

  export type ContactRelationshipUncheckedUpdateManyWithoutSourceNestedInput = {
    create?: XOR<ContactRelationshipCreateWithoutSourceInput, ContactRelationshipUncheckedCreateWithoutSourceInput> | ContactRelationshipCreateWithoutSourceInput[] | ContactRelationshipUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: ContactRelationshipCreateOrConnectWithoutSourceInput | ContactRelationshipCreateOrConnectWithoutSourceInput[]
    upsert?: ContactRelationshipUpsertWithWhereUniqueWithoutSourceInput | ContactRelationshipUpsertWithWhereUniqueWithoutSourceInput[]
    createMany?: ContactRelationshipCreateManySourceInputEnvelope
    set?: ContactRelationshipWhereUniqueInput | ContactRelationshipWhereUniqueInput[]
    disconnect?: ContactRelationshipWhereUniqueInput | ContactRelationshipWhereUniqueInput[]
    delete?: ContactRelationshipWhereUniqueInput | ContactRelationshipWhereUniqueInput[]
    connect?: ContactRelationshipWhereUniqueInput | ContactRelationshipWhereUniqueInput[]
    update?: ContactRelationshipUpdateWithWhereUniqueWithoutSourceInput | ContactRelationshipUpdateWithWhereUniqueWithoutSourceInput[]
    updateMany?: ContactRelationshipUpdateManyWithWhereWithoutSourceInput | ContactRelationshipUpdateManyWithWhereWithoutSourceInput[]
    deleteMany?: ContactRelationshipScalarWhereInput | ContactRelationshipScalarWhereInput[]
  }

  export type ContactRelationshipUncheckedUpdateManyWithoutTargetNestedInput = {
    create?: XOR<ContactRelationshipCreateWithoutTargetInput, ContactRelationshipUncheckedCreateWithoutTargetInput> | ContactRelationshipCreateWithoutTargetInput[] | ContactRelationshipUncheckedCreateWithoutTargetInput[]
    connectOrCreate?: ContactRelationshipCreateOrConnectWithoutTargetInput | ContactRelationshipCreateOrConnectWithoutTargetInput[]
    upsert?: ContactRelationshipUpsertWithWhereUniqueWithoutTargetInput | ContactRelationshipUpsertWithWhereUniqueWithoutTargetInput[]
    createMany?: ContactRelationshipCreateManyTargetInputEnvelope
    set?: ContactRelationshipWhereUniqueInput | ContactRelationshipWhereUniqueInput[]
    disconnect?: ContactRelationshipWhereUniqueInput | ContactRelationshipWhereUniqueInput[]
    delete?: ContactRelationshipWhereUniqueInput | ContactRelationshipWhereUniqueInput[]
    connect?: ContactRelationshipWhereUniqueInput | ContactRelationshipWhereUniqueInput[]
    update?: ContactRelationshipUpdateWithWhereUniqueWithoutTargetInput | ContactRelationshipUpdateWithWhereUniqueWithoutTargetInput[]
    updateMany?: ContactRelationshipUpdateManyWithWhereWithoutTargetInput | ContactRelationshipUpdateManyWithWhereWithoutTargetInput[]
    deleteMany?: ContactRelationshipScalarWhereInput | ContactRelationshipScalarWhereInput[]
  }

  export type ContactCreateNestedOneWithoutRelationAsSourceInput = {
    create?: XOR<ContactCreateWithoutRelationAsSourceInput, ContactUncheckedCreateWithoutRelationAsSourceInput>
    connectOrCreate?: ContactCreateOrConnectWithoutRelationAsSourceInput
    connect?: ContactWhereUniqueInput
  }

  export type ContactCreateNestedOneWithoutRelationAsTargetInput = {
    create?: XOR<ContactCreateWithoutRelationAsTargetInput, ContactUncheckedCreateWithoutRelationAsTargetInput>
    connectOrCreate?: ContactCreateOrConnectWithoutRelationAsTargetInput
    connect?: ContactWhereUniqueInput
  }

  export type ContactUpdateOneRequiredWithoutRelationAsSourceNestedInput = {
    create?: XOR<ContactCreateWithoutRelationAsSourceInput, ContactUncheckedCreateWithoutRelationAsSourceInput>
    connectOrCreate?: ContactCreateOrConnectWithoutRelationAsSourceInput
    upsert?: ContactUpsertWithoutRelationAsSourceInput
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutRelationAsSourceInput, ContactUpdateWithoutRelationAsSourceInput>, ContactUncheckedUpdateWithoutRelationAsSourceInput>
  }

  export type ContactUpdateOneRequiredWithoutRelationAsTargetNestedInput = {
    create?: XOR<ContactCreateWithoutRelationAsTargetInput, ContactUncheckedCreateWithoutRelationAsTargetInput>
    connectOrCreate?: ContactCreateOrConnectWithoutRelationAsTargetInput
    upsert?: ContactUpsertWithoutRelationAsTargetInput
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutRelationAsTargetInput, ContactUpdateWithoutRelationAsTargetInput>, ContactUncheckedUpdateWithoutRelationAsTargetInput>
  }

  export type ActivityCreateNestedOneWithoutStepsInput = {
    create?: XOR<ActivityCreateWithoutStepsInput, ActivityUncheckedCreateWithoutStepsInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutStepsInput
    connect?: ActivityWhereUniqueInput
  }

  export type ActivityStepUserJoinCreateNestedManyWithoutStepRelationInput = {
    create?: XOR<ActivityStepUserJoinCreateWithoutStepRelationInput, ActivityStepUserJoinUncheckedCreateWithoutStepRelationInput> | ActivityStepUserJoinCreateWithoutStepRelationInput[] | ActivityStepUserJoinUncheckedCreateWithoutStepRelationInput[]
    connectOrCreate?: ActivityStepUserJoinCreateOrConnectWithoutStepRelationInput | ActivityStepUserJoinCreateOrConnectWithoutStepRelationInput[]
    createMany?: ActivityStepUserJoinCreateManyStepRelationInputEnvelope
    connect?: ActivityStepUserJoinWhereUniqueInput | ActivityStepUserJoinWhereUniqueInput[]
  }

  export type TenetCreateNestedOneWithoutActivityStepsInput = {
    create?: XOR<TenetCreateWithoutActivityStepsInput, TenetUncheckedCreateWithoutActivityStepsInput>
    connectOrCreate?: TenetCreateOrConnectWithoutActivityStepsInput
    connect?: TenetWhereUniqueInput
  }

  export type ActivityStepUserJoinUncheckedCreateNestedManyWithoutStepRelationInput = {
    create?: XOR<ActivityStepUserJoinCreateWithoutStepRelationInput, ActivityStepUserJoinUncheckedCreateWithoutStepRelationInput> | ActivityStepUserJoinCreateWithoutStepRelationInput[] | ActivityStepUserJoinUncheckedCreateWithoutStepRelationInput[]
    connectOrCreate?: ActivityStepUserJoinCreateOrConnectWithoutStepRelationInput | ActivityStepUserJoinCreateOrConnectWithoutStepRelationInput[]
    createMany?: ActivityStepUserJoinCreateManyStepRelationInputEnvelope
    connect?: ActivityStepUserJoinWhereUniqueInput | ActivityStepUserJoinWhereUniqueInput[]
  }

  export type EnumActivityStepTypeFieldUpdateOperationsInput = {
    set?: $Enums.ActivityStepType
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ActivityUpdateOneRequiredWithoutStepsNestedInput = {
    create?: XOR<ActivityCreateWithoutStepsInput, ActivityUncheckedCreateWithoutStepsInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutStepsInput
    upsert?: ActivityUpsertWithoutStepsInput
    connect?: ActivityWhereUniqueInput
    update?: XOR<XOR<ActivityUpdateToOneWithWhereWithoutStepsInput, ActivityUpdateWithoutStepsInput>, ActivityUncheckedUpdateWithoutStepsInput>
  }

  export type ActivityStepUserJoinUpdateManyWithoutStepRelationNestedInput = {
    create?: XOR<ActivityStepUserJoinCreateWithoutStepRelationInput, ActivityStepUserJoinUncheckedCreateWithoutStepRelationInput> | ActivityStepUserJoinCreateWithoutStepRelationInput[] | ActivityStepUserJoinUncheckedCreateWithoutStepRelationInput[]
    connectOrCreate?: ActivityStepUserJoinCreateOrConnectWithoutStepRelationInput | ActivityStepUserJoinCreateOrConnectWithoutStepRelationInput[]
    upsert?: ActivityStepUserJoinUpsertWithWhereUniqueWithoutStepRelationInput | ActivityStepUserJoinUpsertWithWhereUniqueWithoutStepRelationInput[]
    createMany?: ActivityStepUserJoinCreateManyStepRelationInputEnvelope
    set?: ActivityStepUserJoinWhereUniqueInput | ActivityStepUserJoinWhereUniqueInput[]
    disconnect?: ActivityStepUserJoinWhereUniqueInput | ActivityStepUserJoinWhereUniqueInput[]
    delete?: ActivityStepUserJoinWhereUniqueInput | ActivityStepUserJoinWhereUniqueInput[]
    connect?: ActivityStepUserJoinWhereUniqueInput | ActivityStepUserJoinWhereUniqueInput[]
    update?: ActivityStepUserJoinUpdateWithWhereUniqueWithoutStepRelationInput | ActivityStepUserJoinUpdateWithWhereUniqueWithoutStepRelationInput[]
    updateMany?: ActivityStepUserJoinUpdateManyWithWhereWithoutStepRelationInput | ActivityStepUserJoinUpdateManyWithWhereWithoutStepRelationInput[]
    deleteMany?: ActivityStepUserJoinScalarWhereInput | ActivityStepUserJoinScalarWhereInput[]
  }

  export type TenetUpdateOneRequiredWithoutActivityStepsNestedInput = {
    create?: XOR<TenetCreateWithoutActivityStepsInput, TenetUncheckedCreateWithoutActivityStepsInput>
    connectOrCreate?: TenetCreateOrConnectWithoutActivityStepsInput
    upsert?: TenetUpsertWithoutActivityStepsInput
    connect?: TenetWhereUniqueInput
    update?: XOR<XOR<TenetUpdateToOneWithWhereWithoutActivityStepsInput, TenetUpdateWithoutActivityStepsInput>, TenetUncheckedUpdateWithoutActivityStepsInput>
  }

  export type ActivityStepUserJoinUncheckedUpdateManyWithoutStepRelationNestedInput = {
    create?: XOR<ActivityStepUserJoinCreateWithoutStepRelationInput, ActivityStepUserJoinUncheckedCreateWithoutStepRelationInput> | ActivityStepUserJoinCreateWithoutStepRelationInput[] | ActivityStepUserJoinUncheckedCreateWithoutStepRelationInput[]
    connectOrCreate?: ActivityStepUserJoinCreateOrConnectWithoutStepRelationInput | ActivityStepUserJoinCreateOrConnectWithoutStepRelationInput[]
    upsert?: ActivityStepUserJoinUpsertWithWhereUniqueWithoutStepRelationInput | ActivityStepUserJoinUpsertWithWhereUniqueWithoutStepRelationInput[]
    createMany?: ActivityStepUserJoinCreateManyStepRelationInputEnvelope
    set?: ActivityStepUserJoinWhereUniqueInput | ActivityStepUserJoinWhereUniqueInput[]
    disconnect?: ActivityStepUserJoinWhereUniqueInput | ActivityStepUserJoinWhereUniqueInput[]
    delete?: ActivityStepUserJoinWhereUniqueInput | ActivityStepUserJoinWhereUniqueInput[]
    connect?: ActivityStepUserJoinWhereUniqueInput | ActivityStepUserJoinWhereUniqueInput[]
    update?: ActivityStepUserJoinUpdateWithWhereUniqueWithoutStepRelationInput | ActivityStepUserJoinUpdateWithWhereUniqueWithoutStepRelationInput[]
    updateMany?: ActivityStepUserJoinUpdateManyWithWhereWithoutStepRelationInput | ActivityStepUserJoinUpdateManyWithWhereWithoutStepRelationInput[]
    deleteMany?: ActivityStepUserJoinScalarWhereInput | ActivityStepUserJoinScalarWhereInput[]
  }

  export type ActivityStepCreateNestedOneWithoutAssignedToInput = {
    create?: XOR<ActivityStepCreateWithoutAssignedToInput, ActivityStepUncheckedCreateWithoutAssignedToInput>
    connectOrCreate?: ActivityStepCreateOrConnectWithoutAssignedToInput
    connect?: ActivityStepWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutActivityStepsInput = {
    create?: XOR<UserCreateWithoutActivityStepsInput, UserUncheckedCreateWithoutActivityStepsInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivityStepsInput
    connect?: UserWhereUniqueInput
  }

  export type ActivityStepUpdateOneRequiredWithoutAssignedToNestedInput = {
    create?: XOR<ActivityStepCreateWithoutAssignedToInput, ActivityStepUncheckedCreateWithoutAssignedToInput>
    connectOrCreate?: ActivityStepCreateOrConnectWithoutAssignedToInput
    upsert?: ActivityStepUpsertWithoutAssignedToInput
    connect?: ActivityStepWhereUniqueInput
    update?: XOR<XOR<ActivityStepUpdateToOneWithWhereWithoutAssignedToInput, ActivityStepUpdateWithoutAssignedToInput>, ActivityStepUncheckedUpdateWithoutAssignedToInput>
  }

  export type UserUpdateOneRequiredWithoutActivityStepsNestedInput = {
    create?: XOR<UserCreateWithoutActivityStepsInput, UserUncheckedCreateWithoutActivityStepsInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivityStepsInput
    upsert?: UserUpsertWithoutActivityStepsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutActivityStepsInput, UserUpdateWithoutActivityStepsInput>, UserUncheckedUpdateWithoutActivityStepsInput>
  }

  export type UserCreateNestedOneWithoutWaypointsInput = {
    create?: XOR<UserCreateWithoutWaypointsInput, UserUncheckedCreateWithoutWaypointsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWaypointsInput
    connect?: UserWhereUniqueInput
  }

  export type ActivityWaypointCreateNestedOneWithoutUsersInput = {
    create?: XOR<ActivityWaypointCreateWithoutUsersInput, ActivityWaypointUncheckedCreateWithoutUsersInput>
    connectOrCreate?: ActivityWaypointCreateOrConnectWithoutUsersInput
    connect?: ActivityWaypointWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutWaypointsNestedInput = {
    create?: XOR<UserCreateWithoutWaypointsInput, UserUncheckedCreateWithoutWaypointsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWaypointsInput
    upsert?: UserUpsertWithoutWaypointsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWaypointsInput, UserUpdateWithoutWaypointsInput>, UserUncheckedUpdateWithoutWaypointsInput>
  }

  export type ActivityWaypointUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<ActivityWaypointCreateWithoutUsersInput, ActivityWaypointUncheckedCreateWithoutUsersInput>
    connectOrCreate?: ActivityWaypointCreateOrConnectWithoutUsersInput
    upsert?: ActivityWaypointUpsertWithoutUsersInput
    connect?: ActivityWaypointWhereUniqueInput
    update?: XOR<XOR<ActivityWaypointUpdateToOneWithWhereWithoutUsersInput, ActivityWaypointUpdateWithoutUsersInput>, ActivityWaypointUncheckedUpdateWithoutUsersInput>
  }

  export type UserWaypointJoinCreateNestedManyWithoutWaypointRelationInput = {
    create?: XOR<UserWaypointJoinCreateWithoutWaypointRelationInput, UserWaypointJoinUncheckedCreateWithoutWaypointRelationInput> | UserWaypointJoinCreateWithoutWaypointRelationInput[] | UserWaypointJoinUncheckedCreateWithoutWaypointRelationInput[]
    connectOrCreate?: UserWaypointJoinCreateOrConnectWithoutWaypointRelationInput | UserWaypointJoinCreateOrConnectWithoutWaypointRelationInput[]
    createMany?: UserWaypointJoinCreateManyWaypointRelationInputEnvelope
    connect?: UserWaypointJoinWhereUniqueInput | UserWaypointJoinWhereUniqueInput[]
  }

  export type ActivityCreateNestedOneWithoutWaypointsInput = {
    create?: XOR<ActivityCreateWithoutWaypointsInput, ActivityUncheckedCreateWithoutWaypointsInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutWaypointsInput
    connect?: ActivityWhereUniqueInput
  }

  export type ActivityCreateNestedManyWithoutParentWaypointInput = {
    create?: XOR<ActivityCreateWithoutParentWaypointInput, ActivityUncheckedCreateWithoutParentWaypointInput> | ActivityCreateWithoutParentWaypointInput[] | ActivityUncheckedCreateWithoutParentWaypointInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutParentWaypointInput | ActivityCreateOrConnectWithoutParentWaypointInput[]
    createMany?: ActivityCreateManyParentWaypointInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type ActivityWaypointTemplateCreateNestedOneWithoutWaypointsInput = {
    create?: XOR<ActivityWaypointTemplateCreateWithoutWaypointsInput, ActivityWaypointTemplateUncheckedCreateWithoutWaypointsInput>
    connectOrCreate?: ActivityWaypointTemplateCreateOrConnectWithoutWaypointsInput
    connect?: ActivityWaypointTemplateWhereUniqueInput
  }

  export type ContactTimelineEventCreateNestedManyWithoutWaypointInput = {
    create?: XOR<ContactTimelineEventCreateWithoutWaypointInput, ContactTimelineEventUncheckedCreateWithoutWaypointInput> | ContactTimelineEventCreateWithoutWaypointInput[] | ContactTimelineEventUncheckedCreateWithoutWaypointInput[]
    connectOrCreate?: ContactTimelineEventCreateOrConnectWithoutWaypointInput | ContactTimelineEventCreateOrConnectWithoutWaypointInput[]
    createMany?: ContactTimelineEventCreateManyWaypointInputEnvelope
    connect?: ContactTimelineEventWhereUniqueInput | ContactTimelineEventWhereUniqueInput[]
  }

  export type TenetCreateNestedOneWithoutActivityWaypointsInput = {
    create?: XOR<TenetCreateWithoutActivityWaypointsInput, TenetUncheckedCreateWithoutActivityWaypointsInput>
    connectOrCreate?: TenetCreateOrConnectWithoutActivityWaypointsInput
    connect?: TenetWhereUniqueInput
  }

  export type NoteCreateNestedManyWithoutWaypointInput = {
    create?: XOR<NoteCreateWithoutWaypointInput, NoteUncheckedCreateWithoutWaypointInput> | NoteCreateWithoutWaypointInput[] | NoteUncheckedCreateWithoutWaypointInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutWaypointInput | NoteCreateOrConnectWithoutWaypointInput[]
    createMany?: NoteCreateManyWaypointInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type UserWaypointJoinUncheckedCreateNestedManyWithoutWaypointRelationInput = {
    create?: XOR<UserWaypointJoinCreateWithoutWaypointRelationInput, UserWaypointJoinUncheckedCreateWithoutWaypointRelationInput> | UserWaypointJoinCreateWithoutWaypointRelationInput[] | UserWaypointJoinUncheckedCreateWithoutWaypointRelationInput[]
    connectOrCreate?: UserWaypointJoinCreateOrConnectWithoutWaypointRelationInput | UserWaypointJoinCreateOrConnectWithoutWaypointRelationInput[]
    createMany?: UserWaypointJoinCreateManyWaypointRelationInputEnvelope
    connect?: UserWaypointJoinWhereUniqueInput | UserWaypointJoinWhereUniqueInput[]
  }

  export type ActivityUncheckedCreateNestedManyWithoutParentWaypointInput = {
    create?: XOR<ActivityCreateWithoutParentWaypointInput, ActivityUncheckedCreateWithoutParentWaypointInput> | ActivityCreateWithoutParentWaypointInput[] | ActivityUncheckedCreateWithoutParentWaypointInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutParentWaypointInput | ActivityCreateOrConnectWithoutParentWaypointInput[]
    createMany?: ActivityCreateManyParentWaypointInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type ContactTimelineEventUncheckedCreateNestedManyWithoutWaypointInput = {
    create?: XOR<ContactTimelineEventCreateWithoutWaypointInput, ContactTimelineEventUncheckedCreateWithoutWaypointInput> | ContactTimelineEventCreateWithoutWaypointInput[] | ContactTimelineEventUncheckedCreateWithoutWaypointInput[]
    connectOrCreate?: ContactTimelineEventCreateOrConnectWithoutWaypointInput | ContactTimelineEventCreateOrConnectWithoutWaypointInput[]
    createMany?: ContactTimelineEventCreateManyWaypointInputEnvelope
    connect?: ContactTimelineEventWhereUniqueInput | ContactTimelineEventWhereUniqueInput[]
  }

  export type NoteUncheckedCreateNestedManyWithoutWaypointInput = {
    create?: XOR<NoteCreateWithoutWaypointInput, NoteUncheckedCreateWithoutWaypointInput> | NoteCreateWithoutWaypointInput[] | NoteUncheckedCreateWithoutWaypointInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutWaypointInput | NoteCreateOrConnectWithoutWaypointInput[]
    createMany?: NoteCreateManyWaypointInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type EnumActivityStatusFieldUpdateOperationsInput = {
    set?: $Enums.ActivityStatus
  }

  export type UserWaypointJoinUpdateManyWithoutWaypointRelationNestedInput = {
    create?: XOR<UserWaypointJoinCreateWithoutWaypointRelationInput, UserWaypointJoinUncheckedCreateWithoutWaypointRelationInput> | UserWaypointJoinCreateWithoutWaypointRelationInput[] | UserWaypointJoinUncheckedCreateWithoutWaypointRelationInput[]
    connectOrCreate?: UserWaypointJoinCreateOrConnectWithoutWaypointRelationInput | UserWaypointJoinCreateOrConnectWithoutWaypointRelationInput[]
    upsert?: UserWaypointJoinUpsertWithWhereUniqueWithoutWaypointRelationInput | UserWaypointJoinUpsertWithWhereUniqueWithoutWaypointRelationInput[]
    createMany?: UserWaypointJoinCreateManyWaypointRelationInputEnvelope
    set?: UserWaypointJoinWhereUniqueInput | UserWaypointJoinWhereUniqueInput[]
    disconnect?: UserWaypointJoinWhereUniqueInput | UserWaypointJoinWhereUniqueInput[]
    delete?: UserWaypointJoinWhereUniqueInput | UserWaypointJoinWhereUniqueInput[]
    connect?: UserWaypointJoinWhereUniqueInput | UserWaypointJoinWhereUniqueInput[]
    update?: UserWaypointJoinUpdateWithWhereUniqueWithoutWaypointRelationInput | UserWaypointJoinUpdateWithWhereUniqueWithoutWaypointRelationInput[]
    updateMany?: UserWaypointJoinUpdateManyWithWhereWithoutWaypointRelationInput | UserWaypointJoinUpdateManyWithWhereWithoutWaypointRelationInput[]
    deleteMany?: UserWaypointJoinScalarWhereInput | UserWaypointJoinScalarWhereInput[]
  }

  export type ActivityUpdateOneRequiredWithoutWaypointsNestedInput = {
    create?: XOR<ActivityCreateWithoutWaypointsInput, ActivityUncheckedCreateWithoutWaypointsInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutWaypointsInput
    upsert?: ActivityUpsertWithoutWaypointsInput
    connect?: ActivityWhereUniqueInput
    update?: XOR<XOR<ActivityUpdateToOneWithWhereWithoutWaypointsInput, ActivityUpdateWithoutWaypointsInput>, ActivityUncheckedUpdateWithoutWaypointsInput>
  }

  export type ActivityUpdateManyWithoutParentWaypointNestedInput = {
    create?: XOR<ActivityCreateWithoutParentWaypointInput, ActivityUncheckedCreateWithoutParentWaypointInput> | ActivityCreateWithoutParentWaypointInput[] | ActivityUncheckedCreateWithoutParentWaypointInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutParentWaypointInput | ActivityCreateOrConnectWithoutParentWaypointInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutParentWaypointInput | ActivityUpsertWithWhereUniqueWithoutParentWaypointInput[]
    createMany?: ActivityCreateManyParentWaypointInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutParentWaypointInput | ActivityUpdateWithWhereUniqueWithoutParentWaypointInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutParentWaypointInput | ActivityUpdateManyWithWhereWithoutParentWaypointInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type ActivityWaypointTemplateUpdateOneWithoutWaypointsNestedInput = {
    create?: XOR<ActivityWaypointTemplateCreateWithoutWaypointsInput, ActivityWaypointTemplateUncheckedCreateWithoutWaypointsInput>
    connectOrCreate?: ActivityWaypointTemplateCreateOrConnectWithoutWaypointsInput
    upsert?: ActivityWaypointTemplateUpsertWithoutWaypointsInput
    disconnect?: ActivityWaypointTemplateWhereInput | boolean
    delete?: ActivityWaypointTemplateWhereInput | boolean
    connect?: ActivityWaypointTemplateWhereUniqueInput
    update?: XOR<XOR<ActivityWaypointTemplateUpdateToOneWithWhereWithoutWaypointsInput, ActivityWaypointTemplateUpdateWithoutWaypointsInput>, ActivityWaypointTemplateUncheckedUpdateWithoutWaypointsInput>
  }

  export type ContactTimelineEventUpdateManyWithoutWaypointNestedInput = {
    create?: XOR<ContactTimelineEventCreateWithoutWaypointInput, ContactTimelineEventUncheckedCreateWithoutWaypointInput> | ContactTimelineEventCreateWithoutWaypointInput[] | ContactTimelineEventUncheckedCreateWithoutWaypointInput[]
    connectOrCreate?: ContactTimelineEventCreateOrConnectWithoutWaypointInput | ContactTimelineEventCreateOrConnectWithoutWaypointInput[]
    upsert?: ContactTimelineEventUpsertWithWhereUniqueWithoutWaypointInput | ContactTimelineEventUpsertWithWhereUniqueWithoutWaypointInput[]
    createMany?: ContactTimelineEventCreateManyWaypointInputEnvelope
    set?: ContactTimelineEventWhereUniqueInput | ContactTimelineEventWhereUniqueInput[]
    disconnect?: ContactTimelineEventWhereUniqueInput | ContactTimelineEventWhereUniqueInput[]
    delete?: ContactTimelineEventWhereUniqueInput | ContactTimelineEventWhereUniqueInput[]
    connect?: ContactTimelineEventWhereUniqueInput | ContactTimelineEventWhereUniqueInput[]
    update?: ContactTimelineEventUpdateWithWhereUniqueWithoutWaypointInput | ContactTimelineEventUpdateWithWhereUniqueWithoutWaypointInput[]
    updateMany?: ContactTimelineEventUpdateManyWithWhereWithoutWaypointInput | ContactTimelineEventUpdateManyWithWhereWithoutWaypointInput[]
    deleteMany?: ContactTimelineEventScalarWhereInput | ContactTimelineEventScalarWhereInput[]
  }

  export type TenetUpdateOneRequiredWithoutActivityWaypointsNestedInput = {
    create?: XOR<TenetCreateWithoutActivityWaypointsInput, TenetUncheckedCreateWithoutActivityWaypointsInput>
    connectOrCreate?: TenetCreateOrConnectWithoutActivityWaypointsInput
    upsert?: TenetUpsertWithoutActivityWaypointsInput
    connect?: TenetWhereUniqueInput
    update?: XOR<XOR<TenetUpdateToOneWithWhereWithoutActivityWaypointsInput, TenetUpdateWithoutActivityWaypointsInput>, TenetUncheckedUpdateWithoutActivityWaypointsInput>
  }

  export type NoteUpdateManyWithoutWaypointNestedInput = {
    create?: XOR<NoteCreateWithoutWaypointInput, NoteUncheckedCreateWithoutWaypointInput> | NoteCreateWithoutWaypointInput[] | NoteUncheckedCreateWithoutWaypointInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutWaypointInput | NoteCreateOrConnectWithoutWaypointInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutWaypointInput | NoteUpsertWithWhereUniqueWithoutWaypointInput[]
    createMany?: NoteCreateManyWaypointInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutWaypointInput | NoteUpdateWithWhereUniqueWithoutWaypointInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutWaypointInput | NoteUpdateManyWithWhereWithoutWaypointInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type UserWaypointJoinUncheckedUpdateManyWithoutWaypointRelationNestedInput = {
    create?: XOR<UserWaypointJoinCreateWithoutWaypointRelationInput, UserWaypointJoinUncheckedCreateWithoutWaypointRelationInput> | UserWaypointJoinCreateWithoutWaypointRelationInput[] | UserWaypointJoinUncheckedCreateWithoutWaypointRelationInput[]
    connectOrCreate?: UserWaypointJoinCreateOrConnectWithoutWaypointRelationInput | UserWaypointJoinCreateOrConnectWithoutWaypointRelationInput[]
    upsert?: UserWaypointJoinUpsertWithWhereUniqueWithoutWaypointRelationInput | UserWaypointJoinUpsertWithWhereUniqueWithoutWaypointRelationInput[]
    createMany?: UserWaypointJoinCreateManyWaypointRelationInputEnvelope
    set?: UserWaypointJoinWhereUniqueInput | UserWaypointJoinWhereUniqueInput[]
    disconnect?: UserWaypointJoinWhereUniqueInput | UserWaypointJoinWhereUniqueInput[]
    delete?: UserWaypointJoinWhereUniqueInput | UserWaypointJoinWhereUniqueInput[]
    connect?: UserWaypointJoinWhereUniqueInput | UserWaypointJoinWhereUniqueInput[]
    update?: UserWaypointJoinUpdateWithWhereUniqueWithoutWaypointRelationInput | UserWaypointJoinUpdateWithWhereUniqueWithoutWaypointRelationInput[]
    updateMany?: UserWaypointJoinUpdateManyWithWhereWithoutWaypointRelationInput | UserWaypointJoinUpdateManyWithWhereWithoutWaypointRelationInput[]
    deleteMany?: UserWaypointJoinScalarWhereInput | UserWaypointJoinScalarWhereInput[]
  }

  export type ActivityUncheckedUpdateManyWithoutParentWaypointNestedInput = {
    create?: XOR<ActivityCreateWithoutParentWaypointInput, ActivityUncheckedCreateWithoutParentWaypointInput> | ActivityCreateWithoutParentWaypointInput[] | ActivityUncheckedCreateWithoutParentWaypointInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutParentWaypointInput | ActivityCreateOrConnectWithoutParentWaypointInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutParentWaypointInput | ActivityUpsertWithWhereUniqueWithoutParentWaypointInput[]
    createMany?: ActivityCreateManyParentWaypointInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutParentWaypointInput | ActivityUpdateWithWhereUniqueWithoutParentWaypointInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutParentWaypointInput | ActivityUpdateManyWithWhereWithoutParentWaypointInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type ContactTimelineEventUncheckedUpdateManyWithoutWaypointNestedInput = {
    create?: XOR<ContactTimelineEventCreateWithoutWaypointInput, ContactTimelineEventUncheckedCreateWithoutWaypointInput> | ContactTimelineEventCreateWithoutWaypointInput[] | ContactTimelineEventUncheckedCreateWithoutWaypointInput[]
    connectOrCreate?: ContactTimelineEventCreateOrConnectWithoutWaypointInput | ContactTimelineEventCreateOrConnectWithoutWaypointInput[]
    upsert?: ContactTimelineEventUpsertWithWhereUniqueWithoutWaypointInput | ContactTimelineEventUpsertWithWhereUniqueWithoutWaypointInput[]
    createMany?: ContactTimelineEventCreateManyWaypointInputEnvelope
    set?: ContactTimelineEventWhereUniqueInput | ContactTimelineEventWhereUniqueInput[]
    disconnect?: ContactTimelineEventWhereUniqueInput | ContactTimelineEventWhereUniqueInput[]
    delete?: ContactTimelineEventWhereUniqueInput | ContactTimelineEventWhereUniqueInput[]
    connect?: ContactTimelineEventWhereUniqueInput | ContactTimelineEventWhereUniqueInput[]
    update?: ContactTimelineEventUpdateWithWhereUniqueWithoutWaypointInput | ContactTimelineEventUpdateWithWhereUniqueWithoutWaypointInput[]
    updateMany?: ContactTimelineEventUpdateManyWithWhereWithoutWaypointInput | ContactTimelineEventUpdateManyWithWhereWithoutWaypointInput[]
    deleteMany?: ContactTimelineEventScalarWhereInput | ContactTimelineEventScalarWhereInput[]
  }

  export type NoteUncheckedUpdateManyWithoutWaypointNestedInput = {
    create?: XOR<NoteCreateWithoutWaypointInput, NoteUncheckedCreateWithoutWaypointInput> | NoteCreateWithoutWaypointInput[] | NoteUncheckedCreateWithoutWaypointInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutWaypointInput | NoteCreateOrConnectWithoutWaypointInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutWaypointInput | NoteUpsertWithWhereUniqueWithoutWaypointInput[]
    createMany?: NoteCreateManyWaypointInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutWaypointInput | NoteUpdateWithWhereUniqueWithoutWaypointInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutWaypointInput | NoteUpdateManyWithWhereWithoutWaypointInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutTemplateAssignmentsInput = {
    create?: XOR<UserCreateWithoutTemplateAssignmentsInput, UserUncheckedCreateWithoutTemplateAssignmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTemplateAssignmentsInput
    connect?: UserWhereUniqueInput
  }

  export type ActivityTemplateCreateNestedOneWithoutAssignmentsInput = {
    create?: XOR<ActivityTemplateCreateWithoutAssignmentsInput, ActivityTemplateUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: ActivityTemplateCreateOrConnectWithoutAssignmentsInput
    connect?: ActivityTemplateWhereUniqueInput
  }

  export type ActivityWaypointTemplateCreateNestedOneWithoutAssignmentsInput = {
    create?: XOR<ActivityWaypointTemplateCreateWithoutAssignmentsInput, ActivityWaypointTemplateUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: ActivityWaypointTemplateCreateOrConnectWithoutAssignmentsInput
    connect?: ActivityWaypointTemplateWhereUniqueInput
  }

  export type TenetCreateNestedOneWithoutTemplateAssignmentsInput = {
    create?: XOR<TenetCreateWithoutTemplateAssignmentsInput, TenetUncheckedCreateWithoutTemplateAssignmentsInput>
    connectOrCreate?: TenetCreateOrConnectWithoutTemplateAssignmentsInput
    connect?: TenetWhereUniqueInput
  }

  export type NullableEnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role | null
  }

  export type UserUpdateOneWithoutTemplateAssignmentsNestedInput = {
    create?: XOR<UserCreateWithoutTemplateAssignmentsInput, UserUncheckedCreateWithoutTemplateAssignmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTemplateAssignmentsInput
    upsert?: UserUpsertWithoutTemplateAssignmentsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTemplateAssignmentsInput, UserUpdateWithoutTemplateAssignmentsInput>, UserUncheckedUpdateWithoutTemplateAssignmentsInput>
  }

  export type ActivityTemplateUpdateOneWithoutAssignmentsNestedInput = {
    create?: XOR<ActivityTemplateCreateWithoutAssignmentsInput, ActivityTemplateUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: ActivityTemplateCreateOrConnectWithoutAssignmentsInput
    upsert?: ActivityTemplateUpsertWithoutAssignmentsInput
    disconnect?: ActivityTemplateWhereInput | boolean
    delete?: ActivityTemplateWhereInput | boolean
    connect?: ActivityTemplateWhereUniqueInput
    update?: XOR<XOR<ActivityTemplateUpdateToOneWithWhereWithoutAssignmentsInput, ActivityTemplateUpdateWithoutAssignmentsInput>, ActivityTemplateUncheckedUpdateWithoutAssignmentsInput>
  }

  export type ActivityWaypointTemplateUpdateOneWithoutAssignmentsNestedInput = {
    create?: XOR<ActivityWaypointTemplateCreateWithoutAssignmentsInput, ActivityWaypointTemplateUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: ActivityWaypointTemplateCreateOrConnectWithoutAssignmentsInput
    upsert?: ActivityWaypointTemplateUpsertWithoutAssignmentsInput
    disconnect?: ActivityWaypointTemplateWhereInput | boolean
    delete?: ActivityWaypointTemplateWhereInput | boolean
    connect?: ActivityWaypointTemplateWhereUniqueInput
    update?: XOR<XOR<ActivityWaypointTemplateUpdateToOneWithWhereWithoutAssignmentsInput, ActivityWaypointTemplateUpdateWithoutAssignmentsInput>, ActivityWaypointTemplateUncheckedUpdateWithoutAssignmentsInput>
  }

  export type TenetUpdateOneRequiredWithoutTemplateAssignmentsNestedInput = {
    create?: XOR<TenetCreateWithoutTemplateAssignmentsInput, TenetUncheckedCreateWithoutTemplateAssignmentsInput>
    connectOrCreate?: TenetCreateOrConnectWithoutTemplateAssignmentsInput
    upsert?: TenetUpsertWithoutTemplateAssignmentsInput
    connect?: TenetWhereUniqueInput
    update?: XOR<XOR<TenetUpdateToOneWithWhereWithoutTemplateAssignmentsInput, TenetUpdateWithoutTemplateAssignmentsInput>, TenetUncheckedUpdateWithoutTemplateAssignmentsInput>
  }

  export type ActivityTemplateCreateNestedOneWithoutWaypointsInput = {
    create?: XOR<ActivityTemplateCreateWithoutWaypointsInput, ActivityTemplateUncheckedCreateWithoutWaypointsInput>
    connectOrCreate?: ActivityTemplateCreateOrConnectWithoutWaypointsInput
    connect?: ActivityTemplateWhereUniqueInput
  }

  export type ActivityTemplateCreateNestedManyWithoutParentWaypointInput = {
    create?: XOR<ActivityTemplateCreateWithoutParentWaypointInput, ActivityTemplateUncheckedCreateWithoutParentWaypointInput> | ActivityTemplateCreateWithoutParentWaypointInput[] | ActivityTemplateUncheckedCreateWithoutParentWaypointInput[]
    connectOrCreate?: ActivityTemplateCreateOrConnectWithoutParentWaypointInput | ActivityTemplateCreateOrConnectWithoutParentWaypointInput[]
    createMany?: ActivityTemplateCreateManyParentWaypointInputEnvelope
    connect?: ActivityTemplateWhereUniqueInput | ActivityTemplateWhereUniqueInput[]
  }

  export type ActivityWaypointCreateNestedManyWithoutTemplateInput = {
    create?: XOR<ActivityWaypointCreateWithoutTemplateInput, ActivityWaypointUncheckedCreateWithoutTemplateInput> | ActivityWaypointCreateWithoutTemplateInput[] | ActivityWaypointUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: ActivityWaypointCreateOrConnectWithoutTemplateInput | ActivityWaypointCreateOrConnectWithoutTemplateInput[]
    createMany?: ActivityWaypointCreateManyTemplateInputEnvelope
    connect?: ActivityWaypointWhereUniqueInput | ActivityWaypointWhereUniqueInput[]
  }

  export type TemplateAssignmentCreateNestedManyWithoutWaypointTemplateInput = {
    create?: XOR<TemplateAssignmentCreateWithoutWaypointTemplateInput, TemplateAssignmentUncheckedCreateWithoutWaypointTemplateInput> | TemplateAssignmentCreateWithoutWaypointTemplateInput[] | TemplateAssignmentUncheckedCreateWithoutWaypointTemplateInput[]
    connectOrCreate?: TemplateAssignmentCreateOrConnectWithoutWaypointTemplateInput | TemplateAssignmentCreateOrConnectWithoutWaypointTemplateInput[]
    createMany?: TemplateAssignmentCreateManyWaypointTemplateInputEnvelope
    connect?: TemplateAssignmentWhereUniqueInput | TemplateAssignmentWhereUniqueInput[]
  }

  export type TenetCreateNestedOneWithoutActivityWaypointTemplatesInput = {
    create?: XOR<TenetCreateWithoutActivityWaypointTemplatesInput, TenetUncheckedCreateWithoutActivityWaypointTemplatesInput>
    connectOrCreate?: TenetCreateOrConnectWithoutActivityWaypointTemplatesInput
    connect?: TenetWhereUniqueInput
  }

  export type ActivityTemplateUncheckedCreateNestedManyWithoutParentWaypointInput = {
    create?: XOR<ActivityTemplateCreateWithoutParentWaypointInput, ActivityTemplateUncheckedCreateWithoutParentWaypointInput> | ActivityTemplateCreateWithoutParentWaypointInput[] | ActivityTemplateUncheckedCreateWithoutParentWaypointInput[]
    connectOrCreate?: ActivityTemplateCreateOrConnectWithoutParentWaypointInput | ActivityTemplateCreateOrConnectWithoutParentWaypointInput[]
    createMany?: ActivityTemplateCreateManyParentWaypointInputEnvelope
    connect?: ActivityTemplateWhereUniqueInput | ActivityTemplateWhereUniqueInput[]
  }

  export type ActivityWaypointUncheckedCreateNestedManyWithoutTemplateInput = {
    create?: XOR<ActivityWaypointCreateWithoutTemplateInput, ActivityWaypointUncheckedCreateWithoutTemplateInput> | ActivityWaypointCreateWithoutTemplateInput[] | ActivityWaypointUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: ActivityWaypointCreateOrConnectWithoutTemplateInput | ActivityWaypointCreateOrConnectWithoutTemplateInput[]
    createMany?: ActivityWaypointCreateManyTemplateInputEnvelope
    connect?: ActivityWaypointWhereUniqueInput | ActivityWaypointWhereUniqueInput[]
  }

  export type TemplateAssignmentUncheckedCreateNestedManyWithoutWaypointTemplateInput = {
    create?: XOR<TemplateAssignmentCreateWithoutWaypointTemplateInput, TemplateAssignmentUncheckedCreateWithoutWaypointTemplateInput> | TemplateAssignmentCreateWithoutWaypointTemplateInput[] | TemplateAssignmentUncheckedCreateWithoutWaypointTemplateInput[]
    connectOrCreate?: TemplateAssignmentCreateOrConnectWithoutWaypointTemplateInput | TemplateAssignmentCreateOrConnectWithoutWaypointTemplateInput[]
    createMany?: TemplateAssignmentCreateManyWaypointTemplateInputEnvelope
    connect?: TemplateAssignmentWhereUniqueInput | TemplateAssignmentWhereUniqueInput[]
  }

  export type EnumDateOffsetTypeFieldUpdateOperationsInput = {
    set?: $Enums.DateOffsetType
  }

  export type ActivityTemplateUpdateOneRequiredWithoutWaypointsNestedInput = {
    create?: XOR<ActivityTemplateCreateWithoutWaypointsInput, ActivityTemplateUncheckedCreateWithoutWaypointsInput>
    connectOrCreate?: ActivityTemplateCreateOrConnectWithoutWaypointsInput
    upsert?: ActivityTemplateUpsertWithoutWaypointsInput
    connect?: ActivityTemplateWhereUniqueInput
    update?: XOR<XOR<ActivityTemplateUpdateToOneWithWhereWithoutWaypointsInput, ActivityTemplateUpdateWithoutWaypointsInput>, ActivityTemplateUncheckedUpdateWithoutWaypointsInput>
  }

  export type ActivityTemplateUpdateManyWithoutParentWaypointNestedInput = {
    create?: XOR<ActivityTemplateCreateWithoutParentWaypointInput, ActivityTemplateUncheckedCreateWithoutParentWaypointInput> | ActivityTemplateCreateWithoutParentWaypointInput[] | ActivityTemplateUncheckedCreateWithoutParentWaypointInput[]
    connectOrCreate?: ActivityTemplateCreateOrConnectWithoutParentWaypointInput | ActivityTemplateCreateOrConnectWithoutParentWaypointInput[]
    upsert?: ActivityTemplateUpsertWithWhereUniqueWithoutParentWaypointInput | ActivityTemplateUpsertWithWhereUniqueWithoutParentWaypointInput[]
    createMany?: ActivityTemplateCreateManyParentWaypointInputEnvelope
    set?: ActivityTemplateWhereUniqueInput | ActivityTemplateWhereUniqueInput[]
    disconnect?: ActivityTemplateWhereUniqueInput | ActivityTemplateWhereUniqueInput[]
    delete?: ActivityTemplateWhereUniqueInput | ActivityTemplateWhereUniqueInput[]
    connect?: ActivityTemplateWhereUniqueInput | ActivityTemplateWhereUniqueInput[]
    update?: ActivityTemplateUpdateWithWhereUniqueWithoutParentWaypointInput | ActivityTemplateUpdateWithWhereUniqueWithoutParentWaypointInput[]
    updateMany?: ActivityTemplateUpdateManyWithWhereWithoutParentWaypointInput | ActivityTemplateUpdateManyWithWhereWithoutParentWaypointInput[]
    deleteMany?: ActivityTemplateScalarWhereInput | ActivityTemplateScalarWhereInput[]
  }

  export type ActivityWaypointUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<ActivityWaypointCreateWithoutTemplateInput, ActivityWaypointUncheckedCreateWithoutTemplateInput> | ActivityWaypointCreateWithoutTemplateInput[] | ActivityWaypointUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: ActivityWaypointCreateOrConnectWithoutTemplateInput | ActivityWaypointCreateOrConnectWithoutTemplateInput[]
    upsert?: ActivityWaypointUpsertWithWhereUniqueWithoutTemplateInput | ActivityWaypointUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: ActivityWaypointCreateManyTemplateInputEnvelope
    set?: ActivityWaypointWhereUniqueInput | ActivityWaypointWhereUniqueInput[]
    disconnect?: ActivityWaypointWhereUniqueInput | ActivityWaypointWhereUniqueInput[]
    delete?: ActivityWaypointWhereUniqueInput | ActivityWaypointWhereUniqueInput[]
    connect?: ActivityWaypointWhereUniqueInput | ActivityWaypointWhereUniqueInput[]
    update?: ActivityWaypointUpdateWithWhereUniqueWithoutTemplateInput | ActivityWaypointUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: ActivityWaypointUpdateManyWithWhereWithoutTemplateInput | ActivityWaypointUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: ActivityWaypointScalarWhereInput | ActivityWaypointScalarWhereInput[]
  }

  export type TemplateAssignmentUpdateManyWithoutWaypointTemplateNestedInput = {
    create?: XOR<TemplateAssignmentCreateWithoutWaypointTemplateInput, TemplateAssignmentUncheckedCreateWithoutWaypointTemplateInput> | TemplateAssignmentCreateWithoutWaypointTemplateInput[] | TemplateAssignmentUncheckedCreateWithoutWaypointTemplateInput[]
    connectOrCreate?: TemplateAssignmentCreateOrConnectWithoutWaypointTemplateInput | TemplateAssignmentCreateOrConnectWithoutWaypointTemplateInput[]
    upsert?: TemplateAssignmentUpsertWithWhereUniqueWithoutWaypointTemplateInput | TemplateAssignmentUpsertWithWhereUniqueWithoutWaypointTemplateInput[]
    createMany?: TemplateAssignmentCreateManyWaypointTemplateInputEnvelope
    set?: TemplateAssignmentWhereUniqueInput | TemplateAssignmentWhereUniqueInput[]
    disconnect?: TemplateAssignmentWhereUniqueInput | TemplateAssignmentWhereUniqueInput[]
    delete?: TemplateAssignmentWhereUniqueInput | TemplateAssignmentWhereUniqueInput[]
    connect?: TemplateAssignmentWhereUniqueInput | TemplateAssignmentWhereUniqueInput[]
    update?: TemplateAssignmentUpdateWithWhereUniqueWithoutWaypointTemplateInput | TemplateAssignmentUpdateWithWhereUniqueWithoutWaypointTemplateInput[]
    updateMany?: TemplateAssignmentUpdateManyWithWhereWithoutWaypointTemplateInput | TemplateAssignmentUpdateManyWithWhereWithoutWaypointTemplateInput[]
    deleteMany?: TemplateAssignmentScalarWhereInput | TemplateAssignmentScalarWhereInput[]
  }

  export type TenetUpdateOneRequiredWithoutActivityWaypointTemplatesNestedInput = {
    create?: XOR<TenetCreateWithoutActivityWaypointTemplatesInput, TenetUncheckedCreateWithoutActivityWaypointTemplatesInput>
    connectOrCreate?: TenetCreateOrConnectWithoutActivityWaypointTemplatesInput
    upsert?: TenetUpsertWithoutActivityWaypointTemplatesInput
    connect?: TenetWhereUniqueInput
    update?: XOR<XOR<TenetUpdateToOneWithWhereWithoutActivityWaypointTemplatesInput, TenetUpdateWithoutActivityWaypointTemplatesInput>, TenetUncheckedUpdateWithoutActivityWaypointTemplatesInput>
  }

  export type ActivityTemplateUncheckedUpdateManyWithoutParentWaypointNestedInput = {
    create?: XOR<ActivityTemplateCreateWithoutParentWaypointInput, ActivityTemplateUncheckedCreateWithoutParentWaypointInput> | ActivityTemplateCreateWithoutParentWaypointInput[] | ActivityTemplateUncheckedCreateWithoutParentWaypointInput[]
    connectOrCreate?: ActivityTemplateCreateOrConnectWithoutParentWaypointInput | ActivityTemplateCreateOrConnectWithoutParentWaypointInput[]
    upsert?: ActivityTemplateUpsertWithWhereUniqueWithoutParentWaypointInput | ActivityTemplateUpsertWithWhereUniqueWithoutParentWaypointInput[]
    createMany?: ActivityTemplateCreateManyParentWaypointInputEnvelope
    set?: ActivityTemplateWhereUniqueInput | ActivityTemplateWhereUniqueInput[]
    disconnect?: ActivityTemplateWhereUniqueInput | ActivityTemplateWhereUniqueInput[]
    delete?: ActivityTemplateWhereUniqueInput | ActivityTemplateWhereUniqueInput[]
    connect?: ActivityTemplateWhereUniqueInput | ActivityTemplateWhereUniqueInput[]
    update?: ActivityTemplateUpdateWithWhereUniqueWithoutParentWaypointInput | ActivityTemplateUpdateWithWhereUniqueWithoutParentWaypointInput[]
    updateMany?: ActivityTemplateUpdateManyWithWhereWithoutParentWaypointInput | ActivityTemplateUpdateManyWithWhereWithoutParentWaypointInput[]
    deleteMany?: ActivityTemplateScalarWhereInput | ActivityTemplateScalarWhereInput[]
  }

  export type ActivityWaypointUncheckedUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<ActivityWaypointCreateWithoutTemplateInput, ActivityWaypointUncheckedCreateWithoutTemplateInput> | ActivityWaypointCreateWithoutTemplateInput[] | ActivityWaypointUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: ActivityWaypointCreateOrConnectWithoutTemplateInput | ActivityWaypointCreateOrConnectWithoutTemplateInput[]
    upsert?: ActivityWaypointUpsertWithWhereUniqueWithoutTemplateInput | ActivityWaypointUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: ActivityWaypointCreateManyTemplateInputEnvelope
    set?: ActivityWaypointWhereUniqueInput | ActivityWaypointWhereUniqueInput[]
    disconnect?: ActivityWaypointWhereUniqueInput | ActivityWaypointWhereUniqueInput[]
    delete?: ActivityWaypointWhereUniqueInput | ActivityWaypointWhereUniqueInput[]
    connect?: ActivityWaypointWhereUniqueInput | ActivityWaypointWhereUniqueInput[]
    update?: ActivityWaypointUpdateWithWhereUniqueWithoutTemplateInput | ActivityWaypointUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: ActivityWaypointUpdateManyWithWhereWithoutTemplateInput | ActivityWaypointUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: ActivityWaypointScalarWhereInput | ActivityWaypointScalarWhereInput[]
  }

  export type TemplateAssignmentUncheckedUpdateManyWithoutWaypointTemplateNestedInput = {
    create?: XOR<TemplateAssignmentCreateWithoutWaypointTemplateInput, TemplateAssignmentUncheckedCreateWithoutWaypointTemplateInput> | TemplateAssignmentCreateWithoutWaypointTemplateInput[] | TemplateAssignmentUncheckedCreateWithoutWaypointTemplateInput[]
    connectOrCreate?: TemplateAssignmentCreateOrConnectWithoutWaypointTemplateInput | TemplateAssignmentCreateOrConnectWithoutWaypointTemplateInput[]
    upsert?: TemplateAssignmentUpsertWithWhereUniqueWithoutWaypointTemplateInput | TemplateAssignmentUpsertWithWhereUniqueWithoutWaypointTemplateInput[]
    createMany?: TemplateAssignmentCreateManyWaypointTemplateInputEnvelope
    set?: TemplateAssignmentWhereUniqueInput | TemplateAssignmentWhereUniqueInput[]
    disconnect?: TemplateAssignmentWhereUniqueInput | TemplateAssignmentWhereUniqueInput[]
    delete?: TemplateAssignmentWhereUniqueInput | TemplateAssignmentWhereUniqueInput[]
    connect?: TemplateAssignmentWhereUniqueInput | TemplateAssignmentWhereUniqueInput[]
    update?: TemplateAssignmentUpdateWithWhereUniqueWithoutWaypointTemplateInput | TemplateAssignmentUpdateWithWhereUniqueWithoutWaypointTemplateInput[]
    updateMany?: TemplateAssignmentUpdateManyWithWhereWithoutWaypointTemplateInput | TemplateAssignmentUpdateManyWithWhereWithoutWaypointTemplateInput[]
    deleteMany?: TemplateAssignmentScalarWhereInput | TemplateAssignmentScalarWhereInput[]
  }

  export type ActivityTemplateCreateNestedOneWithoutStepsInput = {
    create?: XOR<ActivityTemplateCreateWithoutStepsInput, ActivityTemplateUncheckedCreateWithoutStepsInput>
    connectOrCreate?: ActivityTemplateCreateOrConnectWithoutStepsInput
    connect?: ActivityTemplateWhereUniqueInput
  }

  export type TenetCreateNestedOneWithoutActivityTemplateStepsInput = {
    create?: XOR<TenetCreateWithoutActivityTemplateStepsInput, TenetUncheckedCreateWithoutActivityTemplateStepsInput>
    connectOrCreate?: TenetCreateOrConnectWithoutActivityTemplateStepsInput
    connect?: TenetWhereUniqueInput
  }

  export type ActivityTemplateStepAssignmentCreateNestedManyWithoutActivityTemplateStepInput = {
    create?: XOR<ActivityTemplateStepAssignmentCreateWithoutActivityTemplateStepInput, ActivityTemplateStepAssignmentUncheckedCreateWithoutActivityTemplateStepInput> | ActivityTemplateStepAssignmentCreateWithoutActivityTemplateStepInput[] | ActivityTemplateStepAssignmentUncheckedCreateWithoutActivityTemplateStepInput[]
    connectOrCreate?: ActivityTemplateStepAssignmentCreateOrConnectWithoutActivityTemplateStepInput | ActivityTemplateStepAssignmentCreateOrConnectWithoutActivityTemplateStepInput[]
    createMany?: ActivityTemplateStepAssignmentCreateManyActivityTemplateStepInputEnvelope
    connect?: ActivityTemplateStepAssignmentWhereUniqueInput | ActivityTemplateStepAssignmentWhereUniqueInput[]
  }

  export type ActivityTemplateStepAssignmentUncheckedCreateNestedManyWithoutActivityTemplateStepInput = {
    create?: XOR<ActivityTemplateStepAssignmentCreateWithoutActivityTemplateStepInput, ActivityTemplateStepAssignmentUncheckedCreateWithoutActivityTemplateStepInput> | ActivityTemplateStepAssignmentCreateWithoutActivityTemplateStepInput[] | ActivityTemplateStepAssignmentUncheckedCreateWithoutActivityTemplateStepInput[]
    connectOrCreate?: ActivityTemplateStepAssignmentCreateOrConnectWithoutActivityTemplateStepInput | ActivityTemplateStepAssignmentCreateOrConnectWithoutActivityTemplateStepInput[]
    createMany?: ActivityTemplateStepAssignmentCreateManyActivityTemplateStepInputEnvelope
    connect?: ActivityTemplateStepAssignmentWhereUniqueInput | ActivityTemplateStepAssignmentWhereUniqueInput[]
  }

  export type ActivityTemplateUpdateOneRequiredWithoutStepsNestedInput = {
    create?: XOR<ActivityTemplateCreateWithoutStepsInput, ActivityTemplateUncheckedCreateWithoutStepsInput>
    connectOrCreate?: ActivityTemplateCreateOrConnectWithoutStepsInput
    upsert?: ActivityTemplateUpsertWithoutStepsInput
    connect?: ActivityTemplateWhereUniqueInput
    update?: XOR<XOR<ActivityTemplateUpdateToOneWithWhereWithoutStepsInput, ActivityTemplateUpdateWithoutStepsInput>, ActivityTemplateUncheckedUpdateWithoutStepsInput>
  }

  export type TenetUpdateOneRequiredWithoutActivityTemplateStepsNestedInput = {
    create?: XOR<TenetCreateWithoutActivityTemplateStepsInput, TenetUncheckedCreateWithoutActivityTemplateStepsInput>
    connectOrCreate?: TenetCreateOrConnectWithoutActivityTemplateStepsInput
    upsert?: TenetUpsertWithoutActivityTemplateStepsInput
    connect?: TenetWhereUniqueInput
    update?: XOR<XOR<TenetUpdateToOneWithWhereWithoutActivityTemplateStepsInput, TenetUpdateWithoutActivityTemplateStepsInput>, TenetUncheckedUpdateWithoutActivityTemplateStepsInput>
  }

  export type ActivityTemplateStepAssignmentUpdateManyWithoutActivityTemplateStepNestedInput = {
    create?: XOR<ActivityTemplateStepAssignmentCreateWithoutActivityTemplateStepInput, ActivityTemplateStepAssignmentUncheckedCreateWithoutActivityTemplateStepInput> | ActivityTemplateStepAssignmentCreateWithoutActivityTemplateStepInput[] | ActivityTemplateStepAssignmentUncheckedCreateWithoutActivityTemplateStepInput[]
    connectOrCreate?: ActivityTemplateStepAssignmentCreateOrConnectWithoutActivityTemplateStepInput | ActivityTemplateStepAssignmentCreateOrConnectWithoutActivityTemplateStepInput[]
    upsert?: ActivityTemplateStepAssignmentUpsertWithWhereUniqueWithoutActivityTemplateStepInput | ActivityTemplateStepAssignmentUpsertWithWhereUniqueWithoutActivityTemplateStepInput[]
    createMany?: ActivityTemplateStepAssignmentCreateManyActivityTemplateStepInputEnvelope
    set?: ActivityTemplateStepAssignmentWhereUniqueInput | ActivityTemplateStepAssignmentWhereUniqueInput[]
    disconnect?: ActivityTemplateStepAssignmentWhereUniqueInput | ActivityTemplateStepAssignmentWhereUniqueInput[]
    delete?: ActivityTemplateStepAssignmentWhereUniqueInput | ActivityTemplateStepAssignmentWhereUniqueInput[]
    connect?: ActivityTemplateStepAssignmentWhereUniqueInput | ActivityTemplateStepAssignmentWhereUniqueInput[]
    update?: ActivityTemplateStepAssignmentUpdateWithWhereUniqueWithoutActivityTemplateStepInput | ActivityTemplateStepAssignmentUpdateWithWhereUniqueWithoutActivityTemplateStepInput[]
    updateMany?: ActivityTemplateStepAssignmentUpdateManyWithWhereWithoutActivityTemplateStepInput | ActivityTemplateStepAssignmentUpdateManyWithWhereWithoutActivityTemplateStepInput[]
    deleteMany?: ActivityTemplateStepAssignmentScalarWhereInput | ActivityTemplateStepAssignmentScalarWhereInput[]
  }

  export type ActivityTemplateStepAssignmentUncheckedUpdateManyWithoutActivityTemplateStepNestedInput = {
    create?: XOR<ActivityTemplateStepAssignmentCreateWithoutActivityTemplateStepInput, ActivityTemplateStepAssignmentUncheckedCreateWithoutActivityTemplateStepInput> | ActivityTemplateStepAssignmentCreateWithoutActivityTemplateStepInput[] | ActivityTemplateStepAssignmentUncheckedCreateWithoutActivityTemplateStepInput[]
    connectOrCreate?: ActivityTemplateStepAssignmentCreateOrConnectWithoutActivityTemplateStepInput | ActivityTemplateStepAssignmentCreateOrConnectWithoutActivityTemplateStepInput[]
    upsert?: ActivityTemplateStepAssignmentUpsertWithWhereUniqueWithoutActivityTemplateStepInput | ActivityTemplateStepAssignmentUpsertWithWhereUniqueWithoutActivityTemplateStepInput[]
    createMany?: ActivityTemplateStepAssignmentCreateManyActivityTemplateStepInputEnvelope
    set?: ActivityTemplateStepAssignmentWhereUniqueInput | ActivityTemplateStepAssignmentWhereUniqueInput[]
    disconnect?: ActivityTemplateStepAssignmentWhereUniqueInput | ActivityTemplateStepAssignmentWhereUniqueInput[]
    delete?: ActivityTemplateStepAssignmentWhereUniqueInput | ActivityTemplateStepAssignmentWhereUniqueInput[]
    connect?: ActivityTemplateStepAssignmentWhereUniqueInput | ActivityTemplateStepAssignmentWhereUniqueInput[]
    update?: ActivityTemplateStepAssignmentUpdateWithWhereUniqueWithoutActivityTemplateStepInput | ActivityTemplateStepAssignmentUpdateWithWhereUniqueWithoutActivityTemplateStepInput[]
    updateMany?: ActivityTemplateStepAssignmentUpdateManyWithWhereWithoutActivityTemplateStepInput | ActivityTemplateStepAssignmentUpdateManyWithWhereWithoutActivityTemplateStepInput[]
    deleteMany?: ActivityTemplateStepAssignmentScalarWhereInput | ActivityTemplateStepAssignmentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutTemplateStepAssignmentsInput = {
    create?: XOR<UserCreateWithoutTemplateStepAssignmentsInput, UserUncheckedCreateWithoutTemplateStepAssignmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTemplateStepAssignmentsInput
    connect?: UserWhereUniqueInput
  }

  export type ActivityTemplateStepCreateNestedOneWithoutAssignedToInput = {
    create?: XOR<ActivityTemplateStepCreateWithoutAssignedToInput, ActivityTemplateStepUncheckedCreateWithoutAssignedToInput>
    connectOrCreate?: ActivityTemplateStepCreateOrConnectWithoutAssignedToInput
    connect?: ActivityTemplateStepWhereUniqueInput
  }

  export type TenetCreateNestedOneWithoutActivityTemplateStepAssignmentInput = {
    create?: XOR<TenetCreateWithoutActivityTemplateStepAssignmentInput, TenetUncheckedCreateWithoutActivityTemplateStepAssignmentInput>
    connectOrCreate?: TenetCreateOrConnectWithoutActivityTemplateStepAssignmentInput
    connect?: TenetWhereUniqueInput
  }

  export type UserUpdateOneWithoutTemplateStepAssignmentsNestedInput = {
    create?: XOR<UserCreateWithoutTemplateStepAssignmentsInput, UserUncheckedCreateWithoutTemplateStepAssignmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTemplateStepAssignmentsInput
    upsert?: UserUpsertWithoutTemplateStepAssignmentsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTemplateStepAssignmentsInput, UserUpdateWithoutTemplateStepAssignmentsInput>, UserUncheckedUpdateWithoutTemplateStepAssignmentsInput>
  }

  export type ActivityTemplateStepUpdateOneRequiredWithoutAssignedToNestedInput = {
    create?: XOR<ActivityTemplateStepCreateWithoutAssignedToInput, ActivityTemplateStepUncheckedCreateWithoutAssignedToInput>
    connectOrCreate?: ActivityTemplateStepCreateOrConnectWithoutAssignedToInput
    upsert?: ActivityTemplateStepUpsertWithoutAssignedToInput
    connect?: ActivityTemplateStepWhereUniqueInput
    update?: XOR<XOR<ActivityTemplateStepUpdateToOneWithWhereWithoutAssignedToInput, ActivityTemplateStepUpdateWithoutAssignedToInput>, ActivityTemplateStepUncheckedUpdateWithoutAssignedToInput>
  }

  export type TenetUpdateOneRequiredWithoutActivityTemplateStepAssignmentNestedInput = {
    create?: XOR<TenetCreateWithoutActivityTemplateStepAssignmentInput, TenetUncheckedCreateWithoutActivityTemplateStepAssignmentInput>
    connectOrCreate?: TenetCreateOrConnectWithoutActivityTemplateStepAssignmentInput
    upsert?: TenetUpsertWithoutActivityTemplateStepAssignmentInput
    connect?: TenetWhereUniqueInput
    update?: XOR<XOR<TenetUpdateToOneWithWhereWithoutActivityTemplateStepAssignmentInput, TenetUpdateWithoutActivityTemplateStepAssignmentInput>, TenetUncheckedUpdateWithoutActivityTemplateStepAssignmentInput>
  }

  export type ActivityTemplateStepCreateNestedManyWithoutActivityTemplateInput = {
    create?: XOR<ActivityTemplateStepCreateWithoutActivityTemplateInput, ActivityTemplateStepUncheckedCreateWithoutActivityTemplateInput> | ActivityTemplateStepCreateWithoutActivityTemplateInput[] | ActivityTemplateStepUncheckedCreateWithoutActivityTemplateInput[]
    connectOrCreate?: ActivityTemplateStepCreateOrConnectWithoutActivityTemplateInput | ActivityTemplateStepCreateOrConnectWithoutActivityTemplateInput[]
    createMany?: ActivityTemplateStepCreateManyActivityTemplateInputEnvelope
    connect?: ActivityTemplateStepWhereUniqueInput | ActivityTemplateStepWhereUniqueInput[]
  }

  export type ActivityTemplateCreateNestedOneWithoutDependentsInput = {
    create?: XOR<ActivityTemplateCreateWithoutDependentsInput, ActivityTemplateUncheckedCreateWithoutDependentsInput>
    connectOrCreate?: ActivityTemplateCreateOrConnectWithoutDependentsInput
    connect?: ActivityTemplateWhereUniqueInput
  }

  export type ActivityTemplateCreateNestedManyWithoutStartRelativeToInput = {
    create?: XOR<ActivityTemplateCreateWithoutStartRelativeToInput, ActivityTemplateUncheckedCreateWithoutStartRelativeToInput> | ActivityTemplateCreateWithoutStartRelativeToInput[] | ActivityTemplateUncheckedCreateWithoutStartRelativeToInput[]
    connectOrCreate?: ActivityTemplateCreateOrConnectWithoutStartRelativeToInput | ActivityTemplateCreateOrConnectWithoutStartRelativeToInput[]
    createMany?: ActivityTemplateCreateManyStartRelativeToInputEnvelope
    connect?: ActivityTemplateWhereUniqueInput | ActivityTemplateWhereUniqueInput[]
  }

  export type ActivityWaypointTemplateCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<ActivityWaypointTemplateCreateWithoutActivitiesInput, ActivityWaypointTemplateUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: ActivityWaypointTemplateCreateOrConnectWithoutActivitiesInput
    connect?: ActivityWaypointTemplateWhereUniqueInput
  }

  export type ActivityTemplateCreateNestedOneWithoutChildActivitiesInput = {
    create?: XOR<ActivityTemplateCreateWithoutChildActivitiesInput, ActivityTemplateUncheckedCreateWithoutChildActivitiesInput>
    connectOrCreate?: ActivityTemplateCreateOrConnectWithoutChildActivitiesInput
    connect?: ActivityTemplateWhereUniqueInput
  }

  export type ActivityWaypointTemplateCreateNestedManyWithoutParentActivityInput = {
    create?: XOR<ActivityWaypointTemplateCreateWithoutParentActivityInput, ActivityWaypointTemplateUncheckedCreateWithoutParentActivityInput> | ActivityWaypointTemplateCreateWithoutParentActivityInput[] | ActivityWaypointTemplateUncheckedCreateWithoutParentActivityInput[]
    connectOrCreate?: ActivityWaypointTemplateCreateOrConnectWithoutParentActivityInput | ActivityWaypointTemplateCreateOrConnectWithoutParentActivityInput[]
    createMany?: ActivityWaypointTemplateCreateManyParentActivityInputEnvelope
    connect?: ActivityWaypointTemplateWhereUniqueInput | ActivityWaypointTemplateWhereUniqueInput[]
  }

  export type ActivityTemplateCreateNestedManyWithoutParentActivityInput = {
    create?: XOR<ActivityTemplateCreateWithoutParentActivityInput, ActivityTemplateUncheckedCreateWithoutParentActivityInput> | ActivityTemplateCreateWithoutParentActivityInput[] | ActivityTemplateUncheckedCreateWithoutParentActivityInput[]
    connectOrCreate?: ActivityTemplateCreateOrConnectWithoutParentActivityInput | ActivityTemplateCreateOrConnectWithoutParentActivityInput[]
    createMany?: ActivityTemplateCreateManyParentActivityInputEnvelope
    connect?: ActivityTemplateWhereUniqueInput | ActivityTemplateWhereUniqueInput[]
  }

  export type ActivityCreateNestedManyWithoutTemplateInput = {
    create?: XOR<ActivityCreateWithoutTemplateInput, ActivityUncheckedCreateWithoutTemplateInput> | ActivityCreateWithoutTemplateInput[] | ActivityUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutTemplateInput | ActivityCreateOrConnectWithoutTemplateInput[]
    createMany?: ActivityCreateManyTemplateInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type TemplateAssignmentCreateNestedManyWithoutActivityTemplateInput = {
    create?: XOR<TemplateAssignmentCreateWithoutActivityTemplateInput, TemplateAssignmentUncheckedCreateWithoutActivityTemplateInput> | TemplateAssignmentCreateWithoutActivityTemplateInput[] | TemplateAssignmentUncheckedCreateWithoutActivityTemplateInput[]
    connectOrCreate?: TemplateAssignmentCreateOrConnectWithoutActivityTemplateInput | TemplateAssignmentCreateOrConnectWithoutActivityTemplateInput[]
    createMany?: TemplateAssignmentCreateManyActivityTemplateInputEnvelope
    connect?: TemplateAssignmentWhereUniqueInput | TemplateAssignmentWhereUniqueInput[]
  }

  export type TenetCreateNestedOneWithoutActivityTemplatesInput = {
    create?: XOR<TenetCreateWithoutActivityTemplatesInput, TenetUncheckedCreateWithoutActivityTemplatesInput>
    connectOrCreate?: TenetCreateOrConnectWithoutActivityTemplatesInput
    connect?: TenetWhereUniqueInput
  }

  export type ActivityTemplateStepUncheckedCreateNestedManyWithoutActivityTemplateInput = {
    create?: XOR<ActivityTemplateStepCreateWithoutActivityTemplateInput, ActivityTemplateStepUncheckedCreateWithoutActivityTemplateInput> | ActivityTemplateStepCreateWithoutActivityTemplateInput[] | ActivityTemplateStepUncheckedCreateWithoutActivityTemplateInput[]
    connectOrCreate?: ActivityTemplateStepCreateOrConnectWithoutActivityTemplateInput | ActivityTemplateStepCreateOrConnectWithoutActivityTemplateInput[]
    createMany?: ActivityTemplateStepCreateManyActivityTemplateInputEnvelope
    connect?: ActivityTemplateStepWhereUniqueInput | ActivityTemplateStepWhereUniqueInput[]
  }

  export type ActivityTemplateUncheckedCreateNestedManyWithoutStartRelativeToInput = {
    create?: XOR<ActivityTemplateCreateWithoutStartRelativeToInput, ActivityTemplateUncheckedCreateWithoutStartRelativeToInput> | ActivityTemplateCreateWithoutStartRelativeToInput[] | ActivityTemplateUncheckedCreateWithoutStartRelativeToInput[]
    connectOrCreate?: ActivityTemplateCreateOrConnectWithoutStartRelativeToInput | ActivityTemplateCreateOrConnectWithoutStartRelativeToInput[]
    createMany?: ActivityTemplateCreateManyStartRelativeToInputEnvelope
    connect?: ActivityTemplateWhereUniqueInput | ActivityTemplateWhereUniqueInput[]
  }

  export type ActivityWaypointTemplateUncheckedCreateNestedManyWithoutParentActivityInput = {
    create?: XOR<ActivityWaypointTemplateCreateWithoutParentActivityInput, ActivityWaypointTemplateUncheckedCreateWithoutParentActivityInput> | ActivityWaypointTemplateCreateWithoutParentActivityInput[] | ActivityWaypointTemplateUncheckedCreateWithoutParentActivityInput[]
    connectOrCreate?: ActivityWaypointTemplateCreateOrConnectWithoutParentActivityInput | ActivityWaypointTemplateCreateOrConnectWithoutParentActivityInput[]
    createMany?: ActivityWaypointTemplateCreateManyParentActivityInputEnvelope
    connect?: ActivityWaypointTemplateWhereUniqueInput | ActivityWaypointTemplateWhereUniqueInput[]
  }

  export type ActivityTemplateUncheckedCreateNestedManyWithoutParentActivityInput = {
    create?: XOR<ActivityTemplateCreateWithoutParentActivityInput, ActivityTemplateUncheckedCreateWithoutParentActivityInput> | ActivityTemplateCreateWithoutParentActivityInput[] | ActivityTemplateUncheckedCreateWithoutParentActivityInput[]
    connectOrCreate?: ActivityTemplateCreateOrConnectWithoutParentActivityInput | ActivityTemplateCreateOrConnectWithoutParentActivityInput[]
    createMany?: ActivityTemplateCreateManyParentActivityInputEnvelope
    connect?: ActivityTemplateWhereUniqueInput | ActivityTemplateWhereUniqueInput[]
  }

  export type ActivityUncheckedCreateNestedManyWithoutTemplateInput = {
    create?: XOR<ActivityCreateWithoutTemplateInput, ActivityUncheckedCreateWithoutTemplateInput> | ActivityCreateWithoutTemplateInput[] | ActivityUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutTemplateInput | ActivityCreateOrConnectWithoutTemplateInput[]
    createMany?: ActivityCreateManyTemplateInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type TemplateAssignmentUncheckedCreateNestedManyWithoutActivityTemplateInput = {
    create?: XOR<TemplateAssignmentCreateWithoutActivityTemplateInput, TemplateAssignmentUncheckedCreateWithoutActivityTemplateInput> | TemplateAssignmentCreateWithoutActivityTemplateInput[] | TemplateAssignmentUncheckedCreateWithoutActivityTemplateInput[]
    connectOrCreate?: TemplateAssignmentCreateOrConnectWithoutActivityTemplateInput | TemplateAssignmentCreateOrConnectWithoutActivityTemplateInput[]
    createMany?: TemplateAssignmentCreateManyActivityTemplateInputEnvelope
    connect?: TemplateAssignmentWhereUniqueInput | TemplateAssignmentWhereUniqueInput[]
  }

  export type EnumActivityTypeFieldUpdateOperationsInput = {
    set?: $Enums.ActivityType
  }

  export type EnumActivityPriorityFieldUpdateOperationsInput = {
    set?: $Enums.ActivityPriority
  }

  export type NullableEnumTaskScheduleTypeFieldUpdateOperationsInput = {
    set?: $Enums.TaskScheduleType | null
  }

  export type ActivityTemplateStepUpdateManyWithoutActivityTemplateNestedInput = {
    create?: XOR<ActivityTemplateStepCreateWithoutActivityTemplateInput, ActivityTemplateStepUncheckedCreateWithoutActivityTemplateInput> | ActivityTemplateStepCreateWithoutActivityTemplateInput[] | ActivityTemplateStepUncheckedCreateWithoutActivityTemplateInput[]
    connectOrCreate?: ActivityTemplateStepCreateOrConnectWithoutActivityTemplateInput | ActivityTemplateStepCreateOrConnectWithoutActivityTemplateInput[]
    upsert?: ActivityTemplateStepUpsertWithWhereUniqueWithoutActivityTemplateInput | ActivityTemplateStepUpsertWithWhereUniqueWithoutActivityTemplateInput[]
    createMany?: ActivityTemplateStepCreateManyActivityTemplateInputEnvelope
    set?: ActivityTemplateStepWhereUniqueInput | ActivityTemplateStepWhereUniqueInput[]
    disconnect?: ActivityTemplateStepWhereUniqueInput | ActivityTemplateStepWhereUniqueInput[]
    delete?: ActivityTemplateStepWhereUniqueInput | ActivityTemplateStepWhereUniqueInput[]
    connect?: ActivityTemplateStepWhereUniqueInput | ActivityTemplateStepWhereUniqueInput[]
    update?: ActivityTemplateStepUpdateWithWhereUniqueWithoutActivityTemplateInput | ActivityTemplateStepUpdateWithWhereUniqueWithoutActivityTemplateInput[]
    updateMany?: ActivityTemplateStepUpdateManyWithWhereWithoutActivityTemplateInput | ActivityTemplateStepUpdateManyWithWhereWithoutActivityTemplateInput[]
    deleteMany?: ActivityTemplateStepScalarWhereInput | ActivityTemplateStepScalarWhereInput[]
  }

  export type ActivityTemplateUpdateOneWithoutDependentsNestedInput = {
    create?: XOR<ActivityTemplateCreateWithoutDependentsInput, ActivityTemplateUncheckedCreateWithoutDependentsInput>
    connectOrCreate?: ActivityTemplateCreateOrConnectWithoutDependentsInput
    upsert?: ActivityTemplateUpsertWithoutDependentsInput
    disconnect?: ActivityTemplateWhereInput | boolean
    delete?: ActivityTemplateWhereInput | boolean
    connect?: ActivityTemplateWhereUniqueInput
    update?: XOR<XOR<ActivityTemplateUpdateToOneWithWhereWithoutDependentsInput, ActivityTemplateUpdateWithoutDependentsInput>, ActivityTemplateUncheckedUpdateWithoutDependentsInput>
  }

  export type ActivityTemplateUpdateManyWithoutStartRelativeToNestedInput = {
    create?: XOR<ActivityTemplateCreateWithoutStartRelativeToInput, ActivityTemplateUncheckedCreateWithoutStartRelativeToInput> | ActivityTemplateCreateWithoutStartRelativeToInput[] | ActivityTemplateUncheckedCreateWithoutStartRelativeToInput[]
    connectOrCreate?: ActivityTemplateCreateOrConnectWithoutStartRelativeToInput | ActivityTemplateCreateOrConnectWithoutStartRelativeToInput[]
    upsert?: ActivityTemplateUpsertWithWhereUniqueWithoutStartRelativeToInput | ActivityTemplateUpsertWithWhereUniqueWithoutStartRelativeToInput[]
    createMany?: ActivityTemplateCreateManyStartRelativeToInputEnvelope
    set?: ActivityTemplateWhereUniqueInput | ActivityTemplateWhereUniqueInput[]
    disconnect?: ActivityTemplateWhereUniqueInput | ActivityTemplateWhereUniqueInput[]
    delete?: ActivityTemplateWhereUniqueInput | ActivityTemplateWhereUniqueInput[]
    connect?: ActivityTemplateWhereUniqueInput | ActivityTemplateWhereUniqueInput[]
    update?: ActivityTemplateUpdateWithWhereUniqueWithoutStartRelativeToInput | ActivityTemplateUpdateWithWhereUniqueWithoutStartRelativeToInput[]
    updateMany?: ActivityTemplateUpdateManyWithWhereWithoutStartRelativeToInput | ActivityTemplateUpdateManyWithWhereWithoutStartRelativeToInput[]
    deleteMany?: ActivityTemplateScalarWhereInput | ActivityTemplateScalarWhereInput[]
  }

  export type ActivityWaypointTemplateUpdateOneWithoutActivitiesNestedInput = {
    create?: XOR<ActivityWaypointTemplateCreateWithoutActivitiesInput, ActivityWaypointTemplateUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: ActivityWaypointTemplateCreateOrConnectWithoutActivitiesInput
    upsert?: ActivityWaypointTemplateUpsertWithoutActivitiesInput
    disconnect?: ActivityWaypointTemplateWhereInput | boolean
    delete?: ActivityWaypointTemplateWhereInput | boolean
    connect?: ActivityWaypointTemplateWhereUniqueInput
    update?: XOR<XOR<ActivityWaypointTemplateUpdateToOneWithWhereWithoutActivitiesInput, ActivityWaypointTemplateUpdateWithoutActivitiesInput>, ActivityWaypointTemplateUncheckedUpdateWithoutActivitiesInput>
  }

  export type ActivityTemplateUpdateOneWithoutChildActivitiesNestedInput = {
    create?: XOR<ActivityTemplateCreateWithoutChildActivitiesInput, ActivityTemplateUncheckedCreateWithoutChildActivitiesInput>
    connectOrCreate?: ActivityTemplateCreateOrConnectWithoutChildActivitiesInput
    upsert?: ActivityTemplateUpsertWithoutChildActivitiesInput
    disconnect?: ActivityTemplateWhereInput | boolean
    delete?: ActivityTemplateWhereInput | boolean
    connect?: ActivityTemplateWhereUniqueInput
    update?: XOR<XOR<ActivityTemplateUpdateToOneWithWhereWithoutChildActivitiesInput, ActivityTemplateUpdateWithoutChildActivitiesInput>, ActivityTemplateUncheckedUpdateWithoutChildActivitiesInput>
  }

  export type ActivityWaypointTemplateUpdateManyWithoutParentActivityNestedInput = {
    create?: XOR<ActivityWaypointTemplateCreateWithoutParentActivityInput, ActivityWaypointTemplateUncheckedCreateWithoutParentActivityInput> | ActivityWaypointTemplateCreateWithoutParentActivityInput[] | ActivityWaypointTemplateUncheckedCreateWithoutParentActivityInput[]
    connectOrCreate?: ActivityWaypointTemplateCreateOrConnectWithoutParentActivityInput | ActivityWaypointTemplateCreateOrConnectWithoutParentActivityInput[]
    upsert?: ActivityWaypointTemplateUpsertWithWhereUniqueWithoutParentActivityInput | ActivityWaypointTemplateUpsertWithWhereUniqueWithoutParentActivityInput[]
    createMany?: ActivityWaypointTemplateCreateManyParentActivityInputEnvelope
    set?: ActivityWaypointTemplateWhereUniqueInput | ActivityWaypointTemplateWhereUniqueInput[]
    disconnect?: ActivityWaypointTemplateWhereUniqueInput | ActivityWaypointTemplateWhereUniqueInput[]
    delete?: ActivityWaypointTemplateWhereUniqueInput | ActivityWaypointTemplateWhereUniqueInput[]
    connect?: ActivityWaypointTemplateWhereUniqueInput | ActivityWaypointTemplateWhereUniqueInput[]
    update?: ActivityWaypointTemplateUpdateWithWhereUniqueWithoutParentActivityInput | ActivityWaypointTemplateUpdateWithWhereUniqueWithoutParentActivityInput[]
    updateMany?: ActivityWaypointTemplateUpdateManyWithWhereWithoutParentActivityInput | ActivityWaypointTemplateUpdateManyWithWhereWithoutParentActivityInput[]
    deleteMany?: ActivityWaypointTemplateScalarWhereInput | ActivityWaypointTemplateScalarWhereInput[]
  }

  export type ActivityTemplateUpdateManyWithoutParentActivityNestedInput = {
    create?: XOR<ActivityTemplateCreateWithoutParentActivityInput, ActivityTemplateUncheckedCreateWithoutParentActivityInput> | ActivityTemplateCreateWithoutParentActivityInput[] | ActivityTemplateUncheckedCreateWithoutParentActivityInput[]
    connectOrCreate?: ActivityTemplateCreateOrConnectWithoutParentActivityInput | ActivityTemplateCreateOrConnectWithoutParentActivityInput[]
    upsert?: ActivityTemplateUpsertWithWhereUniqueWithoutParentActivityInput | ActivityTemplateUpsertWithWhereUniqueWithoutParentActivityInput[]
    createMany?: ActivityTemplateCreateManyParentActivityInputEnvelope
    set?: ActivityTemplateWhereUniqueInput | ActivityTemplateWhereUniqueInput[]
    disconnect?: ActivityTemplateWhereUniqueInput | ActivityTemplateWhereUniqueInput[]
    delete?: ActivityTemplateWhereUniqueInput | ActivityTemplateWhereUniqueInput[]
    connect?: ActivityTemplateWhereUniqueInput | ActivityTemplateWhereUniqueInput[]
    update?: ActivityTemplateUpdateWithWhereUniqueWithoutParentActivityInput | ActivityTemplateUpdateWithWhereUniqueWithoutParentActivityInput[]
    updateMany?: ActivityTemplateUpdateManyWithWhereWithoutParentActivityInput | ActivityTemplateUpdateManyWithWhereWithoutParentActivityInput[]
    deleteMany?: ActivityTemplateScalarWhereInput | ActivityTemplateScalarWhereInput[]
  }

  export type ActivityUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<ActivityCreateWithoutTemplateInput, ActivityUncheckedCreateWithoutTemplateInput> | ActivityCreateWithoutTemplateInput[] | ActivityUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutTemplateInput | ActivityCreateOrConnectWithoutTemplateInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutTemplateInput | ActivityUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: ActivityCreateManyTemplateInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutTemplateInput | ActivityUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutTemplateInput | ActivityUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type TemplateAssignmentUpdateManyWithoutActivityTemplateNestedInput = {
    create?: XOR<TemplateAssignmentCreateWithoutActivityTemplateInput, TemplateAssignmentUncheckedCreateWithoutActivityTemplateInput> | TemplateAssignmentCreateWithoutActivityTemplateInput[] | TemplateAssignmentUncheckedCreateWithoutActivityTemplateInput[]
    connectOrCreate?: TemplateAssignmentCreateOrConnectWithoutActivityTemplateInput | TemplateAssignmentCreateOrConnectWithoutActivityTemplateInput[]
    upsert?: TemplateAssignmentUpsertWithWhereUniqueWithoutActivityTemplateInput | TemplateAssignmentUpsertWithWhereUniqueWithoutActivityTemplateInput[]
    createMany?: TemplateAssignmentCreateManyActivityTemplateInputEnvelope
    set?: TemplateAssignmentWhereUniqueInput | TemplateAssignmentWhereUniqueInput[]
    disconnect?: TemplateAssignmentWhereUniqueInput | TemplateAssignmentWhereUniqueInput[]
    delete?: TemplateAssignmentWhereUniqueInput | TemplateAssignmentWhereUniqueInput[]
    connect?: TemplateAssignmentWhereUniqueInput | TemplateAssignmentWhereUniqueInput[]
    update?: TemplateAssignmentUpdateWithWhereUniqueWithoutActivityTemplateInput | TemplateAssignmentUpdateWithWhereUniqueWithoutActivityTemplateInput[]
    updateMany?: TemplateAssignmentUpdateManyWithWhereWithoutActivityTemplateInput | TemplateAssignmentUpdateManyWithWhereWithoutActivityTemplateInput[]
    deleteMany?: TemplateAssignmentScalarWhereInput | TemplateAssignmentScalarWhereInput[]
  }

  export type TenetUpdateOneRequiredWithoutActivityTemplatesNestedInput = {
    create?: XOR<TenetCreateWithoutActivityTemplatesInput, TenetUncheckedCreateWithoutActivityTemplatesInput>
    connectOrCreate?: TenetCreateOrConnectWithoutActivityTemplatesInput
    upsert?: TenetUpsertWithoutActivityTemplatesInput
    connect?: TenetWhereUniqueInput
    update?: XOR<XOR<TenetUpdateToOneWithWhereWithoutActivityTemplatesInput, TenetUpdateWithoutActivityTemplatesInput>, TenetUncheckedUpdateWithoutActivityTemplatesInput>
  }

  export type ActivityTemplateStepUncheckedUpdateManyWithoutActivityTemplateNestedInput = {
    create?: XOR<ActivityTemplateStepCreateWithoutActivityTemplateInput, ActivityTemplateStepUncheckedCreateWithoutActivityTemplateInput> | ActivityTemplateStepCreateWithoutActivityTemplateInput[] | ActivityTemplateStepUncheckedCreateWithoutActivityTemplateInput[]
    connectOrCreate?: ActivityTemplateStepCreateOrConnectWithoutActivityTemplateInput | ActivityTemplateStepCreateOrConnectWithoutActivityTemplateInput[]
    upsert?: ActivityTemplateStepUpsertWithWhereUniqueWithoutActivityTemplateInput | ActivityTemplateStepUpsertWithWhereUniqueWithoutActivityTemplateInput[]
    createMany?: ActivityTemplateStepCreateManyActivityTemplateInputEnvelope
    set?: ActivityTemplateStepWhereUniqueInput | ActivityTemplateStepWhereUniqueInput[]
    disconnect?: ActivityTemplateStepWhereUniqueInput | ActivityTemplateStepWhereUniqueInput[]
    delete?: ActivityTemplateStepWhereUniqueInput | ActivityTemplateStepWhereUniqueInput[]
    connect?: ActivityTemplateStepWhereUniqueInput | ActivityTemplateStepWhereUniqueInput[]
    update?: ActivityTemplateStepUpdateWithWhereUniqueWithoutActivityTemplateInput | ActivityTemplateStepUpdateWithWhereUniqueWithoutActivityTemplateInput[]
    updateMany?: ActivityTemplateStepUpdateManyWithWhereWithoutActivityTemplateInput | ActivityTemplateStepUpdateManyWithWhereWithoutActivityTemplateInput[]
    deleteMany?: ActivityTemplateStepScalarWhereInput | ActivityTemplateStepScalarWhereInput[]
  }

  export type ActivityTemplateUncheckedUpdateManyWithoutStartRelativeToNestedInput = {
    create?: XOR<ActivityTemplateCreateWithoutStartRelativeToInput, ActivityTemplateUncheckedCreateWithoutStartRelativeToInput> | ActivityTemplateCreateWithoutStartRelativeToInput[] | ActivityTemplateUncheckedCreateWithoutStartRelativeToInput[]
    connectOrCreate?: ActivityTemplateCreateOrConnectWithoutStartRelativeToInput | ActivityTemplateCreateOrConnectWithoutStartRelativeToInput[]
    upsert?: ActivityTemplateUpsertWithWhereUniqueWithoutStartRelativeToInput | ActivityTemplateUpsertWithWhereUniqueWithoutStartRelativeToInput[]
    createMany?: ActivityTemplateCreateManyStartRelativeToInputEnvelope
    set?: ActivityTemplateWhereUniqueInput | ActivityTemplateWhereUniqueInput[]
    disconnect?: ActivityTemplateWhereUniqueInput | ActivityTemplateWhereUniqueInput[]
    delete?: ActivityTemplateWhereUniqueInput | ActivityTemplateWhereUniqueInput[]
    connect?: ActivityTemplateWhereUniqueInput | ActivityTemplateWhereUniqueInput[]
    update?: ActivityTemplateUpdateWithWhereUniqueWithoutStartRelativeToInput | ActivityTemplateUpdateWithWhereUniqueWithoutStartRelativeToInput[]
    updateMany?: ActivityTemplateUpdateManyWithWhereWithoutStartRelativeToInput | ActivityTemplateUpdateManyWithWhereWithoutStartRelativeToInput[]
    deleteMany?: ActivityTemplateScalarWhereInput | ActivityTemplateScalarWhereInput[]
  }

  export type ActivityWaypointTemplateUncheckedUpdateManyWithoutParentActivityNestedInput = {
    create?: XOR<ActivityWaypointTemplateCreateWithoutParentActivityInput, ActivityWaypointTemplateUncheckedCreateWithoutParentActivityInput> | ActivityWaypointTemplateCreateWithoutParentActivityInput[] | ActivityWaypointTemplateUncheckedCreateWithoutParentActivityInput[]
    connectOrCreate?: ActivityWaypointTemplateCreateOrConnectWithoutParentActivityInput | ActivityWaypointTemplateCreateOrConnectWithoutParentActivityInput[]
    upsert?: ActivityWaypointTemplateUpsertWithWhereUniqueWithoutParentActivityInput | ActivityWaypointTemplateUpsertWithWhereUniqueWithoutParentActivityInput[]
    createMany?: ActivityWaypointTemplateCreateManyParentActivityInputEnvelope
    set?: ActivityWaypointTemplateWhereUniqueInput | ActivityWaypointTemplateWhereUniqueInput[]
    disconnect?: ActivityWaypointTemplateWhereUniqueInput | ActivityWaypointTemplateWhereUniqueInput[]
    delete?: ActivityWaypointTemplateWhereUniqueInput | ActivityWaypointTemplateWhereUniqueInput[]
    connect?: ActivityWaypointTemplateWhereUniqueInput | ActivityWaypointTemplateWhereUniqueInput[]
    update?: ActivityWaypointTemplateUpdateWithWhereUniqueWithoutParentActivityInput | ActivityWaypointTemplateUpdateWithWhereUniqueWithoutParentActivityInput[]
    updateMany?: ActivityWaypointTemplateUpdateManyWithWhereWithoutParentActivityInput | ActivityWaypointTemplateUpdateManyWithWhereWithoutParentActivityInput[]
    deleteMany?: ActivityWaypointTemplateScalarWhereInput | ActivityWaypointTemplateScalarWhereInput[]
  }

  export type ActivityTemplateUncheckedUpdateManyWithoutParentActivityNestedInput = {
    create?: XOR<ActivityTemplateCreateWithoutParentActivityInput, ActivityTemplateUncheckedCreateWithoutParentActivityInput> | ActivityTemplateCreateWithoutParentActivityInput[] | ActivityTemplateUncheckedCreateWithoutParentActivityInput[]
    connectOrCreate?: ActivityTemplateCreateOrConnectWithoutParentActivityInput | ActivityTemplateCreateOrConnectWithoutParentActivityInput[]
    upsert?: ActivityTemplateUpsertWithWhereUniqueWithoutParentActivityInput | ActivityTemplateUpsertWithWhereUniqueWithoutParentActivityInput[]
    createMany?: ActivityTemplateCreateManyParentActivityInputEnvelope
    set?: ActivityTemplateWhereUniqueInput | ActivityTemplateWhereUniqueInput[]
    disconnect?: ActivityTemplateWhereUniqueInput | ActivityTemplateWhereUniqueInput[]
    delete?: ActivityTemplateWhereUniqueInput | ActivityTemplateWhereUniqueInput[]
    connect?: ActivityTemplateWhereUniqueInput | ActivityTemplateWhereUniqueInput[]
    update?: ActivityTemplateUpdateWithWhereUniqueWithoutParentActivityInput | ActivityTemplateUpdateWithWhereUniqueWithoutParentActivityInput[]
    updateMany?: ActivityTemplateUpdateManyWithWhereWithoutParentActivityInput | ActivityTemplateUpdateManyWithWhereWithoutParentActivityInput[]
    deleteMany?: ActivityTemplateScalarWhereInput | ActivityTemplateScalarWhereInput[]
  }

  export type ActivityUncheckedUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<ActivityCreateWithoutTemplateInput, ActivityUncheckedCreateWithoutTemplateInput> | ActivityCreateWithoutTemplateInput[] | ActivityUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutTemplateInput | ActivityCreateOrConnectWithoutTemplateInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutTemplateInput | ActivityUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: ActivityCreateManyTemplateInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutTemplateInput | ActivityUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutTemplateInput | ActivityUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type TemplateAssignmentUncheckedUpdateManyWithoutActivityTemplateNestedInput = {
    create?: XOR<TemplateAssignmentCreateWithoutActivityTemplateInput, TemplateAssignmentUncheckedCreateWithoutActivityTemplateInput> | TemplateAssignmentCreateWithoutActivityTemplateInput[] | TemplateAssignmentUncheckedCreateWithoutActivityTemplateInput[]
    connectOrCreate?: TemplateAssignmentCreateOrConnectWithoutActivityTemplateInput | TemplateAssignmentCreateOrConnectWithoutActivityTemplateInput[]
    upsert?: TemplateAssignmentUpsertWithWhereUniqueWithoutActivityTemplateInput | TemplateAssignmentUpsertWithWhereUniqueWithoutActivityTemplateInput[]
    createMany?: TemplateAssignmentCreateManyActivityTemplateInputEnvelope
    set?: TemplateAssignmentWhereUniqueInput | TemplateAssignmentWhereUniqueInput[]
    disconnect?: TemplateAssignmentWhereUniqueInput | TemplateAssignmentWhereUniqueInput[]
    delete?: TemplateAssignmentWhereUniqueInput | TemplateAssignmentWhereUniqueInput[]
    connect?: TemplateAssignmentWhereUniqueInput | TemplateAssignmentWhereUniqueInput[]
    update?: TemplateAssignmentUpdateWithWhereUniqueWithoutActivityTemplateInput | TemplateAssignmentUpdateWithWhereUniqueWithoutActivityTemplateInput[]
    updateMany?: TemplateAssignmentUpdateManyWithWhereWithoutActivityTemplateInput | TemplateAssignmentUpdateManyWithWhereWithoutActivityTemplateInput[]
    deleteMany?: TemplateAssignmentScalarWhereInput | TemplateAssignmentScalarWhereInput[]
  }

  export type ActivityStepCreateNestedManyWithoutActivityInput = {
    create?: XOR<ActivityStepCreateWithoutActivityInput, ActivityStepUncheckedCreateWithoutActivityInput> | ActivityStepCreateWithoutActivityInput[] | ActivityStepUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: ActivityStepCreateOrConnectWithoutActivityInput | ActivityStepCreateOrConnectWithoutActivityInput[]
    createMany?: ActivityStepCreateManyActivityInputEnvelope
    connect?: ActivityStepWhereUniqueInput | ActivityStepWhereUniqueInput[]
  }

  export type ActivityWaypointCreateNestedManyWithoutActivityInput = {
    create?: XOR<ActivityWaypointCreateWithoutActivityInput, ActivityWaypointUncheckedCreateWithoutActivityInput> | ActivityWaypointCreateWithoutActivityInput[] | ActivityWaypointUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: ActivityWaypointCreateOrConnectWithoutActivityInput | ActivityWaypointCreateOrConnectWithoutActivityInput[]
    createMany?: ActivityWaypointCreateManyActivityInputEnvelope
    connect?: ActivityWaypointWhereUniqueInput | ActivityWaypointWhereUniqueInput[]
  }

  export type ActivityCreateNestedManyWithoutParentActivityInput = {
    create?: XOR<ActivityCreateWithoutParentActivityInput, ActivityUncheckedCreateWithoutParentActivityInput> | ActivityCreateWithoutParentActivityInput[] | ActivityUncheckedCreateWithoutParentActivityInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutParentActivityInput | ActivityCreateOrConnectWithoutParentActivityInput[]
    createMany?: ActivityCreateManyParentActivityInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type ActivityCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<ActivityCreateWithoutActivitiesInput, ActivityUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutActivitiesInput
    connect?: ActivityWhereUniqueInput
  }

  export type ActivityWaypointCreateNestedOneWithoutChildActivitiesInput = {
    create?: XOR<ActivityWaypointCreateWithoutChildActivitiesInput, ActivityWaypointUncheckedCreateWithoutChildActivitiesInput>
    connectOrCreate?: ActivityWaypointCreateOrConnectWithoutChildActivitiesInput
    connect?: ActivityWaypointWhereUniqueInput
  }

  export type ActivityTemplateCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<ActivityTemplateCreateWithoutActivitiesInput, ActivityTemplateUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: ActivityTemplateCreateOrConnectWithoutActivitiesInput
    connect?: ActivityTemplateWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAssignedActivitiesInput = {
    create?: XOR<UserCreateWithoutAssignedActivitiesInput, UserUncheckedCreateWithoutAssignedActivitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedActivitiesInput
    connect?: UserWhereUniqueInput
  }

  export type ActivityContactJoinCreateNestedManyWithoutActivityRelationInput = {
    create?: XOR<ActivityContactJoinCreateWithoutActivityRelationInput, ActivityContactJoinUncheckedCreateWithoutActivityRelationInput> | ActivityContactJoinCreateWithoutActivityRelationInput[] | ActivityContactJoinUncheckedCreateWithoutActivityRelationInput[]
    connectOrCreate?: ActivityContactJoinCreateOrConnectWithoutActivityRelationInput | ActivityContactJoinCreateOrConnectWithoutActivityRelationInput[]
    createMany?: ActivityContactJoinCreateManyActivityRelationInputEnvelope
    connect?: ActivityContactJoinWhereUniqueInput | ActivityContactJoinWhereUniqueInput[]
  }

  export type ActivityUserJoinCreateNestedManyWithoutActivityRelationInput = {
    create?: XOR<ActivityUserJoinCreateWithoutActivityRelationInput, ActivityUserJoinUncheckedCreateWithoutActivityRelationInput> | ActivityUserJoinCreateWithoutActivityRelationInput[] | ActivityUserJoinUncheckedCreateWithoutActivityRelationInput[]
    connectOrCreate?: ActivityUserJoinCreateOrConnectWithoutActivityRelationInput | ActivityUserJoinCreateOrConnectWithoutActivityRelationInput[]
    createMany?: ActivityUserJoinCreateManyActivityRelationInputEnvelope
    connect?: ActivityUserJoinWhereUniqueInput | ActivityUserJoinWhereUniqueInput[]
  }

  export type TenetCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<TenetCreateWithoutActivitiesInput, TenetUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: TenetCreateOrConnectWithoutActivitiesInput
    connect?: TenetWhereUniqueInput
  }

  export type AttachmentCreateNestedManyWithoutActivityInput = {
    create?: XOR<AttachmentCreateWithoutActivityInput, AttachmentUncheckedCreateWithoutActivityInput> | AttachmentCreateWithoutActivityInput[] | AttachmentUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutActivityInput | AttachmentCreateOrConnectWithoutActivityInput[]
    createMany?: AttachmentCreateManyActivityInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type NoteCreateNestedManyWithoutActivityInput = {
    create?: XOR<NoteCreateWithoutActivityInput, NoteUncheckedCreateWithoutActivityInput> | NoteCreateWithoutActivityInput[] | NoteUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutActivityInput | NoteCreateOrConnectWithoutActivityInput[]
    createMany?: NoteCreateManyActivityInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type ContactTimelineEventCreateNestedManyWithoutActivityInput = {
    create?: XOR<ContactTimelineEventCreateWithoutActivityInput, ContactTimelineEventUncheckedCreateWithoutActivityInput> | ContactTimelineEventCreateWithoutActivityInput[] | ContactTimelineEventUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: ContactTimelineEventCreateOrConnectWithoutActivityInput | ContactTimelineEventCreateOrConnectWithoutActivityInput[]
    createMany?: ContactTimelineEventCreateManyActivityInputEnvelope
    connect?: ContactTimelineEventWhereUniqueInput | ContactTimelineEventWhereUniqueInput[]
  }

  export type OpportunityCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<OpportunityCreateWithoutActivitiesInput, OpportunityUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: OpportunityCreateOrConnectWithoutActivitiesInput
    connect?: OpportunityWhereUniqueInput
  }

  export type ActivityStepUncheckedCreateNestedManyWithoutActivityInput = {
    create?: XOR<ActivityStepCreateWithoutActivityInput, ActivityStepUncheckedCreateWithoutActivityInput> | ActivityStepCreateWithoutActivityInput[] | ActivityStepUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: ActivityStepCreateOrConnectWithoutActivityInput | ActivityStepCreateOrConnectWithoutActivityInput[]
    createMany?: ActivityStepCreateManyActivityInputEnvelope
    connect?: ActivityStepWhereUniqueInput | ActivityStepWhereUniqueInput[]
  }

  export type ActivityWaypointUncheckedCreateNestedManyWithoutActivityInput = {
    create?: XOR<ActivityWaypointCreateWithoutActivityInput, ActivityWaypointUncheckedCreateWithoutActivityInput> | ActivityWaypointCreateWithoutActivityInput[] | ActivityWaypointUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: ActivityWaypointCreateOrConnectWithoutActivityInput | ActivityWaypointCreateOrConnectWithoutActivityInput[]
    createMany?: ActivityWaypointCreateManyActivityInputEnvelope
    connect?: ActivityWaypointWhereUniqueInput | ActivityWaypointWhereUniqueInput[]
  }

  export type ActivityUncheckedCreateNestedManyWithoutParentActivityInput = {
    create?: XOR<ActivityCreateWithoutParentActivityInput, ActivityUncheckedCreateWithoutParentActivityInput> | ActivityCreateWithoutParentActivityInput[] | ActivityUncheckedCreateWithoutParentActivityInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutParentActivityInput | ActivityCreateOrConnectWithoutParentActivityInput[]
    createMany?: ActivityCreateManyParentActivityInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type ActivityContactJoinUncheckedCreateNestedManyWithoutActivityRelationInput = {
    create?: XOR<ActivityContactJoinCreateWithoutActivityRelationInput, ActivityContactJoinUncheckedCreateWithoutActivityRelationInput> | ActivityContactJoinCreateWithoutActivityRelationInput[] | ActivityContactJoinUncheckedCreateWithoutActivityRelationInput[]
    connectOrCreate?: ActivityContactJoinCreateOrConnectWithoutActivityRelationInput | ActivityContactJoinCreateOrConnectWithoutActivityRelationInput[]
    createMany?: ActivityContactJoinCreateManyActivityRelationInputEnvelope
    connect?: ActivityContactJoinWhereUniqueInput | ActivityContactJoinWhereUniqueInput[]
  }

  export type ActivityUserJoinUncheckedCreateNestedManyWithoutActivityRelationInput = {
    create?: XOR<ActivityUserJoinCreateWithoutActivityRelationInput, ActivityUserJoinUncheckedCreateWithoutActivityRelationInput> | ActivityUserJoinCreateWithoutActivityRelationInput[] | ActivityUserJoinUncheckedCreateWithoutActivityRelationInput[]
    connectOrCreate?: ActivityUserJoinCreateOrConnectWithoutActivityRelationInput | ActivityUserJoinCreateOrConnectWithoutActivityRelationInput[]
    createMany?: ActivityUserJoinCreateManyActivityRelationInputEnvelope
    connect?: ActivityUserJoinWhereUniqueInput | ActivityUserJoinWhereUniqueInput[]
  }

  export type AttachmentUncheckedCreateNestedManyWithoutActivityInput = {
    create?: XOR<AttachmentCreateWithoutActivityInput, AttachmentUncheckedCreateWithoutActivityInput> | AttachmentCreateWithoutActivityInput[] | AttachmentUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutActivityInput | AttachmentCreateOrConnectWithoutActivityInput[]
    createMany?: AttachmentCreateManyActivityInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type NoteUncheckedCreateNestedManyWithoutActivityInput = {
    create?: XOR<NoteCreateWithoutActivityInput, NoteUncheckedCreateWithoutActivityInput> | NoteCreateWithoutActivityInput[] | NoteUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutActivityInput | NoteCreateOrConnectWithoutActivityInput[]
    createMany?: NoteCreateManyActivityInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type ContactTimelineEventUncheckedCreateNestedManyWithoutActivityInput = {
    create?: XOR<ContactTimelineEventCreateWithoutActivityInput, ContactTimelineEventUncheckedCreateWithoutActivityInput> | ContactTimelineEventCreateWithoutActivityInput[] | ContactTimelineEventUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: ContactTimelineEventCreateOrConnectWithoutActivityInput | ContactTimelineEventCreateOrConnectWithoutActivityInput[]
    createMany?: ContactTimelineEventCreateManyActivityInputEnvelope
    connect?: ContactTimelineEventWhereUniqueInput | ContactTimelineEventWhereUniqueInput[]
  }

  export type ActivityStepUpdateManyWithoutActivityNestedInput = {
    create?: XOR<ActivityStepCreateWithoutActivityInput, ActivityStepUncheckedCreateWithoutActivityInput> | ActivityStepCreateWithoutActivityInput[] | ActivityStepUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: ActivityStepCreateOrConnectWithoutActivityInput | ActivityStepCreateOrConnectWithoutActivityInput[]
    upsert?: ActivityStepUpsertWithWhereUniqueWithoutActivityInput | ActivityStepUpsertWithWhereUniqueWithoutActivityInput[]
    createMany?: ActivityStepCreateManyActivityInputEnvelope
    set?: ActivityStepWhereUniqueInput | ActivityStepWhereUniqueInput[]
    disconnect?: ActivityStepWhereUniqueInput | ActivityStepWhereUniqueInput[]
    delete?: ActivityStepWhereUniqueInput | ActivityStepWhereUniqueInput[]
    connect?: ActivityStepWhereUniqueInput | ActivityStepWhereUniqueInput[]
    update?: ActivityStepUpdateWithWhereUniqueWithoutActivityInput | ActivityStepUpdateWithWhereUniqueWithoutActivityInput[]
    updateMany?: ActivityStepUpdateManyWithWhereWithoutActivityInput | ActivityStepUpdateManyWithWhereWithoutActivityInput[]
    deleteMany?: ActivityStepScalarWhereInput | ActivityStepScalarWhereInput[]
  }

  export type ActivityWaypointUpdateManyWithoutActivityNestedInput = {
    create?: XOR<ActivityWaypointCreateWithoutActivityInput, ActivityWaypointUncheckedCreateWithoutActivityInput> | ActivityWaypointCreateWithoutActivityInput[] | ActivityWaypointUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: ActivityWaypointCreateOrConnectWithoutActivityInput | ActivityWaypointCreateOrConnectWithoutActivityInput[]
    upsert?: ActivityWaypointUpsertWithWhereUniqueWithoutActivityInput | ActivityWaypointUpsertWithWhereUniqueWithoutActivityInput[]
    createMany?: ActivityWaypointCreateManyActivityInputEnvelope
    set?: ActivityWaypointWhereUniqueInput | ActivityWaypointWhereUniqueInput[]
    disconnect?: ActivityWaypointWhereUniqueInput | ActivityWaypointWhereUniqueInput[]
    delete?: ActivityWaypointWhereUniqueInput | ActivityWaypointWhereUniqueInput[]
    connect?: ActivityWaypointWhereUniqueInput | ActivityWaypointWhereUniqueInput[]
    update?: ActivityWaypointUpdateWithWhereUniqueWithoutActivityInput | ActivityWaypointUpdateWithWhereUniqueWithoutActivityInput[]
    updateMany?: ActivityWaypointUpdateManyWithWhereWithoutActivityInput | ActivityWaypointUpdateManyWithWhereWithoutActivityInput[]
    deleteMany?: ActivityWaypointScalarWhereInput | ActivityWaypointScalarWhereInput[]
  }

  export type ActivityUpdateManyWithoutParentActivityNestedInput = {
    create?: XOR<ActivityCreateWithoutParentActivityInput, ActivityUncheckedCreateWithoutParentActivityInput> | ActivityCreateWithoutParentActivityInput[] | ActivityUncheckedCreateWithoutParentActivityInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutParentActivityInput | ActivityCreateOrConnectWithoutParentActivityInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutParentActivityInput | ActivityUpsertWithWhereUniqueWithoutParentActivityInput[]
    createMany?: ActivityCreateManyParentActivityInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutParentActivityInput | ActivityUpdateWithWhereUniqueWithoutParentActivityInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutParentActivityInput | ActivityUpdateManyWithWhereWithoutParentActivityInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type ActivityUpdateOneWithoutActivitiesNestedInput = {
    create?: XOR<ActivityCreateWithoutActivitiesInput, ActivityUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutActivitiesInput
    upsert?: ActivityUpsertWithoutActivitiesInput
    disconnect?: ActivityWhereInput | boolean
    delete?: ActivityWhereInput | boolean
    connect?: ActivityWhereUniqueInput
    update?: XOR<XOR<ActivityUpdateToOneWithWhereWithoutActivitiesInput, ActivityUpdateWithoutActivitiesInput>, ActivityUncheckedUpdateWithoutActivitiesInput>
  }

  export type ActivityWaypointUpdateOneWithoutChildActivitiesNestedInput = {
    create?: XOR<ActivityWaypointCreateWithoutChildActivitiesInput, ActivityWaypointUncheckedCreateWithoutChildActivitiesInput>
    connectOrCreate?: ActivityWaypointCreateOrConnectWithoutChildActivitiesInput
    upsert?: ActivityWaypointUpsertWithoutChildActivitiesInput
    disconnect?: ActivityWaypointWhereInput | boolean
    delete?: ActivityWaypointWhereInput | boolean
    connect?: ActivityWaypointWhereUniqueInput
    update?: XOR<XOR<ActivityWaypointUpdateToOneWithWhereWithoutChildActivitiesInput, ActivityWaypointUpdateWithoutChildActivitiesInput>, ActivityWaypointUncheckedUpdateWithoutChildActivitiesInput>
  }

  export type ActivityTemplateUpdateOneWithoutActivitiesNestedInput = {
    create?: XOR<ActivityTemplateCreateWithoutActivitiesInput, ActivityTemplateUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: ActivityTemplateCreateOrConnectWithoutActivitiesInput
    upsert?: ActivityTemplateUpsertWithoutActivitiesInput
    disconnect?: ActivityTemplateWhereInput | boolean
    delete?: ActivityTemplateWhereInput | boolean
    connect?: ActivityTemplateWhereUniqueInput
    update?: XOR<XOR<ActivityTemplateUpdateToOneWithWhereWithoutActivitiesInput, ActivityTemplateUpdateWithoutActivitiesInput>, ActivityTemplateUncheckedUpdateWithoutActivitiesInput>
  }

  export type UserUpdateOneRequiredWithoutAssignedActivitiesNestedInput = {
    create?: XOR<UserCreateWithoutAssignedActivitiesInput, UserUncheckedCreateWithoutAssignedActivitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedActivitiesInput
    upsert?: UserUpsertWithoutAssignedActivitiesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignedActivitiesInput, UserUpdateWithoutAssignedActivitiesInput>, UserUncheckedUpdateWithoutAssignedActivitiesInput>
  }

  export type ActivityContactJoinUpdateManyWithoutActivityRelationNestedInput = {
    create?: XOR<ActivityContactJoinCreateWithoutActivityRelationInput, ActivityContactJoinUncheckedCreateWithoutActivityRelationInput> | ActivityContactJoinCreateWithoutActivityRelationInput[] | ActivityContactJoinUncheckedCreateWithoutActivityRelationInput[]
    connectOrCreate?: ActivityContactJoinCreateOrConnectWithoutActivityRelationInput | ActivityContactJoinCreateOrConnectWithoutActivityRelationInput[]
    upsert?: ActivityContactJoinUpsertWithWhereUniqueWithoutActivityRelationInput | ActivityContactJoinUpsertWithWhereUniqueWithoutActivityRelationInput[]
    createMany?: ActivityContactJoinCreateManyActivityRelationInputEnvelope
    set?: ActivityContactJoinWhereUniqueInput | ActivityContactJoinWhereUniqueInput[]
    disconnect?: ActivityContactJoinWhereUniqueInput | ActivityContactJoinWhereUniqueInput[]
    delete?: ActivityContactJoinWhereUniqueInput | ActivityContactJoinWhereUniqueInput[]
    connect?: ActivityContactJoinWhereUniqueInput | ActivityContactJoinWhereUniqueInput[]
    update?: ActivityContactJoinUpdateWithWhereUniqueWithoutActivityRelationInput | ActivityContactJoinUpdateWithWhereUniqueWithoutActivityRelationInput[]
    updateMany?: ActivityContactJoinUpdateManyWithWhereWithoutActivityRelationInput | ActivityContactJoinUpdateManyWithWhereWithoutActivityRelationInput[]
    deleteMany?: ActivityContactJoinScalarWhereInput | ActivityContactJoinScalarWhereInput[]
  }

  export type ActivityUserJoinUpdateManyWithoutActivityRelationNestedInput = {
    create?: XOR<ActivityUserJoinCreateWithoutActivityRelationInput, ActivityUserJoinUncheckedCreateWithoutActivityRelationInput> | ActivityUserJoinCreateWithoutActivityRelationInput[] | ActivityUserJoinUncheckedCreateWithoutActivityRelationInput[]
    connectOrCreate?: ActivityUserJoinCreateOrConnectWithoutActivityRelationInput | ActivityUserJoinCreateOrConnectWithoutActivityRelationInput[]
    upsert?: ActivityUserJoinUpsertWithWhereUniqueWithoutActivityRelationInput | ActivityUserJoinUpsertWithWhereUniqueWithoutActivityRelationInput[]
    createMany?: ActivityUserJoinCreateManyActivityRelationInputEnvelope
    set?: ActivityUserJoinWhereUniqueInput | ActivityUserJoinWhereUniqueInput[]
    disconnect?: ActivityUserJoinWhereUniqueInput | ActivityUserJoinWhereUniqueInput[]
    delete?: ActivityUserJoinWhereUniqueInput | ActivityUserJoinWhereUniqueInput[]
    connect?: ActivityUserJoinWhereUniqueInput | ActivityUserJoinWhereUniqueInput[]
    update?: ActivityUserJoinUpdateWithWhereUniqueWithoutActivityRelationInput | ActivityUserJoinUpdateWithWhereUniqueWithoutActivityRelationInput[]
    updateMany?: ActivityUserJoinUpdateManyWithWhereWithoutActivityRelationInput | ActivityUserJoinUpdateManyWithWhereWithoutActivityRelationInput[]
    deleteMany?: ActivityUserJoinScalarWhereInput | ActivityUserJoinScalarWhereInput[]
  }

  export type TenetUpdateOneRequiredWithoutActivitiesNestedInput = {
    create?: XOR<TenetCreateWithoutActivitiesInput, TenetUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: TenetCreateOrConnectWithoutActivitiesInput
    upsert?: TenetUpsertWithoutActivitiesInput
    connect?: TenetWhereUniqueInput
    update?: XOR<XOR<TenetUpdateToOneWithWhereWithoutActivitiesInput, TenetUpdateWithoutActivitiesInput>, TenetUncheckedUpdateWithoutActivitiesInput>
  }

  export type AttachmentUpdateManyWithoutActivityNestedInput = {
    create?: XOR<AttachmentCreateWithoutActivityInput, AttachmentUncheckedCreateWithoutActivityInput> | AttachmentCreateWithoutActivityInput[] | AttachmentUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutActivityInput | AttachmentCreateOrConnectWithoutActivityInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutActivityInput | AttachmentUpsertWithWhereUniqueWithoutActivityInput[]
    createMany?: AttachmentCreateManyActivityInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutActivityInput | AttachmentUpdateWithWhereUniqueWithoutActivityInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutActivityInput | AttachmentUpdateManyWithWhereWithoutActivityInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type NoteUpdateManyWithoutActivityNestedInput = {
    create?: XOR<NoteCreateWithoutActivityInput, NoteUncheckedCreateWithoutActivityInput> | NoteCreateWithoutActivityInput[] | NoteUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutActivityInput | NoteCreateOrConnectWithoutActivityInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutActivityInput | NoteUpsertWithWhereUniqueWithoutActivityInput[]
    createMany?: NoteCreateManyActivityInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutActivityInput | NoteUpdateWithWhereUniqueWithoutActivityInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutActivityInput | NoteUpdateManyWithWhereWithoutActivityInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type ContactTimelineEventUpdateManyWithoutActivityNestedInput = {
    create?: XOR<ContactTimelineEventCreateWithoutActivityInput, ContactTimelineEventUncheckedCreateWithoutActivityInput> | ContactTimelineEventCreateWithoutActivityInput[] | ContactTimelineEventUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: ContactTimelineEventCreateOrConnectWithoutActivityInput | ContactTimelineEventCreateOrConnectWithoutActivityInput[]
    upsert?: ContactTimelineEventUpsertWithWhereUniqueWithoutActivityInput | ContactTimelineEventUpsertWithWhereUniqueWithoutActivityInput[]
    createMany?: ContactTimelineEventCreateManyActivityInputEnvelope
    set?: ContactTimelineEventWhereUniqueInput | ContactTimelineEventWhereUniqueInput[]
    disconnect?: ContactTimelineEventWhereUniqueInput | ContactTimelineEventWhereUniqueInput[]
    delete?: ContactTimelineEventWhereUniqueInput | ContactTimelineEventWhereUniqueInput[]
    connect?: ContactTimelineEventWhereUniqueInput | ContactTimelineEventWhereUniqueInput[]
    update?: ContactTimelineEventUpdateWithWhereUniqueWithoutActivityInput | ContactTimelineEventUpdateWithWhereUniqueWithoutActivityInput[]
    updateMany?: ContactTimelineEventUpdateManyWithWhereWithoutActivityInput | ContactTimelineEventUpdateManyWithWhereWithoutActivityInput[]
    deleteMany?: ContactTimelineEventScalarWhereInput | ContactTimelineEventScalarWhereInput[]
  }

  export type OpportunityUpdateOneWithoutActivitiesNestedInput = {
    create?: XOR<OpportunityCreateWithoutActivitiesInput, OpportunityUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: OpportunityCreateOrConnectWithoutActivitiesInput
    upsert?: OpportunityUpsertWithoutActivitiesInput
    disconnect?: OpportunityWhereInput | boolean
    delete?: OpportunityWhereInput | boolean
    connect?: OpportunityWhereUniqueInput
    update?: XOR<XOR<OpportunityUpdateToOneWithWhereWithoutActivitiesInput, OpportunityUpdateWithoutActivitiesInput>, OpportunityUncheckedUpdateWithoutActivitiesInput>
  }

  export type ActivityStepUncheckedUpdateManyWithoutActivityNestedInput = {
    create?: XOR<ActivityStepCreateWithoutActivityInput, ActivityStepUncheckedCreateWithoutActivityInput> | ActivityStepCreateWithoutActivityInput[] | ActivityStepUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: ActivityStepCreateOrConnectWithoutActivityInput | ActivityStepCreateOrConnectWithoutActivityInput[]
    upsert?: ActivityStepUpsertWithWhereUniqueWithoutActivityInput | ActivityStepUpsertWithWhereUniqueWithoutActivityInput[]
    createMany?: ActivityStepCreateManyActivityInputEnvelope
    set?: ActivityStepWhereUniqueInput | ActivityStepWhereUniqueInput[]
    disconnect?: ActivityStepWhereUniqueInput | ActivityStepWhereUniqueInput[]
    delete?: ActivityStepWhereUniqueInput | ActivityStepWhereUniqueInput[]
    connect?: ActivityStepWhereUniqueInput | ActivityStepWhereUniqueInput[]
    update?: ActivityStepUpdateWithWhereUniqueWithoutActivityInput | ActivityStepUpdateWithWhereUniqueWithoutActivityInput[]
    updateMany?: ActivityStepUpdateManyWithWhereWithoutActivityInput | ActivityStepUpdateManyWithWhereWithoutActivityInput[]
    deleteMany?: ActivityStepScalarWhereInput | ActivityStepScalarWhereInput[]
  }

  export type ActivityWaypointUncheckedUpdateManyWithoutActivityNestedInput = {
    create?: XOR<ActivityWaypointCreateWithoutActivityInput, ActivityWaypointUncheckedCreateWithoutActivityInput> | ActivityWaypointCreateWithoutActivityInput[] | ActivityWaypointUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: ActivityWaypointCreateOrConnectWithoutActivityInput | ActivityWaypointCreateOrConnectWithoutActivityInput[]
    upsert?: ActivityWaypointUpsertWithWhereUniqueWithoutActivityInput | ActivityWaypointUpsertWithWhereUniqueWithoutActivityInput[]
    createMany?: ActivityWaypointCreateManyActivityInputEnvelope
    set?: ActivityWaypointWhereUniqueInput | ActivityWaypointWhereUniqueInput[]
    disconnect?: ActivityWaypointWhereUniqueInput | ActivityWaypointWhereUniqueInput[]
    delete?: ActivityWaypointWhereUniqueInput | ActivityWaypointWhereUniqueInput[]
    connect?: ActivityWaypointWhereUniqueInput | ActivityWaypointWhereUniqueInput[]
    update?: ActivityWaypointUpdateWithWhereUniqueWithoutActivityInput | ActivityWaypointUpdateWithWhereUniqueWithoutActivityInput[]
    updateMany?: ActivityWaypointUpdateManyWithWhereWithoutActivityInput | ActivityWaypointUpdateManyWithWhereWithoutActivityInput[]
    deleteMany?: ActivityWaypointScalarWhereInput | ActivityWaypointScalarWhereInput[]
  }

  export type ActivityUncheckedUpdateManyWithoutParentActivityNestedInput = {
    create?: XOR<ActivityCreateWithoutParentActivityInput, ActivityUncheckedCreateWithoutParentActivityInput> | ActivityCreateWithoutParentActivityInput[] | ActivityUncheckedCreateWithoutParentActivityInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutParentActivityInput | ActivityCreateOrConnectWithoutParentActivityInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutParentActivityInput | ActivityUpsertWithWhereUniqueWithoutParentActivityInput[]
    createMany?: ActivityCreateManyParentActivityInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutParentActivityInput | ActivityUpdateWithWhereUniqueWithoutParentActivityInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutParentActivityInput | ActivityUpdateManyWithWhereWithoutParentActivityInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type ActivityContactJoinUncheckedUpdateManyWithoutActivityRelationNestedInput = {
    create?: XOR<ActivityContactJoinCreateWithoutActivityRelationInput, ActivityContactJoinUncheckedCreateWithoutActivityRelationInput> | ActivityContactJoinCreateWithoutActivityRelationInput[] | ActivityContactJoinUncheckedCreateWithoutActivityRelationInput[]
    connectOrCreate?: ActivityContactJoinCreateOrConnectWithoutActivityRelationInput | ActivityContactJoinCreateOrConnectWithoutActivityRelationInput[]
    upsert?: ActivityContactJoinUpsertWithWhereUniqueWithoutActivityRelationInput | ActivityContactJoinUpsertWithWhereUniqueWithoutActivityRelationInput[]
    createMany?: ActivityContactJoinCreateManyActivityRelationInputEnvelope
    set?: ActivityContactJoinWhereUniqueInput | ActivityContactJoinWhereUniqueInput[]
    disconnect?: ActivityContactJoinWhereUniqueInput | ActivityContactJoinWhereUniqueInput[]
    delete?: ActivityContactJoinWhereUniqueInput | ActivityContactJoinWhereUniqueInput[]
    connect?: ActivityContactJoinWhereUniqueInput | ActivityContactJoinWhereUniqueInput[]
    update?: ActivityContactJoinUpdateWithWhereUniqueWithoutActivityRelationInput | ActivityContactJoinUpdateWithWhereUniqueWithoutActivityRelationInput[]
    updateMany?: ActivityContactJoinUpdateManyWithWhereWithoutActivityRelationInput | ActivityContactJoinUpdateManyWithWhereWithoutActivityRelationInput[]
    deleteMany?: ActivityContactJoinScalarWhereInput | ActivityContactJoinScalarWhereInput[]
  }

  export type ActivityUserJoinUncheckedUpdateManyWithoutActivityRelationNestedInput = {
    create?: XOR<ActivityUserJoinCreateWithoutActivityRelationInput, ActivityUserJoinUncheckedCreateWithoutActivityRelationInput> | ActivityUserJoinCreateWithoutActivityRelationInput[] | ActivityUserJoinUncheckedCreateWithoutActivityRelationInput[]
    connectOrCreate?: ActivityUserJoinCreateOrConnectWithoutActivityRelationInput | ActivityUserJoinCreateOrConnectWithoutActivityRelationInput[]
    upsert?: ActivityUserJoinUpsertWithWhereUniqueWithoutActivityRelationInput | ActivityUserJoinUpsertWithWhereUniqueWithoutActivityRelationInput[]
    createMany?: ActivityUserJoinCreateManyActivityRelationInputEnvelope
    set?: ActivityUserJoinWhereUniqueInput | ActivityUserJoinWhereUniqueInput[]
    disconnect?: ActivityUserJoinWhereUniqueInput | ActivityUserJoinWhereUniqueInput[]
    delete?: ActivityUserJoinWhereUniqueInput | ActivityUserJoinWhereUniqueInput[]
    connect?: ActivityUserJoinWhereUniqueInput | ActivityUserJoinWhereUniqueInput[]
    update?: ActivityUserJoinUpdateWithWhereUniqueWithoutActivityRelationInput | ActivityUserJoinUpdateWithWhereUniqueWithoutActivityRelationInput[]
    updateMany?: ActivityUserJoinUpdateManyWithWhereWithoutActivityRelationInput | ActivityUserJoinUpdateManyWithWhereWithoutActivityRelationInput[]
    deleteMany?: ActivityUserJoinScalarWhereInput | ActivityUserJoinScalarWhereInput[]
  }

  export type AttachmentUncheckedUpdateManyWithoutActivityNestedInput = {
    create?: XOR<AttachmentCreateWithoutActivityInput, AttachmentUncheckedCreateWithoutActivityInput> | AttachmentCreateWithoutActivityInput[] | AttachmentUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutActivityInput | AttachmentCreateOrConnectWithoutActivityInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutActivityInput | AttachmentUpsertWithWhereUniqueWithoutActivityInput[]
    createMany?: AttachmentCreateManyActivityInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutActivityInput | AttachmentUpdateWithWhereUniqueWithoutActivityInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutActivityInput | AttachmentUpdateManyWithWhereWithoutActivityInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type NoteUncheckedUpdateManyWithoutActivityNestedInput = {
    create?: XOR<NoteCreateWithoutActivityInput, NoteUncheckedCreateWithoutActivityInput> | NoteCreateWithoutActivityInput[] | NoteUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutActivityInput | NoteCreateOrConnectWithoutActivityInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutActivityInput | NoteUpsertWithWhereUniqueWithoutActivityInput[]
    createMany?: NoteCreateManyActivityInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutActivityInput | NoteUpdateWithWhereUniqueWithoutActivityInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutActivityInput | NoteUpdateManyWithWhereWithoutActivityInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type ContactTimelineEventUncheckedUpdateManyWithoutActivityNestedInput = {
    create?: XOR<ContactTimelineEventCreateWithoutActivityInput, ContactTimelineEventUncheckedCreateWithoutActivityInput> | ContactTimelineEventCreateWithoutActivityInput[] | ContactTimelineEventUncheckedCreateWithoutActivityInput[]
    connectOrCreate?: ContactTimelineEventCreateOrConnectWithoutActivityInput | ContactTimelineEventCreateOrConnectWithoutActivityInput[]
    upsert?: ContactTimelineEventUpsertWithWhereUniqueWithoutActivityInput | ContactTimelineEventUpsertWithWhereUniqueWithoutActivityInput[]
    createMany?: ContactTimelineEventCreateManyActivityInputEnvelope
    set?: ContactTimelineEventWhereUniqueInput | ContactTimelineEventWhereUniqueInput[]
    disconnect?: ContactTimelineEventWhereUniqueInput | ContactTimelineEventWhereUniqueInput[]
    delete?: ContactTimelineEventWhereUniqueInput | ContactTimelineEventWhereUniqueInput[]
    connect?: ContactTimelineEventWhereUniqueInput | ContactTimelineEventWhereUniqueInput[]
    update?: ContactTimelineEventUpdateWithWhereUniqueWithoutActivityInput | ContactTimelineEventUpdateWithWhereUniqueWithoutActivityInput[]
    updateMany?: ContactTimelineEventUpdateManyWithWhereWithoutActivityInput | ContactTimelineEventUpdateManyWithWhereWithoutActivityInput[]
    deleteMany?: ContactTimelineEventScalarWhereInput | ContactTimelineEventScalarWhereInput[]
  }

  export type ActivityCreateNestedOneWithoutEventsInput = {
    create?: XOR<ActivityCreateWithoutEventsInput, ActivityUncheckedCreateWithoutEventsInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutEventsInput
    connect?: ActivityWhereUniqueInput
  }

  export type ActivityWaypointCreateNestedOneWithoutEventsInput = {
    create?: XOR<ActivityWaypointCreateWithoutEventsInput, ActivityWaypointUncheckedCreateWithoutEventsInput>
    connectOrCreate?: ActivityWaypointCreateOrConnectWithoutEventsInput
    connect?: ActivityWaypointWhereUniqueInput
  }

  export type OpportunityCreateNestedOneWithoutEventsInput = {
    create?: XOR<OpportunityCreateWithoutEventsInput, OpportunityUncheckedCreateWithoutEventsInput>
    connectOrCreate?: OpportunityCreateOrConnectWithoutEventsInput
    connect?: OpportunityWhereUniqueInput
  }

  export type NoteCreateNestedOneWithoutEventsInput = {
    create?: XOR<NoteCreateWithoutEventsInput, NoteUncheckedCreateWithoutEventsInput>
    connectOrCreate?: NoteCreateOrConnectWithoutEventsInput
    connect?: NoteWhereUniqueInput
  }

  export type ContactTimelineEventContactJoinCreateNestedManyWithoutContactEventRelationInput = {
    create?: XOR<ContactTimelineEventContactJoinCreateWithoutContactEventRelationInput, ContactTimelineEventContactJoinUncheckedCreateWithoutContactEventRelationInput> | ContactTimelineEventContactJoinCreateWithoutContactEventRelationInput[] | ContactTimelineEventContactJoinUncheckedCreateWithoutContactEventRelationInput[]
    connectOrCreate?: ContactTimelineEventContactJoinCreateOrConnectWithoutContactEventRelationInput | ContactTimelineEventContactJoinCreateOrConnectWithoutContactEventRelationInput[]
    createMany?: ContactTimelineEventContactJoinCreateManyContactEventRelationInputEnvelope
    connect?: ContactTimelineEventContactJoinWhereUniqueInput | ContactTimelineEventContactJoinWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutEventsInput = {
    create?: XOR<UserCreateWithoutEventsInput, UserUncheckedCreateWithoutEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEventsInput
    connect?: UserWhereUniqueInput
  }

  export type TenetCreateNestedOneWithoutContactTimelineEventsInput = {
    create?: XOR<TenetCreateWithoutContactTimelineEventsInput, TenetUncheckedCreateWithoutContactTimelineEventsInput>
    connectOrCreate?: TenetCreateOrConnectWithoutContactTimelineEventsInput
    connect?: TenetWhereUniqueInput
  }

  export type ContactTimelineEventContactJoinUncheckedCreateNestedManyWithoutContactEventRelationInput = {
    create?: XOR<ContactTimelineEventContactJoinCreateWithoutContactEventRelationInput, ContactTimelineEventContactJoinUncheckedCreateWithoutContactEventRelationInput> | ContactTimelineEventContactJoinCreateWithoutContactEventRelationInput[] | ContactTimelineEventContactJoinUncheckedCreateWithoutContactEventRelationInput[]
    connectOrCreate?: ContactTimelineEventContactJoinCreateOrConnectWithoutContactEventRelationInput | ContactTimelineEventContactJoinCreateOrConnectWithoutContactEventRelationInput[]
    createMany?: ContactTimelineEventContactJoinCreateManyContactEventRelationInputEnvelope
    connect?: ContactTimelineEventContactJoinWhereUniqueInput | ContactTimelineEventContactJoinWhereUniqueInput[]
  }

  export type EnumContactTimelineEventTypeFieldUpdateOperationsInput = {
    set?: $Enums.ContactTimelineEventType
  }

  export type ActivityUpdateOneWithoutEventsNestedInput = {
    create?: XOR<ActivityCreateWithoutEventsInput, ActivityUncheckedCreateWithoutEventsInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutEventsInput
    upsert?: ActivityUpsertWithoutEventsInput
    disconnect?: ActivityWhereInput | boolean
    delete?: ActivityWhereInput | boolean
    connect?: ActivityWhereUniqueInput
    update?: XOR<XOR<ActivityUpdateToOneWithWhereWithoutEventsInput, ActivityUpdateWithoutEventsInput>, ActivityUncheckedUpdateWithoutEventsInput>
  }

  export type ActivityWaypointUpdateOneWithoutEventsNestedInput = {
    create?: XOR<ActivityWaypointCreateWithoutEventsInput, ActivityWaypointUncheckedCreateWithoutEventsInput>
    connectOrCreate?: ActivityWaypointCreateOrConnectWithoutEventsInput
    upsert?: ActivityWaypointUpsertWithoutEventsInput
    disconnect?: ActivityWaypointWhereInput | boolean
    delete?: ActivityWaypointWhereInput | boolean
    connect?: ActivityWaypointWhereUniqueInput
    update?: XOR<XOR<ActivityWaypointUpdateToOneWithWhereWithoutEventsInput, ActivityWaypointUpdateWithoutEventsInput>, ActivityWaypointUncheckedUpdateWithoutEventsInput>
  }

  export type OpportunityUpdateOneWithoutEventsNestedInput = {
    create?: XOR<OpportunityCreateWithoutEventsInput, OpportunityUncheckedCreateWithoutEventsInput>
    connectOrCreate?: OpportunityCreateOrConnectWithoutEventsInput
    upsert?: OpportunityUpsertWithoutEventsInput
    disconnect?: OpportunityWhereInput | boolean
    delete?: OpportunityWhereInput | boolean
    connect?: OpportunityWhereUniqueInput
    update?: XOR<XOR<OpportunityUpdateToOneWithWhereWithoutEventsInput, OpportunityUpdateWithoutEventsInput>, OpportunityUncheckedUpdateWithoutEventsInput>
  }

  export type NoteUpdateOneWithoutEventsNestedInput = {
    create?: XOR<NoteCreateWithoutEventsInput, NoteUncheckedCreateWithoutEventsInput>
    connectOrCreate?: NoteCreateOrConnectWithoutEventsInput
    upsert?: NoteUpsertWithoutEventsInput
    disconnect?: NoteWhereInput | boolean
    delete?: NoteWhereInput | boolean
    connect?: NoteWhereUniqueInput
    update?: XOR<XOR<NoteUpdateToOneWithWhereWithoutEventsInput, NoteUpdateWithoutEventsInput>, NoteUncheckedUpdateWithoutEventsInput>
  }

  export type ContactTimelineEventContactJoinUpdateManyWithoutContactEventRelationNestedInput = {
    create?: XOR<ContactTimelineEventContactJoinCreateWithoutContactEventRelationInput, ContactTimelineEventContactJoinUncheckedCreateWithoutContactEventRelationInput> | ContactTimelineEventContactJoinCreateWithoutContactEventRelationInput[] | ContactTimelineEventContactJoinUncheckedCreateWithoutContactEventRelationInput[]
    connectOrCreate?: ContactTimelineEventContactJoinCreateOrConnectWithoutContactEventRelationInput | ContactTimelineEventContactJoinCreateOrConnectWithoutContactEventRelationInput[]
    upsert?: ContactTimelineEventContactJoinUpsertWithWhereUniqueWithoutContactEventRelationInput | ContactTimelineEventContactJoinUpsertWithWhereUniqueWithoutContactEventRelationInput[]
    createMany?: ContactTimelineEventContactJoinCreateManyContactEventRelationInputEnvelope
    set?: ContactTimelineEventContactJoinWhereUniqueInput | ContactTimelineEventContactJoinWhereUniqueInput[]
    disconnect?: ContactTimelineEventContactJoinWhereUniqueInput | ContactTimelineEventContactJoinWhereUniqueInput[]
    delete?: ContactTimelineEventContactJoinWhereUniqueInput | ContactTimelineEventContactJoinWhereUniqueInput[]
    connect?: ContactTimelineEventContactJoinWhereUniqueInput | ContactTimelineEventContactJoinWhereUniqueInput[]
    update?: ContactTimelineEventContactJoinUpdateWithWhereUniqueWithoutContactEventRelationInput | ContactTimelineEventContactJoinUpdateWithWhereUniqueWithoutContactEventRelationInput[]
    updateMany?: ContactTimelineEventContactJoinUpdateManyWithWhereWithoutContactEventRelationInput | ContactTimelineEventContactJoinUpdateManyWithWhereWithoutContactEventRelationInput[]
    deleteMany?: ContactTimelineEventContactJoinScalarWhereInput | ContactTimelineEventContactJoinScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutEventsNestedInput = {
    create?: XOR<UserCreateWithoutEventsInput, UserUncheckedCreateWithoutEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEventsInput
    upsert?: UserUpsertWithoutEventsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEventsInput, UserUpdateWithoutEventsInput>, UserUncheckedUpdateWithoutEventsInput>
  }

  export type TenetUpdateOneRequiredWithoutContactTimelineEventsNestedInput = {
    create?: XOR<TenetCreateWithoutContactTimelineEventsInput, TenetUncheckedCreateWithoutContactTimelineEventsInput>
    connectOrCreate?: TenetCreateOrConnectWithoutContactTimelineEventsInput
    upsert?: TenetUpsertWithoutContactTimelineEventsInput
    connect?: TenetWhereUniqueInput
    update?: XOR<XOR<TenetUpdateToOneWithWhereWithoutContactTimelineEventsInput, TenetUpdateWithoutContactTimelineEventsInput>, TenetUncheckedUpdateWithoutContactTimelineEventsInput>
  }

  export type ContactTimelineEventContactJoinUncheckedUpdateManyWithoutContactEventRelationNestedInput = {
    create?: XOR<ContactTimelineEventContactJoinCreateWithoutContactEventRelationInput, ContactTimelineEventContactJoinUncheckedCreateWithoutContactEventRelationInput> | ContactTimelineEventContactJoinCreateWithoutContactEventRelationInput[] | ContactTimelineEventContactJoinUncheckedCreateWithoutContactEventRelationInput[]
    connectOrCreate?: ContactTimelineEventContactJoinCreateOrConnectWithoutContactEventRelationInput | ContactTimelineEventContactJoinCreateOrConnectWithoutContactEventRelationInput[]
    upsert?: ContactTimelineEventContactJoinUpsertWithWhereUniqueWithoutContactEventRelationInput | ContactTimelineEventContactJoinUpsertWithWhereUniqueWithoutContactEventRelationInput[]
    createMany?: ContactTimelineEventContactJoinCreateManyContactEventRelationInputEnvelope
    set?: ContactTimelineEventContactJoinWhereUniqueInput | ContactTimelineEventContactJoinWhereUniqueInput[]
    disconnect?: ContactTimelineEventContactJoinWhereUniqueInput | ContactTimelineEventContactJoinWhereUniqueInput[]
    delete?: ContactTimelineEventContactJoinWhereUniqueInput | ContactTimelineEventContactJoinWhereUniqueInput[]
    connect?: ContactTimelineEventContactJoinWhereUniqueInput | ContactTimelineEventContactJoinWhereUniqueInput[]
    update?: ContactTimelineEventContactJoinUpdateWithWhereUniqueWithoutContactEventRelationInput | ContactTimelineEventContactJoinUpdateWithWhereUniqueWithoutContactEventRelationInput[]
    updateMany?: ContactTimelineEventContactJoinUpdateManyWithWhereWithoutContactEventRelationInput | ContactTimelineEventContactJoinUpdateManyWithWhereWithoutContactEventRelationInput[]
    deleteMany?: ContactTimelineEventContactJoinScalarWhereInput | ContactTimelineEventContactJoinScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAuditEventsInput = {
    create?: XOR<UserCreateWithoutAuditEventsInput, UserUncheckedCreateWithoutAuditEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditEventsInput
    connect?: UserWhereUniqueInput
  }

  export type TenetCreateNestedOneWithoutAuditEventsInput = {
    create?: XOR<TenetCreateWithoutAuditEventsInput, TenetUncheckedCreateWithoutAuditEventsInput>
    connectOrCreate?: TenetCreateOrConnectWithoutAuditEventsInput
    connect?: TenetWhereUniqueInput
  }

  export type EnumAuditEventTypeFieldUpdateOperationsInput = {
    set?: $Enums.AuditEventType
  }

  export type EnumAuditableFieldUpdateOperationsInput = {
    set?: $Enums.Auditable
  }

  export type UserUpdateOneRequiredWithoutAuditEventsNestedInput = {
    create?: XOR<UserCreateWithoutAuditEventsInput, UserUncheckedCreateWithoutAuditEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditEventsInput
    upsert?: UserUpsertWithoutAuditEventsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditEventsInput, UserUpdateWithoutAuditEventsInput>, UserUncheckedUpdateWithoutAuditEventsInput>
  }

  export type TenetUpdateOneRequiredWithoutAuditEventsNestedInput = {
    create?: XOR<TenetCreateWithoutAuditEventsInput, TenetUncheckedCreateWithoutAuditEventsInput>
    connectOrCreate?: TenetCreateOrConnectWithoutAuditEventsInput
    upsert?: TenetUpsertWithoutAuditEventsInput
    connect?: TenetWhereUniqueInput
    update?: XOR<XOR<TenetUpdateToOneWithWhereWithoutAuditEventsInput, TenetUpdateWithoutAuditEventsInput>, TenetUncheckedUpdateWithoutAuditEventsInput>
  }

  export type ContactTimelineEventCreateNestedOneWithoutContactsInput = {
    create?: XOR<ContactTimelineEventCreateWithoutContactsInput, ContactTimelineEventUncheckedCreateWithoutContactsInput>
    connectOrCreate?: ContactTimelineEventCreateOrConnectWithoutContactsInput
    connect?: ContactTimelineEventWhereUniqueInput
  }

  export type ContactCreateNestedOneWithoutTimelineEventsInput = {
    create?: XOR<ContactCreateWithoutTimelineEventsInput, ContactUncheckedCreateWithoutTimelineEventsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutTimelineEventsInput
    connect?: ContactWhereUniqueInput
  }

  export type EnumContactTimelineEventJoinTypeFieldUpdateOperationsInput = {
    set?: $Enums.ContactTimelineEventJoinType
  }

  export type ContactTimelineEventUpdateOneRequiredWithoutContactsNestedInput = {
    create?: XOR<ContactTimelineEventCreateWithoutContactsInput, ContactTimelineEventUncheckedCreateWithoutContactsInput>
    connectOrCreate?: ContactTimelineEventCreateOrConnectWithoutContactsInput
    upsert?: ContactTimelineEventUpsertWithoutContactsInput
    connect?: ContactTimelineEventWhereUniqueInput
    update?: XOR<XOR<ContactTimelineEventUpdateToOneWithWhereWithoutContactsInput, ContactTimelineEventUpdateWithoutContactsInput>, ContactTimelineEventUncheckedUpdateWithoutContactsInput>
  }

  export type ContactUpdateOneRequiredWithoutTimelineEventsNestedInput = {
    create?: XOR<ContactCreateWithoutTimelineEventsInput, ContactUncheckedCreateWithoutTimelineEventsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutTimelineEventsInput
    upsert?: ContactUpsertWithoutTimelineEventsInput
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutTimelineEventsInput, ContactUpdateWithoutTimelineEventsInput>, ContactUncheckedUpdateWithoutTimelineEventsInput>
  }

  export type ActivityWaypointCreateNestedOneWithoutNoteInput = {
    create?: XOR<ActivityWaypointCreateWithoutNoteInput, ActivityWaypointUncheckedCreateWithoutNoteInput>
    connectOrCreate?: ActivityWaypointCreateOrConnectWithoutNoteInput
    connect?: ActivityWaypointWhereUniqueInput
  }

  export type ActivityCreateNestedOneWithoutNotesInput = {
    create?: XOR<ActivityCreateWithoutNotesInput, ActivityUncheckedCreateWithoutNotesInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutNotesInput
    connect?: ActivityWhereUniqueInput
  }

  export type ContactCreateNestedOneWithoutNotesInput = {
    create?: XOR<ContactCreateWithoutNotesInput, ContactUncheckedCreateWithoutNotesInput>
    connectOrCreate?: ContactCreateOrConnectWithoutNotesInput
    connect?: ContactWhereUniqueInput
  }

  export type OpportunityCreateNestedOneWithoutNotesInput = {
    create?: XOR<OpportunityCreateWithoutNotesInput, OpportunityUncheckedCreateWithoutNotesInput>
    connectOrCreate?: OpportunityCreateOrConnectWithoutNotesInput
    connect?: OpportunityWhereUniqueInput
  }

  export type TenetCreateNestedOneWithoutNotesInput = {
    create?: XOR<TenetCreateWithoutNotesInput, TenetUncheckedCreateWithoutNotesInput>
    connectOrCreate?: TenetCreateOrConnectWithoutNotesInput
    connect?: TenetWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutNotesInput = {
    create?: XOR<UserCreateWithoutNotesInput, UserUncheckedCreateWithoutNotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotesInput
    connect?: UserWhereUniqueInput
  }

  export type ContactTimelineEventCreateNestedManyWithoutNoteInput = {
    create?: XOR<ContactTimelineEventCreateWithoutNoteInput, ContactTimelineEventUncheckedCreateWithoutNoteInput> | ContactTimelineEventCreateWithoutNoteInput[] | ContactTimelineEventUncheckedCreateWithoutNoteInput[]
    connectOrCreate?: ContactTimelineEventCreateOrConnectWithoutNoteInput | ContactTimelineEventCreateOrConnectWithoutNoteInput[]
    createMany?: ContactTimelineEventCreateManyNoteInputEnvelope
    connect?: ContactTimelineEventWhereUniqueInput | ContactTimelineEventWhereUniqueInput[]
  }

  export type ContactTimelineEventUncheckedCreateNestedManyWithoutNoteInput = {
    create?: XOR<ContactTimelineEventCreateWithoutNoteInput, ContactTimelineEventUncheckedCreateWithoutNoteInput> | ContactTimelineEventCreateWithoutNoteInput[] | ContactTimelineEventUncheckedCreateWithoutNoteInput[]
    connectOrCreate?: ContactTimelineEventCreateOrConnectWithoutNoteInput | ContactTimelineEventCreateOrConnectWithoutNoteInput[]
    createMany?: ContactTimelineEventCreateManyNoteInputEnvelope
    connect?: ContactTimelineEventWhereUniqueInput | ContactTimelineEventWhereUniqueInput[]
  }

  export type EnumNoteTypeFieldUpdateOperationsInput = {
    set?: $Enums.NoteType
  }

  export type ActivityWaypointUpdateOneWithoutNoteNestedInput = {
    create?: XOR<ActivityWaypointCreateWithoutNoteInput, ActivityWaypointUncheckedCreateWithoutNoteInput>
    connectOrCreate?: ActivityWaypointCreateOrConnectWithoutNoteInput
    upsert?: ActivityWaypointUpsertWithoutNoteInput
    disconnect?: ActivityWaypointWhereInput | boolean
    delete?: ActivityWaypointWhereInput | boolean
    connect?: ActivityWaypointWhereUniqueInput
    update?: XOR<XOR<ActivityWaypointUpdateToOneWithWhereWithoutNoteInput, ActivityWaypointUpdateWithoutNoteInput>, ActivityWaypointUncheckedUpdateWithoutNoteInput>
  }

  export type ActivityUpdateOneWithoutNotesNestedInput = {
    create?: XOR<ActivityCreateWithoutNotesInput, ActivityUncheckedCreateWithoutNotesInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutNotesInput
    upsert?: ActivityUpsertWithoutNotesInput
    disconnect?: ActivityWhereInput | boolean
    delete?: ActivityWhereInput | boolean
    connect?: ActivityWhereUniqueInput
    update?: XOR<XOR<ActivityUpdateToOneWithWhereWithoutNotesInput, ActivityUpdateWithoutNotesInput>, ActivityUncheckedUpdateWithoutNotesInput>
  }

  export type ContactUpdateOneWithoutNotesNestedInput = {
    create?: XOR<ContactCreateWithoutNotesInput, ContactUncheckedCreateWithoutNotesInput>
    connectOrCreate?: ContactCreateOrConnectWithoutNotesInput
    upsert?: ContactUpsertWithoutNotesInput
    disconnect?: ContactWhereInput | boolean
    delete?: ContactWhereInput | boolean
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutNotesInput, ContactUpdateWithoutNotesInput>, ContactUncheckedUpdateWithoutNotesInput>
  }

  export type OpportunityUpdateOneWithoutNotesNestedInput = {
    create?: XOR<OpportunityCreateWithoutNotesInput, OpportunityUncheckedCreateWithoutNotesInput>
    connectOrCreate?: OpportunityCreateOrConnectWithoutNotesInput
    upsert?: OpportunityUpsertWithoutNotesInput
    disconnect?: OpportunityWhereInput | boolean
    delete?: OpportunityWhereInput | boolean
    connect?: OpportunityWhereUniqueInput
    update?: XOR<XOR<OpportunityUpdateToOneWithWhereWithoutNotesInput, OpportunityUpdateWithoutNotesInput>, OpportunityUncheckedUpdateWithoutNotesInput>
  }

  export type TenetUpdateOneRequiredWithoutNotesNestedInput = {
    create?: XOR<TenetCreateWithoutNotesInput, TenetUncheckedCreateWithoutNotesInput>
    connectOrCreate?: TenetCreateOrConnectWithoutNotesInput
    upsert?: TenetUpsertWithoutNotesInput
    connect?: TenetWhereUniqueInput
    update?: XOR<XOR<TenetUpdateToOneWithWhereWithoutNotesInput, TenetUpdateWithoutNotesInput>, TenetUncheckedUpdateWithoutNotesInput>
  }

  export type UserUpdateOneRequiredWithoutNotesNestedInput = {
    create?: XOR<UserCreateWithoutNotesInput, UserUncheckedCreateWithoutNotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotesInput
    upsert?: UserUpsertWithoutNotesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotesInput, UserUpdateWithoutNotesInput>, UserUncheckedUpdateWithoutNotesInput>
  }

  export type ContactTimelineEventUpdateManyWithoutNoteNestedInput = {
    create?: XOR<ContactTimelineEventCreateWithoutNoteInput, ContactTimelineEventUncheckedCreateWithoutNoteInput> | ContactTimelineEventCreateWithoutNoteInput[] | ContactTimelineEventUncheckedCreateWithoutNoteInput[]
    connectOrCreate?: ContactTimelineEventCreateOrConnectWithoutNoteInput | ContactTimelineEventCreateOrConnectWithoutNoteInput[]
    upsert?: ContactTimelineEventUpsertWithWhereUniqueWithoutNoteInput | ContactTimelineEventUpsertWithWhereUniqueWithoutNoteInput[]
    createMany?: ContactTimelineEventCreateManyNoteInputEnvelope
    set?: ContactTimelineEventWhereUniqueInput | ContactTimelineEventWhereUniqueInput[]
    disconnect?: ContactTimelineEventWhereUniqueInput | ContactTimelineEventWhereUniqueInput[]
    delete?: ContactTimelineEventWhereUniqueInput | ContactTimelineEventWhereUniqueInput[]
    connect?: ContactTimelineEventWhereUniqueInput | ContactTimelineEventWhereUniqueInput[]
    update?: ContactTimelineEventUpdateWithWhereUniqueWithoutNoteInput | ContactTimelineEventUpdateWithWhereUniqueWithoutNoteInput[]
    updateMany?: ContactTimelineEventUpdateManyWithWhereWithoutNoteInput | ContactTimelineEventUpdateManyWithWhereWithoutNoteInput[]
    deleteMany?: ContactTimelineEventScalarWhereInput | ContactTimelineEventScalarWhereInput[]
  }

  export type ContactTimelineEventUncheckedUpdateManyWithoutNoteNestedInput = {
    create?: XOR<ContactTimelineEventCreateWithoutNoteInput, ContactTimelineEventUncheckedCreateWithoutNoteInput> | ContactTimelineEventCreateWithoutNoteInput[] | ContactTimelineEventUncheckedCreateWithoutNoteInput[]
    connectOrCreate?: ContactTimelineEventCreateOrConnectWithoutNoteInput | ContactTimelineEventCreateOrConnectWithoutNoteInput[]
    upsert?: ContactTimelineEventUpsertWithWhereUniqueWithoutNoteInput | ContactTimelineEventUpsertWithWhereUniqueWithoutNoteInput[]
    createMany?: ContactTimelineEventCreateManyNoteInputEnvelope
    set?: ContactTimelineEventWhereUniqueInput | ContactTimelineEventWhereUniqueInput[]
    disconnect?: ContactTimelineEventWhereUniqueInput | ContactTimelineEventWhereUniqueInput[]
    delete?: ContactTimelineEventWhereUniqueInput | ContactTimelineEventWhereUniqueInput[]
    connect?: ContactTimelineEventWhereUniqueInput | ContactTimelineEventWhereUniqueInput[]
    update?: ContactTimelineEventUpdateWithWhereUniqueWithoutNoteInput | ContactTimelineEventUpdateWithWhereUniqueWithoutNoteInput[]
    updateMany?: ContactTimelineEventUpdateManyWithWhereWithoutNoteInput | ContactTimelineEventUpdateManyWithWhereWithoutNoteInput[]
    deleteMany?: ContactTimelineEventScalarWhereInput | ContactTimelineEventScalarWhereInput[]
  }

  export type ActivityCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<ActivityCreateWithoutAttachmentsInput, ActivityUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutAttachmentsInput
    connect?: ActivityWhereUniqueInput
  }

  export type TenetCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<TenetCreateWithoutAttachmentsInput, TenetUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: TenetCreateOrConnectWithoutAttachmentsInput
    connect?: TenetWhereUniqueInput
  }

  export type ActivityUpdateOneWithoutAttachmentsNestedInput = {
    create?: XOR<ActivityCreateWithoutAttachmentsInput, ActivityUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutAttachmentsInput
    upsert?: ActivityUpsertWithoutAttachmentsInput
    disconnect?: ActivityWhereInput | boolean
    delete?: ActivityWhereInput | boolean
    connect?: ActivityWhereUniqueInput
    update?: XOR<XOR<ActivityUpdateToOneWithWhereWithoutAttachmentsInput, ActivityUpdateWithoutAttachmentsInput>, ActivityUncheckedUpdateWithoutAttachmentsInput>
  }

  export type TenetUpdateOneRequiredWithoutAttachmentsNestedInput = {
    create?: XOR<TenetCreateWithoutAttachmentsInput, TenetUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: TenetCreateOrConnectWithoutAttachmentsInput
    upsert?: TenetUpsertWithoutAttachmentsInput
    connect?: TenetWhereUniqueInput
    update?: XOR<XOR<TenetUpdateToOneWithWhereWithoutAttachmentsInput, TenetUpdateWithoutAttachmentsInput>, TenetUncheckedUpdateWithoutAttachmentsInput>
  }

  export type ActivityCreateNestedOneWithoutContactsInput = {
    create?: XOR<ActivityCreateWithoutContactsInput, ActivityUncheckedCreateWithoutContactsInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutContactsInput
    connect?: ActivityWhereUniqueInput
  }

  export type ContactCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<ContactCreateWithoutActivitiesInput, ContactUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: ContactCreateOrConnectWithoutActivitiesInput
    connect?: ContactWhereUniqueInput
  }

  export type ActivityUpdateOneRequiredWithoutContactsNestedInput = {
    create?: XOR<ActivityCreateWithoutContactsInput, ActivityUncheckedCreateWithoutContactsInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutContactsInput
    upsert?: ActivityUpsertWithoutContactsInput
    connect?: ActivityWhereUniqueInput
    update?: XOR<XOR<ActivityUpdateToOneWithWhereWithoutContactsInput, ActivityUpdateWithoutContactsInput>, ActivityUncheckedUpdateWithoutContactsInput>
  }

  export type ContactUpdateOneRequiredWithoutActivitiesNestedInput = {
    create?: XOR<ContactCreateWithoutActivitiesInput, ContactUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: ContactCreateOrConnectWithoutActivitiesInput
    upsert?: ContactUpsertWithoutActivitiesInput
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutActivitiesInput, ContactUpdateWithoutActivitiesInput>, ContactUncheckedUpdateWithoutActivitiesInput>
  }

  export type ActivityCreateNestedOneWithoutUsersInput = {
    create?: XOR<ActivityCreateWithoutUsersInput, ActivityUncheckedCreateWithoutUsersInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutUsersInput
    connect?: ActivityWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivitiesInput
    connect?: UserWhereUniqueInput
  }

  export type ActivityUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<ActivityCreateWithoutUsersInput, ActivityUncheckedCreateWithoutUsersInput>
    connectOrCreate?: ActivityCreateOrConnectWithoutUsersInput
    upsert?: ActivityUpsertWithoutUsersInput
    connect?: ActivityWhereUniqueInput
    update?: XOR<XOR<ActivityUpdateToOneWithWhereWithoutUsersInput, ActivityUpdateWithoutUsersInput>, ActivityUncheckedUpdateWithoutUsersInput>
  }

  export type UserUpdateOneRequiredWithoutActivitiesNestedInput = {
    create?: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivitiesInput
    upsert?: UserUpsertWithoutActivitiesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutActivitiesInput, UserUpdateWithoutActivitiesInput>, UserUncheckedUpdateWithoutActivitiesInput>
  }

  export type ContactCreateNestedOneWithoutEmailsInput = {
    create?: XOR<ContactCreateWithoutEmailsInput, ContactUncheckedCreateWithoutEmailsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutEmailsInput
    connect?: ContactWhereUniqueInput
  }

  export type TenetCreateNestedOneWithoutContactEmailsInput = {
    create?: XOR<TenetCreateWithoutContactEmailsInput, TenetUncheckedCreateWithoutContactEmailsInput>
    connectOrCreate?: TenetCreateOrConnectWithoutContactEmailsInput
    connect?: TenetWhereUniqueInput
  }

  export type ContactUpdateOneRequiredWithoutEmailsNestedInput = {
    create?: XOR<ContactCreateWithoutEmailsInput, ContactUncheckedCreateWithoutEmailsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutEmailsInput
    upsert?: ContactUpsertWithoutEmailsInput
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutEmailsInput, ContactUpdateWithoutEmailsInput>, ContactUncheckedUpdateWithoutEmailsInput>
  }

  export type TenetUpdateOneRequiredWithoutContactEmailsNestedInput = {
    create?: XOR<TenetCreateWithoutContactEmailsInput, TenetUncheckedCreateWithoutContactEmailsInput>
    connectOrCreate?: TenetCreateOrConnectWithoutContactEmailsInput
    upsert?: TenetUpsertWithoutContactEmailsInput
    connect?: TenetWhereUniqueInput
    update?: XOR<XOR<TenetUpdateToOneWithWhereWithoutContactEmailsInput, TenetUpdateWithoutContactEmailsInput>, TenetUncheckedUpdateWithoutContactEmailsInput>
  }

  export type ContactCreateNestedOneWithoutPhonesInput = {
    create?: XOR<ContactCreateWithoutPhonesInput, ContactUncheckedCreateWithoutPhonesInput>
    connectOrCreate?: ContactCreateOrConnectWithoutPhonesInput
    connect?: ContactWhereUniqueInput
  }

  export type TenetCreateNestedOneWithoutContactPhonesInput = {
    create?: XOR<TenetCreateWithoutContactPhonesInput, TenetUncheckedCreateWithoutContactPhonesInput>
    connectOrCreate?: TenetCreateOrConnectWithoutContactPhonesInput
    connect?: TenetWhereUniqueInput
  }

  export type EnumPhoneTypeFieldUpdateOperationsInput = {
    set?: $Enums.PhoneType
  }

  export type ContactUpdateOneRequiredWithoutPhonesNestedInput = {
    create?: XOR<ContactCreateWithoutPhonesInput, ContactUncheckedCreateWithoutPhonesInput>
    connectOrCreate?: ContactCreateOrConnectWithoutPhonesInput
    upsert?: ContactUpsertWithoutPhonesInput
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutPhonesInput, ContactUpdateWithoutPhonesInput>, ContactUncheckedUpdateWithoutPhonesInput>
  }

  export type TenetUpdateOneRequiredWithoutContactPhonesNestedInput = {
    create?: XOR<TenetCreateWithoutContactPhonesInput, TenetUncheckedCreateWithoutContactPhonesInput>
    connectOrCreate?: TenetCreateOrConnectWithoutContactPhonesInput
    upsert?: TenetUpsertWithoutContactPhonesInput
    connect?: TenetWhereUniqueInput
    update?: XOR<XOR<TenetUpdateToOneWithWhereWithoutContactPhonesInput, TenetUpdateWithoutContactPhonesInput>, TenetUncheckedUpdateWithoutContactPhonesInput>
  }

  export type ContactCreateNestedOneWithoutAddressesInput = {
    create?: XOR<ContactCreateWithoutAddressesInput, ContactUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: ContactCreateOrConnectWithoutAddressesInput
    connect?: ContactWhereUniqueInput
  }

  export type TenetCreateNestedOneWithoutAddressesInput = {
    create?: XOR<TenetCreateWithoutAddressesInput, TenetUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: TenetCreateOrConnectWithoutAddressesInput
    connect?: TenetWhereUniqueInput
  }

  export type EnumAddressTypeFieldUpdateOperationsInput = {
    set?: $Enums.AddressType
  }

  export type ContactUpdateOneRequiredWithoutAddressesNestedInput = {
    create?: XOR<ContactCreateWithoutAddressesInput, ContactUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: ContactCreateOrConnectWithoutAddressesInput
    upsert?: ContactUpsertWithoutAddressesInput
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutAddressesInput, ContactUpdateWithoutAddressesInput>, ContactUncheckedUpdateWithoutAddressesInput>
  }

  export type TenetUpdateOneRequiredWithoutAddressesNestedInput = {
    create?: XOR<TenetCreateWithoutAddressesInput, TenetUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: TenetCreateOrConnectWithoutAddressesInput
    upsert?: TenetUpsertWithoutAddressesInput
    connect?: TenetWhereUniqueInput
    update?: XOR<XOR<TenetUpdateToOneWithWhereWithoutAddressesInput, TenetUpdateWithoutAddressesInput>, TenetUncheckedUpdateWithoutAddressesInput>
  }

  export type ContactCreateNestedOneWithoutImportantDatesInput = {
    create?: XOR<ContactCreateWithoutImportantDatesInput, ContactUncheckedCreateWithoutImportantDatesInput>
    connectOrCreate?: ContactCreateOrConnectWithoutImportantDatesInput
    connect?: ContactWhereUniqueInput
  }

  export type TenetCreateNestedOneWithoutImportantDatesInput = {
    create?: XOR<TenetCreateWithoutImportantDatesInput, TenetUncheckedCreateWithoutImportantDatesInput>
    connectOrCreate?: TenetCreateOrConnectWithoutImportantDatesInput
    connect?: TenetWhereUniqueInput
  }

  export type EnumImportantDateTypeFieldUpdateOperationsInput = {
    set?: $Enums.ImportantDateType
  }

  export type ContactUpdateOneRequiredWithoutImportantDatesNestedInput = {
    create?: XOR<ContactCreateWithoutImportantDatesInput, ContactUncheckedCreateWithoutImportantDatesInput>
    connectOrCreate?: ContactCreateOrConnectWithoutImportantDatesInput
    upsert?: ContactUpsertWithoutImportantDatesInput
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutImportantDatesInput, ContactUpdateWithoutImportantDatesInput>, ContactUncheckedUpdateWithoutImportantDatesInput>
  }

  export type TenetUpdateOneRequiredWithoutImportantDatesNestedInput = {
    create?: XOR<TenetCreateWithoutImportantDatesInput, TenetUncheckedCreateWithoutImportantDatesInput>
    connectOrCreate?: TenetCreateOrConnectWithoutImportantDatesInput
    upsert?: TenetUpsertWithoutImportantDatesInput
    connect?: TenetWhereUniqueInput
    update?: XOR<XOR<TenetUpdateToOneWithWhereWithoutImportantDatesInput, TenetUpdateWithoutImportantDatesInput>, TenetUncheckedUpdateWithoutImportantDatesInput>
  }

  export type OpportunityCreatestatusHistoryInput = {
    set: $Enums.OpportunityStatus[]
  }

  export type ContactOpportunityJoinCreateNestedManyWithoutOpportunityRelationInput = {
    create?: XOR<ContactOpportunityJoinCreateWithoutOpportunityRelationInput, ContactOpportunityJoinUncheckedCreateWithoutOpportunityRelationInput> | ContactOpportunityJoinCreateWithoutOpportunityRelationInput[] | ContactOpportunityJoinUncheckedCreateWithoutOpportunityRelationInput[]
    connectOrCreate?: ContactOpportunityJoinCreateOrConnectWithoutOpportunityRelationInput | ContactOpportunityJoinCreateOrConnectWithoutOpportunityRelationInput[]
    createMany?: ContactOpportunityJoinCreateManyOpportunityRelationInputEnvelope
    connect?: ContactOpportunityJoinWhereUniqueInput | ContactOpportunityJoinWhereUniqueInput[]
  }

  export type UserOpportunityJoinCreateNestedManyWithoutOpportunityRelationInput = {
    create?: XOR<UserOpportunityJoinCreateWithoutOpportunityRelationInput, UserOpportunityJoinUncheckedCreateWithoutOpportunityRelationInput> | UserOpportunityJoinCreateWithoutOpportunityRelationInput[] | UserOpportunityJoinUncheckedCreateWithoutOpportunityRelationInput[]
    connectOrCreate?: UserOpportunityJoinCreateOrConnectWithoutOpportunityRelationInput | UserOpportunityJoinCreateOrConnectWithoutOpportunityRelationInput[]
    createMany?: UserOpportunityJoinCreateManyOpportunityRelationInputEnvelope
    connect?: UserOpportunityJoinWhereUniqueInput | UserOpportunityJoinWhereUniqueInput[]
  }

  export type ActivityCreateNestedManyWithoutOpportunityInput = {
    create?: XOR<ActivityCreateWithoutOpportunityInput, ActivityUncheckedCreateWithoutOpportunityInput> | ActivityCreateWithoutOpportunityInput[] | ActivityUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutOpportunityInput | ActivityCreateOrConnectWithoutOpportunityInput[]
    createMany?: ActivityCreateManyOpportunityInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type OpportunityProductCreateNestedManyWithoutOpportunityInput = {
    create?: XOR<OpportunityProductCreateWithoutOpportunityInput, OpportunityProductUncheckedCreateWithoutOpportunityInput> | OpportunityProductCreateWithoutOpportunityInput[] | OpportunityProductUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: OpportunityProductCreateOrConnectWithoutOpportunityInput | OpportunityProductCreateOrConnectWithoutOpportunityInput[]
    createMany?: OpportunityProductCreateManyOpportunityInputEnvelope
    connect?: OpportunityProductWhereUniqueInput | OpportunityProductWhereUniqueInput[]
  }

  export type TenetCreateNestedOneWithoutOpportunitiesInput = {
    create?: XOR<TenetCreateWithoutOpportunitiesInput, TenetUncheckedCreateWithoutOpportunitiesInput>
    connectOrCreate?: TenetCreateOrConnectWithoutOpportunitiesInput
    connect?: TenetWhereUniqueInput
  }

  export type ContactTimelineEventCreateNestedManyWithoutOpportunityInput = {
    create?: XOR<ContactTimelineEventCreateWithoutOpportunityInput, ContactTimelineEventUncheckedCreateWithoutOpportunityInput> | ContactTimelineEventCreateWithoutOpportunityInput[] | ContactTimelineEventUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: ContactTimelineEventCreateOrConnectWithoutOpportunityInput | ContactTimelineEventCreateOrConnectWithoutOpportunityInput[]
    createMany?: ContactTimelineEventCreateManyOpportunityInputEnvelope
    connect?: ContactTimelineEventWhereUniqueInput | ContactTimelineEventWhereUniqueInput[]
  }

  export type NoteCreateNestedManyWithoutOpportunityInput = {
    create?: XOR<NoteCreateWithoutOpportunityInput, NoteUncheckedCreateWithoutOpportunityInput> | NoteCreateWithoutOpportunityInput[] | NoteUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutOpportunityInput | NoteCreateOrConnectWithoutOpportunityInput[]
    createMany?: NoteCreateManyOpportunityInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type ContactOpportunityJoinUncheckedCreateNestedManyWithoutOpportunityRelationInput = {
    create?: XOR<ContactOpportunityJoinCreateWithoutOpportunityRelationInput, ContactOpportunityJoinUncheckedCreateWithoutOpportunityRelationInput> | ContactOpportunityJoinCreateWithoutOpportunityRelationInput[] | ContactOpportunityJoinUncheckedCreateWithoutOpportunityRelationInput[]
    connectOrCreate?: ContactOpportunityJoinCreateOrConnectWithoutOpportunityRelationInput | ContactOpportunityJoinCreateOrConnectWithoutOpportunityRelationInput[]
    createMany?: ContactOpportunityJoinCreateManyOpportunityRelationInputEnvelope
    connect?: ContactOpportunityJoinWhereUniqueInput | ContactOpportunityJoinWhereUniqueInput[]
  }

  export type UserOpportunityJoinUncheckedCreateNestedManyWithoutOpportunityRelationInput = {
    create?: XOR<UserOpportunityJoinCreateWithoutOpportunityRelationInput, UserOpportunityJoinUncheckedCreateWithoutOpportunityRelationInput> | UserOpportunityJoinCreateWithoutOpportunityRelationInput[] | UserOpportunityJoinUncheckedCreateWithoutOpportunityRelationInput[]
    connectOrCreate?: UserOpportunityJoinCreateOrConnectWithoutOpportunityRelationInput | UserOpportunityJoinCreateOrConnectWithoutOpportunityRelationInput[]
    createMany?: UserOpportunityJoinCreateManyOpportunityRelationInputEnvelope
    connect?: UserOpportunityJoinWhereUniqueInput | UserOpportunityJoinWhereUniqueInput[]
  }

  export type ActivityUncheckedCreateNestedManyWithoutOpportunityInput = {
    create?: XOR<ActivityCreateWithoutOpportunityInput, ActivityUncheckedCreateWithoutOpportunityInput> | ActivityCreateWithoutOpportunityInput[] | ActivityUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutOpportunityInput | ActivityCreateOrConnectWithoutOpportunityInput[]
    createMany?: ActivityCreateManyOpportunityInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type OpportunityProductUncheckedCreateNestedManyWithoutOpportunityInput = {
    create?: XOR<OpportunityProductCreateWithoutOpportunityInput, OpportunityProductUncheckedCreateWithoutOpportunityInput> | OpportunityProductCreateWithoutOpportunityInput[] | OpportunityProductUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: OpportunityProductCreateOrConnectWithoutOpportunityInput | OpportunityProductCreateOrConnectWithoutOpportunityInput[]
    createMany?: OpportunityProductCreateManyOpportunityInputEnvelope
    connect?: OpportunityProductWhereUniqueInput | OpportunityProductWhereUniqueInput[]
  }

  export type ContactTimelineEventUncheckedCreateNestedManyWithoutOpportunityInput = {
    create?: XOR<ContactTimelineEventCreateWithoutOpportunityInput, ContactTimelineEventUncheckedCreateWithoutOpportunityInput> | ContactTimelineEventCreateWithoutOpportunityInput[] | ContactTimelineEventUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: ContactTimelineEventCreateOrConnectWithoutOpportunityInput | ContactTimelineEventCreateOrConnectWithoutOpportunityInput[]
    createMany?: ContactTimelineEventCreateManyOpportunityInputEnvelope
    connect?: ContactTimelineEventWhereUniqueInput | ContactTimelineEventWhereUniqueInput[]
  }

  export type NoteUncheckedCreateNestedManyWithoutOpportunityInput = {
    create?: XOR<NoteCreateWithoutOpportunityInput, NoteUncheckedCreateWithoutOpportunityInput> | NoteCreateWithoutOpportunityInput[] | NoteUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutOpportunityInput | NoteCreateOrConnectWithoutOpportunityInput[]
    createMany?: NoteCreateManyOpportunityInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumOpportunityStatusFieldUpdateOperationsInput = {
    set?: $Enums.OpportunityStatus
  }

  export type OpportunityUpdatestatusHistoryInput = {
    set?: $Enums.OpportunityStatus[]
    push?: $Enums.OpportunityStatus | $Enums.OpportunityStatus[]
  }

  export type ContactOpportunityJoinUpdateManyWithoutOpportunityRelationNestedInput = {
    create?: XOR<ContactOpportunityJoinCreateWithoutOpportunityRelationInput, ContactOpportunityJoinUncheckedCreateWithoutOpportunityRelationInput> | ContactOpportunityJoinCreateWithoutOpportunityRelationInput[] | ContactOpportunityJoinUncheckedCreateWithoutOpportunityRelationInput[]
    connectOrCreate?: ContactOpportunityJoinCreateOrConnectWithoutOpportunityRelationInput | ContactOpportunityJoinCreateOrConnectWithoutOpportunityRelationInput[]
    upsert?: ContactOpportunityJoinUpsertWithWhereUniqueWithoutOpportunityRelationInput | ContactOpportunityJoinUpsertWithWhereUniqueWithoutOpportunityRelationInput[]
    createMany?: ContactOpportunityJoinCreateManyOpportunityRelationInputEnvelope
    set?: ContactOpportunityJoinWhereUniqueInput | ContactOpportunityJoinWhereUniqueInput[]
    disconnect?: ContactOpportunityJoinWhereUniqueInput | ContactOpportunityJoinWhereUniqueInput[]
    delete?: ContactOpportunityJoinWhereUniqueInput | ContactOpportunityJoinWhereUniqueInput[]
    connect?: ContactOpportunityJoinWhereUniqueInput | ContactOpportunityJoinWhereUniqueInput[]
    update?: ContactOpportunityJoinUpdateWithWhereUniqueWithoutOpportunityRelationInput | ContactOpportunityJoinUpdateWithWhereUniqueWithoutOpportunityRelationInput[]
    updateMany?: ContactOpportunityJoinUpdateManyWithWhereWithoutOpportunityRelationInput | ContactOpportunityJoinUpdateManyWithWhereWithoutOpportunityRelationInput[]
    deleteMany?: ContactOpportunityJoinScalarWhereInput | ContactOpportunityJoinScalarWhereInput[]
  }

  export type UserOpportunityJoinUpdateManyWithoutOpportunityRelationNestedInput = {
    create?: XOR<UserOpportunityJoinCreateWithoutOpportunityRelationInput, UserOpportunityJoinUncheckedCreateWithoutOpportunityRelationInput> | UserOpportunityJoinCreateWithoutOpportunityRelationInput[] | UserOpportunityJoinUncheckedCreateWithoutOpportunityRelationInput[]
    connectOrCreate?: UserOpportunityJoinCreateOrConnectWithoutOpportunityRelationInput | UserOpportunityJoinCreateOrConnectWithoutOpportunityRelationInput[]
    upsert?: UserOpportunityJoinUpsertWithWhereUniqueWithoutOpportunityRelationInput | UserOpportunityJoinUpsertWithWhereUniqueWithoutOpportunityRelationInput[]
    createMany?: UserOpportunityJoinCreateManyOpportunityRelationInputEnvelope
    set?: UserOpportunityJoinWhereUniqueInput | UserOpportunityJoinWhereUniqueInput[]
    disconnect?: UserOpportunityJoinWhereUniqueInput | UserOpportunityJoinWhereUniqueInput[]
    delete?: UserOpportunityJoinWhereUniqueInput | UserOpportunityJoinWhereUniqueInput[]
    connect?: UserOpportunityJoinWhereUniqueInput | UserOpportunityJoinWhereUniqueInput[]
    update?: UserOpportunityJoinUpdateWithWhereUniqueWithoutOpportunityRelationInput | UserOpportunityJoinUpdateWithWhereUniqueWithoutOpportunityRelationInput[]
    updateMany?: UserOpportunityJoinUpdateManyWithWhereWithoutOpportunityRelationInput | UserOpportunityJoinUpdateManyWithWhereWithoutOpportunityRelationInput[]
    deleteMany?: UserOpportunityJoinScalarWhereInput | UserOpportunityJoinScalarWhereInput[]
  }

  export type ActivityUpdateManyWithoutOpportunityNestedInput = {
    create?: XOR<ActivityCreateWithoutOpportunityInput, ActivityUncheckedCreateWithoutOpportunityInput> | ActivityCreateWithoutOpportunityInput[] | ActivityUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutOpportunityInput | ActivityCreateOrConnectWithoutOpportunityInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutOpportunityInput | ActivityUpsertWithWhereUniqueWithoutOpportunityInput[]
    createMany?: ActivityCreateManyOpportunityInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutOpportunityInput | ActivityUpdateWithWhereUniqueWithoutOpportunityInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutOpportunityInput | ActivityUpdateManyWithWhereWithoutOpportunityInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type OpportunityProductUpdateManyWithoutOpportunityNestedInput = {
    create?: XOR<OpportunityProductCreateWithoutOpportunityInput, OpportunityProductUncheckedCreateWithoutOpportunityInput> | OpportunityProductCreateWithoutOpportunityInput[] | OpportunityProductUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: OpportunityProductCreateOrConnectWithoutOpportunityInput | OpportunityProductCreateOrConnectWithoutOpportunityInput[]
    upsert?: OpportunityProductUpsertWithWhereUniqueWithoutOpportunityInput | OpportunityProductUpsertWithWhereUniqueWithoutOpportunityInput[]
    createMany?: OpportunityProductCreateManyOpportunityInputEnvelope
    set?: OpportunityProductWhereUniqueInput | OpportunityProductWhereUniqueInput[]
    disconnect?: OpportunityProductWhereUniqueInput | OpportunityProductWhereUniqueInput[]
    delete?: OpportunityProductWhereUniqueInput | OpportunityProductWhereUniqueInput[]
    connect?: OpportunityProductWhereUniqueInput | OpportunityProductWhereUniqueInput[]
    update?: OpportunityProductUpdateWithWhereUniqueWithoutOpportunityInput | OpportunityProductUpdateWithWhereUniqueWithoutOpportunityInput[]
    updateMany?: OpportunityProductUpdateManyWithWhereWithoutOpportunityInput | OpportunityProductUpdateManyWithWhereWithoutOpportunityInput[]
    deleteMany?: OpportunityProductScalarWhereInput | OpportunityProductScalarWhereInput[]
  }

  export type TenetUpdateOneRequiredWithoutOpportunitiesNestedInput = {
    create?: XOR<TenetCreateWithoutOpportunitiesInput, TenetUncheckedCreateWithoutOpportunitiesInput>
    connectOrCreate?: TenetCreateOrConnectWithoutOpportunitiesInput
    upsert?: TenetUpsertWithoutOpportunitiesInput
    connect?: TenetWhereUniqueInput
    update?: XOR<XOR<TenetUpdateToOneWithWhereWithoutOpportunitiesInput, TenetUpdateWithoutOpportunitiesInput>, TenetUncheckedUpdateWithoutOpportunitiesInput>
  }

  export type ContactTimelineEventUpdateManyWithoutOpportunityNestedInput = {
    create?: XOR<ContactTimelineEventCreateWithoutOpportunityInput, ContactTimelineEventUncheckedCreateWithoutOpportunityInput> | ContactTimelineEventCreateWithoutOpportunityInput[] | ContactTimelineEventUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: ContactTimelineEventCreateOrConnectWithoutOpportunityInput | ContactTimelineEventCreateOrConnectWithoutOpportunityInput[]
    upsert?: ContactTimelineEventUpsertWithWhereUniqueWithoutOpportunityInput | ContactTimelineEventUpsertWithWhereUniqueWithoutOpportunityInput[]
    createMany?: ContactTimelineEventCreateManyOpportunityInputEnvelope
    set?: ContactTimelineEventWhereUniqueInput | ContactTimelineEventWhereUniqueInput[]
    disconnect?: ContactTimelineEventWhereUniqueInput | ContactTimelineEventWhereUniqueInput[]
    delete?: ContactTimelineEventWhereUniqueInput | ContactTimelineEventWhereUniqueInput[]
    connect?: ContactTimelineEventWhereUniqueInput | ContactTimelineEventWhereUniqueInput[]
    update?: ContactTimelineEventUpdateWithWhereUniqueWithoutOpportunityInput | ContactTimelineEventUpdateWithWhereUniqueWithoutOpportunityInput[]
    updateMany?: ContactTimelineEventUpdateManyWithWhereWithoutOpportunityInput | ContactTimelineEventUpdateManyWithWhereWithoutOpportunityInput[]
    deleteMany?: ContactTimelineEventScalarWhereInput | ContactTimelineEventScalarWhereInput[]
  }

  export type NoteUpdateManyWithoutOpportunityNestedInput = {
    create?: XOR<NoteCreateWithoutOpportunityInput, NoteUncheckedCreateWithoutOpportunityInput> | NoteCreateWithoutOpportunityInput[] | NoteUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutOpportunityInput | NoteCreateOrConnectWithoutOpportunityInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutOpportunityInput | NoteUpsertWithWhereUniqueWithoutOpportunityInput[]
    createMany?: NoteCreateManyOpportunityInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutOpportunityInput | NoteUpdateWithWhereUniqueWithoutOpportunityInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutOpportunityInput | NoteUpdateManyWithWhereWithoutOpportunityInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type ContactOpportunityJoinUncheckedUpdateManyWithoutOpportunityRelationNestedInput = {
    create?: XOR<ContactOpportunityJoinCreateWithoutOpportunityRelationInput, ContactOpportunityJoinUncheckedCreateWithoutOpportunityRelationInput> | ContactOpportunityJoinCreateWithoutOpportunityRelationInput[] | ContactOpportunityJoinUncheckedCreateWithoutOpportunityRelationInput[]
    connectOrCreate?: ContactOpportunityJoinCreateOrConnectWithoutOpportunityRelationInput | ContactOpportunityJoinCreateOrConnectWithoutOpportunityRelationInput[]
    upsert?: ContactOpportunityJoinUpsertWithWhereUniqueWithoutOpportunityRelationInput | ContactOpportunityJoinUpsertWithWhereUniqueWithoutOpportunityRelationInput[]
    createMany?: ContactOpportunityJoinCreateManyOpportunityRelationInputEnvelope
    set?: ContactOpportunityJoinWhereUniqueInput | ContactOpportunityJoinWhereUniqueInput[]
    disconnect?: ContactOpportunityJoinWhereUniqueInput | ContactOpportunityJoinWhereUniqueInput[]
    delete?: ContactOpportunityJoinWhereUniqueInput | ContactOpportunityJoinWhereUniqueInput[]
    connect?: ContactOpportunityJoinWhereUniqueInput | ContactOpportunityJoinWhereUniqueInput[]
    update?: ContactOpportunityJoinUpdateWithWhereUniqueWithoutOpportunityRelationInput | ContactOpportunityJoinUpdateWithWhereUniqueWithoutOpportunityRelationInput[]
    updateMany?: ContactOpportunityJoinUpdateManyWithWhereWithoutOpportunityRelationInput | ContactOpportunityJoinUpdateManyWithWhereWithoutOpportunityRelationInput[]
    deleteMany?: ContactOpportunityJoinScalarWhereInput | ContactOpportunityJoinScalarWhereInput[]
  }

  export type UserOpportunityJoinUncheckedUpdateManyWithoutOpportunityRelationNestedInput = {
    create?: XOR<UserOpportunityJoinCreateWithoutOpportunityRelationInput, UserOpportunityJoinUncheckedCreateWithoutOpportunityRelationInput> | UserOpportunityJoinCreateWithoutOpportunityRelationInput[] | UserOpportunityJoinUncheckedCreateWithoutOpportunityRelationInput[]
    connectOrCreate?: UserOpportunityJoinCreateOrConnectWithoutOpportunityRelationInput | UserOpportunityJoinCreateOrConnectWithoutOpportunityRelationInput[]
    upsert?: UserOpportunityJoinUpsertWithWhereUniqueWithoutOpportunityRelationInput | UserOpportunityJoinUpsertWithWhereUniqueWithoutOpportunityRelationInput[]
    createMany?: UserOpportunityJoinCreateManyOpportunityRelationInputEnvelope
    set?: UserOpportunityJoinWhereUniqueInput | UserOpportunityJoinWhereUniqueInput[]
    disconnect?: UserOpportunityJoinWhereUniqueInput | UserOpportunityJoinWhereUniqueInput[]
    delete?: UserOpportunityJoinWhereUniqueInput | UserOpportunityJoinWhereUniqueInput[]
    connect?: UserOpportunityJoinWhereUniqueInput | UserOpportunityJoinWhereUniqueInput[]
    update?: UserOpportunityJoinUpdateWithWhereUniqueWithoutOpportunityRelationInput | UserOpportunityJoinUpdateWithWhereUniqueWithoutOpportunityRelationInput[]
    updateMany?: UserOpportunityJoinUpdateManyWithWhereWithoutOpportunityRelationInput | UserOpportunityJoinUpdateManyWithWhereWithoutOpportunityRelationInput[]
    deleteMany?: UserOpportunityJoinScalarWhereInput | UserOpportunityJoinScalarWhereInput[]
  }

  export type ActivityUncheckedUpdateManyWithoutOpportunityNestedInput = {
    create?: XOR<ActivityCreateWithoutOpportunityInput, ActivityUncheckedCreateWithoutOpportunityInput> | ActivityCreateWithoutOpportunityInput[] | ActivityUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutOpportunityInput | ActivityCreateOrConnectWithoutOpportunityInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutOpportunityInput | ActivityUpsertWithWhereUniqueWithoutOpportunityInput[]
    createMany?: ActivityCreateManyOpportunityInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutOpportunityInput | ActivityUpdateWithWhereUniqueWithoutOpportunityInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutOpportunityInput | ActivityUpdateManyWithWhereWithoutOpportunityInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type OpportunityProductUncheckedUpdateManyWithoutOpportunityNestedInput = {
    create?: XOR<OpportunityProductCreateWithoutOpportunityInput, OpportunityProductUncheckedCreateWithoutOpportunityInput> | OpportunityProductCreateWithoutOpportunityInput[] | OpportunityProductUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: OpportunityProductCreateOrConnectWithoutOpportunityInput | OpportunityProductCreateOrConnectWithoutOpportunityInput[]
    upsert?: OpportunityProductUpsertWithWhereUniqueWithoutOpportunityInput | OpportunityProductUpsertWithWhereUniqueWithoutOpportunityInput[]
    createMany?: OpportunityProductCreateManyOpportunityInputEnvelope
    set?: OpportunityProductWhereUniqueInput | OpportunityProductWhereUniqueInput[]
    disconnect?: OpportunityProductWhereUniqueInput | OpportunityProductWhereUniqueInput[]
    delete?: OpportunityProductWhereUniqueInput | OpportunityProductWhereUniqueInput[]
    connect?: OpportunityProductWhereUniqueInput | OpportunityProductWhereUniqueInput[]
    update?: OpportunityProductUpdateWithWhereUniqueWithoutOpportunityInput | OpportunityProductUpdateWithWhereUniqueWithoutOpportunityInput[]
    updateMany?: OpportunityProductUpdateManyWithWhereWithoutOpportunityInput | OpportunityProductUpdateManyWithWhereWithoutOpportunityInput[]
    deleteMany?: OpportunityProductScalarWhereInput | OpportunityProductScalarWhereInput[]
  }

  export type ContactTimelineEventUncheckedUpdateManyWithoutOpportunityNestedInput = {
    create?: XOR<ContactTimelineEventCreateWithoutOpportunityInput, ContactTimelineEventUncheckedCreateWithoutOpportunityInput> | ContactTimelineEventCreateWithoutOpportunityInput[] | ContactTimelineEventUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: ContactTimelineEventCreateOrConnectWithoutOpportunityInput | ContactTimelineEventCreateOrConnectWithoutOpportunityInput[]
    upsert?: ContactTimelineEventUpsertWithWhereUniqueWithoutOpportunityInput | ContactTimelineEventUpsertWithWhereUniqueWithoutOpportunityInput[]
    createMany?: ContactTimelineEventCreateManyOpportunityInputEnvelope
    set?: ContactTimelineEventWhereUniqueInput | ContactTimelineEventWhereUniqueInput[]
    disconnect?: ContactTimelineEventWhereUniqueInput | ContactTimelineEventWhereUniqueInput[]
    delete?: ContactTimelineEventWhereUniqueInput | ContactTimelineEventWhereUniqueInput[]
    connect?: ContactTimelineEventWhereUniqueInput | ContactTimelineEventWhereUniqueInput[]
    update?: ContactTimelineEventUpdateWithWhereUniqueWithoutOpportunityInput | ContactTimelineEventUpdateWithWhereUniqueWithoutOpportunityInput[]
    updateMany?: ContactTimelineEventUpdateManyWithWhereWithoutOpportunityInput | ContactTimelineEventUpdateManyWithWhereWithoutOpportunityInput[]
    deleteMany?: ContactTimelineEventScalarWhereInput | ContactTimelineEventScalarWhereInput[]
  }

  export type NoteUncheckedUpdateManyWithoutOpportunityNestedInput = {
    create?: XOR<NoteCreateWithoutOpportunityInput, NoteUncheckedCreateWithoutOpportunityInput> | NoteCreateWithoutOpportunityInput[] | NoteUncheckedCreateWithoutOpportunityInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutOpportunityInput | NoteCreateOrConnectWithoutOpportunityInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutOpportunityInput | NoteUpsertWithWhereUniqueWithoutOpportunityInput[]
    createMany?: NoteCreateManyOpportunityInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutOpportunityInput | NoteUpdateWithWhereUniqueWithoutOpportunityInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutOpportunityInput | NoteUpdateManyWithWhereWithoutOpportunityInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type ContactCreateNestedOneWithoutOpportunitiesInput = {
    create?: XOR<ContactCreateWithoutOpportunitiesInput, ContactUncheckedCreateWithoutOpportunitiesInput>
    connectOrCreate?: ContactCreateOrConnectWithoutOpportunitiesInput
    connect?: ContactWhereUniqueInput
  }

  export type OpportunityCreateNestedOneWithoutContactsInput = {
    create?: XOR<OpportunityCreateWithoutContactsInput, OpportunityUncheckedCreateWithoutContactsInput>
    connectOrCreate?: OpportunityCreateOrConnectWithoutContactsInput
    connect?: OpportunityWhereUniqueInput
  }

  export type ContactUpdateOneRequiredWithoutOpportunitiesNestedInput = {
    create?: XOR<ContactCreateWithoutOpportunitiesInput, ContactUncheckedCreateWithoutOpportunitiesInput>
    connectOrCreate?: ContactCreateOrConnectWithoutOpportunitiesInput
    upsert?: ContactUpsertWithoutOpportunitiesInput
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutOpportunitiesInput, ContactUpdateWithoutOpportunitiesInput>, ContactUncheckedUpdateWithoutOpportunitiesInput>
  }

  export type OpportunityUpdateOneRequiredWithoutContactsNestedInput = {
    create?: XOR<OpportunityCreateWithoutContactsInput, OpportunityUncheckedCreateWithoutContactsInput>
    connectOrCreate?: OpportunityCreateOrConnectWithoutContactsInput
    upsert?: OpportunityUpsertWithoutContactsInput
    connect?: OpportunityWhereUniqueInput
    update?: XOR<XOR<OpportunityUpdateToOneWithWhereWithoutContactsInput, OpportunityUpdateWithoutContactsInput>, OpportunityUncheckedUpdateWithoutContactsInput>
  }

  export type UserCreateNestedOneWithoutOpportunitiesInput = {
    create?: XOR<UserCreateWithoutOpportunitiesInput, UserUncheckedCreateWithoutOpportunitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutOpportunitiesInput
    connect?: UserWhereUniqueInput
  }

  export type OpportunityCreateNestedOneWithoutTeamMembersInput = {
    create?: XOR<OpportunityCreateWithoutTeamMembersInput, OpportunityUncheckedCreateWithoutTeamMembersInput>
    connectOrCreate?: OpportunityCreateOrConnectWithoutTeamMembersInput
    connect?: OpportunityWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutOpportunitiesNestedInput = {
    create?: XOR<UserCreateWithoutOpportunitiesInput, UserUncheckedCreateWithoutOpportunitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutOpportunitiesInput
    upsert?: UserUpsertWithoutOpportunitiesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOpportunitiesInput, UserUpdateWithoutOpportunitiesInput>, UserUncheckedUpdateWithoutOpportunitiesInput>
  }

  export type OpportunityUpdateOneRequiredWithoutTeamMembersNestedInput = {
    create?: XOR<OpportunityCreateWithoutTeamMembersInput, OpportunityUncheckedCreateWithoutTeamMembersInput>
    connectOrCreate?: OpportunityCreateOrConnectWithoutTeamMembersInput
    upsert?: OpportunityUpsertWithoutTeamMembersInput
    connect?: OpportunityWhereUniqueInput
    update?: XOR<XOR<OpportunityUpdateToOneWithWhereWithoutTeamMembersInput, OpportunityUpdateWithoutTeamMembersInput>, OpportunityUncheckedUpdateWithoutTeamMembersInput>
  }

  export type OpportunityCreateNestedOneWithoutProductsInput = {
    create?: XOR<OpportunityCreateWithoutProductsInput, OpportunityUncheckedCreateWithoutProductsInput>
    connectOrCreate?: OpportunityCreateOrConnectWithoutProductsInput
    connect?: OpportunityWhereUniqueInput
  }

  export type ProductTypeCreateNestedOneWithoutOpportunitiesInput = {
    create?: XOR<ProductTypeCreateWithoutOpportunitiesInput, ProductTypeUncheckedCreateWithoutOpportunitiesInput>
    connectOrCreate?: ProductTypeCreateOrConnectWithoutOpportunitiesInput
    connect?: ProductTypeWhereUniqueInput
  }

  export type OpportunityUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<OpportunityCreateWithoutProductsInput, OpportunityUncheckedCreateWithoutProductsInput>
    connectOrCreate?: OpportunityCreateOrConnectWithoutProductsInput
    upsert?: OpportunityUpsertWithoutProductsInput
    connect?: OpportunityWhereUniqueInput
    update?: XOR<XOR<OpportunityUpdateToOneWithWhereWithoutProductsInput, OpportunityUpdateWithoutProductsInput>, OpportunityUncheckedUpdateWithoutProductsInput>
  }

  export type ProductTypeUpdateOneRequiredWithoutOpportunitiesNestedInput = {
    create?: XOR<ProductTypeCreateWithoutOpportunitiesInput, ProductTypeUncheckedCreateWithoutOpportunitiesInput>
    connectOrCreate?: ProductTypeCreateOrConnectWithoutOpportunitiesInput
    upsert?: ProductTypeUpsertWithoutOpportunitiesInput
    connect?: ProductTypeWhereUniqueInput
    update?: XOR<XOR<ProductTypeUpdateToOneWithWhereWithoutOpportunitiesInput, ProductTypeUpdateWithoutOpportunitiesInput>, ProductTypeUncheckedUpdateWithoutOpportunitiesInput>
  }

  export type OpportunityProductCreateNestedManyWithoutProductTypeInput = {
    create?: XOR<OpportunityProductCreateWithoutProductTypeInput, OpportunityProductUncheckedCreateWithoutProductTypeInput> | OpportunityProductCreateWithoutProductTypeInput[] | OpportunityProductUncheckedCreateWithoutProductTypeInput[]
    connectOrCreate?: OpportunityProductCreateOrConnectWithoutProductTypeInput | OpportunityProductCreateOrConnectWithoutProductTypeInput[]
    createMany?: OpportunityProductCreateManyProductTypeInputEnvelope
    connect?: OpportunityProductWhereUniqueInput | OpportunityProductWhereUniqueInput[]
  }

  export type TenetCreateNestedOneWithoutProductsInput = {
    create?: XOR<TenetCreateWithoutProductsInput, TenetUncheckedCreateWithoutProductsInput>
    connectOrCreate?: TenetCreateOrConnectWithoutProductsInput
    connect?: TenetWhereUniqueInput
  }

  export type OpportunityProductUncheckedCreateNestedManyWithoutProductTypeInput = {
    create?: XOR<OpportunityProductCreateWithoutProductTypeInput, OpportunityProductUncheckedCreateWithoutProductTypeInput> | OpportunityProductCreateWithoutProductTypeInput[] | OpportunityProductUncheckedCreateWithoutProductTypeInput[]
    connectOrCreate?: OpportunityProductCreateOrConnectWithoutProductTypeInput | OpportunityProductCreateOrConnectWithoutProductTypeInput[]
    createMany?: OpportunityProductCreateManyProductTypeInputEnvelope
    connect?: OpportunityProductWhereUniqueInput | OpportunityProductWhereUniqueInput[]
  }

  export type OpportunityProductUpdateManyWithoutProductTypeNestedInput = {
    create?: XOR<OpportunityProductCreateWithoutProductTypeInput, OpportunityProductUncheckedCreateWithoutProductTypeInput> | OpportunityProductCreateWithoutProductTypeInput[] | OpportunityProductUncheckedCreateWithoutProductTypeInput[]
    connectOrCreate?: OpportunityProductCreateOrConnectWithoutProductTypeInput | OpportunityProductCreateOrConnectWithoutProductTypeInput[]
    upsert?: OpportunityProductUpsertWithWhereUniqueWithoutProductTypeInput | OpportunityProductUpsertWithWhereUniqueWithoutProductTypeInput[]
    createMany?: OpportunityProductCreateManyProductTypeInputEnvelope
    set?: OpportunityProductWhereUniqueInput | OpportunityProductWhereUniqueInput[]
    disconnect?: OpportunityProductWhereUniqueInput | OpportunityProductWhereUniqueInput[]
    delete?: OpportunityProductWhereUniqueInput | OpportunityProductWhereUniqueInput[]
    connect?: OpportunityProductWhereUniqueInput | OpportunityProductWhereUniqueInput[]
    update?: OpportunityProductUpdateWithWhereUniqueWithoutProductTypeInput | OpportunityProductUpdateWithWhereUniqueWithoutProductTypeInput[]
    updateMany?: OpportunityProductUpdateManyWithWhereWithoutProductTypeInput | OpportunityProductUpdateManyWithWhereWithoutProductTypeInput[]
    deleteMany?: OpportunityProductScalarWhereInput | OpportunityProductScalarWhereInput[]
  }

  export type TenetUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<TenetCreateWithoutProductsInput, TenetUncheckedCreateWithoutProductsInput>
    connectOrCreate?: TenetCreateOrConnectWithoutProductsInput
    upsert?: TenetUpsertWithoutProductsInput
    connect?: TenetWhereUniqueInput
    update?: XOR<XOR<TenetUpdateToOneWithWhereWithoutProductsInput, TenetUpdateWithoutProductsInput>, TenetUncheckedUpdateWithoutProductsInput>
  }

  export type OpportunityProductUncheckedUpdateManyWithoutProductTypeNestedInput = {
    create?: XOR<OpportunityProductCreateWithoutProductTypeInput, OpportunityProductUncheckedCreateWithoutProductTypeInput> | OpportunityProductCreateWithoutProductTypeInput[] | OpportunityProductUncheckedCreateWithoutProductTypeInput[]
    connectOrCreate?: OpportunityProductCreateOrConnectWithoutProductTypeInput | OpportunityProductCreateOrConnectWithoutProductTypeInput[]
    upsert?: OpportunityProductUpsertWithWhereUniqueWithoutProductTypeInput | OpportunityProductUpsertWithWhereUniqueWithoutProductTypeInput[]
    createMany?: OpportunityProductCreateManyProductTypeInputEnvelope
    set?: OpportunityProductWhereUniqueInput | OpportunityProductWhereUniqueInput[]
    disconnect?: OpportunityProductWhereUniqueInput | OpportunityProductWhereUniqueInput[]
    delete?: OpportunityProductWhereUniqueInput | OpportunityProductWhereUniqueInput[]
    connect?: OpportunityProductWhereUniqueInput | OpportunityProductWhereUniqueInput[]
    update?: OpportunityProductUpdateWithWhereUniqueWithoutProductTypeInput | OpportunityProductUpdateWithWhereUniqueWithoutProductTypeInput[]
    updateMany?: OpportunityProductUpdateManyWithWhereWithoutProductTypeInput | OpportunityProductUpdateManyWithWhereWithoutProductTypeInput[]
    deleteMany?: OpportunityProductScalarWhereInput | OpportunityProductScalarWhereInput[]
  }

  export type TenetCreateNestedOneWithoutLogsInput = {
    create?: XOR<TenetCreateWithoutLogsInput, TenetUncheckedCreateWithoutLogsInput>
    connectOrCreate?: TenetCreateOrConnectWithoutLogsInput
    connect?: TenetWhereUniqueInput
  }

  export type EnumLogLevelFieldUpdateOperationsInput = {
    set?: $Enums.LogLevel
  }

  export type TenetUpdateOneWithoutLogsNestedInput = {
    create?: XOR<TenetCreateWithoutLogsInput, TenetUncheckedCreateWithoutLogsInput>
    connectOrCreate?: TenetCreateOrConnectWithoutLogsInput
    upsert?: TenetUpsertWithoutLogsInput
    disconnect?: TenetWhereInput | boolean
    delete?: TenetWhereInput | boolean
    connect?: TenetWhereUniqueInput
    update?: XOR<XOR<TenetUpdateToOneWithWhereWithoutLogsInput, TenetUpdateWithoutLogsInput>, TenetUncheckedUpdateWithoutLogsInput>
  }

  export type UserCreateNestedOneWithoutTokensInput = {
    create?: XOR<UserCreateWithoutTokensInput, UserUncheckedCreateWithoutTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTokensNestedInput = {
    create?: XOR<UserCreateWithoutTokensInput, UserUncheckedCreateWithoutTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutTokensInput
    upsert?: UserUpsertWithoutTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTokensInput, UserUpdateWithoutTokensInput>, UserUncheckedUpdateWithoutTokensInput>
  }

  export type WrappedObjectCreateNestedManyWithoutTestObjectInput = {
    create?: XOR<WrappedObjectCreateWithoutTestObjectInput, WrappedObjectUncheckedCreateWithoutTestObjectInput> | WrappedObjectCreateWithoutTestObjectInput[] | WrappedObjectUncheckedCreateWithoutTestObjectInput[]
    connectOrCreate?: WrappedObjectCreateOrConnectWithoutTestObjectInput | WrappedObjectCreateOrConnectWithoutTestObjectInput[]
    createMany?: WrappedObjectCreateManyTestObjectInputEnvelope
    connect?: WrappedObjectWhereUniqueInput | WrappedObjectWhereUniqueInput[]
  }

  export type JoinTestObjectCreateNestedManyWithoutTestObjectRelationInput = {
    create?: XOR<JoinTestObjectCreateWithoutTestObjectRelationInput, JoinTestObjectUncheckedCreateWithoutTestObjectRelationInput> | JoinTestObjectCreateWithoutTestObjectRelationInput[] | JoinTestObjectUncheckedCreateWithoutTestObjectRelationInput[]
    connectOrCreate?: JoinTestObjectCreateOrConnectWithoutTestObjectRelationInput | JoinTestObjectCreateOrConnectWithoutTestObjectRelationInput[]
    createMany?: JoinTestObjectCreateManyTestObjectRelationInputEnvelope
    connect?: JoinTestObjectWhereUniqueInput | JoinTestObjectWhereUniqueInput[]
  }

  export type JoinTestObject2CreateNestedManyWithoutTestObjectRelationInput = {
    create?: XOR<JoinTestObject2CreateWithoutTestObjectRelationInput, JoinTestObject2UncheckedCreateWithoutTestObjectRelationInput> | JoinTestObject2CreateWithoutTestObjectRelationInput[] | JoinTestObject2UncheckedCreateWithoutTestObjectRelationInput[]
    connectOrCreate?: JoinTestObject2CreateOrConnectWithoutTestObjectRelationInput | JoinTestObject2CreateOrConnectWithoutTestObjectRelationInput[]
    createMany?: JoinTestObject2CreateManyTestObjectRelationInputEnvelope
    connect?: JoinTestObject2WhereUniqueInput | JoinTestObject2WhereUniqueInput[]
  }

  export type WrappedObjectUncheckedCreateNestedManyWithoutTestObjectInput = {
    create?: XOR<WrappedObjectCreateWithoutTestObjectInput, WrappedObjectUncheckedCreateWithoutTestObjectInput> | WrappedObjectCreateWithoutTestObjectInput[] | WrappedObjectUncheckedCreateWithoutTestObjectInput[]
    connectOrCreate?: WrappedObjectCreateOrConnectWithoutTestObjectInput | WrappedObjectCreateOrConnectWithoutTestObjectInput[]
    createMany?: WrappedObjectCreateManyTestObjectInputEnvelope
    connect?: WrappedObjectWhereUniqueInput | WrappedObjectWhereUniqueInput[]
  }

  export type JoinTestObjectUncheckedCreateNestedManyWithoutTestObjectRelationInput = {
    create?: XOR<JoinTestObjectCreateWithoutTestObjectRelationInput, JoinTestObjectUncheckedCreateWithoutTestObjectRelationInput> | JoinTestObjectCreateWithoutTestObjectRelationInput[] | JoinTestObjectUncheckedCreateWithoutTestObjectRelationInput[]
    connectOrCreate?: JoinTestObjectCreateOrConnectWithoutTestObjectRelationInput | JoinTestObjectCreateOrConnectWithoutTestObjectRelationInput[]
    createMany?: JoinTestObjectCreateManyTestObjectRelationInputEnvelope
    connect?: JoinTestObjectWhereUniqueInput | JoinTestObjectWhereUniqueInput[]
  }

  export type JoinTestObject2UncheckedCreateNestedManyWithoutTestObjectRelationInput = {
    create?: XOR<JoinTestObject2CreateWithoutTestObjectRelationInput, JoinTestObject2UncheckedCreateWithoutTestObjectRelationInput> | JoinTestObject2CreateWithoutTestObjectRelationInput[] | JoinTestObject2UncheckedCreateWithoutTestObjectRelationInput[]
    connectOrCreate?: JoinTestObject2CreateOrConnectWithoutTestObjectRelationInput | JoinTestObject2CreateOrConnectWithoutTestObjectRelationInput[]
    createMany?: JoinTestObject2CreateManyTestObjectRelationInputEnvelope
    connect?: JoinTestObject2WhereUniqueInput | JoinTestObject2WhereUniqueInput[]
  }

  export type WrappedObjectUpdateManyWithoutTestObjectNestedInput = {
    create?: XOR<WrappedObjectCreateWithoutTestObjectInput, WrappedObjectUncheckedCreateWithoutTestObjectInput> | WrappedObjectCreateWithoutTestObjectInput[] | WrappedObjectUncheckedCreateWithoutTestObjectInput[]
    connectOrCreate?: WrappedObjectCreateOrConnectWithoutTestObjectInput | WrappedObjectCreateOrConnectWithoutTestObjectInput[]
    upsert?: WrappedObjectUpsertWithWhereUniqueWithoutTestObjectInput | WrappedObjectUpsertWithWhereUniqueWithoutTestObjectInput[]
    createMany?: WrappedObjectCreateManyTestObjectInputEnvelope
    set?: WrappedObjectWhereUniqueInput | WrappedObjectWhereUniqueInput[]
    disconnect?: WrappedObjectWhereUniqueInput | WrappedObjectWhereUniqueInput[]
    delete?: WrappedObjectWhereUniqueInput | WrappedObjectWhereUniqueInput[]
    connect?: WrappedObjectWhereUniqueInput | WrappedObjectWhereUniqueInput[]
    update?: WrappedObjectUpdateWithWhereUniqueWithoutTestObjectInput | WrappedObjectUpdateWithWhereUniqueWithoutTestObjectInput[]
    updateMany?: WrappedObjectUpdateManyWithWhereWithoutTestObjectInput | WrappedObjectUpdateManyWithWhereWithoutTestObjectInput[]
    deleteMany?: WrappedObjectScalarWhereInput | WrappedObjectScalarWhereInput[]
  }

  export type JoinTestObjectUpdateManyWithoutTestObjectRelationNestedInput = {
    create?: XOR<JoinTestObjectCreateWithoutTestObjectRelationInput, JoinTestObjectUncheckedCreateWithoutTestObjectRelationInput> | JoinTestObjectCreateWithoutTestObjectRelationInput[] | JoinTestObjectUncheckedCreateWithoutTestObjectRelationInput[]
    connectOrCreate?: JoinTestObjectCreateOrConnectWithoutTestObjectRelationInput | JoinTestObjectCreateOrConnectWithoutTestObjectRelationInput[]
    upsert?: JoinTestObjectUpsertWithWhereUniqueWithoutTestObjectRelationInput | JoinTestObjectUpsertWithWhereUniqueWithoutTestObjectRelationInput[]
    createMany?: JoinTestObjectCreateManyTestObjectRelationInputEnvelope
    set?: JoinTestObjectWhereUniqueInput | JoinTestObjectWhereUniqueInput[]
    disconnect?: JoinTestObjectWhereUniqueInput | JoinTestObjectWhereUniqueInput[]
    delete?: JoinTestObjectWhereUniqueInput | JoinTestObjectWhereUniqueInput[]
    connect?: JoinTestObjectWhereUniqueInput | JoinTestObjectWhereUniqueInput[]
    update?: JoinTestObjectUpdateWithWhereUniqueWithoutTestObjectRelationInput | JoinTestObjectUpdateWithWhereUniqueWithoutTestObjectRelationInput[]
    updateMany?: JoinTestObjectUpdateManyWithWhereWithoutTestObjectRelationInput | JoinTestObjectUpdateManyWithWhereWithoutTestObjectRelationInput[]
    deleteMany?: JoinTestObjectScalarWhereInput | JoinTestObjectScalarWhereInput[]
  }

  export type JoinTestObject2UpdateManyWithoutTestObjectRelationNestedInput = {
    create?: XOR<JoinTestObject2CreateWithoutTestObjectRelationInput, JoinTestObject2UncheckedCreateWithoutTestObjectRelationInput> | JoinTestObject2CreateWithoutTestObjectRelationInput[] | JoinTestObject2UncheckedCreateWithoutTestObjectRelationInput[]
    connectOrCreate?: JoinTestObject2CreateOrConnectWithoutTestObjectRelationInput | JoinTestObject2CreateOrConnectWithoutTestObjectRelationInput[]
    upsert?: JoinTestObject2UpsertWithWhereUniqueWithoutTestObjectRelationInput | JoinTestObject2UpsertWithWhereUniqueWithoutTestObjectRelationInput[]
    createMany?: JoinTestObject2CreateManyTestObjectRelationInputEnvelope
    set?: JoinTestObject2WhereUniqueInput | JoinTestObject2WhereUniqueInput[]
    disconnect?: JoinTestObject2WhereUniqueInput | JoinTestObject2WhereUniqueInput[]
    delete?: JoinTestObject2WhereUniqueInput | JoinTestObject2WhereUniqueInput[]
    connect?: JoinTestObject2WhereUniqueInput | JoinTestObject2WhereUniqueInput[]
    update?: JoinTestObject2UpdateWithWhereUniqueWithoutTestObjectRelationInput | JoinTestObject2UpdateWithWhereUniqueWithoutTestObjectRelationInput[]
    updateMany?: JoinTestObject2UpdateManyWithWhereWithoutTestObjectRelationInput | JoinTestObject2UpdateManyWithWhereWithoutTestObjectRelationInput[]
    deleteMany?: JoinTestObject2ScalarWhereInput | JoinTestObject2ScalarWhereInput[]
  }

  export type WrappedObjectUncheckedUpdateManyWithoutTestObjectNestedInput = {
    create?: XOR<WrappedObjectCreateWithoutTestObjectInput, WrappedObjectUncheckedCreateWithoutTestObjectInput> | WrappedObjectCreateWithoutTestObjectInput[] | WrappedObjectUncheckedCreateWithoutTestObjectInput[]
    connectOrCreate?: WrappedObjectCreateOrConnectWithoutTestObjectInput | WrappedObjectCreateOrConnectWithoutTestObjectInput[]
    upsert?: WrappedObjectUpsertWithWhereUniqueWithoutTestObjectInput | WrappedObjectUpsertWithWhereUniqueWithoutTestObjectInput[]
    createMany?: WrappedObjectCreateManyTestObjectInputEnvelope
    set?: WrappedObjectWhereUniqueInput | WrappedObjectWhereUniqueInput[]
    disconnect?: WrappedObjectWhereUniqueInput | WrappedObjectWhereUniqueInput[]
    delete?: WrappedObjectWhereUniqueInput | WrappedObjectWhereUniqueInput[]
    connect?: WrappedObjectWhereUniqueInput | WrappedObjectWhereUniqueInput[]
    update?: WrappedObjectUpdateWithWhereUniqueWithoutTestObjectInput | WrappedObjectUpdateWithWhereUniqueWithoutTestObjectInput[]
    updateMany?: WrappedObjectUpdateManyWithWhereWithoutTestObjectInput | WrappedObjectUpdateManyWithWhereWithoutTestObjectInput[]
    deleteMany?: WrappedObjectScalarWhereInput | WrappedObjectScalarWhereInput[]
  }

  export type JoinTestObjectUncheckedUpdateManyWithoutTestObjectRelationNestedInput = {
    create?: XOR<JoinTestObjectCreateWithoutTestObjectRelationInput, JoinTestObjectUncheckedCreateWithoutTestObjectRelationInput> | JoinTestObjectCreateWithoutTestObjectRelationInput[] | JoinTestObjectUncheckedCreateWithoutTestObjectRelationInput[]
    connectOrCreate?: JoinTestObjectCreateOrConnectWithoutTestObjectRelationInput | JoinTestObjectCreateOrConnectWithoutTestObjectRelationInput[]
    upsert?: JoinTestObjectUpsertWithWhereUniqueWithoutTestObjectRelationInput | JoinTestObjectUpsertWithWhereUniqueWithoutTestObjectRelationInput[]
    createMany?: JoinTestObjectCreateManyTestObjectRelationInputEnvelope
    set?: JoinTestObjectWhereUniqueInput | JoinTestObjectWhereUniqueInput[]
    disconnect?: JoinTestObjectWhereUniqueInput | JoinTestObjectWhereUniqueInput[]
    delete?: JoinTestObjectWhereUniqueInput | JoinTestObjectWhereUniqueInput[]
    connect?: JoinTestObjectWhereUniqueInput | JoinTestObjectWhereUniqueInput[]
    update?: JoinTestObjectUpdateWithWhereUniqueWithoutTestObjectRelationInput | JoinTestObjectUpdateWithWhereUniqueWithoutTestObjectRelationInput[]
    updateMany?: JoinTestObjectUpdateManyWithWhereWithoutTestObjectRelationInput | JoinTestObjectUpdateManyWithWhereWithoutTestObjectRelationInput[]
    deleteMany?: JoinTestObjectScalarWhereInput | JoinTestObjectScalarWhereInput[]
  }

  export type JoinTestObject2UncheckedUpdateManyWithoutTestObjectRelationNestedInput = {
    create?: XOR<JoinTestObject2CreateWithoutTestObjectRelationInput, JoinTestObject2UncheckedCreateWithoutTestObjectRelationInput> | JoinTestObject2CreateWithoutTestObjectRelationInput[] | JoinTestObject2UncheckedCreateWithoutTestObjectRelationInput[]
    connectOrCreate?: JoinTestObject2CreateOrConnectWithoutTestObjectRelationInput | JoinTestObject2CreateOrConnectWithoutTestObjectRelationInput[]
    upsert?: JoinTestObject2UpsertWithWhereUniqueWithoutTestObjectRelationInput | JoinTestObject2UpsertWithWhereUniqueWithoutTestObjectRelationInput[]
    createMany?: JoinTestObject2CreateManyTestObjectRelationInputEnvelope
    set?: JoinTestObject2WhereUniqueInput | JoinTestObject2WhereUniqueInput[]
    disconnect?: JoinTestObject2WhereUniqueInput | JoinTestObject2WhereUniqueInput[]
    delete?: JoinTestObject2WhereUniqueInput | JoinTestObject2WhereUniqueInput[]
    connect?: JoinTestObject2WhereUniqueInput | JoinTestObject2WhereUniqueInput[]
    update?: JoinTestObject2UpdateWithWhereUniqueWithoutTestObjectRelationInput | JoinTestObject2UpdateWithWhereUniqueWithoutTestObjectRelationInput[]
    updateMany?: JoinTestObject2UpdateManyWithWhereWithoutTestObjectRelationInput | JoinTestObject2UpdateManyWithWhereWithoutTestObjectRelationInput[]
    deleteMany?: JoinTestObject2ScalarWhereInput | JoinTestObject2ScalarWhereInput[]
  }

  export type TestObjectCreateNestedOneWithoutWrappedInput = {
    create?: XOR<TestObjectCreateWithoutWrappedInput, TestObjectUncheckedCreateWithoutWrappedInput>
    connectOrCreate?: TestObjectCreateOrConnectWithoutWrappedInput
    connect?: TestObjectWhereUniqueInput
  }

  export type TestObjectUpdateOneRequiredWithoutWrappedNestedInput = {
    create?: XOR<TestObjectCreateWithoutWrappedInput, TestObjectUncheckedCreateWithoutWrappedInput>
    connectOrCreate?: TestObjectCreateOrConnectWithoutWrappedInput
    upsert?: TestObjectUpsertWithoutWrappedInput
    connect?: TestObjectWhereUniqueInput
    update?: XOR<XOR<TestObjectUpdateToOneWithWhereWithoutWrappedInput, TestObjectUpdateWithoutWrappedInput>, TestObjectUncheckedUpdateWithoutWrappedInput>
  }

  export type TestObjectCreateNestedOneWithoutJoin1Input = {
    create?: XOR<TestObjectCreateWithoutJoin1Input, TestObjectUncheckedCreateWithoutJoin1Input>
    connectOrCreate?: TestObjectCreateOrConnectWithoutJoin1Input
    connect?: TestObjectWhereUniqueInput
  }

  export type JoinedObject1CreateNestedOneWithoutTestObjectsInput = {
    create?: XOR<JoinedObject1CreateWithoutTestObjectsInput, JoinedObject1UncheckedCreateWithoutTestObjectsInput>
    connectOrCreate?: JoinedObject1CreateOrConnectWithoutTestObjectsInput
    connect?: JoinedObject1WhereUniqueInput
  }

  export type TestObjectUpdateOneRequiredWithoutJoin1NestedInput = {
    create?: XOR<TestObjectCreateWithoutJoin1Input, TestObjectUncheckedCreateWithoutJoin1Input>
    connectOrCreate?: TestObjectCreateOrConnectWithoutJoin1Input
    upsert?: TestObjectUpsertWithoutJoin1Input
    connect?: TestObjectWhereUniqueInput
    update?: XOR<XOR<TestObjectUpdateToOneWithWhereWithoutJoin1Input, TestObjectUpdateWithoutJoin1Input>, TestObjectUncheckedUpdateWithoutJoin1Input>
  }

  export type JoinedObject1UpdateOneRequiredWithoutTestObjectsNestedInput = {
    create?: XOR<JoinedObject1CreateWithoutTestObjectsInput, JoinedObject1UncheckedCreateWithoutTestObjectsInput>
    connectOrCreate?: JoinedObject1CreateOrConnectWithoutTestObjectsInput
    upsert?: JoinedObject1UpsertWithoutTestObjectsInput
    connect?: JoinedObject1WhereUniqueInput
    update?: XOR<XOR<JoinedObject1UpdateToOneWithWhereWithoutTestObjectsInput, JoinedObject1UpdateWithoutTestObjectsInput>, JoinedObject1UncheckedUpdateWithoutTestObjectsInput>
  }

  export type TestObjectCreateNestedOneWithoutJoin2Input = {
    create?: XOR<TestObjectCreateWithoutJoin2Input, TestObjectUncheckedCreateWithoutJoin2Input>
    connectOrCreate?: TestObjectCreateOrConnectWithoutJoin2Input
    connect?: TestObjectWhereUniqueInput
  }

  export type JoinedObject2CreateNestedOneWithoutTestObjectsInput = {
    create?: XOR<JoinedObject2CreateWithoutTestObjectsInput, JoinedObject2UncheckedCreateWithoutTestObjectsInput>
    connectOrCreate?: JoinedObject2CreateOrConnectWithoutTestObjectsInput
    connect?: JoinedObject2WhereUniqueInput
  }

  export type TestObjectUpdateOneRequiredWithoutJoin2NestedInput = {
    create?: XOR<TestObjectCreateWithoutJoin2Input, TestObjectUncheckedCreateWithoutJoin2Input>
    connectOrCreate?: TestObjectCreateOrConnectWithoutJoin2Input
    upsert?: TestObjectUpsertWithoutJoin2Input
    connect?: TestObjectWhereUniqueInput
    update?: XOR<XOR<TestObjectUpdateToOneWithWhereWithoutJoin2Input, TestObjectUpdateWithoutJoin2Input>, TestObjectUncheckedUpdateWithoutJoin2Input>
  }

  export type JoinedObject2UpdateOneRequiredWithoutTestObjectsNestedInput = {
    create?: XOR<JoinedObject2CreateWithoutTestObjectsInput, JoinedObject2UncheckedCreateWithoutTestObjectsInput>
    connectOrCreate?: JoinedObject2CreateOrConnectWithoutTestObjectsInput
    upsert?: JoinedObject2UpsertWithoutTestObjectsInput
    connect?: JoinedObject2WhereUniqueInput
    update?: XOR<XOR<JoinedObject2UpdateToOneWithWhereWithoutTestObjectsInput, JoinedObject2UpdateWithoutTestObjectsInput>, JoinedObject2UncheckedUpdateWithoutTestObjectsInput>
  }

  export type JoinTestObjectCreateNestedManyWithoutJoinedObjectRelationInput = {
    create?: XOR<JoinTestObjectCreateWithoutJoinedObjectRelationInput, JoinTestObjectUncheckedCreateWithoutJoinedObjectRelationInput> | JoinTestObjectCreateWithoutJoinedObjectRelationInput[] | JoinTestObjectUncheckedCreateWithoutJoinedObjectRelationInput[]
    connectOrCreate?: JoinTestObjectCreateOrConnectWithoutJoinedObjectRelationInput | JoinTestObjectCreateOrConnectWithoutJoinedObjectRelationInput[]
    createMany?: JoinTestObjectCreateManyJoinedObjectRelationInputEnvelope
    connect?: JoinTestObjectWhereUniqueInput | JoinTestObjectWhereUniqueInput[]
  }

  export type JoinTestObjectUncheckedCreateNestedManyWithoutJoinedObjectRelationInput = {
    create?: XOR<JoinTestObjectCreateWithoutJoinedObjectRelationInput, JoinTestObjectUncheckedCreateWithoutJoinedObjectRelationInput> | JoinTestObjectCreateWithoutJoinedObjectRelationInput[] | JoinTestObjectUncheckedCreateWithoutJoinedObjectRelationInput[]
    connectOrCreate?: JoinTestObjectCreateOrConnectWithoutJoinedObjectRelationInput | JoinTestObjectCreateOrConnectWithoutJoinedObjectRelationInput[]
    createMany?: JoinTestObjectCreateManyJoinedObjectRelationInputEnvelope
    connect?: JoinTestObjectWhereUniqueInput | JoinTestObjectWhereUniqueInput[]
  }

  export type JoinTestObjectUpdateManyWithoutJoinedObjectRelationNestedInput = {
    create?: XOR<JoinTestObjectCreateWithoutJoinedObjectRelationInput, JoinTestObjectUncheckedCreateWithoutJoinedObjectRelationInput> | JoinTestObjectCreateWithoutJoinedObjectRelationInput[] | JoinTestObjectUncheckedCreateWithoutJoinedObjectRelationInput[]
    connectOrCreate?: JoinTestObjectCreateOrConnectWithoutJoinedObjectRelationInput | JoinTestObjectCreateOrConnectWithoutJoinedObjectRelationInput[]
    upsert?: JoinTestObjectUpsertWithWhereUniqueWithoutJoinedObjectRelationInput | JoinTestObjectUpsertWithWhereUniqueWithoutJoinedObjectRelationInput[]
    createMany?: JoinTestObjectCreateManyJoinedObjectRelationInputEnvelope
    set?: JoinTestObjectWhereUniqueInput | JoinTestObjectWhereUniqueInput[]
    disconnect?: JoinTestObjectWhereUniqueInput | JoinTestObjectWhereUniqueInput[]
    delete?: JoinTestObjectWhereUniqueInput | JoinTestObjectWhereUniqueInput[]
    connect?: JoinTestObjectWhereUniqueInput | JoinTestObjectWhereUniqueInput[]
    update?: JoinTestObjectUpdateWithWhereUniqueWithoutJoinedObjectRelationInput | JoinTestObjectUpdateWithWhereUniqueWithoutJoinedObjectRelationInput[]
    updateMany?: JoinTestObjectUpdateManyWithWhereWithoutJoinedObjectRelationInput | JoinTestObjectUpdateManyWithWhereWithoutJoinedObjectRelationInput[]
    deleteMany?: JoinTestObjectScalarWhereInput | JoinTestObjectScalarWhereInput[]
  }

  export type JoinTestObjectUncheckedUpdateManyWithoutJoinedObjectRelationNestedInput = {
    create?: XOR<JoinTestObjectCreateWithoutJoinedObjectRelationInput, JoinTestObjectUncheckedCreateWithoutJoinedObjectRelationInput> | JoinTestObjectCreateWithoutJoinedObjectRelationInput[] | JoinTestObjectUncheckedCreateWithoutJoinedObjectRelationInput[]
    connectOrCreate?: JoinTestObjectCreateOrConnectWithoutJoinedObjectRelationInput | JoinTestObjectCreateOrConnectWithoutJoinedObjectRelationInput[]
    upsert?: JoinTestObjectUpsertWithWhereUniqueWithoutJoinedObjectRelationInput | JoinTestObjectUpsertWithWhereUniqueWithoutJoinedObjectRelationInput[]
    createMany?: JoinTestObjectCreateManyJoinedObjectRelationInputEnvelope
    set?: JoinTestObjectWhereUniqueInput | JoinTestObjectWhereUniqueInput[]
    disconnect?: JoinTestObjectWhereUniqueInput | JoinTestObjectWhereUniqueInput[]
    delete?: JoinTestObjectWhereUniqueInput | JoinTestObjectWhereUniqueInput[]
    connect?: JoinTestObjectWhereUniqueInput | JoinTestObjectWhereUniqueInput[]
    update?: JoinTestObjectUpdateWithWhereUniqueWithoutJoinedObjectRelationInput | JoinTestObjectUpdateWithWhereUniqueWithoutJoinedObjectRelationInput[]
    updateMany?: JoinTestObjectUpdateManyWithWhereWithoutJoinedObjectRelationInput | JoinTestObjectUpdateManyWithWhereWithoutJoinedObjectRelationInput[]
    deleteMany?: JoinTestObjectScalarWhereInput | JoinTestObjectScalarWhereInput[]
  }

  export type JoinTestObject2CreateNestedManyWithoutJoinedObjectRelationInput = {
    create?: XOR<JoinTestObject2CreateWithoutJoinedObjectRelationInput, JoinTestObject2UncheckedCreateWithoutJoinedObjectRelationInput> | JoinTestObject2CreateWithoutJoinedObjectRelationInput[] | JoinTestObject2UncheckedCreateWithoutJoinedObjectRelationInput[]
    connectOrCreate?: JoinTestObject2CreateOrConnectWithoutJoinedObjectRelationInput | JoinTestObject2CreateOrConnectWithoutJoinedObjectRelationInput[]
    createMany?: JoinTestObject2CreateManyJoinedObjectRelationInputEnvelope
    connect?: JoinTestObject2WhereUniqueInput | JoinTestObject2WhereUniqueInput[]
  }

  export type JoinTestObject2UncheckedCreateNestedManyWithoutJoinedObjectRelationInput = {
    create?: XOR<JoinTestObject2CreateWithoutJoinedObjectRelationInput, JoinTestObject2UncheckedCreateWithoutJoinedObjectRelationInput> | JoinTestObject2CreateWithoutJoinedObjectRelationInput[] | JoinTestObject2UncheckedCreateWithoutJoinedObjectRelationInput[]
    connectOrCreate?: JoinTestObject2CreateOrConnectWithoutJoinedObjectRelationInput | JoinTestObject2CreateOrConnectWithoutJoinedObjectRelationInput[]
    createMany?: JoinTestObject2CreateManyJoinedObjectRelationInputEnvelope
    connect?: JoinTestObject2WhereUniqueInput | JoinTestObject2WhereUniqueInput[]
  }

  export type JoinTestObject2UpdateManyWithoutJoinedObjectRelationNestedInput = {
    create?: XOR<JoinTestObject2CreateWithoutJoinedObjectRelationInput, JoinTestObject2UncheckedCreateWithoutJoinedObjectRelationInput> | JoinTestObject2CreateWithoutJoinedObjectRelationInput[] | JoinTestObject2UncheckedCreateWithoutJoinedObjectRelationInput[]
    connectOrCreate?: JoinTestObject2CreateOrConnectWithoutJoinedObjectRelationInput | JoinTestObject2CreateOrConnectWithoutJoinedObjectRelationInput[]
    upsert?: JoinTestObject2UpsertWithWhereUniqueWithoutJoinedObjectRelationInput | JoinTestObject2UpsertWithWhereUniqueWithoutJoinedObjectRelationInput[]
    createMany?: JoinTestObject2CreateManyJoinedObjectRelationInputEnvelope
    set?: JoinTestObject2WhereUniqueInput | JoinTestObject2WhereUniqueInput[]
    disconnect?: JoinTestObject2WhereUniqueInput | JoinTestObject2WhereUniqueInput[]
    delete?: JoinTestObject2WhereUniqueInput | JoinTestObject2WhereUniqueInput[]
    connect?: JoinTestObject2WhereUniqueInput | JoinTestObject2WhereUniqueInput[]
    update?: JoinTestObject2UpdateWithWhereUniqueWithoutJoinedObjectRelationInput | JoinTestObject2UpdateWithWhereUniqueWithoutJoinedObjectRelationInput[]
    updateMany?: JoinTestObject2UpdateManyWithWhereWithoutJoinedObjectRelationInput | JoinTestObject2UpdateManyWithWhereWithoutJoinedObjectRelationInput[]
    deleteMany?: JoinTestObject2ScalarWhereInput | JoinTestObject2ScalarWhereInput[]
  }

  export type JoinTestObject2UncheckedUpdateManyWithoutJoinedObjectRelationNestedInput = {
    create?: XOR<JoinTestObject2CreateWithoutJoinedObjectRelationInput, JoinTestObject2UncheckedCreateWithoutJoinedObjectRelationInput> | JoinTestObject2CreateWithoutJoinedObjectRelationInput[] | JoinTestObject2UncheckedCreateWithoutJoinedObjectRelationInput[]
    connectOrCreate?: JoinTestObject2CreateOrConnectWithoutJoinedObjectRelationInput | JoinTestObject2CreateOrConnectWithoutJoinedObjectRelationInput[]
    upsert?: JoinTestObject2UpsertWithWhereUniqueWithoutJoinedObjectRelationInput | JoinTestObject2UpsertWithWhereUniqueWithoutJoinedObjectRelationInput[]
    createMany?: JoinTestObject2CreateManyJoinedObjectRelationInputEnvelope
    set?: JoinTestObject2WhereUniqueInput | JoinTestObject2WhereUniqueInput[]
    disconnect?: JoinTestObject2WhereUniqueInput | JoinTestObject2WhereUniqueInput[]
    delete?: JoinTestObject2WhereUniqueInput | JoinTestObject2WhereUniqueInput[]
    connect?: JoinTestObject2WhereUniqueInput | JoinTestObject2WhereUniqueInput[]
    update?: JoinTestObject2UpdateWithWhereUniqueWithoutJoinedObjectRelationInput | JoinTestObject2UpdateWithWhereUniqueWithoutJoinedObjectRelationInput[]
    updateMany?: JoinTestObject2UpdateManyWithWhereWithoutJoinedObjectRelationInput | JoinTestObject2UpdateManyWithWhereWithoutJoinedObjectRelationInput[]
    deleteMany?: JoinTestObject2ScalarWhereInput | JoinTestObject2ScalarWhereInput[]
  }

  export type SelfReferencialJoinModelCreateNestedOneWithoutJoinsAsSourceInput = {
    create?: XOR<SelfReferencialJoinModelCreateWithoutJoinsAsSourceInput, SelfReferencialJoinModelUncheckedCreateWithoutJoinsAsSourceInput>
    connectOrCreate?: SelfReferencialJoinModelCreateOrConnectWithoutJoinsAsSourceInput
    connect?: SelfReferencialJoinModelWhereUniqueInput
  }

  export type SelfReferencialJoinModelCreateNestedOneWithoutJoinsAsTargetInput = {
    create?: XOR<SelfReferencialJoinModelCreateWithoutJoinsAsTargetInput, SelfReferencialJoinModelUncheckedCreateWithoutJoinsAsTargetInput>
    connectOrCreate?: SelfReferencialJoinModelCreateOrConnectWithoutJoinsAsTargetInput
    connect?: SelfReferencialJoinModelWhereUniqueInput
  }

  export type SelfReferencialJoinModelUpdateOneRequiredWithoutJoinsAsSourceNestedInput = {
    create?: XOR<SelfReferencialJoinModelCreateWithoutJoinsAsSourceInput, SelfReferencialJoinModelUncheckedCreateWithoutJoinsAsSourceInput>
    connectOrCreate?: SelfReferencialJoinModelCreateOrConnectWithoutJoinsAsSourceInput
    upsert?: SelfReferencialJoinModelUpsertWithoutJoinsAsSourceInput
    connect?: SelfReferencialJoinModelWhereUniqueInput
    update?: XOR<XOR<SelfReferencialJoinModelUpdateToOneWithWhereWithoutJoinsAsSourceInput, SelfReferencialJoinModelUpdateWithoutJoinsAsSourceInput>, SelfReferencialJoinModelUncheckedUpdateWithoutJoinsAsSourceInput>
  }

  export type SelfReferencialJoinModelUpdateOneRequiredWithoutJoinsAsTargetNestedInput = {
    create?: XOR<SelfReferencialJoinModelCreateWithoutJoinsAsTargetInput, SelfReferencialJoinModelUncheckedCreateWithoutJoinsAsTargetInput>
    connectOrCreate?: SelfReferencialJoinModelCreateOrConnectWithoutJoinsAsTargetInput
    upsert?: SelfReferencialJoinModelUpsertWithoutJoinsAsTargetInput
    connect?: SelfReferencialJoinModelWhereUniqueInput
    update?: XOR<XOR<SelfReferencialJoinModelUpdateToOneWithWhereWithoutJoinsAsTargetInput, SelfReferencialJoinModelUpdateWithoutJoinsAsTargetInput>, SelfReferencialJoinModelUncheckedUpdateWithoutJoinsAsTargetInput>
  }

  export type JoinSelfReferenceCreateNestedManyWithoutSourceInput = {
    create?: XOR<JoinSelfReferenceCreateWithoutSourceInput, JoinSelfReferenceUncheckedCreateWithoutSourceInput> | JoinSelfReferenceCreateWithoutSourceInput[] | JoinSelfReferenceUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: JoinSelfReferenceCreateOrConnectWithoutSourceInput | JoinSelfReferenceCreateOrConnectWithoutSourceInput[]
    createMany?: JoinSelfReferenceCreateManySourceInputEnvelope
    connect?: JoinSelfReferenceWhereUniqueInput | JoinSelfReferenceWhereUniqueInput[]
  }

  export type JoinSelfReferenceCreateNestedManyWithoutTargetInput = {
    create?: XOR<JoinSelfReferenceCreateWithoutTargetInput, JoinSelfReferenceUncheckedCreateWithoutTargetInput> | JoinSelfReferenceCreateWithoutTargetInput[] | JoinSelfReferenceUncheckedCreateWithoutTargetInput[]
    connectOrCreate?: JoinSelfReferenceCreateOrConnectWithoutTargetInput | JoinSelfReferenceCreateOrConnectWithoutTargetInput[]
    createMany?: JoinSelfReferenceCreateManyTargetInputEnvelope
    connect?: JoinSelfReferenceWhereUniqueInput | JoinSelfReferenceWhereUniqueInput[]
  }

  export type JoinSelfReferenceUncheckedCreateNestedManyWithoutSourceInput = {
    create?: XOR<JoinSelfReferenceCreateWithoutSourceInput, JoinSelfReferenceUncheckedCreateWithoutSourceInput> | JoinSelfReferenceCreateWithoutSourceInput[] | JoinSelfReferenceUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: JoinSelfReferenceCreateOrConnectWithoutSourceInput | JoinSelfReferenceCreateOrConnectWithoutSourceInput[]
    createMany?: JoinSelfReferenceCreateManySourceInputEnvelope
    connect?: JoinSelfReferenceWhereUniqueInput | JoinSelfReferenceWhereUniqueInput[]
  }

  export type JoinSelfReferenceUncheckedCreateNestedManyWithoutTargetInput = {
    create?: XOR<JoinSelfReferenceCreateWithoutTargetInput, JoinSelfReferenceUncheckedCreateWithoutTargetInput> | JoinSelfReferenceCreateWithoutTargetInput[] | JoinSelfReferenceUncheckedCreateWithoutTargetInput[]
    connectOrCreate?: JoinSelfReferenceCreateOrConnectWithoutTargetInput | JoinSelfReferenceCreateOrConnectWithoutTargetInput[]
    createMany?: JoinSelfReferenceCreateManyTargetInputEnvelope
    connect?: JoinSelfReferenceWhereUniqueInput | JoinSelfReferenceWhereUniqueInput[]
  }

  export type JoinSelfReferenceUpdateManyWithoutSourceNestedInput = {
    create?: XOR<JoinSelfReferenceCreateWithoutSourceInput, JoinSelfReferenceUncheckedCreateWithoutSourceInput> | JoinSelfReferenceCreateWithoutSourceInput[] | JoinSelfReferenceUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: JoinSelfReferenceCreateOrConnectWithoutSourceInput | JoinSelfReferenceCreateOrConnectWithoutSourceInput[]
    upsert?: JoinSelfReferenceUpsertWithWhereUniqueWithoutSourceInput | JoinSelfReferenceUpsertWithWhereUniqueWithoutSourceInput[]
    createMany?: JoinSelfReferenceCreateManySourceInputEnvelope
    set?: JoinSelfReferenceWhereUniqueInput | JoinSelfReferenceWhereUniqueInput[]
    disconnect?: JoinSelfReferenceWhereUniqueInput | JoinSelfReferenceWhereUniqueInput[]
    delete?: JoinSelfReferenceWhereUniqueInput | JoinSelfReferenceWhereUniqueInput[]
    connect?: JoinSelfReferenceWhereUniqueInput | JoinSelfReferenceWhereUniqueInput[]
    update?: JoinSelfReferenceUpdateWithWhereUniqueWithoutSourceInput | JoinSelfReferenceUpdateWithWhereUniqueWithoutSourceInput[]
    updateMany?: JoinSelfReferenceUpdateManyWithWhereWithoutSourceInput | JoinSelfReferenceUpdateManyWithWhereWithoutSourceInput[]
    deleteMany?: JoinSelfReferenceScalarWhereInput | JoinSelfReferenceScalarWhereInput[]
  }

  export type JoinSelfReferenceUpdateManyWithoutTargetNestedInput = {
    create?: XOR<JoinSelfReferenceCreateWithoutTargetInput, JoinSelfReferenceUncheckedCreateWithoutTargetInput> | JoinSelfReferenceCreateWithoutTargetInput[] | JoinSelfReferenceUncheckedCreateWithoutTargetInput[]
    connectOrCreate?: JoinSelfReferenceCreateOrConnectWithoutTargetInput | JoinSelfReferenceCreateOrConnectWithoutTargetInput[]
    upsert?: JoinSelfReferenceUpsertWithWhereUniqueWithoutTargetInput | JoinSelfReferenceUpsertWithWhereUniqueWithoutTargetInput[]
    createMany?: JoinSelfReferenceCreateManyTargetInputEnvelope
    set?: JoinSelfReferenceWhereUniqueInput | JoinSelfReferenceWhereUniqueInput[]
    disconnect?: JoinSelfReferenceWhereUniqueInput | JoinSelfReferenceWhereUniqueInput[]
    delete?: JoinSelfReferenceWhereUniqueInput | JoinSelfReferenceWhereUniqueInput[]
    connect?: JoinSelfReferenceWhereUniqueInput | JoinSelfReferenceWhereUniqueInput[]
    update?: JoinSelfReferenceUpdateWithWhereUniqueWithoutTargetInput | JoinSelfReferenceUpdateWithWhereUniqueWithoutTargetInput[]
    updateMany?: JoinSelfReferenceUpdateManyWithWhereWithoutTargetInput | JoinSelfReferenceUpdateManyWithWhereWithoutTargetInput[]
    deleteMany?: JoinSelfReferenceScalarWhereInput | JoinSelfReferenceScalarWhereInput[]
  }

  export type JoinSelfReferenceUncheckedUpdateManyWithoutSourceNestedInput = {
    create?: XOR<JoinSelfReferenceCreateWithoutSourceInput, JoinSelfReferenceUncheckedCreateWithoutSourceInput> | JoinSelfReferenceCreateWithoutSourceInput[] | JoinSelfReferenceUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: JoinSelfReferenceCreateOrConnectWithoutSourceInput | JoinSelfReferenceCreateOrConnectWithoutSourceInput[]
    upsert?: JoinSelfReferenceUpsertWithWhereUniqueWithoutSourceInput | JoinSelfReferenceUpsertWithWhereUniqueWithoutSourceInput[]
    createMany?: JoinSelfReferenceCreateManySourceInputEnvelope
    set?: JoinSelfReferenceWhereUniqueInput | JoinSelfReferenceWhereUniqueInput[]
    disconnect?: JoinSelfReferenceWhereUniqueInput | JoinSelfReferenceWhereUniqueInput[]
    delete?: JoinSelfReferenceWhereUniqueInput | JoinSelfReferenceWhereUniqueInput[]
    connect?: JoinSelfReferenceWhereUniqueInput | JoinSelfReferenceWhereUniqueInput[]
    update?: JoinSelfReferenceUpdateWithWhereUniqueWithoutSourceInput | JoinSelfReferenceUpdateWithWhereUniqueWithoutSourceInput[]
    updateMany?: JoinSelfReferenceUpdateManyWithWhereWithoutSourceInput | JoinSelfReferenceUpdateManyWithWhereWithoutSourceInput[]
    deleteMany?: JoinSelfReferenceScalarWhereInput | JoinSelfReferenceScalarWhereInput[]
  }

  export type JoinSelfReferenceUncheckedUpdateManyWithoutTargetNestedInput = {
    create?: XOR<JoinSelfReferenceCreateWithoutTargetInput, JoinSelfReferenceUncheckedCreateWithoutTargetInput> | JoinSelfReferenceCreateWithoutTargetInput[] | JoinSelfReferenceUncheckedCreateWithoutTargetInput[]
    connectOrCreate?: JoinSelfReferenceCreateOrConnectWithoutTargetInput | JoinSelfReferenceCreateOrConnectWithoutTargetInput[]
    upsert?: JoinSelfReferenceUpsertWithWhereUniqueWithoutTargetInput | JoinSelfReferenceUpsertWithWhereUniqueWithoutTargetInput[]
    createMany?: JoinSelfReferenceCreateManyTargetInputEnvelope
    set?: JoinSelfReferenceWhereUniqueInput | JoinSelfReferenceWhereUniqueInput[]
    disconnect?: JoinSelfReferenceWhereUniqueInput | JoinSelfReferenceWhereUniqueInput[]
    delete?: JoinSelfReferenceWhereUniqueInput | JoinSelfReferenceWhereUniqueInput[]
    connect?: JoinSelfReferenceWhereUniqueInput | JoinSelfReferenceWhereUniqueInput[]
    update?: JoinSelfReferenceUpdateWithWhereUniqueWithoutTargetInput | JoinSelfReferenceUpdateWithWhereUniqueWithoutTargetInput[]
    updateMany?: JoinSelfReferenceUpdateManyWithWhereWithoutTargetInput | JoinSelfReferenceUpdateManyWithWhereWithoutTargetInput[]
    deleteMany?: JoinSelfReferenceScalarWhereInput | JoinSelfReferenceScalarWhereInput[]
  }

  export type NestedBytesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel>
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesFilter<$PrismaModel> | Uint8Array
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel>
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Uint8Array
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumAccessGroupFilter<$PrismaModel = never> = {
    equals?: $Enums.AccessGroup | EnumAccessGroupFieldRefInput<$PrismaModel>
    in?: $Enums.AccessGroup[] | ListEnumAccessGroupFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccessGroup[] | ListEnumAccessGroupFieldRefInput<$PrismaModel>
    not?: NestedEnumAccessGroupFilter<$PrismaModel> | $Enums.AccessGroup
  }

  export type NestedBytesNullableFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Uint8Array | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumAccessGroupWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccessGroup | EnumAccessGroupFieldRefInput<$PrismaModel>
    in?: $Enums.AccessGroup[] | ListEnumAccessGroupFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccessGroup[] | ListEnumAccessGroupFieldRefInput<$PrismaModel>
    not?: NestedEnumAccessGroupWithAggregatesFilter<$PrismaModel> | $Enums.AccessGroup
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccessGroupFilter<$PrismaModel>
    _max?: NestedEnumAccessGroupFilter<$PrismaModel>
  }

  export type NestedBytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Uint8Array | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumContactTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactType | EnumContactTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContactTypeFilter<$PrismaModel> | $Enums.ContactType
  }

  export type NestedEnumContactStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactStatus | EnumContactStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContactStatus[] | ListEnumContactStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactStatus[] | ListEnumContactStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContactStatusFilter<$PrismaModel> | $Enums.ContactStatus
  }

  export type NestedEnumLifecycleStageNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.LifecycleStage | EnumLifecycleStageFieldRefInput<$PrismaModel> | null
    in?: $Enums.LifecycleStage[] | ListEnumLifecycleStageFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.LifecycleStage[] | ListEnumLifecycleStageFieldRefInput<$PrismaModel> | null
    not?: NestedEnumLifecycleStageNullableFilter<$PrismaModel> | $Enums.LifecycleStage | null
  }

  export type NestedEnumHouseholdRelationshipStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.HouseholdRelationshipStatus | EnumHouseholdRelationshipStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.HouseholdRelationshipStatus[] | ListEnumHouseholdRelationshipStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.HouseholdRelationshipStatus[] | ListEnumHouseholdRelationshipStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumHouseholdRelationshipStatusNullableFilter<$PrismaModel> | $Enums.HouseholdRelationshipStatus | null
  }

  export type NestedEnumCompanyRelationshipStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanyRelationshipStatus | EnumCompanyRelationshipStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.CompanyRelationshipStatus[] | ListEnumCompanyRelationshipStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CompanyRelationshipStatus[] | ListEnumCompanyRelationshipStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCompanyRelationshipStatusNullableFilter<$PrismaModel> | $Enums.CompanyRelationshipStatus | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumContactTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactType | EnumContactTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContactTypeWithAggregatesFilter<$PrismaModel> | $Enums.ContactType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContactTypeFilter<$PrismaModel>
    _max?: NestedEnumContactTypeFilter<$PrismaModel>
  }

  export type NestedEnumContactStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactStatus | EnumContactStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContactStatus[] | ListEnumContactStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactStatus[] | ListEnumContactStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContactStatusWithAggregatesFilter<$PrismaModel> | $Enums.ContactStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContactStatusFilter<$PrismaModel>
    _max?: NestedEnumContactStatusFilter<$PrismaModel>
  }

  export type NestedEnumLifecycleStageNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LifecycleStage | EnumLifecycleStageFieldRefInput<$PrismaModel> | null
    in?: $Enums.LifecycleStage[] | ListEnumLifecycleStageFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.LifecycleStage[] | ListEnumLifecycleStageFieldRefInput<$PrismaModel> | null
    not?: NestedEnumLifecycleStageNullableWithAggregatesFilter<$PrismaModel> | $Enums.LifecycleStage | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumLifecycleStageNullableFilter<$PrismaModel>
    _max?: NestedEnumLifecycleStageNullableFilter<$PrismaModel>
  }

  export type NestedEnumHouseholdRelationshipStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HouseholdRelationshipStatus | EnumHouseholdRelationshipStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.HouseholdRelationshipStatus[] | ListEnumHouseholdRelationshipStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.HouseholdRelationshipStatus[] | ListEnumHouseholdRelationshipStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumHouseholdRelationshipStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.HouseholdRelationshipStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumHouseholdRelationshipStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumHouseholdRelationshipStatusNullableFilter<$PrismaModel>
  }

  export type NestedEnumCompanyRelationshipStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanyRelationshipStatus | EnumCompanyRelationshipStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.CompanyRelationshipStatus[] | ListEnumCompanyRelationshipStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CompanyRelationshipStatus[] | ListEnumCompanyRelationshipStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCompanyRelationshipStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.CompanyRelationshipStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumCompanyRelationshipStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumCompanyRelationshipStatusNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumActivityStepTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityStepType | EnumActivityStepTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityStepType[] | ListEnumActivityStepTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityStepType[] | ListEnumActivityStepTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityStepTypeFilter<$PrismaModel> | $Enums.ActivityStepType
  }

  export type NestedEnumActivityStepTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityStepType | EnumActivityStepTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityStepType[] | ListEnumActivityStepTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityStepType[] | ListEnumActivityStepTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityStepTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActivityStepType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActivityStepTypeFilter<$PrismaModel>
    _max?: NestedEnumActivityStepTypeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumActivityStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityStatus | EnumActivityStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityStatus[] | ListEnumActivityStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityStatus[] | ListEnumActivityStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityStatusFilter<$PrismaModel> | $Enums.ActivityStatus
  }

  export type NestedEnumActivityStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityStatus | EnumActivityStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityStatus[] | ListEnumActivityStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityStatus[] | ListEnumActivityStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityStatusWithAggregatesFilter<$PrismaModel> | $Enums.ActivityStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActivityStatusFilter<$PrismaModel>
    _max?: NestedEnumActivityStatusFilter<$PrismaModel>
  }

  export type NestedEnumRoleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRoleNullableFilter<$PrismaModel> | $Enums.Role | null
  }

  export type NestedEnumRoleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRoleNullableWithAggregatesFilter<$PrismaModel> | $Enums.Role | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRoleNullableFilter<$PrismaModel>
    _max?: NestedEnumRoleNullableFilter<$PrismaModel>
  }

  export type NestedEnumDateOffsetTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DateOffsetType | EnumDateOffsetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DateOffsetType[] | ListEnumDateOffsetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DateOffsetType[] | ListEnumDateOffsetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDateOffsetTypeFilter<$PrismaModel> | $Enums.DateOffsetType
  }

  export type NestedEnumDateOffsetTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DateOffsetType | EnumDateOffsetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DateOffsetType[] | ListEnumDateOffsetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DateOffsetType[] | ListEnumDateOffsetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDateOffsetTypeWithAggregatesFilter<$PrismaModel> | $Enums.DateOffsetType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDateOffsetTypeFilter<$PrismaModel>
    _max?: NestedEnumDateOffsetTypeFilter<$PrismaModel>
  }

  export type NestedEnumActivityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTypeFilter<$PrismaModel> | $Enums.ActivityType
  }

  export type NestedEnumActivityPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityPriority | EnumActivityPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityPriority[] | ListEnumActivityPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityPriority[] | ListEnumActivityPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityPriorityFilter<$PrismaModel> | $Enums.ActivityPriority
  }

  export type NestedEnumTaskScheduleTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskScheduleType | EnumTaskScheduleTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.TaskScheduleType[] | ListEnumTaskScheduleTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TaskScheduleType[] | ListEnumTaskScheduleTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTaskScheduleTypeNullableFilter<$PrismaModel> | $Enums.TaskScheduleType | null
  }

  export type NestedEnumActivityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActivityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActivityTypeFilter<$PrismaModel>
    _max?: NestedEnumActivityTypeFilter<$PrismaModel>
  }

  export type NestedEnumActivityPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityPriority | EnumActivityPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityPriority[] | ListEnumActivityPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityPriority[] | ListEnumActivityPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityPriorityWithAggregatesFilter<$PrismaModel> | $Enums.ActivityPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActivityPriorityFilter<$PrismaModel>
    _max?: NestedEnumActivityPriorityFilter<$PrismaModel>
  }

  export type NestedEnumTaskScheduleTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskScheduleType | EnumTaskScheduleTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.TaskScheduleType[] | ListEnumTaskScheduleTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TaskScheduleType[] | ListEnumTaskScheduleTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTaskScheduleTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.TaskScheduleType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTaskScheduleTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumTaskScheduleTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumContactTimelineEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactTimelineEventType | EnumContactTimelineEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContactTimelineEventType[] | ListEnumContactTimelineEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactTimelineEventType[] | ListEnumContactTimelineEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContactTimelineEventTypeFilter<$PrismaModel> | $Enums.ContactTimelineEventType
  }

  export type NestedEnumContactTimelineEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactTimelineEventType | EnumContactTimelineEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContactTimelineEventType[] | ListEnumContactTimelineEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactTimelineEventType[] | ListEnumContactTimelineEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContactTimelineEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.ContactTimelineEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContactTimelineEventTypeFilter<$PrismaModel>
    _max?: NestedEnumContactTimelineEventTypeFilter<$PrismaModel>
  }

  export type NestedEnumAuditEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditEventType | EnumAuditEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AuditEventType[] | ListEnumAuditEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditEventType[] | ListEnumAuditEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditEventTypeFilter<$PrismaModel> | $Enums.AuditEventType
  }

  export type NestedEnumAuditableFilter<$PrismaModel = never> = {
    equals?: $Enums.Auditable | EnumAuditableFieldRefInput<$PrismaModel>
    in?: $Enums.Auditable[] | ListEnumAuditableFieldRefInput<$PrismaModel>
    notIn?: $Enums.Auditable[] | ListEnumAuditableFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditableFilter<$PrismaModel> | $Enums.Auditable
  }

  export type NestedEnumAuditEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditEventType | EnumAuditEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AuditEventType[] | ListEnumAuditEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditEventType[] | ListEnumAuditEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.AuditEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditEventTypeFilter<$PrismaModel>
    _max?: NestedEnumAuditEventTypeFilter<$PrismaModel>
  }

  export type NestedEnumAuditableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Auditable | EnumAuditableFieldRefInput<$PrismaModel>
    in?: $Enums.Auditable[] | ListEnumAuditableFieldRefInput<$PrismaModel>
    notIn?: $Enums.Auditable[] | ListEnumAuditableFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditableWithAggregatesFilter<$PrismaModel> | $Enums.Auditable
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditableFilter<$PrismaModel>
    _max?: NestedEnumAuditableFilter<$PrismaModel>
  }

  export type NestedEnumContactTimelineEventJoinTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactTimelineEventJoinType | EnumContactTimelineEventJoinTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContactTimelineEventJoinType[] | ListEnumContactTimelineEventJoinTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactTimelineEventJoinType[] | ListEnumContactTimelineEventJoinTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContactTimelineEventJoinTypeFilter<$PrismaModel> | $Enums.ContactTimelineEventJoinType
  }

  export type NestedEnumContactTimelineEventJoinTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactTimelineEventJoinType | EnumContactTimelineEventJoinTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContactTimelineEventJoinType[] | ListEnumContactTimelineEventJoinTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactTimelineEventJoinType[] | ListEnumContactTimelineEventJoinTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContactTimelineEventJoinTypeWithAggregatesFilter<$PrismaModel> | $Enums.ContactTimelineEventJoinType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContactTimelineEventJoinTypeFilter<$PrismaModel>
    _max?: NestedEnumContactTimelineEventJoinTypeFilter<$PrismaModel>
  }

  export type NestedEnumNoteTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NoteType | EnumNoteTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NoteType[] | ListEnumNoteTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NoteType[] | ListEnumNoteTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNoteTypeFilter<$PrismaModel> | $Enums.NoteType
  }

  export type NestedEnumNoteTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NoteType | EnumNoteTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NoteType[] | ListEnumNoteTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NoteType[] | ListEnumNoteTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNoteTypeWithAggregatesFilter<$PrismaModel> | $Enums.NoteType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNoteTypeFilter<$PrismaModel>
    _max?: NestedEnumNoteTypeFilter<$PrismaModel>
  }

  export type NestedEnumPhoneTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PhoneType | EnumPhoneTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PhoneType[] | ListEnumPhoneTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PhoneType[] | ListEnumPhoneTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPhoneTypeFilter<$PrismaModel> | $Enums.PhoneType
  }

  export type NestedEnumPhoneTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PhoneType | EnumPhoneTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PhoneType[] | ListEnumPhoneTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PhoneType[] | ListEnumPhoneTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPhoneTypeWithAggregatesFilter<$PrismaModel> | $Enums.PhoneType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPhoneTypeFilter<$PrismaModel>
    _max?: NestedEnumPhoneTypeFilter<$PrismaModel>
  }

  export type NestedEnumAddressTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AddressType | EnumAddressTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AddressType[] | ListEnumAddressTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AddressType[] | ListEnumAddressTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAddressTypeFilter<$PrismaModel> | $Enums.AddressType
  }

  export type NestedEnumAddressTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AddressType | EnumAddressTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AddressType[] | ListEnumAddressTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AddressType[] | ListEnumAddressTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAddressTypeWithAggregatesFilter<$PrismaModel> | $Enums.AddressType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAddressTypeFilter<$PrismaModel>
    _max?: NestedEnumAddressTypeFilter<$PrismaModel>
  }

  export type NestedEnumImportantDateTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ImportantDateType | EnumImportantDateTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ImportantDateType[] | ListEnumImportantDateTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImportantDateType[] | ListEnumImportantDateTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumImportantDateTypeFilter<$PrismaModel> | $Enums.ImportantDateType
  }

  export type NestedEnumImportantDateTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ImportantDateType | EnumImportantDateTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ImportantDateType[] | ListEnumImportantDateTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImportantDateType[] | ListEnumImportantDateTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumImportantDateTypeWithAggregatesFilter<$PrismaModel> | $Enums.ImportantDateType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumImportantDateTypeFilter<$PrismaModel>
    _max?: NestedEnumImportantDateTypeFilter<$PrismaModel>
  }

  export type NestedEnumOpportunityStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OpportunityStatus | EnumOpportunityStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OpportunityStatus[] | ListEnumOpportunityStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OpportunityStatus[] | ListEnumOpportunityStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOpportunityStatusFilter<$PrismaModel> | $Enums.OpportunityStatus
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumOpportunityStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OpportunityStatus | EnumOpportunityStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OpportunityStatus[] | ListEnumOpportunityStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OpportunityStatus[] | ListEnumOpportunityStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOpportunityStatusWithAggregatesFilter<$PrismaModel> | $Enums.OpportunityStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOpportunityStatusFilter<$PrismaModel>
    _max?: NestedEnumOpportunityStatusFilter<$PrismaModel>
  }

  export type NestedEnumLogLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.LogLevel | EnumLogLevelFieldRefInput<$PrismaModel>
    in?: $Enums.LogLevel[] | ListEnumLogLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.LogLevel[] | ListEnumLogLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumLogLevelFilter<$PrismaModel> | $Enums.LogLevel
  }

  export type NestedEnumLogLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LogLevel | EnumLogLevelFieldRefInput<$PrismaModel>
    in?: $Enums.LogLevel[] | ListEnumLogLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.LogLevel[] | ListEnumLogLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumLogLevelWithAggregatesFilter<$PrismaModel> | $Enums.LogLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLogLevelFilter<$PrismaModel>
    _max?: NestedEnumLogLevelFilter<$PrismaModel>
  }

  export type UserCreateWithoutTenetInput = {
    id: Uint8Array
    email: string
    firstName: string
    lastName: string
    fullName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password: string
    enabled?: boolean
    type?: $Enums.AccessGroup
    system?: boolean
    deleted?: boolean
    deletedAt?: Date | string | null
    tokens?: TokenCreateNestedManyWithoutUserInput
    activities?: ActivityUserJoinCreateNestedManyWithoutUserRelationInput
    notes?: NoteCreateNestedManyWithoutAuthorInput
    waypoints?: UserWaypointJoinCreateNestedManyWithoutUserRelationInput
    events?: ContactTimelineEventCreateNestedManyWithoutUserInput
    auditEvents?: AuditEventCreateNestedManyWithoutUserInput
    templateAssignments?: TemplateAssignmentCreateNestedManyWithoutSpecificUserInput
    assignedActivities?: ActivityCreateNestedManyWithoutAssignedByInput
    opportunities?: UserOpportunityJoinCreateNestedManyWithoutUserRelationInput
    activitySteps?: ActivityStepUserJoinCreateNestedManyWithoutUserRelationInput
    templateStepAssignments?: ActivityTemplateStepAssignmentCreateNestedManyWithoutSpecificUserInput
  }

  export type UserUncheckedCreateWithoutTenetInput = {
    id: Uint8Array
    email: string
    firstName: string
    lastName: string
    fullName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password: string
    enabled?: boolean
    type?: $Enums.AccessGroup
    system?: boolean
    deleted?: boolean
    deletedAt?: Date | string | null
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUserJoinUncheckedCreateNestedManyWithoutUserRelationInput
    notes?: NoteUncheckedCreateNestedManyWithoutAuthorInput
    waypoints?: UserWaypointJoinUncheckedCreateNestedManyWithoutUserRelationInput
    events?: ContactTimelineEventUncheckedCreateNestedManyWithoutUserInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutUserInput
    templateAssignments?: TemplateAssignmentUncheckedCreateNestedManyWithoutSpecificUserInput
    assignedActivities?: ActivityUncheckedCreateNestedManyWithoutAssignedByInput
    opportunities?: UserOpportunityJoinUncheckedCreateNestedManyWithoutUserRelationInput
    activitySteps?: ActivityStepUserJoinUncheckedCreateNestedManyWithoutUserRelationInput
    templateStepAssignments?: ActivityTemplateStepAssignmentUncheckedCreateNestedManyWithoutSpecificUserInput
  }

  export type UserCreateOrConnectWithoutTenetInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTenetInput, UserUncheckedCreateWithoutTenetInput>
  }

  export type UserCreateManyTenetInputEnvelope = {
    data: UserCreateManyTenetInput | UserCreateManyTenetInput[]
    skipDuplicates?: boolean
  }

  export type LogCreateWithoutTenetInput = {
    id: Uint8Array
    userEmail?: string | null
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    severity?: $Enums.LogLevel
    stacktrace?: string | null
    source?: string | null
    secureDetails?: string | null
  }

  export type LogUncheckedCreateWithoutTenetInput = {
    id: Uint8Array
    userEmail?: string | null
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    severity?: $Enums.LogLevel
    stacktrace?: string | null
    source?: string | null
    secureDetails?: string | null
  }

  export type LogCreateOrConnectWithoutTenetInput = {
    where: LogWhereUniqueInput
    create: XOR<LogCreateWithoutTenetInput, LogUncheckedCreateWithoutTenetInput>
  }

  export type LogCreateManyTenetInputEnvelope = {
    data: LogCreateManyTenetInput | LogCreateManyTenetInput[]
    skipDuplicates?: boolean
  }

  export type ContactCreateWithoutTenetInput = {
    id: Uint8Array
    firstName?: string | null
    lastName: string
    fullName: string
    importantNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.ContactType
    status: $Enums.ContactStatus
    lifecycleStage?: $Enums.LifecycleStage | null
    lastContactedDate?: Date | string | null
    followUpDate?: Date | string | null
    householdStatus?: $Enums.HouseholdRelationshipStatus | null
    position?: string | null
    companyStatus?: $Enums.CompanyRelationshipStatus | null
    industry?: string | null
    website?: string | null
    size?: number | null
    deleted?: boolean
    deletedAt?: Date | string | null
    notes?: NoteCreateNestedManyWithoutContactInput
    timelineEvents?: ContactTimelineEventContactJoinCreateNestedManyWithoutContactRelationInput
    addresses?: AddressCreateNestedManyWithoutContactInput
    emails?: ContactEmailCreateNestedManyWithoutContactInput
    phones?: ContactPhoneCreateNestedManyWithoutContactInput
    importantDates?: ImportantDateCreateNestedManyWithoutContactInput
    activities?: ActivityContactJoinCreateNestedManyWithoutContactRelationInput
    household?: ContactCreateNestedOneWithoutHouseholdMembersInput
    headOfHouseholdFor?: ContactCreateNestedOneWithoutHeadOfHouseholdInput
    company?: ContactCreateNestedOneWithoutEmployeesInput
    primaryContactFor?: ContactCreateNestedOneWithoutPrimaryContactInput
    headOfHousehold?: ContactCreateNestedOneWithoutHeadOfHouseholdForInput
    householdMembers?: ContactCreateNestedManyWithoutHouseholdInput
    employees?: ContactCreateNestedManyWithoutCompanyInput
    primaryContact?: ContactCreateNestedOneWithoutPrimaryContactForInput
    opportunities?: ContactOpportunityJoinCreateNestedManyWithoutContactRelationInput
    relationAsSource?: ContactRelationshipCreateNestedManyWithoutSourceInput
    relationAsTarget?: ContactRelationshipCreateNestedManyWithoutTargetInput
  }

  export type ContactUncheckedCreateWithoutTenetInput = {
    id: Uint8Array
    firstName?: string | null
    lastName: string
    fullName: string
    importantNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.ContactType
    status: $Enums.ContactStatus
    lifecycleStage?: $Enums.LifecycleStage | null
    lastContactedDate?: Date | string | null
    followUpDate?: Date | string | null
    householdId?: Uint8Array | null
    householdStatus?: $Enums.HouseholdRelationshipStatus | null
    companyId?: Uint8Array | null
    position?: string | null
    companyStatus?: $Enums.CompanyRelationshipStatus | null
    headOfHouseholdId?: Uint8Array | null
    industry?: string | null
    website?: string | null
    size?: number | null
    primaryContactId?: Uint8Array | null
    deleted?: boolean
    deletedAt?: Date | string | null
    notes?: NoteUncheckedCreateNestedManyWithoutContactInput
    timelineEvents?: ContactTimelineEventContactJoinUncheckedCreateNestedManyWithoutContactRelationInput
    addresses?: AddressUncheckedCreateNestedManyWithoutContactInput
    emails?: ContactEmailUncheckedCreateNestedManyWithoutContactInput
    phones?: ContactPhoneUncheckedCreateNestedManyWithoutContactInput
    importantDates?: ImportantDateUncheckedCreateNestedManyWithoutContactInput
    activities?: ActivityContactJoinUncheckedCreateNestedManyWithoutContactRelationInput
    headOfHouseholdFor?: ContactUncheckedCreateNestedOneWithoutHeadOfHouseholdInput
    primaryContactFor?: ContactUncheckedCreateNestedOneWithoutPrimaryContactInput
    householdMembers?: ContactUncheckedCreateNestedManyWithoutHouseholdInput
    employees?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    opportunities?: ContactOpportunityJoinUncheckedCreateNestedManyWithoutContactRelationInput
    relationAsSource?: ContactRelationshipUncheckedCreateNestedManyWithoutSourceInput
    relationAsTarget?: ContactRelationshipUncheckedCreateNestedManyWithoutTargetInput
  }

  export type ContactCreateOrConnectWithoutTenetInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutTenetInput, ContactUncheckedCreateWithoutTenetInput>
  }

  export type ContactCreateManyTenetInputEnvelope = {
    data: ContactCreateManyTenetInput | ContactCreateManyTenetInput[]
    skipDuplicates?: boolean
  }

  export type ActivityCreateWithoutTenetInput = {
    id: Uint8Array
    title: string
    type: $Enums.ActivityType
    taskScheduleType?: $Enums.TaskScheduleType | null
    startDate: Date | string
    endDate: Date | string
    completedAt?: Date | string | null
    description?: string | null
    priority?: $Enums.ActivityPriority
    status: $Enums.ActivityStatus
    phoneNumber?: string | null
    location?: string | null
    holdReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean
    deletedAt?: Date | string | null
    order?: number | null
    steps?: ActivityStepCreateNestedManyWithoutActivityInput
    waypoints?: ActivityWaypointCreateNestedManyWithoutActivityInput
    activities?: ActivityCreateNestedManyWithoutParentActivityInput
    parentActivity?: ActivityCreateNestedOneWithoutActivitiesInput
    parentWaypoint?: ActivityWaypointCreateNestedOneWithoutChildActivitiesInput
    template?: ActivityTemplateCreateNestedOneWithoutActivitiesInput
    assignedBy: UserCreateNestedOneWithoutAssignedActivitiesInput
    contacts?: ActivityContactJoinCreateNestedManyWithoutActivityRelationInput
    users?: ActivityUserJoinCreateNestedManyWithoutActivityRelationInput
    attachments?: AttachmentCreateNestedManyWithoutActivityInput
    notes?: NoteCreateNestedManyWithoutActivityInput
    events?: ContactTimelineEventCreateNestedManyWithoutActivityInput
    opportunity?: OpportunityCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateWithoutTenetInput = {
    id: Uint8Array
    title: string
    type: $Enums.ActivityType
    parentActivityId?: Uint8Array | null
    parentWaypointId?: Uint8Array | null
    templateId?: Uint8Array | null
    taskScheduleType?: $Enums.TaskScheduleType | null
    startDate: Date | string
    endDate: Date | string
    completedAt?: Date | string | null
    description?: string | null
    priority?: $Enums.ActivityPriority
    status: $Enums.ActivityStatus
    assignedById: Uint8Array
    phoneNumber?: string | null
    location?: string | null
    holdReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean
    deletedAt?: Date | string | null
    order?: number | null
    opportunityId?: Uint8Array | null
    steps?: ActivityStepUncheckedCreateNestedManyWithoutActivityInput
    waypoints?: ActivityWaypointUncheckedCreateNestedManyWithoutActivityInput
    activities?: ActivityUncheckedCreateNestedManyWithoutParentActivityInput
    contacts?: ActivityContactJoinUncheckedCreateNestedManyWithoutActivityRelationInput
    users?: ActivityUserJoinUncheckedCreateNestedManyWithoutActivityRelationInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutActivityInput
    notes?: NoteUncheckedCreateNestedManyWithoutActivityInput
    events?: ContactTimelineEventUncheckedCreateNestedManyWithoutActivityInput
  }

  export type ActivityCreateOrConnectWithoutTenetInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutTenetInput, ActivityUncheckedCreateWithoutTenetInput>
  }

  export type ActivityCreateManyTenetInputEnvelope = {
    data: ActivityCreateManyTenetInput | ActivityCreateManyTenetInput[]
    skipDuplicates?: boolean
  }

  export type AddressCreateWithoutTenetInput = {
    id: Uint8Array
    street: string
    city: string
    state: string
    zip: string
    country: string
    type: $Enums.AddressType
    primary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    timezone?: string | null
    contact: ContactCreateNestedOneWithoutAddressesInput
  }

  export type AddressUncheckedCreateWithoutTenetInput = {
    id: Uint8Array
    street: string
    city: string
    state: string
    zip: string
    country: string
    type: $Enums.AddressType
    primary?: boolean
    contactId: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
    timezone?: string | null
  }

  export type AddressCreateOrConnectWithoutTenetInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutTenetInput, AddressUncheckedCreateWithoutTenetInput>
  }

  export type AddressCreateManyTenetInputEnvelope = {
    data: AddressCreateManyTenetInput | AddressCreateManyTenetInput[]
    skipDuplicates?: boolean
  }

  export type ContactEmailCreateWithoutTenetInput = {
    id: Uint8Array
    email: string
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contact: ContactCreateNestedOneWithoutEmailsInput
  }

  export type ContactEmailUncheckedCreateWithoutTenetInput = {
    id: Uint8Array
    email: string
    isPrimary?: boolean
    contactId: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactEmailCreateOrConnectWithoutTenetInput = {
    where: ContactEmailWhereUniqueInput
    create: XOR<ContactEmailCreateWithoutTenetInput, ContactEmailUncheckedCreateWithoutTenetInput>
  }

  export type ContactEmailCreateManyTenetInputEnvelope = {
    data: ContactEmailCreateManyTenetInput | ContactEmailCreateManyTenetInput[]
    skipDuplicates?: boolean
  }

  export type ContactPhoneCreateWithoutTenetInput = {
    id: Uint8Array
    number: string
    type: $Enums.PhoneType
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contact: ContactCreateNestedOneWithoutPhonesInput
  }

  export type ContactPhoneUncheckedCreateWithoutTenetInput = {
    id: Uint8Array
    number: string
    type: $Enums.PhoneType
    isPrimary?: boolean
    contactId: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactPhoneCreateOrConnectWithoutTenetInput = {
    where: ContactPhoneWhereUniqueInput
    create: XOR<ContactPhoneCreateWithoutTenetInput, ContactPhoneUncheckedCreateWithoutTenetInput>
  }

  export type ContactPhoneCreateManyTenetInputEnvelope = {
    data: ContactPhoneCreateManyTenetInput | ContactPhoneCreateManyTenetInput[]
    skipDuplicates?: boolean
  }

  export type ImportantDateCreateWithoutTenetInput = {
    id: Uint8Array
    date: Date | string
    type: $Enums.ImportantDateType
    createdAt?: Date | string
    updatedAt?: Date | string
    contact: ContactCreateNestedOneWithoutImportantDatesInput
  }

  export type ImportantDateUncheckedCreateWithoutTenetInput = {
    id: Uint8Array
    date: Date | string
    type: $Enums.ImportantDateType
    contactId: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImportantDateCreateOrConnectWithoutTenetInput = {
    where: ImportantDateWhereUniqueInput
    create: XOR<ImportantDateCreateWithoutTenetInput, ImportantDateUncheckedCreateWithoutTenetInput>
  }

  export type ImportantDateCreateManyTenetInputEnvelope = {
    data: ImportantDateCreateManyTenetInput | ImportantDateCreateManyTenetInput[]
    skipDuplicates?: boolean
  }

  export type AttachmentCreateWithoutTenetInput = {
    id: Uint8Array
    name: string
    location: string
    activity?: ActivityCreateNestedOneWithoutAttachmentsInput
  }

  export type AttachmentUncheckedCreateWithoutTenetInput = {
    id: Uint8Array
    name: string
    location: string
    activityId?: Uint8Array | null
  }

  export type AttachmentCreateOrConnectWithoutTenetInput = {
    where: AttachmentWhereUniqueInput
    create: XOR<AttachmentCreateWithoutTenetInput, AttachmentUncheckedCreateWithoutTenetInput>
  }

  export type AttachmentCreateManyTenetInputEnvelope = {
    data: AttachmentCreateManyTenetInput | AttachmentCreateManyTenetInput[]
    skipDuplicates?: boolean
  }

  export type NoteCreateWithoutTenetInput = {
    id: Uint8Array
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean
    deletedAt?: Date | string | null
    noteType?: $Enums.NoteType
    waypoint?: ActivityWaypointCreateNestedOneWithoutNoteInput
    activity?: ActivityCreateNestedOneWithoutNotesInput
    contact?: ContactCreateNestedOneWithoutNotesInput
    opportunity?: OpportunityCreateNestedOneWithoutNotesInput
    author: UserCreateNestedOneWithoutNotesInput
    events?: ContactTimelineEventCreateNestedManyWithoutNoteInput
  }

  export type NoteUncheckedCreateWithoutTenetInput = {
    id: Uint8Array
    content: string
    waypointId?: Uint8Array | null
    activityId?: Uint8Array | null
    contactId?: Uint8Array | null
    opportunityId?: Uint8Array | null
    authorId: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean
    deletedAt?: Date | string | null
    noteType?: $Enums.NoteType
    events?: ContactTimelineEventUncheckedCreateNestedManyWithoutNoteInput
  }

  export type NoteCreateOrConnectWithoutTenetInput = {
    where: NoteWhereUniqueInput
    create: XOR<NoteCreateWithoutTenetInput, NoteUncheckedCreateWithoutTenetInput>
  }

  export type NoteCreateManyTenetInputEnvelope = {
    data: NoteCreateManyTenetInput | NoteCreateManyTenetInput[]
    skipDuplicates?: boolean
  }

  export type AuditEventCreateWithoutTenetInput = {
    id: Uint8Array
    type: $Enums.AuditEventType
    details?: string | null
    referenceId: Uint8Array
    reference: $Enums.Auditable
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAuditEventsInput
  }

  export type AuditEventUncheckedCreateWithoutTenetInput = {
    id: Uint8Array
    userId: Uint8Array
    type: $Enums.AuditEventType
    details?: string | null
    referenceId: Uint8Array
    reference: $Enums.Auditable
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditEventCreateOrConnectWithoutTenetInput = {
    where: AuditEventWhereUniqueInput
    create: XOR<AuditEventCreateWithoutTenetInput, AuditEventUncheckedCreateWithoutTenetInput>
  }

  export type AuditEventCreateManyTenetInputEnvelope = {
    data: AuditEventCreateManyTenetInput | AuditEventCreateManyTenetInput[]
    skipDuplicates?: boolean
  }

  export type ContactTimelineEventCreateWithoutTenetInput = {
    id: Uint8Array
    extraInfo?: string | null
    eventType: $Enums.ContactTimelineEventType
    relationshipType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activity?: ActivityCreateNestedOneWithoutEventsInput
    waypoint?: ActivityWaypointCreateNestedOneWithoutEventsInput
    opportunity?: OpportunityCreateNestedOneWithoutEventsInput
    note?: NoteCreateNestedOneWithoutEventsInput
    contacts?: ContactTimelineEventContactJoinCreateNestedManyWithoutContactEventRelationInput
    user: UserCreateNestedOneWithoutEventsInput
  }

  export type ContactTimelineEventUncheckedCreateWithoutTenetInput = {
    id: Uint8Array
    activityId?: Uint8Array | null
    waypointId?: Uint8Array | null
    opportunityId?: Uint8Array | null
    noteId?: Uint8Array | null
    extraInfo?: string | null
    userId: Uint8Array
    eventType: $Enums.ContactTimelineEventType
    relationshipType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: ContactTimelineEventContactJoinUncheckedCreateNestedManyWithoutContactEventRelationInput
  }

  export type ContactTimelineEventCreateOrConnectWithoutTenetInput = {
    where: ContactTimelineEventWhereUniqueInput
    create: XOR<ContactTimelineEventCreateWithoutTenetInput, ContactTimelineEventUncheckedCreateWithoutTenetInput>
  }

  export type ContactTimelineEventCreateManyTenetInputEnvelope = {
    data: ContactTimelineEventCreateManyTenetInput | ContactTimelineEventCreateManyTenetInput[]
    skipDuplicates?: boolean
  }

  export type ActivityStepCreateWithoutTenetInput = {
    id: Uint8Array
    title: string
    completed: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    type?: $Enums.ActivityStepType
    order: number
    activity: ActivityCreateNestedOneWithoutStepsInput
    assignedTo?: ActivityStepUserJoinCreateNestedManyWithoutStepRelationInput
  }

  export type ActivityStepUncheckedCreateWithoutTenetInput = {
    id: Uint8Array
    title: string
    completed: boolean
    activityId: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
    type?: $Enums.ActivityStepType
    order: number
    assignedTo?: ActivityStepUserJoinUncheckedCreateNestedManyWithoutStepRelationInput
  }

  export type ActivityStepCreateOrConnectWithoutTenetInput = {
    where: ActivityStepWhereUniqueInput
    create: XOR<ActivityStepCreateWithoutTenetInput, ActivityStepUncheckedCreateWithoutTenetInput>
  }

  export type ActivityStepCreateManyTenetInputEnvelope = {
    data: ActivityStepCreateManyTenetInput | ActivityStepCreateManyTenetInput[]
    skipDuplicates?: boolean
  }

  export type ActivityWaypointCreateWithoutTenetInput = {
    id: Uint8Array
    title: string
    description?: string | null
    summary?: string | null
    status: $Enums.ActivityStatus
    order: number
    actualStart: Date | string
    dueDate: Date | string
    actualEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserWaypointJoinCreateNestedManyWithoutWaypointRelationInput
    activity: ActivityCreateNestedOneWithoutWaypointsInput
    childActivities?: ActivityCreateNestedManyWithoutParentWaypointInput
    template?: ActivityWaypointTemplateCreateNestedOneWithoutWaypointsInput
    events?: ContactTimelineEventCreateNestedManyWithoutWaypointInput
    Note?: NoteCreateNestedManyWithoutWaypointInput
  }

  export type ActivityWaypointUncheckedCreateWithoutTenetInput = {
    id: Uint8Array
    title: string
    description?: string | null
    summary?: string | null
    status: $Enums.ActivityStatus
    order: number
    actualStart: Date | string
    dueDate: Date | string
    actualEnd?: Date | string | null
    activityId: Uint8Array
    templateId?: Uint8Array | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserWaypointJoinUncheckedCreateNestedManyWithoutWaypointRelationInput
    childActivities?: ActivityUncheckedCreateNestedManyWithoutParentWaypointInput
    events?: ContactTimelineEventUncheckedCreateNestedManyWithoutWaypointInput
    Note?: NoteUncheckedCreateNestedManyWithoutWaypointInput
  }

  export type ActivityWaypointCreateOrConnectWithoutTenetInput = {
    where: ActivityWaypointWhereUniqueInput
    create: XOR<ActivityWaypointCreateWithoutTenetInput, ActivityWaypointUncheckedCreateWithoutTenetInput>
  }

  export type ActivityWaypointCreateManyTenetInputEnvelope = {
    data: ActivityWaypointCreateManyTenetInput | ActivityWaypointCreateManyTenetInput[]
    skipDuplicates?: boolean
  }

  export type TemplateAssignmentCreateWithoutTenetInput = {
    id: Uint8Array
    specificRole?: $Enums.Role | null
    createdAt?: Date | string
    updatedAt?: Date | string
    specificUser?: UserCreateNestedOneWithoutTemplateAssignmentsInput
    activityTemplate?: ActivityTemplateCreateNestedOneWithoutAssignmentsInput
    waypointTemplate?: ActivityWaypointTemplateCreateNestedOneWithoutAssignmentsInput
  }

  export type TemplateAssignmentUncheckedCreateWithoutTenetInput = {
    id: Uint8Array
    specificUserId?: Uint8Array | null
    specificRole?: $Enums.Role | null
    activityTemplateId?: Uint8Array | null
    waypointTemplateId?: Uint8Array | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TemplateAssignmentCreateOrConnectWithoutTenetInput = {
    where: TemplateAssignmentWhereUniqueInput
    create: XOR<TemplateAssignmentCreateWithoutTenetInput, TemplateAssignmentUncheckedCreateWithoutTenetInput>
  }

  export type TemplateAssignmentCreateManyTenetInputEnvelope = {
    data: TemplateAssignmentCreateManyTenetInput | TemplateAssignmentCreateManyTenetInput[]
    skipDuplicates?: boolean
  }

  export type ActivityWaypointTemplateCreateWithoutTenetInput = {
    id: Uint8Array
    title: string
    description?: string | null
    defaultStatus: $Enums.ActivityStatus
    order: number
    dateOffsetType: $Enums.DateOffsetType
    dueDate: number
    createdAt?: Date | string
    updatedAt?: Date | string
    parentActivity: ActivityTemplateCreateNestedOneWithoutWaypointsInput
    activities?: ActivityTemplateCreateNestedManyWithoutParentWaypointInput
    waypoints?: ActivityWaypointCreateNestedManyWithoutTemplateInput
    assignments?: TemplateAssignmentCreateNestedManyWithoutWaypointTemplateInput
  }

  export type ActivityWaypointTemplateUncheckedCreateWithoutTenetInput = {
    id: Uint8Array
    title: string
    description?: string | null
    defaultStatus: $Enums.ActivityStatus
    order: number
    dateOffsetType: $Enums.DateOffsetType
    dueDate: number
    parentActivityId: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityTemplateUncheckedCreateNestedManyWithoutParentWaypointInput
    waypoints?: ActivityWaypointUncheckedCreateNestedManyWithoutTemplateInput
    assignments?: TemplateAssignmentUncheckedCreateNestedManyWithoutWaypointTemplateInput
  }

  export type ActivityWaypointTemplateCreateOrConnectWithoutTenetInput = {
    where: ActivityWaypointTemplateWhereUniqueInput
    create: XOR<ActivityWaypointTemplateCreateWithoutTenetInput, ActivityWaypointTemplateUncheckedCreateWithoutTenetInput>
  }

  export type ActivityWaypointTemplateCreateManyTenetInputEnvelope = {
    data: ActivityWaypointTemplateCreateManyTenetInput | ActivityWaypointTemplateCreateManyTenetInput[]
    skipDuplicates?: boolean
  }

  export type ActivityTemplateCreateWithoutTenetInput = {
    id: Uint8Array
    title: string
    description?: string | null
    type: $Enums.ActivityType
    defaultPriority: $Enums.ActivityPriority
    defaultStatus: $Enums.ActivityStatus
    taskScheduleType?: $Enums.TaskScheduleType | null
    dateOffsetType: $Enums.DateOffsetType
    startDate: number
    endDate: number
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: number | null
    steps?: ActivityTemplateStepCreateNestedManyWithoutActivityTemplateInput
    startRelativeTo?: ActivityTemplateCreateNestedOneWithoutDependentsInput
    dependents?: ActivityTemplateCreateNestedManyWithoutStartRelativeToInput
    parentWaypoint?: ActivityWaypointTemplateCreateNestedOneWithoutActivitiesInput
    parentActivity?: ActivityTemplateCreateNestedOneWithoutChildActivitiesInput
    waypoints?: ActivityWaypointTemplateCreateNestedManyWithoutParentActivityInput
    childActivities?: ActivityTemplateCreateNestedManyWithoutParentActivityInput
    activities?: ActivityCreateNestedManyWithoutTemplateInput
    assignments?: TemplateAssignmentCreateNestedManyWithoutActivityTemplateInput
  }

  export type ActivityTemplateUncheckedCreateWithoutTenetInput = {
    id: Uint8Array
    title: string
    description?: string | null
    type: $Enums.ActivityType
    defaultPriority: $Enums.ActivityPriority
    defaultStatus: $Enums.ActivityStatus
    taskScheduleType?: $Enums.TaskScheduleType | null
    dateOffsetType: $Enums.DateOffsetType
    startDate: number
    endDate: number
    startRelativeToId?: Uint8Array | null
    parentWaypointId?: Uint8Array | null
    parentActivityId?: Uint8Array | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: number | null
    steps?: ActivityTemplateStepUncheckedCreateNestedManyWithoutActivityTemplateInput
    dependents?: ActivityTemplateUncheckedCreateNestedManyWithoutStartRelativeToInput
    waypoints?: ActivityWaypointTemplateUncheckedCreateNestedManyWithoutParentActivityInput
    childActivities?: ActivityTemplateUncheckedCreateNestedManyWithoutParentActivityInput
    activities?: ActivityUncheckedCreateNestedManyWithoutTemplateInput
    assignments?: TemplateAssignmentUncheckedCreateNestedManyWithoutActivityTemplateInput
  }

  export type ActivityTemplateCreateOrConnectWithoutTenetInput = {
    where: ActivityTemplateWhereUniqueInput
    create: XOR<ActivityTemplateCreateWithoutTenetInput, ActivityTemplateUncheckedCreateWithoutTenetInput>
  }

  export type ActivityTemplateCreateManyTenetInputEnvelope = {
    data: ActivityTemplateCreateManyTenetInput | ActivityTemplateCreateManyTenetInput[]
    skipDuplicates?: boolean
  }

  export type ActivityTemplateStepCreateWithoutTenetInput = {
    id: Uint8Array
    order: number
    title: string
    type?: $Enums.ActivityStepType
    activityTemplate: ActivityTemplateCreateNestedOneWithoutStepsInput
    assignedTo?: ActivityTemplateStepAssignmentCreateNestedManyWithoutActivityTemplateStepInput
  }

  export type ActivityTemplateStepUncheckedCreateWithoutTenetInput = {
    id: Uint8Array
    order: number
    title: string
    type?: $Enums.ActivityStepType
    activityTemplateId: Uint8Array
    assignedTo?: ActivityTemplateStepAssignmentUncheckedCreateNestedManyWithoutActivityTemplateStepInput
  }

  export type ActivityTemplateStepCreateOrConnectWithoutTenetInput = {
    where: ActivityTemplateStepWhereUniqueInput
    create: XOR<ActivityTemplateStepCreateWithoutTenetInput, ActivityTemplateStepUncheckedCreateWithoutTenetInput>
  }

  export type ActivityTemplateStepCreateManyTenetInputEnvelope = {
    data: ActivityTemplateStepCreateManyTenetInput | ActivityTemplateStepCreateManyTenetInput[]
    skipDuplicates?: boolean
  }

  export type OpportunityCreateWithoutTenetInput = {
    id: Uint8Array
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    value: number
    probability: number
    expectedCloseDate: Date | string
    actualCloseDate?: Date | string | null
    status: $Enums.OpportunityStatus
    statusHistory?: OpportunityCreatestatusHistoryInput | $Enums.OpportunityStatus[]
    deleted?: boolean
    deletedAt?: Date | string | null
    expectedValue: number
    contacts?: ContactOpportunityJoinCreateNestedManyWithoutOpportunityRelationInput
    teamMembers?: UserOpportunityJoinCreateNestedManyWithoutOpportunityRelationInput
    activities?: ActivityCreateNestedManyWithoutOpportunityInput
    products?: OpportunityProductCreateNestedManyWithoutOpportunityInput
    events?: ContactTimelineEventCreateNestedManyWithoutOpportunityInput
    notes?: NoteCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityUncheckedCreateWithoutTenetInput = {
    id: Uint8Array
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    value: number
    probability: number
    expectedCloseDate: Date | string
    actualCloseDate?: Date | string | null
    status: $Enums.OpportunityStatus
    statusHistory?: OpportunityCreatestatusHistoryInput | $Enums.OpportunityStatus[]
    deleted?: boolean
    deletedAt?: Date | string | null
    expectedValue: number
    contacts?: ContactOpportunityJoinUncheckedCreateNestedManyWithoutOpportunityRelationInput
    teamMembers?: UserOpportunityJoinUncheckedCreateNestedManyWithoutOpportunityRelationInput
    activities?: ActivityUncheckedCreateNestedManyWithoutOpportunityInput
    products?: OpportunityProductUncheckedCreateNestedManyWithoutOpportunityInput
    events?: ContactTimelineEventUncheckedCreateNestedManyWithoutOpportunityInput
    notes?: NoteUncheckedCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityCreateOrConnectWithoutTenetInput = {
    where: OpportunityWhereUniqueInput
    create: XOR<OpportunityCreateWithoutTenetInput, OpportunityUncheckedCreateWithoutTenetInput>
  }

  export type OpportunityCreateManyTenetInputEnvelope = {
    data: OpportunityCreateManyTenetInput | OpportunityCreateManyTenetInput[]
    skipDuplicates?: boolean
  }

  export type ProductTypeCreateWithoutTenetInput = {
    id: Uint8Array
    title: string
    description?: string | null
    defaultCommission: number
    createdAt?: Date | string
    updatedAt?: Date | string
    opportunities?: OpportunityProductCreateNestedManyWithoutProductTypeInput
  }

  export type ProductTypeUncheckedCreateWithoutTenetInput = {
    id: Uint8Array
    title: string
    description?: string | null
    defaultCommission: number
    createdAt?: Date | string
    updatedAt?: Date | string
    opportunities?: OpportunityProductUncheckedCreateNestedManyWithoutProductTypeInput
  }

  export type ProductTypeCreateOrConnectWithoutTenetInput = {
    where: ProductTypeWhereUniqueInput
    create: XOR<ProductTypeCreateWithoutTenetInput, ProductTypeUncheckedCreateWithoutTenetInput>
  }

  export type ProductTypeCreateManyTenetInputEnvelope = {
    data: ProductTypeCreateManyTenetInput | ProductTypeCreateManyTenetInput[]
    skipDuplicates?: boolean
  }

  export type ActivityTemplateStepAssignmentCreateWithoutTenetInput = {
    id: Uint8Array
    specificRole?: $Enums.Role | null
    specificUser?: UserCreateNestedOneWithoutTemplateStepAssignmentsInput
    activityTemplateStep: ActivityTemplateStepCreateNestedOneWithoutAssignedToInput
  }

  export type ActivityTemplateStepAssignmentUncheckedCreateWithoutTenetInput = {
    id: Uint8Array
    specificUserId?: Uint8Array | null
    specificRole?: $Enums.Role | null
    activityTemplateStepId: Uint8Array
  }

  export type ActivityTemplateStepAssignmentCreateOrConnectWithoutTenetInput = {
    where: ActivityTemplateStepAssignmentWhereUniqueInput
    create: XOR<ActivityTemplateStepAssignmentCreateWithoutTenetInput, ActivityTemplateStepAssignmentUncheckedCreateWithoutTenetInput>
  }

  export type ActivityTemplateStepAssignmentCreateManyTenetInputEnvelope = {
    data: ActivityTemplateStepAssignmentCreateManyTenetInput | ActivityTemplateStepAssignmentCreateManyTenetInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutTenetInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutTenetInput, UserUncheckedUpdateWithoutTenetInput>
    create: XOR<UserCreateWithoutTenetInput, UserUncheckedCreateWithoutTenetInput>
  }

  export type UserUpdateWithWhereUniqueWithoutTenetInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutTenetInput, UserUncheckedUpdateWithoutTenetInput>
  }

  export type UserUpdateManyWithWhereWithoutTenetInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutTenetInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: BytesFilter<"User"> | Uint8Array
    email?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    fullName?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    password?: StringFilter<"User"> | string
    enabled?: BoolFilter<"User"> | boolean
    type?: EnumAccessGroupFilter<"User"> | $Enums.AccessGroup
    tenetId?: BytesNullableFilter<"User"> | Uint8Array | null
    system?: BoolFilter<"User"> | boolean
    deleted?: BoolFilter<"User"> | boolean
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
  }

  export type LogUpsertWithWhereUniqueWithoutTenetInput = {
    where: LogWhereUniqueInput
    update: XOR<LogUpdateWithoutTenetInput, LogUncheckedUpdateWithoutTenetInput>
    create: XOR<LogCreateWithoutTenetInput, LogUncheckedCreateWithoutTenetInput>
  }

  export type LogUpdateWithWhereUniqueWithoutTenetInput = {
    where: LogWhereUniqueInput
    data: XOR<LogUpdateWithoutTenetInput, LogUncheckedUpdateWithoutTenetInput>
  }

  export type LogUpdateManyWithWhereWithoutTenetInput = {
    where: LogScalarWhereInput
    data: XOR<LogUpdateManyMutationInput, LogUncheckedUpdateManyWithoutTenetInput>
  }

  export type LogScalarWhereInput = {
    AND?: LogScalarWhereInput | LogScalarWhereInput[]
    OR?: LogScalarWhereInput[]
    NOT?: LogScalarWhereInput | LogScalarWhereInput[]
    id?: BytesFilter<"Log"> | Uint8Array
    userEmail?: StringNullableFilter<"Log"> | string | null
    tenetId?: BytesNullableFilter<"Log"> | Uint8Array | null
    message?: StringFilter<"Log"> | string
    createdAt?: DateTimeFilter<"Log"> | Date | string
    updatedAt?: DateTimeFilter<"Log"> | Date | string
    severity?: EnumLogLevelFilter<"Log"> | $Enums.LogLevel
    stacktrace?: StringNullableFilter<"Log"> | string | null
    source?: StringNullableFilter<"Log"> | string | null
    secureDetails?: StringNullableFilter<"Log"> | string | null
  }

  export type ContactUpsertWithWhereUniqueWithoutTenetInput = {
    where: ContactWhereUniqueInput
    update: XOR<ContactUpdateWithoutTenetInput, ContactUncheckedUpdateWithoutTenetInput>
    create: XOR<ContactCreateWithoutTenetInput, ContactUncheckedCreateWithoutTenetInput>
  }

  export type ContactUpdateWithWhereUniqueWithoutTenetInput = {
    where: ContactWhereUniqueInput
    data: XOR<ContactUpdateWithoutTenetInput, ContactUncheckedUpdateWithoutTenetInput>
  }

  export type ContactUpdateManyWithWhereWithoutTenetInput = {
    where: ContactScalarWhereInput
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyWithoutTenetInput>
  }

  export type ContactScalarWhereInput = {
    AND?: ContactScalarWhereInput | ContactScalarWhereInput[]
    OR?: ContactScalarWhereInput[]
    NOT?: ContactScalarWhereInput | ContactScalarWhereInput[]
    id?: BytesFilter<"Contact"> | Uint8Array
    firstName?: StringNullableFilter<"Contact"> | string | null
    lastName?: StringFilter<"Contact"> | string
    fullName?: StringFilter<"Contact"> | string
    tenetId?: BytesFilter<"Contact"> | Uint8Array
    importantNotes?: StringNullableFilter<"Contact"> | string | null
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    type?: EnumContactTypeFilter<"Contact"> | $Enums.ContactType
    status?: EnumContactStatusFilter<"Contact"> | $Enums.ContactStatus
    lifecycleStage?: EnumLifecycleStageNullableFilter<"Contact"> | $Enums.LifecycleStage | null
    lastContactedDate?: DateTimeNullableFilter<"Contact"> | Date | string | null
    followUpDate?: DateTimeNullableFilter<"Contact"> | Date | string | null
    householdId?: BytesNullableFilter<"Contact"> | Uint8Array | null
    householdStatus?: EnumHouseholdRelationshipStatusNullableFilter<"Contact"> | $Enums.HouseholdRelationshipStatus | null
    companyId?: BytesNullableFilter<"Contact"> | Uint8Array | null
    position?: StringNullableFilter<"Contact"> | string | null
    companyStatus?: EnumCompanyRelationshipStatusNullableFilter<"Contact"> | $Enums.CompanyRelationshipStatus | null
    headOfHouseholdId?: BytesNullableFilter<"Contact"> | Uint8Array | null
    industry?: StringNullableFilter<"Contact"> | string | null
    website?: StringNullableFilter<"Contact"> | string | null
    size?: IntNullableFilter<"Contact"> | number | null
    primaryContactId?: BytesNullableFilter<"Contact"> | Uint8Array | null
    deleted?: BoolFilter<"Contact"> | boolean
    deletedAt?: DateTimeNullableFilter<"Contact"> | Date | string | null
  }

  export type ActivityUpsertWithWhereUniqueWithoutTenetInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutTenetInput, ActivityUncheckedUpdateWithoutTenetInput>
    create: XOR<ActivityCreateWithoutTenetInput, ActivityUncheckedCreateWithoutTenetInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutTenetInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutTenetInput, ActivityUncheckedUpdateWithoutTenetInput>
  }

  export type ActivityUpdateManyWithWhereWithoutTenetInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutTenetInput>
  }

  export type ActivityScalarWhereInput = {
    AND?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
    OR?: ActivityScalarWhereInput[]
    NOT?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
    id?: BytesFilter<"Activity"> | Uint8Array
    title?: StringFilter<"Activity"> | string
    type?: EnumActivityTypeFilter<"Activity"> | $Enums.ActivityType
    parentActivityId?: BytesNullableFilter<"Activity"> | Uint8Array | null
    parentWaypointId?: BytesNullableFilter<"Activity"> | Uint8Array | null
    templateId?: BytesNullableFilter<"Activity"> | Uint8Array | null
    taskScheduleType?: EnumTaskScheduleTypeNullableFilter<"Activity"> | $Enums.TaskScheduleType | null
    startDate?: DateTimeFilter<"Activity"> | Date | string
    endDate?: DateTimeFilter<"Activity"> | Date | string
    completedAt?: DateTimeNullableFilter<"Activity"> | Date | string | null
    description?: StringNullableFilter<"Activity"> | string | null
    priority?: EnumActivityPriorityFilter<"Activity"> | $Enums.ActivityPriority
    status?: EnumActivityStatusFilter<"Activity"> | $Enums.ActivityStatus
    assignedById?: BytesFilter<"Activity"> | Uint8Array
    phoneNumber?: StringNullableFilter<"Activity"> | string | null
    location?: StringNullableFilter<"Activity"> | string | null
    holdReason?: StringNullableFilter<"Activity"> | string | null
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    updatedAt?: DateTimeFilter<"Activity"> | Date | string
    tenetId?: BytesFilter<"Activity"> | Uint8Array
    deleted?: BoolFilter<"Activity"> | boolean
    deletedAt?: DateTimeNullableFilter<"Activity"> | Date | string | null
    order?: IntNullableFilter<"Activity"> | number | null
    opportunityId?: BytesNullableFilter<"Activity"> | Uint8Array | null
  }

  export type AddressUpsertWithWhereUniqueWithoutTenetInput = {
    where: AddressWhereUniqueInput
    update: XOR<AddressUpdateWithoutTenetInput, AddressUncheckedUpdateWithoutTenetInput>
    create: XOR<AddressCreateWithoutTenetInput, AddressUncheckedCreateWithoutTenetInput>
  }

  export type AddressUpdateWithWhereUniqueWithoutTenetInput = {
    where: AddressWhereUniqueInput
    data: XOR<AddressUpdateWithoutTenetInput, AddressUncheckedUpdateWithoutTenetInput>
  }

  export type AddressUpdateManyWithWhereWithoutTenetInput = {
    where: AddressScalarWhereInput
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyWithoutTenetInput>
  }

  export type AddressScalarWhereInput = {
    AND?: AddressScalarWhereInput | AddressScalarWhereInput[]
    OR?: AddressScalarWhereInput[]
    NOT?: AddressScalarWhereInput | AddressScalarWhereInput[]
    id?: BytesFilter<"Address"> | Uint8Array
    street?: StringFilter<"Address"> | string
    city?: StringFilter<"Address"> | string
    state?: StringFilter<"Address"> | string
    zip?: StringFilter<"Address"> | string
    country?: StringFilter<"Address"> | string
    type?: EnumAddressTypeFilter<"Address"> | $Enums.AddressType
    primary?: BoolFilter<"Address"> | boolean
    contactId?: BytesFilter<"Address"> | Uint8Array
    tenetId?: BytesFilter<"Address"> | Uint8Array
    createdAt?: DateTimeFilter<"Address"> | Date | string
    updatedAt?: DateTimeFilter<"Address"> | Date | string
    timezone?: StringNullableFilter<"Address"> | string | null
  }

  export type ContactEmailUpsertWithWhereUniqueWithoutTenetInput = {
    where: ContactEmailWhereUniqueInput
    update: XOR<ContactEmailUpdateWithoutTenetInput, ContactEmailUncheckedUpdateWithoutTenetInput>
    create: XOR<ContactEmailCreateWithoutTenetInput, ContactEmailUncheckedCreateWithoutTenetInput>
  }

  export type ContactEmailUpdateWithWhereUniqueWithoutTenetInput = {
    where: ContactEmailWhereUniqueInput
    data: XOR<ContactEmailUpdateWithoutTenetInput, ContactEmailUncheckedUpdateWithoutTenetInput>
  }

  export type ContactEmailUpdateManyWithWhereWithoutTenetInput = {
    where: ContactEmailScalarWhereInput
    data: XOR<ContactEmailUpdateManyMutationInput, ContactEmailUncheckedUpdateManyWithoutTenetInput>
  }

  export type ContactEmailScalarWhereInput = {
    AND?: ContactEmailScalarWhereInput | ContactEmailScalarWhereInput[]
    OR?: ContactEmailScalarWhereInput[]
    NOT?: ContactEmailScalarWhereInput | ContactEmailScalarWhereInput[]
    id?: BytesFilter<"ContactEmail"> | Uint8Array
    email?: StringFilter<"ContactEmail"> | string
    isPrimary?: BoolFilter<"ContactEmail"> | boolean
    contactId?: BytesFilter<"ContactEmail"> | Uint8Array
    tenetId?: BytesFilter<"ContactEmail"> | Uint8Array
    createdAt?: DateTimeFilter<"ContactEmail"> | Date | string
    updatedAt?: DateTimeFilter<"ContactEmail"> | Date | string
  }

  export type ContactPhoneUpsertWithWhereUniqueWithoutTenetInput = {
    where: ContactPhoneWhereUniqueInput
    update: XOR<ContactPhoneUpdateWithoutTenetInput, ContactPhoneUncheckedUpdateWithoutTenetInput>
    create: XOR<ContactPhoneCreateWithoutTenetInput, ContactPhoneUncheckedCreateWithoutTenetInput>
  }

  export type ContactPhoneUpdateWithWhereUniqueWithoutTenetInput = {
    where: ContactPhoneWhereUniqueInput
    data: XOR<ContactPhoneUpdateWithoutTenetInput, ContactPhoneUncheckedUpdateWithoutTenetInput>
  }

  export type ContactPhoneUpdateManyWithWhereWithoutTenetInput = {
    where: ContactPhoneScalarWhereInput
    data: XOR<ContactPhoneUpdateManyMutationInput, ContactPhoneUncheckedUpdateManyWithoutTenetInput>
  }

  export type ContactPhoneScalarWhereInput = {
    AND?: ContactPhoneScalarWhereInput | ContactPhoneScalarWhereInput[]
    OR?: ContactPhoneScalarWhereInput[]
    NOT?: ContactPhoneScalarWhereInput | ContactPhoneScalarWhereInput[]
    id?: BytesFilter<"ContactPhone"> | Uint8Array
    number?: StringFilter<"ContactPhone"> | string
    type?: EnumPhoneTypeFilter<"ContactPhone"> | $Enums.PhoneType
    isPrimary?: BoolFilter<"ContactPhone"> | boolean
    contactId?: BytesFilter<"ContactPhone"> | Uint8Array
    tenetId?: BytesFilter<"ContactPhone"> | Uint8Array
    createdAt?: DateTimeFilter<"ContactPhone"> | Date | string
    updatedAt?: DateTimeFilter<"ContactPhone"> | Date | string
  }

  export type ImportantDateUpsertWithWhereUniqueWithoutTenetInput = {
    where: ImportantDateWhereUniqueInput
    update: XOR<ImportantDateUpdateWithoutTenetInput, ImportantDateUncheckedUpdateWithoutTenetInput>
    create: XOR<ImportantDateCreateWithoutTenetInput, ImportantDateUncheckedCreateWithoutTenetInput>
  }

  export type ImportantDateUpdateWithWhereUniqueWithoutTenetInput = {
    where: ImportantDateWhereUniqueInput
    data: XOR<ImportantDateUpdateWithoutTenetInput, ImportantDateUncheckedUpdateWithoutTenetInput>
  }

  export type ImportantDateUpdateManyWithWhereWithoutTenetInput = {
    where: ImportantDateScalarWhereInput
    data: XOR<ImportantDateUpdateManyMutationInput, ImportantDateUncheckedUpdateManyWithoutTenetInput>
  }

  export type ImportantDateScalarWhereInput = {
    AND?: ImportantDateScalarWhereInput | ImportantDateScalarWhereInput[]
    OR?: ImportantDateScalarWhereInput[]
    NOT?: ImportantDateScalarWhereInput | ImportantDateScalarWhereInput[]
    id?: BytesFilter<"ImportantDate"> | Uint8Array
    date?: DateTimeFilter<"ImportantDate"> | Date | string
    type?: EnumImportantDateTypeFilter<"ImportantDate"> | $Enums.ImportantDateType
    contactId?: BytesFilter<"ImportantDate"> | Uint8Array
    tenetId?: BytesFilter<"ImportantDate"> | Uint8Array
    createdAt?: DateTimeFilter<"ImportantDate"> | Date | string
    updatedAt?: DateTimeFilter<"ImportantDate"> | Date | string
  }

  export type AttachmentUpsertWithWhereUniqueWithoutTenetInput = {
    where: AttachmentWhereUniqueInput
    update: XOR<AttachmentUpdateWithoutTenetInput, AttachmentUncheckedUpdateWithoutTenetInput>
    create: XOR<AttachmentCreateWithoutTenetInput, AttachmentUncheckedCreateWithoutTenetInput>
  }

  export type AttachmentUpdateWithWhereUniqueWithoutTenetInput = {
    where: AttachmentWhereUniqueInput
    data: XOR<AttachmentUpdateWithoutTenetInput, AttachmentUncheckedUpdateWithoutTenetInput>
  }

  export type AttachmentUpdateManyWithWhereWithoutTenetInput = {
    where: AttachmentScalarWhereInput
    data: XOR<AttachmentUpdateManyMutationInput, AttachmentUncheckedUpdateManyWithoutTenetInput>
  }

  export type AttachmentScalarWhereInput = {
    AND?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
    OR?: AttachmentScalarWhereInput[]
    NOT?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
    id?: BytesFilter<"Attachment"> | Uint8Array
    name?: StringFilter<"Attachment"> | string
    location?: StringFilter<"Attachment"> | string
    activityId?: BytesNullableFilter<"Attachment"> | Uint8Array | null
    tenetId?: BytesFilter<"Attachment"> | Uint8Array
  }

  export type NoteUpsertWithWhereUniqueWithoutTenetInput = {
    where: NoteWhereUniqueInput
    update: XOR<NoteUpdateWithoutTenetInput, NoteUncheckedUpdateWithoutTenetInput>
    create: XOR<NoteCreateWithoutTenetInput, NoteUncheckedCreateWithoutTenetInput>
  }

  export type NoteUpdateWithWhereUniqueWithoutTenetInput = {
    where: NoteWhereUniqueInput
    data: XOR<NoteUpdateWithoutTenetInput, NoteUncheckedUpdateWithoutTenetInput>
  }

  export type NoteUpdateManyWithWhereWithoutTenetInput = {
    where: NoteScalarWhereInput
    data: XOR<NoteUpdateManyMutationInput, NoteUncheckedUpdateManyWithoutTenetInput>
  }

  export type NoteScalarWhereInput = {
    AND?: NoteScalarWhereInput | NoteScalarWhereInput[]
    OR?: NoteScalarWhereInput[]
    NOT?: NoteScalarWhereInput | NoteScalarWhereInput[]
    id?: BytesFilter<"Note"> | Uint8Array
    content?: StringFilter<"Note"> | string
    waypointId?: BytesNullableFilter<"Note"> | Uint8Array | null
    activityId?: BytesNullableFilter<"Note"> | Uint8Array | null
    contactId?: BytesNullableFilter<"Note"> | Uint8Array | null
    opportunityId?: BytesNullableFilter<"Note"> | Uint8Array | null
    tenetId?: BytesFilter<"Note"> | Uint8Array
    authorId?: BytesFilter<"Note"> | Uint8Array
    createdAt?: DateTimeFilter<"Note"> | Date | string
    updatedAt?: DateTimeFilter<"Note"> | Date | string
    deleted?: BoolFilter<"Note"> | boolean
    deletedAt?: DateTimeNullableFilter<"Note"> | Date | string | null
    noteType?: EnumNoteTypeFilter<"Note"> | $Enums.NoteType
  }

  export type AuditEventUpsertWithWhereUniqueWithoutTenetInput = {
    where: AuditEventWhereUniqueInput
    update: XOR<AuditEventUpdateWithoutTenetInput, AuditEventUncheckedUpdateWithoutTenetInput>
    create: XOR<AuditEventCreateWithoutTenetInput, AuditEventUncheckedCreateWithoutTenetInput>
  }

  export type AuditEventUpdateWithWhereUniqueWithoutTenetInput = {
    where: AuditEventWhereUniqueInput
    data: XOR<AuditEventUpdateWithoutTenetInput, AuditEventUncheckedUpdateWithoutTenetInput>
  }

  export type AuditEventUpdateManyWithWhereWithoutTenetInput = {
    where: AuditEventScalarWhereInput
    data: XOR<AuditEventUpdateManyMutationInput, AuditEventUncheckedUpdateManyWithoutTenetInput>
  }

  export type AuditEventScalarWhereInput = {
    AND?: AuditEventScalarWhereInput | AuditEventScalarWhereInput[]
    OR?: AuditEventScalarWhereInput[]
    NOT?: AuditEventScalarWhereInput | AuditEventScalarWhereInput[]
    id?: BytesFilter<"AuditEvent"> | Uint8Array
    userId?: BytesFilter<"AuditEvent"> | Uint8Array
    tenetId?: BytesFilter<"AuditEvent"> | Uint8Array
    type?: EnumAuditEventTypeFilter<"AuditEvent"> | $Enums.AuditEventType
    details?: StringNullableFilter<"AuditEvent"> | string | null
    referenceId?: BytesFilter<"AuditEvent"> | Uint8Array
    reference?: EnumAuditableFilter<"AuditEvent"> | $Enums.Auditable
    createdAt?: DateTimeFilter<"AuditEvent"> | Date | string
    updatedAt?: DateTimeFilter<"AuditEvent"> | Date | string
  }

  export type ContactTimelineEventUpsertWithWhereUniqueWithoutTenetInput = {
    where: ContactTimelineEventWhereUniqueInput
    update: XOR<ContactTimelineEventUpdateWithoutTenetInput, ContactTimelineEventUncheckedUpdateWithoutTenetInput>
    create: XOR<ContactTimelineEventCreateWithoutTenetInput, ContactTimelineEventUncheckedCreateWithoutTenetInput>
  }

  export type ContactTimelineEventUpdateWithWhereUniqueWithoutTenetInput = {
    where: ContactTimelineEventWhereUniqueInput
    data: XOR<ContactTimelineEventUpdateWithoutTenetInput, ContactTimelineEventUncheckedUpdateWithoutTenetInput>
  }

  export type ContactTimelineEventUpdateManyWithWhereWithoutTenetInput = {
    where: ContactTimelineEventScalarWhereInput
    data: XOR<ContactTimelineEventUpdateManyMutationInput, ContactTimelineEventUncheckedUpdateManyWithoutTenetInput>
  }

  export type ContactTimelineEventScalarWhereInput = {
    AND?: ContactTimelineEventScalarWhereInput | ContactTimelineEventScalarWhereInput[]
    OR?: ContactTimelineEventScalarWhereInput[]
    NOT?: ContactTimelineEventScalarWhereInput | ContactTimelineEventScalarWhereInput[]
    id?: BytesFilter<"ContactTimelineEvent"> | Uint8Array
    activityId?: BytesNullableFilter<"ContactTimelineEvent"> | Uint8Array | null
    waypointId?: BytesNullableFilter<"ContactTimelineEvent"> | Uint8Array | null
    opportunityId?: BytesNullableFilter<"ContactTimelineEvent"> | Uint8Array | null
    noteId?: BytesNullableFilter<"ContactTimelineEvent"> | Uint8Array | null
    extraInfo?: StringNullableFilter<"ContactTimelineEvent"> | string | null
    userId?: BytesFilter<"ContactTimelineEvent"> | Uint8Array
    tenetId?: BytesFilter<"ContactTimelineEvent"> | Uint8Array
    eventType?: EnumContactTimelineEventTypeFilter<"ContactTimelineEvent"> | $Enums.ContactTimelineEventType
    relationshipType?: StringNullableFilter<"ContactTimelineEvent"> | string | null
    createdAt?: DateTimeFilter<"ContactTimelineEvent"> | Date | string
    updatedAt?: DateTimeFilter<"ContactTimelineEvent"> | Date | string
  }

  export type ActivityStepUpsertWithWhereUniqueWithoutTenetInput = {
    where: ActivityStepWhereUniqueInput
    update: XOR<ActivityStepUpdateWithoutTenetInput, ActivityStepUncheckedUpdateWithoutTenetInput>
    create: XOR<ActivityStepCreateWithoutTenetInput, ActivityStepUncheckedCreateWithoutTenetInput>
  }

  export type ActivityStepUpdateWithWhereUniqueWithoutTenetInput = {
    where: ActivityStepWhereUniqueInput
    data: XOR<ActivityStepUpdateWithoutTenetInput, ActivityStepUncheckedUpdateWithoutTenetInput>
  }

  export type ActivityStepUpdateManyWithWhereWithoutTenetInput = {
    where: ActivityStepScalarWhereInput
    data: XOR<ActivityStepUpdateManyMutationInput, ActivityStepUncheckedUpdateManyWithoutTenetInput>
  }

  export type ActivityStepScalarWhereInput = {
    AND?: ActivityStepScalarWhereInput | ActivityStepScalarWhereInput[]
    OR?: ActivityStepScalarWhereInput[]
    NOT?: ActivityStepScalarWhereInput | ActivityStepScalarWhereInput[]
    id?: BytesFilter<"ActivityStep"> | Uint8Array
    title?: StringFilter<"ActivityStep"> | string
    completed?: BoolFilter<"ActivityStep"> | boolean
    activityId?: BytesFilter<"ActivityStep"> | Uint8Array
    createdAt?: DateTimeFilter<"ActivityStep"> | Date | string
    updatedAt?: DateTimeFilter<"ActivityStep"> | Date | string
    tenetId?: BytesFilter<"ActivityStep"> | Uint8Array
    type?: EnumActivityStepTypeFilter<"ActivityStep"> | $Enums.ActivityStepType
    order?: IntFilter<"ActivityStep"> | number
  }

  export type ActivityWaypointUpsertWithWhereUniqueWithoutTenetInput = {
    where: ActivityWaypointWhereUniqueInput
    update: XOR<ActivityWaypointUpdateWithoutTenetInput, ActivityWaypointUncheckedUpdateWithoutTenetInput>
    create: XOR<ActivityWaypointCreateWithoutTenetInput, ActivityWaypointUncheckedCreateWithoutTenetInput>
  }

  export type ActivityWaypointUpdateWithWhereUniqueWithoutTenetInput = {
    where: ActivityWaypointWhereUniqueInput
    data: XOR<ActivityWaypointUpdateWithoutTenetInput, ActivityWaypointUncheckedUpdateWithoutTenetInput>
  }

  export type ActivityWaypointUpdateManyWithWhereWithoutTenetInput = {
    where: ActivityWaypointScalarWhereInput
    data: XOR<ActivityWaypointUpdateManyMutationInput, ActivityWaypointUncheckedUpdateManyWithoutTenetInput>
  }

  export type ActivityWaypointScalarWhereInput = {
    AND?: ActivityWaypointScalarWhereInput | ActivityWaypointScalarWhereInput[]
    OR?: ActivityWaypointScalarWhereInput[]
    NOT?: ActivityWaypointScalarWhereInput | ActivityWaypointScalarWhereInput[]
    id?: BytesFilter<"ActivityWaypoint"> | Uint8Array
    title?: StringFilter<"ActivityWaypoint"> | string
    description?: StringNullableFilter<"ActivityWaypoint"> | string | null
    summary?: StringNullableFilter<"ActivityWaypoint"> | string | null
    status?: EnumActivityStatusFilter<"ActivityWaypoint"> | $Enums.ActivityStatus
    order?: IntFilter<"ActivityWaypoint"> | number
    actualStart?: DateTimeFilter<"ActivityWaypoint"> | Date | string
    dueDate?: DateTimeFilter<"ActivityWaypoint"> | Date | string
    actualEnd?: DateTimeNullableFilter<"ActivityWaypoint"> | Date | string | null
    activityId?: BytesFilter<"ActivityWaypoint"> | Uint8Array
    templateId?: BytesNullableFilter<"ActivityWaypoint"> | Uint8Array | null
    createdAt?: DateTimeFilter<"ActivityWaypoint"> | Date | string
    updatedAt?: DateTimeFilter<"ActivityWaypoint"> | Date | string
    tenetId?: BytesFilter<"ActivityWaypoint"> | Uint8Array
  }

  export type TemplateAssignmentUpsertWithWhereUniqueWithoutTenetInput = {
    where: TemplateAssignmentWhereUniqueInput
    update: XOR<TemplateAssignmentUpdateWithoutTenetInput, TemplateAssignmentUncheckedUpdateWithoutTenetInput>
    create: XOR<TemplateAssignmentCreateWithoutTenetInput, TemplateAssignmentUncheckedCreateWithoutTenetInput>
  }

  export type TemplateAssignmentUpdateWithWhereUniqueWithoutTenetInput = {
    where: TemplateAssignmentWhereUniqueInput
    data: XOR<TemplateAssignmentUpdateWithoutTenetInput, TemplateAssignmentUncheckedUpdateWithoutTenetInput>
  }

  export type TemplateAssignmentUpdateManyWithWhereWithoutTenetInput = {
    where: TemplateAssignmentScalarWhereInput
    data: XOR<TemplateAssignmentUpdateManyMutationInput, TemplateAssignmentUncheckedUpdateManyWithoutTenetInput>
  }

  export type TemplateAssignmentScalarWhereInput = {
    AND?: TemplateAssignmentScalarWhereInput | TemplateAssignmentScalarWhereInput[]
    OR?: TemplateAssignmentScalarWhereInput[]
    NOT?: TemplateAssignmentScalarWhereInput | TemplateAssignmentScalarWhereInput[]
    id?: BytesFilter<"TemplateAssignment"> | Uint8Array
    specificUserId?: BytesNullableFilter<"TemplateAssignment"> | Uint8Array | null
    specificRole?: EnumRoleNullableFilter<"TemplateAssignment"> | $Enums.Role | null
    activityTemplateId?: BytesNullableFilter<"TemplateAssignment"> | Uint8Array | null
    waypointTemplateId?: BytesNullableFilter<"TemplateAssignment"> | Uint8Array | null
    createdAt?: DateTimeFilter<"TemplateAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"TemplateAssignment"> | Date | string
    tenetId?: BytesFilter<"TemplateAssignment"> | Uint8Array
  }

  export type ActivityWaypointTemplateUpsertWithWhereUniqueWithoutTenetInput = {
    where: ActivityWaypointTemplateWhereUniqueInput
    update: XOR<ActivityWaypointTemplateUpdateWithoutTenetInput, ActivityWaypointTemplateUncheckedUpdateWithoutTenetInput>
    create: XOR<ActivityWaypointTemplateCreateWithoutTenetInput, ActivityWaypointTemplateUncheckedCreateWithoutTenetInput>
  }

  export type ActivityWaypointTemplateUpdateWithWhereUniqueWithoutTenetInput = {
    where: ActivityWaypointTemplateWhereUniqueInput
    data: XOR<ActivityWaypointTemplateUpdateWithoutTenetInput, ActivityWaypointTemplateUncheckedUpdateWithoutTenetInput>
  }

  export type ActivityWaypointTemplateUpdateManyWithWhereWithoutTenetInput = {
    where: ActivityWaypointTemplateScalarWhereInput
    data: XOR<ActivityWaypointTemplateUpdateManyMutationInput, ActivityWaypointTemplateUncheckedUpdateManyWithoutTenetInput>
  }

  export type ActivityWaypointTemplateScalarWhereInput = {
    AND?: ActivityWaypointTemplateScalarWhereInput | ActivityWaypointTemplateScalarWhereInput[]
    OR?: ActivityWaypointTemplateScalarWhereInput[]
    NOT?: ActivityWaypointTemplateScalarWhereInput | ActivityWaypointTemplateScalarWhereInput[]
    id?: BytesFilter<"ActivityWaypointTemplate"> | Uint8Array
    title?: StringFilter<"ActivityWaypointTemplate"> | string
    description?: StringNullableFilter<"ActivityWaypointTemplate"> | string | null
    defaultStatus?: EnumActivityStatusFilter<"ActivityWaypointTemplate"> | $Enums.ActivityStatus
    order?: IntFilter<"ActivityWaypointTemplate"> | number
    dateOffsetType?: EnumDateOffsetTypeFilter<"ActivityWaypointTemplate"> | $Enums.DateOffsetType
    dueDate?: IntFilter<"ActivityWaypointTemplate"> | number
    parentActivityId?: BytesFilter<"ActivityWaypointTemplate"> | Uint8Array
    createdAt?: DateTimeFilter<"ActivityWaypointTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"ActivityWaypointTemplate"> | Date | string
    tenetId?: BytesFilter<"ActivityWaypointTemplate"> | Uint8Array
  }

  export type ActivityTemplateUpsertWithWhereUniqueWithoutTenetInput = {
    where: ActivityTemplateWhereUniqueInput
    update: XOR<ActivityTemplateUpdateWithoutTenetInput, ActivityTemplateUncheckedUpdateWithoutTenetInput>
    create: XOR<ActivityTemplateCreateWithoutTenetInput, ActivityTemplateUncheckedCreateWithoutTenetInput>
  }

  export type ActivityTemplateUpdateWithWhereUniqueWithoutTenetInput = {
    where: ActivityTemplateWhereUniqueInput
    data: XOR<ActivityTemplateUpdateWithoutTenetInput, ActivityTemplateUncheckedUpdateWithoutTenetInput>
  }

  export type ActivityTemplateUpdateManyWithWhereWithoutTenetInput = {
    where: ActivityTemplateScalarWhereInput
    data: XOR<ActivityTemplateUpdateManyMutationInput, ActivityTemplateUncheckedUpdateManyWithoutTenetInput>
  }

  export type ActivityTemplateScalarWhereInput = {
    AND?: ActivityTemplateScalarWhereInput | ActivityTemplateScalarWhereInput[]
    OR?: ActivityTemplateScalarWhereInput[]
    NOT?: ActivityTemplateScalarWhereInput | ActivityTemplateScalarWhereInput[]
    id?: BytesFilter<"ActivityTemplate"> | Uint8Array
    title?: StringFilter<"ActivityTemplate"> | string
    description?: StringNullableFilter<"ActivityTemplate"> | string | null
    type?: EnumActivityTypeFilter<"ActivityTemplate"> | $Enums.ActivityType
    defaultPriority?: EnumActivityPriorityFilter<"ActivityTemplate"> | $Enums.ActivityPriority
    defaultStatus?: EnumActivityStatusFilter<"ActivityTemplate"> | $Enums.ActivityStatus
    taskScheduleType?: EnumTaskScheduleTypeNullableFilter<"ActivityTemplate"> | $Enums.TaskScheduleType | null
    dateOffsetType?: EnumDateOffsetTypeFilter<"ActivityTemplate"> | $Enums.DateOffsetType
    startDate?: IntFilter<"ActivityTemplate"> | number
    endDate?: IntFilter<"ActivityTemplate"> | number
    startRelativeToId?: BytesNullableFilter<"ActivityTemplate"> | Uint8Array | null
    parentWaypointId?: BytesNullableFilter<"ActivityTemplate"> | Uint8Array | null
    parentActivityId?: BytesNullableFilter<"ActivityTemplate"> | Uint8Array | null
    createdAt?: DateTimeFilter<"ActivityTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"ActivityTemplate"> | Date | string
    tenetId?: BytesFilter<"ActivityTemplate"> | Uint8Array
    order?: IntNullableFilter<"ActivityTemplate"> | number | null
  }

  export type ActivityTemplateStepUpsertWithWhereUniqueWithoutTenetInput = {
    where: ActivityTemplateStepWhereUniqueInput
    update: XOR<ActivityTemplateStepUpdateWithoutTenetInput, ActivityTemplateStepUncheckedUpdateWithoutTenetInput>
    create: XOR<ActivityTemplateStepCreateWithoutTenetInput, ActivityTemplateStepUncheckedCreateWithoutTenetInput>
  }

  export type ActivityTemplateStepUpdateWithWhereUniqueWithoutTenetInput = {
    where: ActivityTemplateStepWhereUniqueInput
    data: XOR<ActivityTemplateStepUpdateWithoutTenetInput, ActivityTemplateStepUncheckedUpdateWithoutTenetInput>
  }

  export type ActivityTemplateStepUpdateManyWithWhereWithoutTenetInput = {
    where: ActivityTemplateStepScalarWhereInput
    data: XOR<ActivityTemplateStepUpdateManyMutationInput, ActivityTemplateStepUncheckedUpdateManyWithoutTenetInput>
  }

  export type ActivityTemplateStepScalarWhereInput = {
    AND?: ActivityTemplateStepScalarWhereInput | ActivityTemplateStepScalarWhereInput[]
    OR?: ActivityTemplateStepScalarWhereInput[]
    NOT?: ActivityTemplateStepScalarWhereInput | ActivityTemplateStepScalarWhereInput[]
    id?: BytesFilter<"ActivityTemplateStep"> | Uint8Array
    order?: IntFilter<"ActivityTemplateStep"> | number
    title?: StringFilter<"ActivityTemplateStep"> | string
    type?: EnumActivityStepTypeFilter<"ActivityTemplateStep"> | $Enums.ActivityStepType
    activityTemplateId?: BytesFilter<"ActivityTemplateStep"> | Uint8Array
    tenetId?: BytesFilter<"ActivityTemplateStep"> | Uint8Array
  }

  export type OpportunityUpsertWithWhereUniqueWithoutTenetInput = {
    where: OpportunityWhereUniqueInput
    update: XOR<OpportunityUpdateWithoutTenetInput, OpportunityUncheckedUpdateWithoutTenetInput>
    create: XOR<OpportunityCreateWithoutTenetInput, OpportunityUncheckedCreateWithoutTenetInput>
  }

  export type OpportunityUpdateWithWhereUniqueWithoutTenetInput = {
    where: OpportunityWhereUniqueInput
    data: XOR<OpportunityUpdateWithoutTenetInput, OpportunityUncheckedUpdateWithoutTenetInput>
  }

  export type OpportunityUpdateManyWithWhereWithoutTenetInput = {
    where: OpportunityScalarWhereInput
    data: XOR<OpportunityUpdateManyMutationInput, OpportunityUncheckedUpdateManyWithoutTenetInput>
  }

  export type OpportunityScalarWhereInput = {
    AND?: OpportunityScalarWhereInput | OpportunityScalarWhereInput[]
    OR?: OpportunityScalarWhereInput[]
    NOT?: OpportunityScalarWhereInput | OpportunityScalarWhereInput[]
    id?: BytesFilter<"Opportunity"> | Uint8Array
    title?: StringFilter<"Opportunity"> | string
    description?: StringNullableFilter<"Opportunity"> | string | null
    createdAt?: DateTimeFilter<"Opportunity"> | Date | string
    updatedAt?: DateTimeFilter<"Opportunity"> | Date | string
    value?: FloatFilter<"Opportunity"> | number
    probability?: FloatFilter<"Opportunity"> | number
    expectedCloseDate?: DateTimeFilter<"Opportunity"> | Date | string
    actualCloseDate?: DateTimeNullableFilter<"Opportunity"> | Date | string | null
    status?: EnumOpportunityStatusFilter<"Opportunity"> | $Enums.OpportunityStatus
    statusHistory?: EnumOpportunityStatusNullableListFilter<"Opportunity">
    deleted?: BoolFilter<"Opportunity"> | boolean
    deletedAt?: DateTimeNullableFilter<"Opportunity"> | Date | string | null
    tenetId?: BytesFilter<"Opportunity"> | Uint8Array
    expectedValue?: FloatFilter<"Opportunity"> | number
  }

  export type ProductTypeUpsertWithWhereUniqueWithoutTenetInput = {
    where: ProductTypeWhereUniqueInput
    update: XOR<ProductTypeUpdateWithoutTenetInput, ProductTypeUncheckedUpdateWithoutTenetInput>
    create: XOR<ProductTypeCreateWithoutTenetInput, ProductTypeUncheckedCreateWithoutTenetInput>
  }

  export type ProductTypeUpdateWithWhereUniqueWithoutTenetInput = {
    where: ProductTypeWhereUniqueInput
    data: XOR<ProductTypeUpdateWithoutTenetInput, ProductTypeUncheckedUpdateWithoutTenetInput>
  }

  export type ProductTypeUpdateManyWithWhereWithoutTenetInput = {
    where: ProductTypeScalarWhereInput
    data: XOR<ProductTypeUpdateManyMutationInput, ProductTypeUncheckedUpdateManyWithoutTenetInput>
  }

  export type ProductTypeScalarWhereInput = {
    AND?: ProductTypeScalarWhereInput | ProductTypeScalarWhereInput[]
    OR?: ProductTypeScalarWhereInput[]
    NOT?: ProductTypeScalarWhereInput | ProductTypeScalarWhereInput[]
    id?: BytesFilter<"ProductType"> | Uint8Array
    title?: StringFilter<"ProductType"> | string
    description?: StringNullableFilter<"ProductType"> | string | null
    defaultCommission?: FloatFilter<"ProductType"> | number
    createdAt?: DateTimeFilter<"ProductType"> | Date | string
    updatedAt?: DateTimeFilter<"ProductType"> | Date | string
    tenetId?: BytesFilter<"ProductType"> | Uint8Array
  }

  export type ActivityTemplateStepAssignmentUpsertWithWhereUniqueWithoutTenetInput = {
    where: ActivityTemplateStepAssignmentWhereUniqueInput
    update: XOR<ActivityTemplateStepAssignmentUpdateWithoutTenetInput, ActivityTemplateStepAssignmentUncheckedUpdateWithoutTenetInput>
    create: XOR<ActivityTemplateStepAssignmentCreateWithoutTenetInput, ActivityTemplateStepAssignmentUncheckedCreateWithoutTenetInput>
  }

  export type ActivityTemplateStepAssignmentUpdateWithWhereUniqueWithoutTenetInput = {
    where: ActivityTemplateStepAssignmentWhereUniqueInput
    data: XOR<ActivityTemplateStepAssignmentUpdateWithoutTenetInput, ActivityTemplateStepAssignmentUncheckedUpdateWithoutTenetInput>
  }

  export type ActivityTemplateStepAssignmentUpdateManyWithWhereWithoutTenetInput = {
    where: ActivityTemplateStepAssignmentScalarWhereInput
    data: XOR<ActivityTemplateStepAssignmentUpdateManyMutationInput, ActivityTemplateStepAssignmentUncheckedUpdateManyWithoutTenetInput>
  }

  export type ActivityTemplateStepAssignmentScalarWhereInput = {
    AND?: ActivityTemplateStepAssignmentScalarWhereInput | ActivityTemplateStepAssignmentScalarWhereInput[]
    OR?: ActivityTemplateStepAssignmentScalarWhereInput[]
    NOT?: ActivityTemplateStepAssignmentScalarWhereInput | ActivityTemplateStepAssignmentScalarWhereInput[]
    id?: BytesFilter<"ActivityTemplateStepAssignment"> | Uint8Array
    specificUserId?: BytesNullableFilter<"ActivityTemplateStepAssignment"> | Uint8Array | null
    specificRole?: EnumRoleNullableFilter<"ActivityTemplateStepAssignment"> | $Enums.Role | null
    activityTemplateStepId?: BytesFilter<"ActivityTemplateStepAssignment"> | Uint8Array
    tenetId?: BytesFilter<"ActivityTemplateStepAssignment"> | Uint8Array
  }

  export type TokenCreateWithoutUserInput = {
    id: Uint8Array
    createdAt?: Date | string
    refresh?: boolean
  }

  export type TokenUncheckedCreateWithoutUserInput = {
    id: Uint8Array
    createdAt?: Date | string
    refresh?: boolean
  }

  export type TokenCreateOrConnectWithoutUserInput = {
    where: TokenWhereUniqueInput
    create: XOR<TokenCreateWithoutUserInput, TokenUncheckedCreateWithoutUserInput>
  }

  export type TokenCreateManyUserInputEnvelope = {
    data: TokenCreateManyUserInput | TokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TenetCreateWithoutUsersInput = {
    id: Uint8Array
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    logs?: LogCreateNestedManyWithoutTenetInput
    contacts?: ContactCreateNestedManyWithoutTenetInput
    activities?: ActivityCreateNestedManyWithoutTenetInput
    addresses?: AddressCreateNestedManyWithoutTenetInput
    contactEmails?: ContactEmailCreateNestedManyWithoutTenetInput
    contactPhones?: ContactPhoneCreateNestedManyWithoutTenetInput
    importantDates?: ImportantDateCreateNestedManyWithoutTenetInput
    attachments?: AttachmentCreateNestedManyWithoutTenetInput
    notes?: NoteCreateNestedManyWithoutTenetInput
    auditEvents?: AuditEventCreateNestedManyWithoutTenetInput
    contactTimelineEvents?: ContactTimelineEventCreateNestedManyWithoutTenetInput
    activitySteps?: ActivityStepCreateNestedManyWithoutTenetInput
    activityWaypoints?: ActivityWaypointCreateNestedManyWithoutTenetInput
    templateAssignments?: TemplateAssignmentCreateNestedManyWithoutTenetInput
    activityWaypointTemplates?: ActivityWaypointTemplateCreateNestedManyWithoutTenetInput
    activityTemplates?: ActivityTemplateCreateNestedManyWithoutTenetInput
    activityTemplateSteps?: ActivityTemplateStepCreateNestedManyWithoutTenetInput
    opportunities?: OpportunityCreateNestedManyWithoutTenetInput
    products?: ProductTypeCreateNestedManyWithoutTenetInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentCreateNestedManyWithoutTenetInput
  }

  export type TenetUncheckedCreateWithoutUsersInput = {
    id: Uint8Array
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    logs?: LogUncheckedCreateNestedManyWithoutTenetInput
    contacts?: ContactUncheckedCreateNestedManyWithoutTenetInput
    activities?: ActivityUncheckedCreateNestedManyWithoutTenetInput
    addresses?: AddressUncheckedCreateNestedManyWithoutTenetInput
    contactEmails?: ContactEmailUncheckedCreateNestedManyWithoutTenetInput
    contactPhones?: ContactPhoneUncheckedCreateNestedManyWithoutTenetInput
    importantDates?: ImportantDateUncheckedCreateNestedManyWithoutTenetInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTenetInput
    notes?: NoteUncheckedCreateNestedManyWithoutTenetInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutTenetInput
    contactTimelineEvents?: ContactTimelineEventUncheckedCreateNestedManyWithoutTenetInput
    activitySteps?: ActivityStepUncheckedCreateNestedManyWithoutTenetInput
    activityWaypoints?: ActivityWaypointUncheckedCreateNestedManyWithoutTenetInput
    templateAssignments?: TemplateAssignmentUncheckedCreateNestedManyWithoutTenetInput
    activityWaypointTemplates?: ActivityWaypointTemplateUncheckedCreateNestedManyWithoutTenetInput
    activityTemplates?: ActivityTemplateUncheckedCreateNestedManyWithoutTenetInput
    activityTemplateSteps?: ActivityTemplateStepUncheckedCreateNestedManyWithoutTenetInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutTenetInput
    products?: ProductTypeUncheckedCreateNestedManyWithoutTenetInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentUncheckedCreateNestedManyWithoutTenetInput
  }

  export type TenetCreateOrConnectWithoutUsersInput = {
    where: TenetWhereUniqueInput
    create: XOR<TenetCreateWithoutUsersInput, TenetUncheckedCreateWithoutUsersInput>
  }

  export type ActivityUserJoinCreateWithoutUserRelationInput = {
    activityRelation: ActivityCreateNestedOneWithoutUsersInput
  }

  export type ActivityUserJoinUncheckedCreateWithoutUserRelationInput = {
    activityId: Uint8Array
  }

  export type ActivityUserJoinCreateOrConnectWithoutUserRelationInput = {
    where: ActivityUserJoinWhereUniqueInput
    create: XOR<ActivityUserJoinCreateWithoutUserRelationInput, ActivityUserJoinUncheckedCreateWithoutUserRelationInput>
  }

  export type ActivityUserJoinCreateManyUserRelationInputEnvelope = {
    data: ActivityUserJoinCreateManyUserRelationInput | ActivityUserJoinCreateManyUserRelationInput[]
    skipDuplicates?: boolean
  }

  export type NoteCreateWithoutAuthorInput = {
    id: Uint8Array
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean
    deletedAt?: Date | string | null
    noteType?: $Enums.NoteType
    waypoint?: ActivityWaypointCreateNestedOneWithoutNoteInput
    activity?: ActivityCreateNestedOneWithoutNotesInput
    contact?: ContactCreateNestedOneWithoutNotesInput
    opportunity?: OpportunityCreateNestedOneWithoutNotesInput
    tenet: TenetCreateNestedOneWithoutNotesInput
    events?: ContactTimelineEventCreateNestedManyWithoutNoteInput
  }

  export type NoteUncheckedCreateWithoutAuthorInput = {
    id: Uint8Array
    content: string
    waypointId?: Uint8Array | null
    activityId?: Uint8Array | null
    contactId?: Uint8Array | null
    opportunityId?: Uint8Array | null
    tenetId: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean
    deletedAt?: Date | string | null
    noteType?: $Enums.NoteType
    events?: ContactTimelineEventUncheckedCreateNestedManyWithoutNoteInput
  }

  export type NoteCreateOrConnectWithoutAuthorInput = {
    where: NoteWhereUniqueInput
    create: XOR<NoteCreateWithoutAuthorInput, NoteUncheckedCreateWithoutAuthorInput>
  }

  export type NoteCreateManyAuthorInputEnvelope = {
    data: NoteCreateManyAuthorInput | NoteCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type UserWaypointJoinCreateWithoutUserRelationInput = {
    waypointRelation: ActivityWaypointCreateNestedOneWithoutUsersInput
  }

  export type UserWaypointJoinUncheckedCreateWithoutUserRelationInput = {
    waypointId: Uint8Array
  }

  export type UserWaypointJoinCreateOrConnectWithoutUserRelationInput = {
    where: UserWaypointJoinWhereUniqueInput
    create: XOR<UserWaypointJoinCreateWithoutUserRelationInput, UserWaypointJoinUncheckedCreateWithoutUserRelationInput>
  }

  export type UserWaypointJoinCreateManyUserRelationInputEnvelope = {
    data: UserWaypointJoinCreateManyUserRelationInput | UserWaypointJoinCreateManyUserRelationInput[]
    skipDuplicates?: boolean
  }

  export type ContactTimelineEventCreateWithoutUserInput = {
    id: Uint8Array
    extraInfo?: string | null
    eventType: $Enums.ContactTimelineEventType
    relationshipType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activity?: ActivityCreateNestedOneWithoutEventsInput
    waypoint?: ActivityWaypointCreateNestedOneWithoutEventsInput
    opportunity?: OpportunityCreateNestedOneWithoutEventsInput
    note?: NoteCreateNestedOneWithoutEventsInput
    contacts?: ContactTimelineEventContactJoinCreateNestedManyWithoutContactEventRelationInput
    tenet: TenetCreateNestedOneWithoutContactTimelineEventsInput
  }

  export type ContactTimelineEventUncheckedCreateWithoutUserInput = {
    id: Uint8Array
    activityId?: Uint8Array | null
    waypointId?: Uint8Array | null
    opportunityId?: Uint8Array | null
    noteId?: Uint8Array | null
    extraInfo?: string | null
    tenetId: Uint8Array
    eventType: $Enums.ContactTimelineEventType
    relationshipType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: ContactTimelineEventContactJoinUncheckedCreateNestedManyWithoutContactEventRelationInput
  }

  export type ContactTimelineEventCreateOrConnectWithoutUserInput = {
    where: ContactTimelineEventWhereUniqueInput
    create: XOR<ContactTimelineEventCreateWithoutUserInput, ContactTimelineEventUncheckedCreateWithoutUserInput>
  }

  export type ContactTimelineEventCreateManyUserInputEnvelope = {
    data: ContactTimelineEventCreateManyUserInput | ContactTimelineEventCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditEventCreateWithoutUserInput = {
    id: Uint8Array
    type: $Enums.AuditEventType
    details?: string | null
    referenceId: Uint8Array
    reference: $Enums.Auditable
    createdAt?: Date | string
    updatedAt?: Date | string
    tenet: TenetCreateNestedOneWithoutAuditEventsInput
  }

  export type AuditEventUncheckedCreateWithoutUserInput = {
    id: Uint8Array
    tenetId: Uint8Array
    type: $Enums.AuditEventType
    details?: string | null
    referenceId: Uint8Array
    reference: $Enums.Auditable
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditEventCreateOrConnectWithoutUserInput = {
    where: AuditEventWhereUniqueInput
    create: XOR<AuditEventCreateWithoutUserInput, AuditEventUncheckedCreateWithoutUserInput>
  }

  export type AuditEventCreateManyUserInputEnvelope = {
    data: AuditEventCreateManyUserInput | AuditEventCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TemplateAssignmentCreateWithoutSpecificUserInput = {
    id: Uint8Array
    specificRole?: $Enums.Role | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activityTemplate?: ActivityTemplateCreateNestedOneWithoutAssignmentsInput
    waypointTemplate?: ActivityWaypointTemplateCreateNestedOneWithoutAssignmentsInput
    tenet: TenetCreateNestedOneWithoutTemplateAssignmentsInput
  }

  export type TemplateAssignmentUncheckedCreateWithoutSpecificUserInput = {
    id: Uint8Array
    specificRole?: $Enums.Role | null
    activityTemplateId?: Uint8Array | null
    waypointTemplateId?: Uint8Array | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
  }

  export type TemplateAssignmentCreateOrConnectWithoutSpecificUserInput = {
    where: TemplateAssignmentWhereUniqueInput
    create: XOR<TemplateAssignmentCreateWithoutSpecificUserInput, TemplateAssignmentUncheckedCreateWithoutSpecificUserInput>
  }

  export type TemplateAssignmentCreateManySpecificUserInputEnvelope = {
    data: TemplateAssignmentCreateManySpecificUserInput | TemplateAssignmentCreateManySpecificUserInput[]
    skipDuplicates?: boolean
  }

  export type ActivityCreateWithoutAssignedByInput = {
    id: Uint8Array
    title: string
    type: $Enums.ActivityType
    taskScheduleType?: $Enums.TaskScheduleType | null
    startDate: Date | string
    endDate: Date | string
    completedAt?: Date | string | null
    description?: string | null
    priority?: $Enums.ActivityPriority
    status: $Enums.ActivityStatus
    phoneNumber?: string | null
    location?: string | null
    holdReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean
    deletedAt?: Date | string | null
    order?: number | null
    steps?: ActivityStepCreateNestedManyWithoutActivityInput
    waypoints?: ActivityWaypointCreateNestedManyWithoutActivityInput
    activities?: ActivityCreateNestedManyWithoutParentActivityInput
    parentActivity?: ActivityCreateNestedOneWithoutActivitiesInput
    parentWaypoint?: ActivityWaypointCreateNestedOneWithoutChildActivitiesInput
    template?: ActivityTemplateCreateNestedOneWithoutActivitiesInput
    contacts?: ActivityContactJoinCreateNestedManyWithoutActivityRelationInput
    users?: ActivityUserJoinCreateNestedManyWithoutActivityRelationInput
    tenet: TenetCreateNestedOneWithoutActivitiesInput
    attachments?: AttachmentCreateNestedManyWithoutActivityInput
    notes?: NoteCreateNestedManyWithoutActivityInput
    events?: ContactTimelineEventCreateNestedManyWithoutActivityInput
    opportunity?: OpportunityCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateWithoutAssignedByInput = {
    id: Uint8Array
    title: string
    type: $Enums.ActivityType
    parentActivityId?: Uint8Array | null
    parentWaypointId?: Uint8Array | null
    templateId?: Uint8Array | null
    taskScheduleType?: $Enums.TaskScheduleType | null
    startDate: Date | string
    endDate: Date | string
    completedAt?: Date | string | null
    description?: string | null
    priority?: $Enums.ActivityPriority
    status: $Enums.ActivityStatus
    phoneNumber?: string | null
    location?: string | null
    holdReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
    deleted?: boolean
    deletedAt?: Date | string | null
    order?: number | null
    opportunityId?: Uint8Array | null
    steps?: ActivityStepUncheckedCreateNestedManyWithoutActivityInput
    waypoints?: ActivityWaypointUncheckedCreateNestedManyWithoutActivityInput
    activities?: ActivityUncheckedCreateNestedManyWithoutParentActivityInput
    contacts?: ActivityContactJoinUncheckedCreateNestedManyWithoutActivityRelationInput
    users?: ActivityUserJoinUncheckedCreateNestedManyWithoutActivityRelationInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutActivityInput
    notes?: NoteUncheckedCreateNestedManyWithoutActivityInput
    events?: ContactTimelineEventUncheckedCreateNestedManyWithoutActivityInput
  }

  export type ActivityCreateOrConnectWithoutAssignedByInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutAssignedByInput, ActivityUncheckedCreateWithoutAssignedByInput>
  }

  export type ActivityCreateManyAssignedByInputEnvelope = {
    data: ActivityCreateManyAssignedByInput | ActivityCreateManyAssignedByInput[]
    skipDuplicates?: boolean
  }

  export type UserOpportunityJoinCreateWithoutUserRelationInput = {
    opportunityRelation: OpportunityCreateNestedOneWithoutTeamMembersInput
  }

  export type UserOpportunityJoinUncheckedCreateWithoutUserRelationInput = {
    opportunityId: Uint8Array
  }

  export type UserOpportunityJoinCreateOrConnectWithoutUserRelationInput = {
    where: UserOpportunityJoinWhereUniqueInput
    create: XOR<UserOpportunityJoinCreateWithoutUserRelationInput, UserOpportunityJoinUncheckedCreateWithoutUserRelationInput>
  }

  export type UserOpportunityJoinCreateManyUserRelationInputEnvelope = {
    data: UserOpportunityJoinCreateManyUserRelationInput | UserOpportunityJoinCreateManyUserRelationInput[]
    skipDuplicates?: boolean
  }

  export type ActivityStepUserJoinCreateWithoutUserRelationInput = {
    stepRelation: ActivityStepCreateNestedOneWithoutAssignedToInput
  }

  export type ActivityStepUserJoinUncheckedCreateWithoutUserRelationInput = {
    activityStepId: Uint8Array
  }

  export type ActivityStepUserJoinCreateOrConnectWithoutUserRelationInput = {
    where: ActivityStepUserJoinWhereUniqueInput
    create: XOR<ActivityStepUserJoinCreateWithoutUserRelationInput, ActivityStepUserJoinUncheckedCreateWithoutUserRelationInput>
  }

  export type ActivityStepUserJoinCreateManyUserRelationInputEnvelope = {
    data: ActivityStepUserJoinCreateManyUserRelationInput | ActivityStepUserJoinCreateManyUserRelationInput[]
    skipDuplicates?: boolean
  }

  export type ActivityTemplateStepAssignmentCreateWithoutSpecificUserInput = {
    id: Uint8Array
    specificRole?: $Enums.Role | null
    activityTemplateStep: ActivityTemplateStepCreateNestedOneWithoutAssignedToInput
    tenet: TenetCreateNestedOneWithoutActivityTemplateStepAssignmentInput
  }

  export type ActivityTemplateStepAssignmentUncheckedCreateWithoutSpecificUserInput = {
    id: Uint8Array
    specificRole?: $Enums.Role | null
    activityTemplateStepId: Uint8Array
    tenetId: Uint8Array
  }

  export type ActivityTemplateStepAssignmentCreateOrConnectWithoutSpecificUserInput = {
    where: ActivityTemplateStepAssignmentWhereUniqueInput
    create: XOR<ActivityTemplateStepAssignmentCreateWithoutSpecificUserInput, ActivityTemplateStepAssignmentUncheckedCreateWithoutSpecificUserInput>
  }

  export type ActivityTemplateStepAssignmentCreateManySpecificUserInputEnvelope = {
    data: ActivityTemplateStepAssignmentCreateManySpecificUserInput | ActivityTemplateStepAssignmentCreateManySpecificUserInput[]
    skipDuplicates?: boolean
  }

  export type TokenUpsertWithWhereUniqueWithoutUserInput = {
    where: TokenWhereUniqueInput
    update: XOR<TokenUpdateWithoutUserInput, TokenUncheckedUpdateWithoutUserInput>
    create: XOR<TokenCreateWithoutUserInput, TokenUncheckedCreateWithoutUserInput>
  }

  export type TokenUpdateWithWhereUniqueWithoutUserInput = {
    where: TokenWhereUniqueInput
    data: XOR<TokenUpdateWithoutUserInput, TokenUncheckedUpdateWithoutUserInput>
  }

  export type TokenUpdateManyWithWhereWithoutUserInput = {
    where: TokenScalarWhereInput
    data: XOR<TokenUpdateManyMutationInput, TokenUncheckedUpdateManyWithoutUserInput>
  }

  export type TokenScalarWhereInput = {
    AND?: TokenScalarWhereInput | TokenScalarWhereInput[]
    OR?: TokenScalarWhereInput[]
    NOT?: TokenScalarWhereInput | TokenScalarWhereInput[]
    id?: BytesFilter<"Token"> | Uint8Array
    userId?: BytesFilter<"Token"> | Uint8Array
    createdAt?: DateTimeFilter<"Token"> | Date | string
    refresh?: BoolFilter<"Token"> | boolean
  }

  export type TenetUpsertWithoutUsersInput = {
    update: XOR<TenetUpdateWithoutUsersInput, TenetUncheckedUpdateWithoutUsersInput>
    create: XOR<TenetCreateWithoutUsersInput, TenetUncheckedCreateWithoutUsersInput>
    where?: TenetWhereInput
  }

  export type TenetUpdateToOneWithWhereWithoutUsersInput = {
    where?: TenetWhereInput
    data: XOR<TenetUpdateWithoutUsersInput, TenetUncheckedUpdateWithoutUsersInput>
  }

  export type TenetUpdateWithoutUsersInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logs?: LogUpdateManyWithoutTenetNestedInput
    contacts?: ContactUpdateManyWithoutTenetNestedInput
    activities?: ActivityUpdateManyWithoutTenetNestedInput
    addresses?: AddressUpdateManyWithoutTenetNestedInput
    contactEmails?: ContactEmailUpdateManyWithoutTenetNestedInput
    contactPhones?: ContactPhoneUpdateManyWithoutTenetNestedInput
    importantDates?: ImportantDateUpdateManyWithoutTenetNestedInput
    attachments?: AttachmentUpdateManyWithoutTenetNestedInput
    notes?: NoteUpdateManyWithoutTenetNestedInput
    auditEvents?: AuditEventUpdateManyWithoutTenetNestedInput
    contactTimelineEvents?: ContactTimelineEventUpdateManyWithoutTenetNestedInput
    activitySteps?: ActivityStepUpdateManyWithoutTenetNestedInput
    activityWaypoints?: ActivityWaypointUpdateManyWithoutTenetNestedInput
    templateAssignments?: TemplateAssignmentUpdateManyWithoutTenetNestedInput
    activityWaypointTemplates?: ActivityWaypointTemplateUpdateManyWithoutTenetNestedInput
    activityTemplates?: ActivityTemplateUpdateManyWithoutTenetNestedInput
    activityTemplateSteps?: ActivityTemplateStepUpdateManyWithoutTenetNestedInput
    opportunities?: OpportunityUpdateManyWithoutTenetNestedInput
    products?: ProductTypeUpdateManyWithoutTenetNestedInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentUpdateManyWithoutTenetNestedInput
  }

  export type TenetUncheckedUpdateWithoutUsersInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logs?: LogUncheckedUpdateManyWithoutTenetNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutTenetNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutTenetNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutTenetNestedInput
    contactEmails?: ContactEmailUncheckedUpdateManyWithoutTenetNestedInput
    contactPhones?: ContactPhoneUncheckedUpdateManyWithoutTenetNestedInput
    importantDates?: ImportantDateUncheckedUpdateManyWithoutTenetNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTenetNestedInput
    notes?: NoteUncheckedUpdateManyWithoutTenetNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutTenetNestedInput
    contactTimelineEvents?: ContactTimelineEventUncheckedUpdateManyWithoutTenetNestedInput
    activitySteps?: ActivityStepUncheckedUpdateManyWithoutTenetNestedInput
    activityWaypoints?: ActivityWaypointUncheckedUpdateManyWithoutTenetNestedInput
    templateAssignments?: TemplateAssignmentUncheckedUpdateManyWithoutTenetNestedInput
    activityWaypointTemplates?: ActivityWaypointTemplateUncheckedUpdateManyWithoutTenetNestedInput
    activityTemplates?: ActivityTemplateUncheckedUpdateManyWithoutTenetNestedInput
    activityTemplateSteps?: ActivityTemplateStepUncheckedUpdateManyWithoutTenetNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutTenetNestedInput
    products?: ProductTypeUncheckedUpdateManyWithoutTenetNestedInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentUncheckedUpdateManyWithoutTenetNestedInput
  }

  export type ActivityUserJoinUpsertWithWhereUniqueWithoutUserRelationInput = {
    where: ActivityUserJoinWhereUniqueInput
    update: XOR<ActivityUserJoinUpdateWithoutUserRelationInput, ActivityUserJoinUncheckedUpdateWithoutUserRelationInput>
    create: XOR<ActivityUserJoinCreateWithoutUserRelationInput, ActivityUserJoinUncheckedCreateWithoutUserRelationInput>
  }

  export type ActivityUserJoinUpdateWithWhereUniqueWithoutUserRelationInput = {
    where: ActivityUserJoinWhereUniqueInput
    data: XOR<ActivityUserJoinUpdateWithoutUserRelationInput, ActivityUserJoinUncheckedUpdateWithoutUserRelationInput>
  }

  export type ActivityUserJoinUpdateManyWithWhereWithoutUserRelationInput = {
    where: ActivityUserJoinScalarWhereInput
    data: XOR<ActivityUserJoinUpdateManyMutationInput, ActivityUserJoinUncheckedUpdateManyWithoutUserRelationInput>
  }

  export type ActivityUserJoinScalarWhereInput = {
    AND?: ActivityUserJoinScalarWhereInput | ActivityUserJoinScalarWhereInput[]
    OR?: ActivityUserJoinScalarWhereInput[]
    NOT?: ActivityUserJoinScalarWhereInput | ActivityUserJoinScalarWhereInput[]
    activityId?: BytesFilter<"ActivityUserJoin"> | Uint8Array
    userId?: BytesFilter<"ActivityUserJoin"> | Uint8Array
  }

  export type NoteUpsertWithWhereUniqueWithoutAuthorInput = {
    where: NoteWhereUniqueInput
    update: XOR<NoteUpdateWithoutAuthorInput, NoteUncheckedUpdateWithoutAuthorInput>
    create: XOR<NoteCreateWithoutAuthorInput, NoteUncheckedCreateWithoutAuthorInput>
  }

  export type NoteUpdateWithWhereUniqueWithoutAuthorInput = {
    where: NoteWhereUniqueInput
    data: XOR<NoteUpdateWithoutAuthorInput, NoteUncheckedUpdateWithoutAuthorInput>
  }

  export type NoteUpdateManyWithWhereWithoutAuthorInput = {
    where: NoteScalarWhereInput
    data: XOR<NoteUpdateManyMutationInput, NoteUncheckedUpdateManyWithoutAuthorInput>
  }

  export type UserWaypointJoinUpsertWithWhereUniqueWithoutUserRelationInput = {
    where: UserWaypointJoinWhereUniqueInput
    update: XOR<UserWaypointJoinUpdateWithoutUserRelationInput, UserWaypointJoinUncheckedUpdateWithoutUserRelationInput>
    create: XOR<UserWaypointJoinCreateWithoutUserRelationInput, UserWaypointJoinUncheckedCreateWithoutUserRelationInput>
  }

  export type UserWaypointJoinUpdateWithWhereUniqueWithoutUserRelationInput = {
    where: UserWaypointJoinWhereUniqueInput
    data: XOR<UserWaypointJoinUpdateWithoutUserRelationInput, UserWaypointJoinUncheckedUpdateWithoutUserRelationInput>
  }

  export type UserWaypointJoinUpdateManyWithWhereWithoutUserRelationInput = {
    where: UserWaypointJoinScalarWhereInput
    data: XOR<UserWaypointJoinUpdateManyMutationInput, UserWaypointJoinUncheckedUpdateManyWithoutUserRelationInput>
  }

  export type UserWaypointJoinScalarWhereInput = {
    AND?: UserWaypointJoinScalarWhereInput | UserWaypointJoinScalarWhereInput[]
    OR?: UserWaypointJoinScalarWhereInput[]
    NOT?: UserWaypointJoinScalarWhereInput | UserWaypointJoinScalarWhereInput[]
    userId?: BytesFilter<"UserWaypointJoin"> | Uint8Array
    waypointId?: BytesFilter<"UserWaypointJoin"> | Uint8Array
  }

  export type ContactTimelineEventUpsertWithWhereUniqueWithoutUserInput = {
    where: ContactTimelineEventWhereUniqueInput
    update: XOR<ContactTimelineEventUpdateWithoutUserInput, ContactTimelineEventUncheckedUpdateWithoutUserInput>
    create: XOR<ContactTimelineEventCreateWithoutUserInput, ContactTimelineEventUncheckedCreateWithoutUserInput>
  }

  export type ContactTimelineEventUpdateWithWhereUniqueWithoutUserInput = {
    where: ContactTimelineEventWhereUniqueInput
    data: XOR<ContactTimelineEventUpdateWithoutUserInput, ContactTimelineEventUncheckedUpdateWithoutUserInput>
  }

  export type ContactTimelineEventUpdateManyWithWhereWithoutUserInput = {
    where: ContactTimelineEventScalarWhereInput
    data: XOR<ContactTimelineEventUpdateManyMutationInput, ContactTimelineEventUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditEventUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditEventWhereUniqueInput
    update: XOR<AuditEventUpdateWithoutUserInput, AuditEventUncheckedUpdateWithoutUserInput>
    create: XOR<AuditEventCreateWithoutUserInput, AuditEventUncheckedCreateWithoutUserInput>
  }

  export type AuditEventUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditEventWhereUniqueInput
    data: XOR<AuditEventUpdateWithoutUserInput, AuditEventUncheckedUpdateWithoutUserInput>
  }

  export type AuditEventUpdateManyWithWhereWithoutUserInput = {
    where: AuditEventScalarWhereInput
    data: XOR<AuditEventUpdateManyMutationInput, AuditEventUncheckedUpdateManyWithoutUserInput>
  }

  export type TemplateAssignmentUpsertWithWhereUniqueWithoutSpecificUserInput = {
    where: TemplateAssignmentWhereUniqueInput
    update: XOR<TemplateAssignmentUpdateWithoutSpecificUserInput, TemplateAssignmentUncheckedUpdateWithoutSpecificUserInput>
    create: XOR<TemplateAssignmentCreateWithoutSpecificUserInput, TemplateAssignmentUncheckedCreateWithoutSpecificUserInput>
  }

  export type TemplateAssignmentUpdateWithWhereUniqueWithoutSpecificUserInput = {
    where: TemplateAssignmentWhereUniqueInput
    data: XOR<TemplateAssignmentUpdateWithoutSpecificUserInput, TemplateAssignmentUncheckedUpdateWithoutSpecificUserInput>
  }

  export type TemplateAssignmentUpdateManyWithWhereWithoutSpecificUserInput = {
    where: TemplateAssignmentScalarWhereInput
    data: XOR<TemplateAssignmentUpdateManyMutationInput, TemplateAssignmentUncheckedUpdateManyWithoutSpecificUserInput>
  }

  export type ActivityUpsertWithWhereUniqueWithoutAssignedByInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutAssignedByInput, ActivityUncheckedUpdateWithoutAssignedByInput>
    create: XOR<ActivityCreateWithoutAssignedByInput, ActivityUncheckedCreateWithoutAssignedByInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutAssignedByInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutAssignedByInput, ActivityUncheckedUpdateWithoutAssignedByInput>
  }

  export type ActivityUpdateManyWithWhereWithoutAssignedByInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutAssignedByInput>
  }

  export type UserOpportunityJoinUpsertWithWhereUniqueWithoutUserRelationInput = {
    where: UserOpportunityJoinWhereUniqueInput
    update: XOR<UserOpportunityJoinUpdateWithoutUserRelationInput, UserOpportunityJoinUncheckedUpdateWithoutUserRelationInput>
    create: XOR<UserOpportunityJoinCreateWithoutUserRelationInput, UserOpportunityJoinUncheckedCreateWithoutUserRelationInput>
  }

  export type UserOpportunityJoinUpdateWithWhereUniqueWithoutUserRelationInput = {
    where: UserOpportunityJoinWhereUniqueInput
    data: XOR<UserOpportunityJoinUpdateWithoutUserRelationInput, UserOpportunityJoinUncheckedUpdateWithoutUserRelationInput>
  }

  export type UserOpportunityJoinUpdateManyWithWhereWithoutUserRelationInput = {
    where: UserOpportunityJoinScalarWhereInput
    data: XOR<UserOpportunityJoinUpdateManyMutationInput, UserOpportunityJoinUncheckedUpdateManyWithoutUserRelationInput>
  }

  export type UserOpportunityJoinScalarWhereInput = {
    AND?: UserOpportunityJoinScalarWhereInput | UserOpportunityJoinScalarWhereInput[]
    OR?: UserOpportunityJoinScalarWhereInput[]
    NOT?: UserOpportunityJoinScalarWhereInput | UserOpportunityJoinScalarWhereInput[]
    userId?: BytesFilter<"UserOpportunityJoin"> | Uint8Array
    opportunityId?: BytesFilter<"UserOpportunityJoin"> | Uint8Array
  }

  export type ActivityStepUserJoinUpsertWithWhereUniqueWithoutUserRelationInput = {
    where: ActivityStepUserJoinWhereUniqueInput
    update: XOR<ActivityStepUserJoinUpdateWithoutUserRelationInput, ActivityStepUserJoinUncheckedUpdateWithoutUserRelationInput>
    create: XOR<ActivityStepUserJoinCreateWithoutUserRelationInput, ActivityStepUserJoinUncheckedCreateWithoutUserRelationInput>
  }

  export type ActivityStepUserJoinUpdateWithWhereUniqueWithoutUserRelationInput = {
    where: ActivityStepUserJoinWhereUniqueInput
    data: XOR<ActivityStepUserJoinUpdateWithoutUserRelationInput, ActivityStepUserJoinUncheckedUpdateWithoutUserRelationInput>
  }

  export type ActivityStepUserJoinUpdateManyWithWhereWithoutUserRelationInput = {
    where: ActivityStepUserJoinScalarWhereInput
    data: XOR<ActivityStepUserJoinUpdateManyMutationInput, ActivityStepUserJoinUncheckedUpdateManyWithoutUserRelationInput>
  }

  export type ActivityStepUserJoinScalarWhereInput = {
    AND?: ActivityStepUserJoinScalarWhereInput | ActivityStepUserJoinScalarWhereInput[]
    OR?: ActivityStepUserJoinScalarWhereInput[]
    NOT?: ActivityStepUserJoinScalarWhereInput | ActivityStepUserJoinScalarWhereInput[]
    activityStepId?: BytesFilter<"ActivityStepUserJoin"> | Uint8Array
    userId?: BytesFilter<"ActivityStepUserJoin"> | Uint8Array
  }

  export type ActivityTemplateStepAssignmentUpsertWithWhereUniqueWithoutSpecificUserInput = {
    where: ActivityTemplateStepAssignmentWhereUniqueInput
    update: XOR<ActivityTemplateStepAssignmentUpdateWithoutSpecificUserInput, ActivityTemplateStepAssignmentUncheckedUpdateWithoutSpecificUserInput>
    create: XOR<ActivityTemplateStepAssignmentCreateWithoutSpecificUserInput, ActivityTemplateStepAssignmentUncheckedCreateWithoutSpecificUserInput>
  }

  export type ActivityTemplateStepAssignmentUpdateWithWhereUniqueWithoutSpecificUserInput = {
    where: ActivityTemplateStepAssignmentWhereUniqueInput
    data: XOR<ActivityTemplateStepAssignmentUpdateWithoutSpecificUserInput, ActivityTemplateStepAssignmentUncheckedUpdateWithoutSpecificUserInput>
  }

  export type ActivityTemplateStepAssignmentUpdateManyWithWhereWithoutSpecificUserInput = {
    where: ActivityTemplateStepAssignmentScalarWhereInput
    data: XOR<ActivityTemplateStepAssignmentUpdateManyMutationInput, ActivityTemplateStepAssignmentUncheckedUpdateManyWithoutSpecificUserInput>
  }

  export type TenetCreateWithoutContactsInput = {
    id: Uint8Array
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenetInput
    logs?: LogCreateNestedManyWithoutTenetInput
    activities?: ActivityCreateNestedManyWithoutTenetInput
    addresses?: AddressCreateNestedManyWithoutTenetInput
    contactEmails?: ContactEmailCreateNestedManyWithoutTenetInput
    contactPhones?: ContactPhoneCreateNestedManyWithoutTenetInput
    importantDates?: ImportantDateCreateNestedManyWithoutTenetInput
    attachments?: AttachmentCreateNestedManyWithoutTenetInput
    notes?: NoteCreateNestedManyWithoutTenetInput
    auditEvents?: AuditEventCreateNestedManyWithoutTenetInput
    contactTimelineEvents?: ContactTimelineEventCreateNestedManyWithoutTenetInput
    activitySteps?: ActivityStepCreateNestedManyWithoutTenetInput
    activityWaypoints?: ActivityWaypointCreateNestedManyWithoutTenetInput
    templateAssignments?: TemplateAssignmentCreateNestedManyWithoutTenetInput
    activityWaypointTemplates?: ActivityWaypointTemplateCreateNestedManyWithoutTenetInput
    activityTemplates?: ActivityTemplateCreateNestedManyWithoutTenetInput
    activityTemplateSteps?: ActivityTemplateStepCreateNestedManyWithoutTenetInput
    opportunities?: OpportunityCreateNestedManyWithoutTenetInput
    products?: ProductTypeCreateNestedManyWithoutTenetInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentCreateNestedManyWithoutTenetInput
  }

  export type TenetUncheckedCreateWithoutContactsInput = {
    id: Uint8Array
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenetInput
    logs?: LogUncheckedCreateNestedManyWithoutTenetInput
    activities?: ActivityUncheckedCreateNestedManyWithoutTenetInput
    addresses?: AddressUncheckedCreateNestedManyWithoutTenetInput
    contactEmails?: ContactEmailUncheckedCreateNestedManyWithoutTenetInput
    contactPhones?: ContactPhoneUncheckedCreateNestedManyWithoutTenetInput
    importantDates?: ImportantDateUncheckedCreateNestedManyWithoutTenetInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTenetInput
    notes?: NoteUncheckedCreateNestedManyWithoutTenetInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutTenetInput
    contactTimelineEvents?: ContactTimelineEventUncheckedCreateNestedManyWithoutTenetInput
    activitySteps?: ActivityStepUncheckedCreateNestedManyWithoutTenetInput
    activityWaypoints?: ActivityWaypointUncheckedCreateNestedManyWithoutTenetInput
    templateAssignments?: TemplateAssignmentUncheckedCreateNestedManyWithoutTenetInput
    activityWaypointTemplates?: ActivityWaypointTemplateUncheckedCreateNestedManyWithoutTenetInput
    activityTemplates?: ActivityTemplateUncheckedCreateNestedManyWithoutTenetInput
    activityTemplateSteps?: ActivityTemplateStepUncheckedCreateNestedManyWithoutTenetInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutTenetInput
    products?: ProductTypeUncheckedCreateNestedManyWithoutTenetInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentUncheckedCreateNestedManyWithoutTenetInput
  }

  export type TenetCreateOrConnectWithoutContactsInput = {
    where: TenetWhereUniqueInput
    create: XOR<TenetCreateWithoutContactsInput, TenetUncheckedCreateWithoutContactsInput>
  }

  export type NoteCreateWithoutContactInput = {
    id: Uint8Array
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean
    deletedAt?: Date | string | null
    noteType?: $Enums.NoteType
    waypoint?: ActivityWaypointCreateNestedOneWithoutNoteInput
    activity?: ActivityCreateNestedOneWithoutNotesInput
    opportunity?: OpportunityCreateNestedOneWithoutNotesInput
    tenet: TenetCreateNestedOneWithoutNotesInput
    author: UserCreateNestedOneWithoutNotesInput
    events?: ContactTimelineEventCreateNestedManyWithoutNoteInput
  }

  export type NoteUncheckedCreateWithoutContactInput = {
    id: Uint8Array
    content: string
    waypointId?: Uint8Array | null
    activityId?: Uint8Array | null
    opportunityId?: Uint8Array | null
    tenetId: Uint8Array
    authorId: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean
    deletedAt?: Date | string | null
    noteType?: $Enums.NoteType
    events?: ContactTimelineEventUncheckedCreateNestedManyWithoutNoteInput
  }

  export type NoteCreateOrConnectWithoutContactInput = {
    where: NoteWhereUniqueInput
    create: XOR<NoteCreateWithoutContactInput, NoteUncheckedCreateWithoutContactInput>
  }

  export type NoteCreateManyContactInputEnvelope = {
    data: NoteCreateManyContactInput | NoteCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type ContactTimelineEventContactJoinCreateWithoutContactRelationInput = {
    type: $Enums.ContactTimelineEventJoinType
    contactEventRelation: ContactTimelineEventCreateNestedOneWithoutContactsInput
  }

  export type ContactTimelineEventContactJoinUncheckedCreateWithoutContactRelationInput = {
    contactEventId: Uint8Array
    type: $Enums.ContactTimelineEventJoinType
  }

  export type ContactTimelineEventContactJoinCreateOrConnectWithoutContactRelationInput = {
    where: ContactTimelineEventContactJoinWhereUniqueInput
    create: XOR<ContactTimelineEventContactJoinCreateWithoutContactRelationInput, ContactTimelineEventContactJoinUncheckedCreateWithoutContactRelationInput>
  }

  export type ContactTimelineEventContactJoinCreateManyContactRelationInputEnvelope = {
    data: ContactTimelineEventContactJoinCreateManyContactRelationInput | ContactTimelineEventContactJoinCreateManyContactRelationInput[]
    skipDuplicates?: boolean
  }

  export type AddressCreateWithoutContactInput = {
    id: Uint8Array
    street: string
    city: string
    state: string
    zip: string
    country: string
    type: $Enums.AddressType
    primary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    timezone?: string | null
    tenet: TenetCreateNestedOneWithoutAddressesInput
  }

  export type AddressUncheckedCreateWithoutContactInput = {
    id: Uint8Array
    street: string
    city: string
    state: string
    zip: string
    country: string
    type: $Enums.AddressType
    primary?: boolean
    tenetId: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
    timezone?: string | null
  }

  export type AddressCreateOrConnectWithoutContactInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutContactInput, AddressUncheckedCreateWithoutContactInput>
  }

  export type AddressCreateManyContactInputEnvelope = {
    data: AddressCreateManyContactInput | AddressCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type ContactEmailCreateWithoutContactInput = {
    id: Uint8Array
    email: string
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenet: TenetCreateNestedOneWithoutContactEmailsInput
  }

  export type ContactEmailUncheckedCreateWithoutContactInput = {
    id: Uint8Array
    email: string
    isPrimary?: boolean
    tenetId: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactEmailCreateOrConnectWithoutContactInput = {
    where: ContactEmailWhereUniqueInput
    create: XOR<ContactEmailCreateWithoutContactInput, ContactEmailUncheckedCreateWithoutContactInput>
  }

  export type ContactEmailCreateManyContactInputEnvelope = {
    data: ContactEmailCreateManyContactInput | ContactEmailCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type ContactPhoneCreateWithoutContactInput = {
    id: Uint8Array
    number: string
    type: $Enums.PhoneType
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenet: TenetCreateNestedOneWithoutContactPhonesInput
  }

  export type ContactPhoneUncheckedCreateWithoutContactInput = {
    id: Uint8Array
    number: string
    type: $Enums.PhoneType
    isPrimary?: boolean
    tenetId: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactPhoneCreateOrConnectWithoutContactInput = {
    where: ContactPhoneWhereUniqueInput
    create: XOR<ContactPhoneCreateWithoutContactInput, ContactPhoneUncheckedCreateWithoutContactInput>
  }

  export type ContactPhoneCreateManyContactInputEnvelope = {
    data: ContactPhoneCreateManyContactInput | ContactPhoneCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type ImportantDateCreateWithoutContactInput = {
    id: Uint8Array
    date: Date | string
    type: $Enums.ImportantDateType
    createdAt?: Date | string
    updatedAt?: Date | string
    tenet: TenetCreateNestedOneWithoutImportantDatesInput
  }

  export type ImportantDateUncheckedCreateWithoutContactInput = {
    id: Uint8Array
    date: Date | string
    type: $Enums.ImportantDateType
    tenetId: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImportantDateCreateOrConnectWithoutContactInput = {
    where: ImportantDateWhereUniqueInput
    create: XOR<ImportantDateCreateWithoutContactInput, ImportantDateUncheckedCreateWithoutContactInput>
  }

  export type ImportantDateCreateManyContactInputEnvelope = {
    data: ImportantDateCreateManyContactInput | ImportantDateCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type ActivityContactJoinCreateWithoutContactRelationInput = {
    activityRelation: ActivityCreateNestedOneWithoutContactsInput
  }

  export type ActivityContactJoinUncheckedCreateWithoutContactRelationInput = {
    activityId: Uint8Array
  }

  export type ActivityContactJoinCreateOrConnectWithoutContactRelationInput = {
    where: ActivityContactJoinWhereUniqueInput
    create: XOR<ActivityContactJoinCreateWithoutContactRelationInput, ActivityContactJoinUncheckedCreateWithoutContactRelationInput>
  }

  export type ActivityContactJoinCreateManyContactRelationInputEnvelope = {
    data: ActivityContactJoinCreateManyContactRelationInput | ActivityContactJoinCreateManyContactRelationInput[]
    skipDuplicates?: boolean
  }

  export type ContactCreateWithoutHouseholdMembersInput = {
    id: Uint8Array
    firstName?: string | null
    lastName: string
    fullName: string
    importantNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.ContactType
    status: $Enums.ContactStatus
    lifecycleStage?: $Enums.LifecycleStage | null
    lastContactedDate?: Date | string | null
    followUpDate?: Date | string | null
    householdStatus?: $Enums.HouseholdRelationshipStatus | null
    position?: string | null
    companyStatus?: $Enums.CompanyRelationshipStatus | null
    industry?: string | null
    website?: string | null
    size?: number | null
    deleted?: boolean
    deletedAt?: Date | string | null
    tenet: TenetCreateNestedOneWithoutContactsInput
    notes?: NoteCreateNestedManyWithoutContactInput
    timelineEvents?: ContactTimelineEventContactJoinCreateNestedManyWithoutContactRelationInput
    addresses?: AddressCreateNestedManyWithoutContactInput
    emails?: ContactEmailCreateNestedManyWithoutContactInput
    phones?: ContactPhoneCreateNestedManyWithoutContactInput
    importantDates?: ImportantDateCreateNestedManyWithoutContactInput
    activities?: ActivityContactJoinCreateNestedManyWithoutContactRelationInput
    household?: ContactCreateNestedOneWithoutHouseholdMembersInput
    headOfHouseholdFor?: ContactCreateNestedOneWithoutHeadOfHouseholdInput
    company?: ContactCreateNestedOneWithoutEmployeesInput
    primaryContactFor?: ContactCreateNestedOneWithoutPrimaryContactInput
    headOfHousehold?: ContactCreateNestedOneWithoutHeadOfHouseholdForInput
    employees?: ContactCreateNestedManyWithoutCompanyInput
    primaryContact?: ContactCreateNestedOneWithoutPrimaryContactForInput
    opportunities?: ContactOpportunityJoinCreateNestedManyWithoutContactRelationInput
    relationAsSource?: ContactRelationshipCreateNestedManyWithoutSourceInput
    relationAsTarget?: ContactRelationshipCreateNestedManyWithoutTargetInput
  }

  export type ContactUncheckedCreateWithoutHouseholdMembersInput = {
    id: Uint8Array
    firstName?: string | null
    lastName: string
    fullName: string
    tenetId: Uint8Array
    importantNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.ContactType
    status: $Enums.ContactStatus
    lifecycleStage?: $Enums.LifecycleStage | null
    lastContactedDate?: Date | string | null
    followUpDate?: Date | string | null
    householdId?: Uint8Array | null
    householdStatus?: $Enums.HouseholdRelationshipStatus | null
    companyId?: Uint8Array | null
    position?: string | null
    companyStatus?: $Enums.CompanyRelationshipStatus | null
    headOfHouseholdId?: Uint8Array | null
    industry?: string | null
    website?: string | null
    size?: number | null
    primaryContactId?: Uint8Array | null
    deleted?: boolean
    deletedAt?: Date | string | null
    notes?: NoteUncheckedCreateNestedManyWithoutContactInput
    timelineEvents?: ContactTimelineEventContactJoinUncheckedCreateNestedManyWithoutContactRelationInput
    addresses?: AddressUncheckedCreateNestedManyWithoutContactInput
    emails?: ContactEmailUncheckedCreateNestedManyWithoutContactInput
    phones?: ContactPhoneUncheckedCreateNestedManyWithoutContactInput
    importantDates?: ImportantDateUncheckedCreateNestedManyWithoutContactInput
    activities?: ActivityContactJoinUncheckedCreateNestedManyWithoutContactRelationInput
    headOfHouseholdFor?: ContactUncheckedCreateNestedOneWithoutHeadOfHouseholdInput
    primaryContactFor?: ContactUncheckedCreateNestedOneWithoutPrimaryContactInput
    employees?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    opportunities?: ContactOpportunityJoinUncheckedCreateNestedManyWithoutContactRelationInput
    relationAsSource?: ContactRelationshipUncheckedCreateNestedManyWithoutSourceInput
    relationAsTarget?: ContactRelationshipUncheckedCreateNestedManyWithoutTargetInput
  }

  export type ContactCreateOrConnectWithoutHouseholdMembersInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutHouseholdMembersInput, ContactUncheckedCreateWithoutHouseholdMembersInput>
  }

  export type ContactCreateWithoutHeadOfHouseholdInput = {
    id: Uint8Array
    firstName?: string | null
    lastName: string
    fullName: string
    importantNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.ContactType
    status: $Enums.ContactStatus
    lifecycleStage?: $Enums.LifecycleStage | null
    lastContactedDate?: Date | string | null
    followUpDate?: Date | string | null
    householdStatus?: $Enums.HouseholdRelationshipStatus | null
    position?: string | null
    companyStatus?: $Enums.CompanyRelationshipStatus | null
    industry?: string | null
    website?: string | null
    size?: number | null
    deleted?: boolean
    deletedAt?: Date | string | null
    tenet: TenetCreateNestedOneWithoutContactsInput
    notes?: NoteCreateNestedManyWithoutContactInput
    timelineEvents?: ContactTimelineEventContactJoinCreateNestedManyWithoutContactRelationInput
    addresses?: AddressCreateNestedManyWithoutContactInput
    emails?: ContactEmailCreateNestedManyWithoutContactInput
    phones?: ContactPhoneCreateNestedManyWithoutContactInput
    importantDates?: ImportantDateCreateNestedManyWithoutContactInput
    activities?: ActivityContactJoinCreateNestedManyWithoutContactRelationInput
    household?: ContactCreateNestedOneWithoutHouseholdMembersInput
    headOfHouseholdFor?: ContactCreateNestedOneWithoutHeadOfHouseholdInput
    company?: ContactCreateNestedOneWithoutEmployeesInput
    primaryContactFor?: ContactCreateNestedOneWithoutPrimaryContactInput
    householdMembers?: ContactCreateNestedManyWithoutHouseholdInput
    employees?: ContactCreateNestedManyWithoutCompanyInput
    primaryContact?: ContactCreateNestedOneWithoutPrimaryContactForInput
    opportunities?: ContactOpportunityJoinCreateNestedManyWithoutContactRelationInput
    relationAsSource?: ContactRelationshipCreateNestedManyWithoutSourceInput
    relationAsTarget?: ContactRelationshipCreateNestedManyWithoutTargetInput
  }

  export type ContactUncheckedCreateWithoutHeadOfHouseholdInput = {
    id: Uint8Array
    firstName?: string | null
    lastName: string
    fullName: string
    tenetId: Uint8Array
    importantNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.ContactType
    status: $Enums.ContactStatus
    lifecycleStage?: $Enums.LifecycleStage | null
    lastContactedDate?: Date | string | null
    followUpDate?: Date | string | null
    householdId?: Uint8Array | null
    householdStatus?: $Enums.HouseholdRelationshipStatus | null
    companyId?: Uint8Array | null
    position?: string | null
    companyStatus?: $Enums.CompanyRelationshipStatus | null
    industry?: string | null
    website?: string | null
    size?: number | null
    primaryContactId?: Uint8Array | null
    deleted?: boolean
    deletedAt?: Date | string | null
    notes?: NoteUncheckedCreateNestedManyWithoutContactInput
    timelineEvents?: ContactTimelineEventContactJoinUncheckedCreateNestedManyWithoutContactRelationInput
    addresses?: AddressUncheckedCreateNestedManyWithoutContactInput
    emails?: ContactEmailUncheckedCreateNestedManyWithoutContactInput
    phones?: ContactPhoneUncheckedCreateNestedManyWithoutContactInput
    importantDates?: ImportantDateUncheckedCreateNestedManyWithoutContactInput
    activities?: ActivityContactJoinUncheckedCreateNestedManyWithoutContactRelationInput
    headOfHouseholdFor?: ContactUncheckedCreateNestedOneWithoutHeadOfHouseholdInput
    primaryContactFor?: ContactUncheckedCreateNestedOneWithoutPrimaryContactInput
    householdMembers?: ContactUncheckedCreateNestedManyWithoutHouseholdInput
    employees?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    opportunities?: ContactOpportunityJoinUncheckedCreateNestedManyWithoutContactRelationInput
    relationAsSource?: ContactRelationshipUncheckedCreateNestedManyWithoutSourceInput
    relationAsTarget?: ContactRelationshipUncheckedCreateNestedManyWithoutTargetInput
  }

  export type ContactCreateOrConnectWithoutHeadOfHouseholdInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutHeadOfHouseholdInput, ContactUncheckedCreateWithoutHeadOfHouseholdInput>
  }

  export type ContactCreateWithoutEmployeesInput = {
    id: Uint8Array
    firstName?: string | null
    lastName: string
    fullName: string
    importantNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.ContactType
    status: $Enums.ContactStatus
    lifecycleStage?: $Enums.LifecycleStage | null
    lastContactedDate?: Date | string | null
    followUpDate?: Date | string | null
    householdStatus?: $Enums.HouseholdRelationshipStatus | null
    position?: string | null
    companyStatus?: $Enums.CompanyRelationshipStatus | null
    industry?: string | null
    website?: string | null
    size?: number | null
    deleted?: boolean
    deletedAt?: Date | string | null
    tenet: TenetCreateNestedOneWithoutContactsInput
    notes?: NoteCreateNestedManyWithoutContactInput
    timelineEvents?: ContactTimelineEventContactJoinCreateNestedManyWithoutContactRelationInput
    addresses?: AddressCreateNestedManyWithoutContactInput
    emails?: ContactEmailCreateNestedManyWithoutContactInput
    phones?: ContactPhoneCreateNestedManyWithoutContactInput
    importantDates?: ImportantDateCreateNestedManyWithoutContactInput
    activities?: ActivityContactJoinCreateNestedManyWithoutContactRelationInput
    household?: ContactCreateNestedOneWithoutHouseholdMembersInput
    headOfHouseholdFor?: ContactCreateNestedOneWithoutHeadOfHouseholdInput
    company?: ContactCreateNestedOneWithoutEmployeesInput
    primaryContactFor?: ContactCreateNestedOneWithoutPrimaryContactInput
    headOfHousehold?: ContactCreateNestedOneWithoutHeadOfHouseholdForInput
    householdMembers?: ContactCreateNestedManyWithoutHouseholdInput
    primaryContact?: ContactCreateNestedOneWithoutPrimaryContactForInput
    opportunities?: ContactOpportunityJoinCreateNestedManyWithoutContactRelationInput
    relationAsSource?: ContactRelationshipCreateNestedManyWithoutSourceInput
    relationAsTarget?: ContactRelationshipCreateNestedManyWithoutTargetInput
  }

  export type ContactUncheckedCreateWithoutEmployeesInput = {
    id: Uint8Array
    firstName?: string | null
    lastName: string
    fullName: string
    tenetId: Uint8Array
    importantNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.ContactType
    status: $Enums.ContactStatus
    lifecycleStage?: $Enums.LifecycleStage | null
    lastContactedDate?: Date | string | null
    followUpDate?: Date | string | null
    householdId?: Uint8Array | null
    householdStatus?: $Enums.HouseholdRelationshipStatus | null
    companyId?: Uint8Array | null
    position?: string | null
    companyStatus?: $Enums.CompanyRelationshipStatus | null
    headOfHouseholdId?: Uint8Array | null
    industry?: string | null
    website?: string | null
    size?: number | null
    primaryContactId?: Uint8Array | null
    deleted?: boolean
    deletedAt?: Date | string | null
    notes?: NoteUncheckedCreateNestedManyWithoutContactInput
    timelineEvents?: ContactTimelineEventContactJoinUncheckedCreateNestedManyWithoutContactRelationInput
    addresses?: AddressUncheckedCreateNestedManyWithoutContactInput
    emails?: ContactEmailUncheckedCreateNestedManyWithoutContactInput
    phones?: ContactPhoneUncheckedCreateNestedManyWithoutContactInput
    importantDates?: ImportantDateUncheckedCreateNestedManyWithoutContactInput
    activities?: ActivityContactJoinUncheckedCreateNestedManyWithoutContactRelationInput
    headOfHouseholdFor?: ContactUncheckedCreateNestedOneWithoutHeadOfHouseholdInput
    primaryContactFor?: ContactUncheckedCreateNestedOneWithoutPrimaryContactInput
    householdMembers?: ContactUncheckedCreateNestedManyWithoutHouseholdInput
    opportunities?: ContactOpportunityJoinUncheckedCreateNestedManyWithoutContactRelationInput
    relationAsSource?: ContactRelationshipUncheckedCreateNestedManyWithoutSourceInput
    relationAsTarget?: ContactRelationshipUncheckedCreateNestedManyWithoutTargetInput
  }

  export type ContactCreateOrConnectWithoutEmployeesInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutEmployeesInput, ContactUncheckedCreateWithoutEmployeesInput>
  }

  export type ContactCreateWithoutPrimaryContactInput = {
    id: Uint8Array
    firstName?: string | null
    lastName: string
    fullName: string
    importantNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.ContactType
    status: $Enums.ContactStatus
    lifecycleStage?: $Enums.LifecycleStage | null
    lastContactedDate?: Date | string | null
    followUpDate?: Date | string | null
    householdStatus?: $Enums.HouseholdRelationshipStatus | null
    position?: string | null
    companyStatus?: $Enums.CompanyRelationshipStatus | null
    industry?: string | null
    website?: string | null
    size?: number | null
    deleted?: boolean
    deletedAt?: Date | string | null
    tenet: TenetCreateNestedOneWithoutContactsInput
    notes?: NoteCreateNestedManyWithoutContactInput
    timelineEvents?: ContactTimelineEventContactJoinCreateNestedManyWithoutContactRelationInput
    addresses?: AddressCreateNestedManyWithoutContactInput
    emails?: ContactEmailCreateNestedManyWithoutContactInput
    phones?: ContactPhoneCreateNestedManyWithoutContactInput
    importantDates?: ImportantDateCreateNestedManyWithoutContactInput
    activities?: ActivityContactJoinCreateNestedManyWithoutContactRelationInput
    household?: ContactCreateNestedOneWithoutHouseholdMembersInput
    headOfHouseholdFor?: ContactCreateNestedOneWithoutHeadOfHouseholdInput
    company?: ContactCreateNestedOneWithoutEmployeesInput
    primaryContactFor?: ContactCreateNestedOneWithoutPrimaryContactInput
    headOfHousehold?: ContactCreateNestedOneWithoutHeadOfHouseholdForInput
    householdMembers?: ContactCreateNestedManyWithoutHouseholdInput
    employees?: ContactCreateNestedManyWithoutCompanyInput
    opportunities?: ContactOpportunityJoinCreateNestedManyWithoutContactRelationInput
    relationAsSource?: ContactRelationshipCreateNestedManyWithoutSourceInput
    relationAsTarget?: ContactRelationshipCreateNestedManyWithoutTargetInput
  }

  export type ContactUncheckedCreateWithoutPrimaryContactInput = {
    id: Uint8Array
    firstName?: string | null
    lastName: string
    fullName: string
    tenetId: Uint8Array
    importantNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.ContactType
    status: $Enums.ContactStatus
    lifecycleStage?: $Enums.LifecycleStage | null
    lastContactedDate?: Date | string | null
    followUpDate?: Date | string | null
    householdId?: Uint8Array | null
    householdStatus?: $Enums.HouseholdRelationshipStatus | null
    companyId?: Uint8Array | null
    position?: string | null
    companyStatus?: $Enums.CompanyRelationshipStatus | null
    headOfHouseholdId?: Uint8Array | null
    industry?: string | null
    website?: string | null
    size?: number | null
    deleted?: boolean
    deletedAt?: Date | string | null
    notes?: NoteUncheckedCreateNestedManyWithoutContactInput
    timelineEvents?: ContactTimelineEventContactJoinUncheckedCreateNestedManyWithoutContactRelationInput
    addresses?: AddressUncheckedCreateNestedManyWithoutContactInput
    emails?: ContactEmailUncheckedCreateNestedManyWithoutContactInput
    phones?: ContactPhoneUncheckedCreateNestedManyWithoutContactInput
    importantDates?: ImportantDateUncheckedCreateNestedManyWithoutContactInput
    activities?: ActivityContactJoinUncheckedCreateNestedManyWithoutContactRelationInput
    headOfHouseholdFor?: ContactUncheckedCreateNestedOneWithoutHeadOfHouseholdInput
    primaryContactFor?: ContactUncheckedCreateNestedOneWithoutPrimaryContactInput
    householdMembers?: ContactUncheckedCreateNestedManyWithoutHouseholdInput
    employees?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    opportunities?: ContactOpportunityJoinUncheckedCreateNestedManyWithoutContactRelationInput
    relationAsSource?: ContactRelationshipUncheckedCreateNestedManyWithoutSourceInput
    relationAsTarget?: ContactRelationshipUncheckedCreateNestedManyWithoutTargetInput
  }

  export type ContactCreateOrConnectWithoutPrimaryContactInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutPrimaryContactInput, ContactUncheckedCreateWithoutPrimaryContactInput>
  }

  export type ContactCreateWithoutHeadOfHouseholdForInput = {
    id: Uint8Array
    firstName?: string | null
    lastName: string
    fullName: string
    importantNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.ContactType
    status: $Enums.ContactStatus
    lifecycleStage?: $Enums.LifecycleStage | null
    lastContactedDate?: Date | string | null
    followUpDate?: Date | string | null
    householdStatus?: $Enums.HouseholdRelationshipStatus | null
    position?: string | null
    companyStatus?: $Enums.CompanyRelationshipStatus | null
    industry?: string | null
    website?: string | null
    size?: number | null
    deleted?: boolean
    deletedAt?: Date | string | null
    tenet: TenetCreateNestedOneWithoutContactsInput
    notes?: NoteCreateNestedManyWithoutContactInput
    timelineEvents?: ContactTimelineEventContactJoinCreateNestedManyWithoutContactRelationInput
    addresses?: AddressCreateNestedManyWithoutContactInput
    emails?: ContactEmailCreateNestedManyWithoutContactInput
    phones?: ContactPhoneCreateNestedManyWithoutContactInput
    importantDates?: ImportantDateCreateNestedManyWithoutContactInput
    activities?: ActivityContactJoinCreateNestedManyWithoutContactRelationInput
    household?: ContactCreateNestedOneWithoutHouseholdMembersInput
    company?: ContactCreateNestedOneWithoutEmployeesInput
    primaryContactFor?: ContactCreateNestedOneWithoutPrimaryContactInput
    headOfHousehold?: ContactCreateNestedOneWithoutHeadOfHouseholdForInput
    householdMembers?: ContactCreateNestedManyWithoutHouseholdInput
    employees?: ContactCreateNestedManyWithoutCompanyInput
    primaryContact?: ContactCreateNestedOneWithoutPrimaryContactForInput
    opportunities?: ContactOpportunityJoinCreateNestedManyWithoutContactRelationInput
    relationAsSource?: ContactRelationshipCreateNestedManyWithoutSourceInput
    relationAsTarget?: ContactRelationshipCreateNestedManyWithoutTargetInput
  }

  export type ContactUncheckedCreateWithoutHeadOfHouseholdForInput = {
    id: Uint8Array
    firstName?: string | null
    lastName: string
    fullName: string
    tenetId: Uint8Array
    importantNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.ContactType
    status: $Enums.ContactStatus
    lifecycleStage?: $Enums.LifecycleStage | null
    lastContactedDate?: Date | string | null
    followUpDate?: Date | string | null
    householdId?: Uint8Array | null
    householdStatus?: $Enums.HouseholdRelationshipStatus | null
    companyId?: Uint8Array | null
    position?: string | null
    companyStatus?: $Enums.CompanyRelationshipStatus | null
    headOfHouseholdId?: Uint8Array | null
    industry?: string | null
    website?: string | null
    size?: number | null
    primaryContactId?: Uint8Array | null
    deleted?: boolean
    deletedAt?: Date | string | null
    notes?: NoteUncheckedCreateNestedManyWithoutContactInput
    timelineEvents?: ContactTimelineEventContactJoinUncheckedCreateNestedManyWithoutContactRelationInput
    addresses?: AddressUncheckedCreateNestedManyWithoutContactInput
    emails?: ContactEmailUncheckedCreateNestedManyWithoutContactInput
    phones?: ContactPhoneUncheckedCreateNestedManyWithoutContactInput
    importantDates?: ImportantDateUncheckedCreateNestedManyWithoutContactInput
    activities?: ActivityContactJoinUncheckedCreateNestedManyWithoutContactRelationInput
    primaryContactFor?: ContactUncheckedCreateNestedOneWithoutPrimaryContactInput
    householdMembers?: ContactUncheckedCreateNestedManyWithoutHouseholdInput
    employees?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    opportunities?: ContactOpportunityJoinUncheckedCreateNestedManyWithoutContactRelationInput
    relationAsSource?: ContactRelationshipUncheckedCreateNestedManyWithoutSourceInput
    relationAsTarget?: ContactRelationshipUncheckedCreateNestedManyWithoutTargetInput
  }

  export type ContactCreateOrConnectWithoutHeadOfHouseholdForInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutHeadOfHouseholdForInput, ContactUncheckedCreateWithoutHeadOfHouseholdForInput>
  }

  export type ContactCreateWithoutHouseholdInput = {
    id: Uint8Array
    firstName?: string | null
    lastName: string
    fullName: string
    importantNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.ContactType
    status: $Enums.ContactStatus
    lifecycleStage?: $Enums.LifecycleStage | null
    lastContactedDate?: Date | string | null
    followUpDate?: Date | string | null
    householdStatus?: $Enums.HouseholdRelationshipStatus | null
    position?: string | null
    companyStatus?: $Enums.CompanyRelationshipStatus | null
    industry?: string | null
    website?: string | null
    size?: number | null
    deleted?: boolean
    deletedAt?: Date | string | null
    tenet: TenetCreateNestedOneWithoutContactsInput
    notes?: NoteCreateNestedManyWithoutContactInput
    timelineEvents?: ContactTimelineEventContactJoinCreateNestedManyWithoutContactRelationInput
    addresses?: AddressCreateNestedManyWithoutContactInput
    emails?: ContactEmailCreateNestedManyWithoutContactInput
    phones?: ContactPhoneCreateNestedManyWithoutContactInput
    importantDates?: ImportantDateCreateNestedManyWithoutContactInput
    activities?: ActivityContactJoinCreateNestedManyWithoutContactRelationInput
    headOfHouseholdFor?: ContactCreateNestedOneWithoutHeadOfHouseholdInput
    company?: ContactCreateNestedOneWithoutEmployeesInput
    primaryContactFor?: ContactCreateNestedOneWithoutPrimaryContactInput
    headOfHousehold?: ContactCreateNestedOneWithoutHeadOfHouseholdForInput
    householdMembers?: ContactCreateNestedManyWithoutHouseholdInput
    employees?: ContactCreateNestedManyWithoutCompanyInput
    primaryContact?: ContactCreateNestedOneWithoutPrimaryContactForInput
    opportunities?: ContactOpportunityJoinCreateNestedManyWithoutContactRelationInput
    relationAsSource?: ContactRelationshipCreateNestedManyWithoutSourceInput
    relationAsTarget?: ContactRelationshipCreateNestedManyWithoutTargetInput
  }

  export type ContactUncheckedCreateWithoutHouseholdInput = {
    id: Uint8Array
    firstName?: string | null
    lastName: string
    fullName: string
    tenetId: Uint8Array
    importantNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.ContactType
    status: $Enums.ContactStatus
    lifecycleStage?: $Enums.LifecycleStage | null
    lastContactedDate?: Date | string | null
    followUpDate?: Date | string | null
    householdStatus?: $Enums.HouseholdRelationshipStatus | null
    companyId?: Uint8Array | null
    position?: string | null
    companyStatus?: $Enums.CompanyRelationshipStatus | null
    headOfHouseholdId?: Uint8Array | null
    industry?: string | null
    website?: string | null
    size?: number | null
    primaryContactId?: Uint8Array | null
    deleted?: boolean
    deletedAt?: Date | string | null
    notes?: NoteUncheckedCreateNestedManyWithoutContactInput
    timelineEvents?: ContactTimelineEventContactJoinUncheckedCreateNestedManyWithoutContactRelationInput
    addresses?: AddressUncheckedCreateNestedManyWithoutContactInput
    emails?: ContactEmailUncheckedCreateNestedManyWithoutContactInput
    phones?: ContactPhoneUncheckedCreateNestedManyWithoutContactInput
    importantDates?: ImportantDateUncheckedCreateNestedManyWithoutContactInput
    activities?: ActivityContactJoinUncheckedCreateNestedManyWithoutContactRelationInput
    headOfHouseholdFor?: ContactUncheckedCreateNestedOneWithoutHeadOfHouseholdInput
    primaryContactFor?: ContactUncheckedCreateNestedOneWithoutPrimaryContactInput
    householdMembers?: ContactUncheckedCreateNestedManyWithoutHouseholdInput
    employees?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    opportunities?: ContactOpportunityJoinUncheckedCreateNestedManyWithoutContactRelationInput
    relationAsSource?: ContactRelationshipUncheckedCreateNestedManyWithoutSourceInput
    relationAsTarget?: ContactRelationshipUncheckedCreateNestedManyWithoutTargetInput
  }

  export type ContactCreateOrConnectWithoutHouseholdInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutHouseholdInput, ContactUncheckedCreateWithoutHouseholdInput>
  }

  export type ContactCreateManyHouseholdInputEnvelope = {
    data: ContactCreateManyHouseholdInput | ContactCreateManyHouseholdInput[]
    skipDuplicates?: boolean
  }

  export type ContactCreateWithoutCompanyInput = {
    id: Uint8Array
    firstName?: string | null
    lastName: string
    fullName: string
    importantNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.ContactType
    status: $Enums.ContactStatus
    lifecycleStage?: $Enums.LifecycleStage | null
    lastContactedDate?: Date | string | null
    followUpDate?: Date | string | null
    householdStatus?: $Enums.HouseholdRelationshipStatus | null
    position?: string | null
    companyStatus?: $Enums.CompanyRelationshipStatus | null
    industry?: string | null
    website?: string | null
    size?: number | null
    deleted?: boolean
    deletedAt?: Date | string | null
    tenet: TenetCreateNestedOneWithoutContactsInput
    notes?: NoteCreateNestedManyWithoutContactInput
    timelineEvents?: ContactTimelineEventContactJoinCreateNestedManyWithoutContactRelationInput
    addresses?: AddressCreateNestedManyWithoutContactInput
    emails?: ContactEmailCreateNestedManyWithoutContactInput
    phones?: ContactPhoneCreateNestedManyWithoutContactInput
    importantDates?: ImportantDateCreateNestedManyWithoutContactInput
    activities?: ActivityContactJoinCreateNestedManyWithoutContactRelationInput
    household?: ContactCreateNestedOneWithoutHouseholdMembersInput
    headOfHouseholdFor?: ContactCreateNestedOneWithoutHeadOfHouseholdInput
    primaryContactFor?: ContactCreateNestedOneWithoutPrimaryContactInput
    headOfHousehold?: ContactCreateNestedOneWithoutHeadOfHouseholdForInput
    householdMembers?: ContactCreateNestedManyWithoutHouseholdInput
    employees?: ContactCreateNestedManyWithoutCompanyInput
    primaryContact?: ContactCreateNestedOneWithoutPrimaryContactForInput
    opportunities?: ContactOpportunityJoinCreateNestedManyWithoutContactRelationInput
    relationAsSource?: ContactRelationshipCreateNestedManyWithoutSourceInput
    relationAsTarget?: ContactRelationshipCreateNestedManyWithoutTargetInput
  }

  export type ContactUncheckedCreateWithoutCompanyInput = {
    id: Uint8Array
    firstName?: string | null
    lastName: string
    fullName: string
    tenetId: Uint8Array
    importantNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.ContactType
    status: $Enums.ContactStatus
    lifecycleStage?: $Enums.LifecycleStage | null
    lastContactedDate?: Date | string | null
    followUpDate?: Date | string | null
    householdId?: Uint8Array | null
    householdStatus?: $Enums.HouseholdRelationshipStatus | null
    position?: string | null
    companyStatus?: $Enums.CompanyRelationshipStatus | null
    headOfHouseholdId?: Uint8Array | null
    industry?: string | null
    website?: string | null
    size?: number | null
    primaryContactId?: Uint8Array | null
    deleted?: boolean
    deletedAt?: Date | string | null
    notes?: NoteUncheckedCreateNestedManyWithoutContactInput
    timelineEvents?: ContactTimelineEventContactJoinUncheckedCreateNestedManyWithoutContactRelationInput
    addresses?: AddressUncheckedCreateNestedManyWithoutContactInput
    emails?: ContactEmailUncheckedCreateNestedManyWithoutContactInput
    phones?: ContactPhoneUncheckedCreateNestedManyWithoutContactInput
    importantDates?: ImportantDateUncheckedCreateNestedManyWithoutContactInput
    activities?: ActivityContactJoinUncheckedCreateNestedManyWithoutContactRelationInput
    headOfHouseholdFor?: ContactUncheckedCreateNestedOneWithoutHeadOfHouseholdInput
    primaryContactFor?: ContactUncheckedCreateNestedOneWithoutPrimaryContactInput
    householdMembers?: ContactUncheckedCreateNestedManyWithoutHouseholdInput
    employees?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    opportunities?: ContactOpportunityJoinUncheckedCreateNestedManyWithoutContactRelationInput
    relationAsSource?: ContactRelationshipUncheckedCreateNestedManyWithoutSourceInput
    relationAsTarget?: ContactRelationshipUncheckedCreateNestedManyWithoutTargetInput
  }

  export type ContactCreateOrConnectWithoutCompanyInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutCompanyInput, ContactUncheckedCreateWithoutCompanyInput>
  }

  export type ContactCreateManyCompanyInputEnvelope = {
    data: ContactCreateManyCompanyInput | ContactCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type ContactCreateWithoutPrimaryContactForInput = {
    id: Uint8Array
    firstName?: string | null
    lastName: string
    fullName: string
    importantNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.ContactType
    status: $Enums.ContactStatus
    lifecycleStage?: $Enums.LifecycleStage | null
    lastContactedDate?: Date | string | null
    followUpDate?: Date | string | null
    householdStatus?: $Enums.HouseholdRelationshipStatus | null
    position?: string | null
    companyStatus?: $Enums.CompanyRelationshipStatus | null
    industry?: string | null
    website?: string | null
    size?: number | null
    deleted?: boolean
    deletedAt?: Date | string | null
    tenet: TenetCreateNestedOneWithoutContactsInput
    notes?: NoteCreateNestedManyWithoutContactInput
    timelineEvents?: ContactTimelineEventContactJoinCreateNestedManyWithoutContactRelationInput
    addresses?: AddressCreateNestedManyWithoutContactInput
    emails?: ContactEmailCreateNestedManyWithoutContactInput
    phones?: ContactPhoneCreateNestedManyWithoutContactInput
    importantDates?: ImportantDateCreateNestedManyWithoutContactInput
    activities?: ActivityContactJoinCreateNestedManyWithoutContactRelationInput
    household?: ContactCreateNestedOneWithoutHouseholdMembersInput
    headOfHouseholdFor?: ContactCreateNestedOneWithoutHeadOfHouseholdInput
    company?: ContactCreateNestedOneWithoutEmployeesInput
    headOfHousehold?: ContactCreateNestedOneWithoutHeadOfHouseholdForInput
    householdMembers?: ContactCreateNestedManyWithoutHouseholdInput
    employees?: ContactCreateNestedManyWithoutCompanyInput
    primaryContact?: ContactCreateNestedOneWithoutPrimaryContactForInput
    opportunities?: ContactOpportunityJoinCreateNestedManyWithoutContactRelationInput
    relationAsSource?: ContactRelationshipCreateNestedManyWithoutSourceInput
    relationAsTarget?: ContactRelationshipCreateNestedManyWithoutTargetInput
  }

  export type ContactUncheckedCreateWithoutPrimaryContactForInput = {
    id: Uint8Array
    firstName?: string | null
    lastName: string
    fullName: string
    tenetId: Uint8Array
    importantNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.ContactType
    status: $Enums.ContactStatus
    lifecycleStage?: $Enums.LifecycleStage | null
    lastContactedDate?: Date | string | null
    followUpDate?: Date | string | null
    householdId?: Uint8Array | null
    householdStatus?: $Enums.HouseholdRelationshipStatus | null
    companyId?: Uint8Array | null
    position?: string | null
    companyStatus?: $Enums.CompanyRelationshipStatus | null
    headOfHouseholdId?: Uint8Array | null
    industry?: string | null
    website?: string | null
    size?: number | null
    primaryContactId?: Uint8Array | null
    deleted?: boolean
    deletedAt?: Date | string | null
    notes?: NoteUncheckedCreateNestedManyWithoutContactInput
    timelineEvents?: ContactTimelineEventContactJoinUncheckedCreateNestedManyWithoutContactRelationInput
    addresses?: AddressUncheckedCreateNestedManyWithoutContactInput
    emails?: ContactEmailUncheckedCreateNestedManyWithoutContactInput
    phones?: ContactPhoneUncheckedCreateNestedManyWithoutContactInput
    importantDates?: ImportantDateUncheckedCreateNestedManyWithoutContactInput
    activities?: ActivityContactJoinUncheckedCreateNestedManyWithoutContactRelationInput
    headOfHouseholdFor?: ContactUncheckedCreateNestedOneWithoutHeadOfHouseholdInput
    householdMembers?: ContactUncheckedCreateNestedManyWithoutHouseholdInput
    employees?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    opportunities?: ContactOpportunityJoinUncheckedCreateNestedManyWithoutContactRelationInput
    relationAsSource?: ContactRelationshipUncheckedCreateNestedManyWithoutSourceInput
    relationAsTarget?: ContactRelationshipUncheckedCreateNestedManyWithoutTargetInput
  }

  export type ContactCreateOrConnectWithoutPrimaryContactForInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutPrimaryContactForInput, ContactUncheckedCreateWithoutPrimaryContactForInput>
  }

  export type ContactOpportunityJoinCreateWithoutContactRelationInput = {
    opportunityRelation: OpportunityCreateNestedOneWithoutContactsInput
  }

  export type ContactOpportunityJoinUncheckedCreateWithoutContactRelationInput = {
    opportunityId: Uint8Array
  }

  export type ContactOpportunityJoinCreateOrConnectWithoutContactRelationInput = {
    where: ContactOpportunityJoinWhereUniqueInput
    create: XOR<ContactOpportunityJoinCreateWithoutContactRelationInput, ContactOpportunityJoinUncheckedCreateWithoutContactRelationInput>
  }

  export type ContactOpportunityJoinCreateManyContactRelationInputEnvelope = {
    data: ContactOpportunityJoinCreateManyContactRelationInput | ContactOpportunityJoinCreateManyContactRelationInput[]
    skipDuplicates?: boolean
  }

  export type ContactRelationshipCreateWithoutSourceInput = {
    id: Uint8Array
    type: string
    established?: Date | string | null
    notes?: string | null
    target: ContactCreateNestedOneWithoutRelationAsTargetInput
  }

  export type ContactRelationshipUncheckedCreateWithoutSourceInput = {
    id: Uint8Array
    targetId: Uint8Array
    type: string
    established?: Date | string | null
    notes?: string | null
  }

  export type ContactRelationshipCreateOrConnectWithoutSourceInput = {
    where: ContactRelationshipWhereUniqueInput
    create: XOR<ContactRelationshipCreateWithoutSourceInput, ContactRelationshipUncheckedCreateWithoutSourceInput>
  }

  export type ContactRelationshipCreateManySourceInputEnvelope = {
    data: ContactRelationshipCreateManySourceInput | ContactRelationshipCreateManySourceInput[]
    skipDuplicates?: boolean
  }

  export type ContactRelationshipCreateWithoutTargetInput = {
    id: Uint8Array
    type: string
    established?: Date | string | null
    notes?: string | null
    source: ContactCreateNestedOneWithoutRelationAsSourceInput
  }

  export type ContactRelationshipUncheckedCreateWithoutTargetInput = {
    id: Uint8Array
    sourceId: Uint8Array
    type: string
    established?: Date | string | null
    notes?: string | null
  }

  export type ContactRelationshipCreateOrConnectWithoutTargetInput = {
    where: ContactRelationshipWhereUniqueInput
    create: XOR<ContactRelationshipCreateWithoutTargetInput, ContactRelationshipUncheckedCreateWithoutTargetInput>
  }

  export type ContactRelationshipCreateManyTargetInputEnvelope = {
    data: ContactRelationshipCreateManyTargetInput | ContactRelationshipCreateManyTargetInput[]
    skipDuplicates?: boolean
  }

  export type TenetUpsertWithoutContactsInput = {
    update: XOR<TenetUpdateWithoutContactsInput, TenetUncheckedUpdateWithoutContactsInput>
    create: XOR<TenetCreateWithoutContactsInput, TenetUncheckedCreateWithoutContactsInput>
    where?: TenetWhereInput
  }

  export type TenetUpdateToOneWithWhereWithoutContactsInput = {
    where?: TenetWhereInput
    data: XOR<TenetUpdateWithoutContactsInput, TenetUncheckedUpdateWithoutContactsInput>
  }

  export type TenetUpdateWithoutContactsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenetNestedInput
    logs?: LogUpdateManyWithoutTenetNestedInput
    activities?: ActivityUpdateManyWithoutTenetNestedInput
    addresses?: AddressUpdateManyWithoutTenetNestedInput
    contactEmails?: ContactEmailUpdateManyWithoutTenetNestedInput
    contactPhones?: ContactPhoneUpdateManyWithoutTenetNestedInput
    importantDates?: ImportantDateUpdateManyWithoutTenetNestedInput
    attachments?: AttachmentUpdateManyWithoutTenetNestedInput
    notes?: NoteUpdateManyWithoutTenetNestedInput
    auditEvents?: AuditEventUpdateManyWithoutTenetNestedInput
    contactTimelineEvents?: ContactTimelineEventUpdateManyWithoutTenetNestedInput
    activitySteps?: ActivityStepUpdateManyWithoutTenetNestedInput
    activityWaypoints?: ActivityWaypointUpdateManyWithoutTenetNestedInput
    templateAssignments?: TemplateAssignmentUpdateManyWithoutTenetNestedInput
    activityWaypointTemplates?: ActivityWaypointTemplateUpdateManyWithoutTenetNestedInput
    activityTemplates?: ActivityTemplateUpdateManyWithoutTenetNestedInput
    activityTemplateSteps?: ActivityTemplateStepUpdateManyWithoutTenetNestedInput
    opportunities?: OpportunityUpdateManyWithoutTenetNestedInput
    products?: ProductTypeUpdateManyWithoutTenetNestedInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentUpdateManyWithoutTenetNestedInput
  }

  export type TenetUncheckedUpdateWithoutContactsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenetNestedInput
    logs?: LogUncheckedUpdateManyWithoutTenetNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutTenetNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutTenetNestedInput
    contactEmails?: ContactEmailUncheckedUpdateManyWithoutTenetNestedInput
    contactPhones?: ContactPhoneUncheckedUpdateManyWithoutTenetNestedInput
    importantDates?: ImportantDateUncheckedUpdateManyWithoutTenetNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTenetNestedInput
    notes?: NoteUncheckedUpdateManyWithoutTenetNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutTenetNestedInput
    contactTimelineEvents?: ContactTimelineEventUncheckedUpdateManyWithoutTenetNestedInput
    activitySteps?: ActivityStepUncheckedUpdateManyWithoutTenetNestedInput
    activityWaypoints?: ActivityWaypointUncheckedUpdateManyWithoutTenetNestedInput
    templateAssignments?: TemplateAssignmentUncheckedUpdateManyWithoutTenetNestedInput
    activityWaypointTemplates?: ActivityWaypointTemplateUncheckedUpdateManyWithoutTenetNestedInput
    activityTemplates?: ActivityTemplateUncheckedUpdateManyWithoutTenetNestedInput
    activityTemplateSteps?: ActivityTemplateStepUncheckedUpdateManyWithoutTenetNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutTenetNestedInput
    products?: ProductTypeUncheckedUpdateManyWithoutTenetNestedInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentUncheckedUpdateManyWithoutTenetNestedInput
  }

  export type NoteUpsertWithWhereUniqueWithoutContactInput = {
    where: NoteWhereUniqueInput
    update: XOR<NoteUpdateWithoutContactInput, NoteUncheckedUpdateWithoutContactInput>
    create: XOR<NoteCreateWithoutContactInput, NoteUncheckedCreateWithoutContactInput>
  }

  export type NoteUpdateWithWhereUniqueWithoutContactInput = {
    where: NoteWhereUniqueInput
    data: XOR<NoteUpdateWithoutContactInput, NoteUncheckedUpdateWithoutContactInput>
  }

  export type NoteUpdateManyWithWhereWithoutContactInput = {
    where: NoteScalarWhereInput
    data: XOR<NoteUpdateManyMutationInput, NoteUncheckedUpdateManyWithoutContactInput>
  }

  export type ContactTimelineEventContactJoinUpsertWithWhereUniqueWithoutContactRelationInput = {
    where: ContactTimelineEventContactJoinWhereUniqueInput
    update: XOR<ContactTimelineEventContactJoinUpdateWithoutContactRelationInput, ContactTimelineEventContactJoinUncheckedUpdateWithoutContactRelationInput>
    create: XOR<ContactTimelineEventContactJoinCreateWithoutContactRelationInput, ContactTimelineEventContactJoinUncheckedCreateWithoutContactRelationInput>
  }

  export type ContactTimelineEventContactJoinUpdateWithWhereUniqueWithoutContactRelationInput = {
    where: ContactTimelineEventContactJoinWhereUniqueInput
    data: XOR<ContactTimelineEventContactJoinUpdateWithoutContactRelationInput, ContactTimelineEventContactJoinUncheckedUpdateWithoutContactRelationInput>
  }

  export type ContactTimelineEventContactJoinUpdateManyWithWhereWithoutContactRelationInput = {
    where: ContactTimelineEventContactJoinScalarWhereInput
    data: XOR<ContactTimelineEventContactJoinUpdateManyMutationInput, ContactTimelineEventContactJoinUncheckedUpdateManyWithoutContactRelationInput>
  }

  export type ContactTimelineEventContactJoinScalarWhereInput = {
    AND?: ContactTimelineEventContactJoinScalarWhereInput | ContactTimelineEventContactJoinScalarWhereInput[]
    OR?: ContactTimelineEventContactJoinScalarWhereInput[]
    NOT?: ContactTimelineEventContactJoinScalarWhereInput | ContactTimelineEventContactJoinScalarWhereInput[]
    contactEventId?: BytesFilter<"ContactTimelineEventContactJoin"> | Uint8Array
    contactId?: BytesFilter<"ContactTimelineEventContactJoin"> | Uint8Array
    type?: EnumContactTimelineEventJoinTypeFilter<"ContactTimelineEventContactJoin"> | $Enums.ContactTimelineEventJoinType
  }

  export type AddressUpsertWithWhereUniqueWithoutContactInput = {
    where: AddressWhereUniqueInput
    update: XOR<AddressUpdateWithoutContactInput, AddressUncheckedUpdateWithoutContactInput>
    create: XOR<AddressCreateWithoutContactInput, AddressUncheckedCreateWithoutContactInput>
  }

  export type AddressUpdateWithWhereUniqueWithoutContactInput = {
    where: AddressWhereUniqueInput
    data: XOR<AddressUpdateWithoutContactInput, AddressUncheckedUpdateWithoutContactInput>
  }

  export type AddressUpdateManyWithWhereWithoutContactInput = {
    where: AddressScalarWhereInput
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyWithoutContactInput>
  }

  export type ContactEmailUpsertWithWhereUniqueWithoutContactInput = {
    where: ContactEmailWhereUniqueInput
    update: XOR<ContactEmailUpdateWithoutContactInput, ContactEmailUncheckedUpdateWithoutContactInput>
    create: XOR<ContactEmailCreateWithoutContactInput, ContactEmailUncheckedCreateWithoutContactInput>
  }

  export type ContactEmailUpdateWithWhereUniqueWithoutContactInput = {
    where: ContactEmailWhereUniqueInput
    data: XOR<ContactEmailUpdateWithoutContactInput, ContactEmailUncheckedUpdateWithoutContactInput>
  }

  export type ContactEmailUpdateManyWithWhereWithoutContactInput = {
    where: ContactEmailScalarWhereInput
    data: XOR<ContactEmailUpdateManyMutationInput, ContactEmailUncheckedUpdateManyWithoutContactInput>
  }

  export type ContactPhoneUpsertWithWhereUniqueWithoutContactInput = {
    where: ContactPhoneWhereUniqueInput
    update: XOR<ContactPhoneUpdateWithoutContactInput, ContactPhoneUncheckedUpdateWithoutContactInput>
    create: XOR<ContactPhoneCreateWithoutContactInput, ContactPhoneUncheckedCreateWithoutContactInput>
  }

  export type ContactPhoneUpdateWithWhereUniqueWithoutContactInput = {
    where: ContactPhoneWhereUniqueInput
    data: XOR<ContactPhoneUpdateWithoutContactInput, ContactPhoneUncheckedUpdateWithoutContactInput>
  }

  export type ContactPhoneUpdateManyWithWhereWithoutContactInput = {
    where: ContactPhoneScalarWhereInput
    data: XOR<ContactPhoneUpdateManyMutationInput, ContactPhoneUncheckedUpdateManyWithoutContactInput>
  }

  export type ImportantDateUpsertWithWhereUniqueWithoutContactInput = {
    where: ImportantDateWhereUniqueInput
    update: XOR<ImportantDateUpdateWithoutContactInput, ImportantDateUncheckedUpdateWithoutContactInput>
    create: XOR<ImportantDateCreateWithoutContactInput, ImportantDateUncheckedCreateWithoutContactInput>
  }

  export type ImportantDateUpdateWithWhereUniqueWithoutContactInput = {
    where: ImportantDateWhereUniqueInput
    data: XOR<ImportantDateUpdateWithoutContactInput, ImportantDateUncheckedUpdateWithoutContactInput>
  }

  export type ImportantDateUpdateManyWithWhereWithoutContactInput = {
    where: ImportantDateScalarWhereInput
    data: XOR<ImportantDateUpdateManyMutationInput, ImportantDateUncheckedUpdateManyWithoutContactInput>
  }

  export type ActivityContactJoinUpsertWithWhereUniqueWithoutContactRelationInput = {
    where: ActivityContactJoinWhereUniqueInput
    update: XOR<ActivityContactJoinUpdateWithoutContactRelationInput, ActivityContactJoinUncheckedUpdateWithoutContactRelationInput>
    create: XOR<ActivityContactJoinCreateWithoutContactRelationInput, ActivityContactJoinUncheckedCreateWithoutContactRelationInput>
  }

  export type ActivityContactJoinUpdateWithWhereUniqueWithoutContactRelationInput = {
    where: ActivityContactJoinWhereUniqueInput
    data: XOR<ActivityContactJoinUpdateWithoutContactRelationInput, ActivityContactJoinUncheckedUpdateWithoutContactRelationInput>
  }

  export type ActivityContactJoinUpdateManyWithWhereWithoutContactRelationInput = {
    where: ActivityContactJoinScalarWhereInput
    data: XOR<ActivityContactJoinUpdateManyMutationInput, ActivityContactJoinUncheckedUpdateManyWithoutContactRelationInput>
  }

  export type ActivityContactJoinScalarWhereInput = {
    AND?: ActivityContactJoinScalarWhereInput | ActivityContactJoinScalarWhereInput[]
    OR?: ActivityContactJoinScalarWhereInput[]
    NOT?: ActivityContactJoinScalarWhereInput | ActivityContactJoinScalarWhereInput[]
    activityId?: BytesFilter<"ActivityContactJoin"> | Uint8Array
    contactId?: BytesFilter<"ActivityContactJoin"> | Uint8Array
  }

  export type ContactUpsertWithoutHouseholdMembersInput = {
    update: XOR<ContactUpdateWithoutHouseholdMembersInput, ContactUncheckedUpdateWithoutHouseholdMembersInput>
    create: XOR<ContactCreateWithoutHouseholdMembersInput, ContactUncheckedCreateWithoutHouseholdMembersInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutHouseholdMembersInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutHouseholdMembersInput, ContactUncheckedUpdateWithoutHouseholdMembersInput>
  }

  export type ContactUpdateWithoutHouseholdMembersInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    importantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    lifecycleStage?: NullableEnumLifecycleStageFieldUpdateOperationsInput | $Enums.LifecycleStage | null
    lastContactedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    householdStatus?: NullableEnumHouseholdRelationshipStatusFieldUpdateOperationsInput | $Enums.HouseholdRelationshipStatus | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyStatus?: NullableEnumCompanyRelationshipStatusFieldUpdateOperationsInput | $Enums.CompanyRelationshipStatus | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenet?: TenetUpdateOneRequiredWithoutContactsNestedInput
    notes?: NoteUpdateManyWithoutContactNestedInput
    timelineEvents?: ContactTimelineEventContactJoinUpdateManyWithoutContactRelationNestedInput
    addresses?: AddressUpdateManyWithoutContactNestedInput
    emails?: ContactEmailUpdateManyWithoutContactNestedInput
    phones?: ContactPhoneUpdateManyWithoutContactNestedInput
    importantDates?: ImportantDateUpdateManyWithoutContactNestedInput
    activities?: ActivityContactJoinUpdateManyWithoutContactRelationNestedInput
    household?: ContactUpdateOneWithoutHouseholdMembersNestedInput
    headOfHouseholdFor?: ContactUpdateOneWithoutHeadOfHouseholdNestedInput
    company?: ContactUpdateOneWithoutEmployeesNestedInput
    primaryContactFor?: ContactUpdateOneWithoutPrimaryContactNestedInput
    headOfHousehold?: ContactUpdateOneWithoutHeadOfHouseholdForNestedInput
    employees?: ContactUpdateManyWithoutCompanyNestedInput
    primaryContact?: ContactUpdateOneWithoutPrimaryContactForNestedInput
    opportunities?: ContactOpportunityJoinUpdateManyWithoutContactRelationNestedInput
    relationAsSource?: ContactRelationshipUpdateManyWithoutSourceNestedInput
    relationAsTarget?: ContactRelationshipUpdateManyWithoutTargetNestedInput
  }

  export type ContactUncheckedUpdateWithoutHouseholdMembersInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    importantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    lifecycleStage?: NullableEnumLifecycleStageFieldUpdateOperationsInput | $Enums.LifecycleStage | null
    lastContactedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    householdId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    householdStatus?: NullableEnumHouseholdRelationshipStatusFieldUpdateOperationsInput | $Enums.HouseholdRelationshipStatus | null
    companyId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyStatus?: NullableEnumCompanyRelationshipStatusFieldUpdateOperationsInput | $Enums.CompanyRelationshipStatus | null
    headOfHouseholdId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    primaryContactId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NoteUncheckedUpdateManyWithoutContactNestedInput
    timelineEvents?: ContactTimelineEventContactJoinUncheckedUpdateManyWithoutContactRelationNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutContactNestedInput
    emails?: ContactEmailUncheckedUpdateManyWithoutContactNestedInput
    phones?: ContactPhoneUncheckedUpdateManyWithoutContactNestedInput
    importantDates?: ImportantDateUncheckedUpdateManyWithoutContactNestedInput
    activities?: ActivityContactJoinUncheckedUpdateManyWithoutContactRelationNestedInput
    headOfHouseholdFor?: ContactUncheckedUpdateOneWithoutHeadOfHouseholdNestedInput
    primaryContactFor?: ContactUncheckedUpdateOneWithoutPrimaryContactNestedInput
    employees?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    opportunities?: ContactOpportunityJoinUncheckedUpdateManyWithoutContactRelationNestedInput
    relationAsSource?: ContactRelationshipUncheckedUpdateManyWithoutSourceNestedInput
    relationAsTarget?: ContactRelationshipUncheckedUpdateManyWithoutTargetNestedInput
  }

  export type ContactUpsertWithoutHeadOfHouseholdInput = {
    update: XOR<ContactUpdateWithoutHeadOfHouseholdInput, ContactUncheckedUpdateWithoutHeadOfHouseholdInput>
    create: XOR<ContactCreateWithoutHeadOfHouseholdInput, ContactUncheckedCreateWithoutHeadOfHouseholdInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutHeadOfHouseholdInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutHeadOfHouseholdInput, ContactUncheckedUpdateWithoutHeadOfHouseholdInput>
  }

  export type ContactUpdateWithoutHeadOfHouseholdInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    importantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    lifecycleStage?: NullableEnumLifecycleStageFieldUpdateOperationsInput | $Enums.LifecycleStage | null
    lastContactedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    householdStatus?: NullableEnumHouseholdRelationshipStatusFieldUpdateOperationsInput | $Enums.HouseholdRelationshipStatus | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyStatus?: NullableEnumCompanyRelationshipStatusFieldUpdateOperationsInput | $Enums.CompanyRelationshipStatus | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenet?: TenetUpdateOneRequiredWithoutContactsNestedInput
    notes?: NoteUpdateManyWithoutContactNestedInput
    timelineEvents?: ContactTimelineEventContactJoinUpdateManyWithoutContactRelationNestedInput
    addresses?: AddressUpdateManyWithoutContactNestedInput
    emails?: ContactEmailUpdateManyWithoutContactNestedInput
    phones?: ContactPhoneUpdateManyWithoutContactNestedInput
    importantDates?: ImportantDateUpdateManyWithoutContactNestedInput
    activities?: ActivityContactJoinUpdateManyWithoutContactRelationNestedInput
    household?: ContactUpdateOneWithoutHouseholdMembersNestedInput
    headOfHouseholdFor?: ContactUpdateOneWithoutHeadOfHouseholdNestedInput
    company?: ContactUpdateOneWithoutEmployeesNestedInput
    primaryContactFor?: ContactUpdateOneWithoutPrimaryContactNestedInput
    householdMembers?: ContactUpdateManyWithoutHouseholdNestedInput
    employees?: ContactUpdateManyWithoutCompanyNestedInput
    primaryContact?: ContactUpdateOneWithoutPrimaryContactForNestedInput
    opportunities?: ContactOpportunityJoinUpdateManyWithoutContactRelationNestedInput
    relationAsSource?: ContactRelationshipUpdateManyWithoutSourceNestedInput
    relationAsTarget?: ContactRelationshipUpdateManyWithoutTargetNestedInput
  }

  export type ContactUncheckedUpdateWithoutHeadOfHouseholdInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    importantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    lifecycleStage?: NullableEnumLifecycleStageFieldUpdateOperationsInput | $Enums.LifecycleStage | null
    lastContactedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    householdId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    householdStatus?: NullableEnumHouseholdRelationshipStatusFieldUpdateOperationsInput | $Enums.HouseholdRelationshipStatus | null
    companyId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyStatus?: NullableEnumCompanyRelationshipStatusFieldUpdateOperationsInput | $Enums.CompanyRelationshipStatus | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    primaryContactId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NoteUncheckedUpdateManyWithoutContactNestedInput
    timelineEvents?: ContactTimelineEventContactJoinUncheckedUpdateManyWithoutContactRelationNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutContactNestedInput
    emails?: ContactEmailUncheckedUpdateManyWithoutContactNestedInput
    phones?: ContactPhoneUncheckedUpdateManyWithoutContactNestedInput
    importantDates?: ImportantDateUncheckedUpdateManyWithoutContactNestedInput
    activities?: ActivityContactJoinUncheckedUpdateManyWithoutContactRelationNestedInput
    headOfHouseholdFor?: ContactUncheckedUpdateOneWithoutHeadOfHouseholdNestedInput
    primaryContactFor?: ContactUncheckedUpdateOneWithoutPrimaryContactNestedInput
    householdMembers?: ContactUncheckedUpdateManyWithoutHouseholdNestedInput
    employees?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    opportunities?: ContactOpportunityJoinUncheckedUpdateManyWithoutContactRelationNestedInput
    relationAsSource?: ContactRelationshipUncheckedUpdateManyWithoutSourceNestedInput
    relationAsTarget?: ContactRelationshipUncheckedUpdateManyWithoutTargetNestedInput
  }

  export type ContactUpsertWithoutEmployeesInput = {
    update: XOR<ContactUpdateWithoutEmployeesInput, ContactUncheckedUpdateWithoutEmployeesInput>
    create: XOR<ContactCreateWithoutEmployeesInput, ContactUncheckedCreateWithoutEmployeesInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutEmployeesInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutEmployeesInput, ContactUncheckedUpdateWithoutEmployeesInput>
  }

  export type ContactUpdateWithoutEmployeesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    importantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    lifecycleStage?: NullableEnumLifecycleStageFieldUpdateOperationsInput | $Enums.LifecycleStage | null
    lastContactedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    householdStatus?: NullableEnumHouseholdRelationshipStatusFieldUpdateOperationsInput | $Enums.HouseholdRelationshipStatus | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyStatus?: NullableEnumCompanyRelationshipStatusFieldUpdateOperationsInput | $Enums.CompanyRelationshipStatus | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenet?: TenetUpdateOneRequiredWithoutContactsNestedInput
    notes?: NoteUpdateManyWithoutContactNestedInput
    timelineEvents?: ContactTimelineEventContactJoinUpdateManyWithoutContactRelationNestedInput
    addresses?: AddressUpdateManyWithoutContactNestedInput
    emails?: ContactEmailUpdateManyWithoutContactNestedInput
    phones?: ContactPhoneUpdateManyWithoutContactNestedInput
    importantDates?: ImportantDateUpdateManyWithoutContactNestedInput
    activities?: ActivityContactJoinUpdateManyWithoutContactRelationNestedInput
    household?: ContactUpdateOneWithoutHouseholdMembersNestedInput
    headOfHouseholdFor?: ContactUpdateOneWithoutHeadOfHouseholdNestedInput
    company?: ContactUpdateOneWithoutEmployeesNestedInput
    primaryContactFor?: ContactUpdateOneWithoutPrimaryContactNestedInput
    headOfHousehold?: ContactUpdateOneWithoutHeadOfHouseholdForNestedInput
    householdMembers?: ContactUpdateManyWithoutHouseholdNestedInput
    primaryContact?: ContactUpdateOneWithoutPrimaryContactForNestedInput
    opportunities?: ContactOpportunityJoinUpdateManyWithoutContactRelationNestedInput
    relationAsSource?: ContactRelationshipUpdateManyWithoutSourceNestedInput
    relationAsTarget?: ContactRelationshipUpdateManyWithoutTargetNestedInput
  }

  export type ContactUncheckedUpdateWithoutEmployeesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    importantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    lifecycleStage?: NullableEnumLifecycleStageFieldUpdateOperationsInput | $Enums.LifecycleStage | null
    lastContactedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    householdId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    householdStatus?: NullableEnumHouseholdRelationshipStatusFieldUpdateOperationsInput | $Enums.HouseholdRelationshipStatus | null
    companyId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyStatus?: NullableEnumCompanyRelationshipStatusFieldUpdateOperationsInput | $Enums.CompanyRelationshipStatus | null
    headOfHouseholdId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    primaryContactId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NoteUncheckedUpdateManyWithoutContactNestedInput
    timelineEvents?: ContactTimelineEventContactJoinUncheckedUpdateManyWithoutContactRelationNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutContactNestedInput
    emails?: ContactEmailUncheckedUpdateManyWithoutContactNestedInput
    phones?: ContactPhoneUncheckedUpdateManyWithoutContactNestedInput
    importantDates?: ImportantDateUncheckedUpdateManyWithoutContactNestedInput
    activities?: ActivityContactJoinUncheckedUpdateManyWithoutContactRelationNestedInput
    headOfHouseholdFor?: ContactUncheckedUpdateOneWithoutHeadOfHouseholdNestedInput
    primaryContactFor?: ContactUncheckedUpdateOneWithoutPrimaryContactNestedInput
    householdMembers?: ContactUncheckedUpdateManyWithoutHouseholdNestedInput
    opportunities?: ContactOpportunityJoinUncheckedUpdateManyWithoutContactRelationNestedInput
    relationAsSource?: ContactRelationshipUncheckedUpdateManyWithoutSourceNestedInput
    relationAsTarget?: ContactRelationshipUncheckedUpdateManyWithoutTargetNestedInput
  }

  export type ContactUpsertWithoutPrimaryContactInput = {
    update: XOR<ContactUpdateWithoutPrimaryContactInput, ContactUncheckedUpdateWithoutPrimaryContactInput>
    create: XOR<ContactCreateWithoutPrimaryContactInput, ContactUncheckedCreateWithoutPrimaryContactInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutPrimaryContactInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutPrimaryContactInput, ContactUncheckedUpdateWithoutPrimaryContactInput>
  }

  export type ContactUpdateWithoutPrimaryContactInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    importantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    lifecycleStage?: NullableEnumLifecycleStageFieldUpdateOperationsInput | $Enums.LifecycleStage | null
    lastContactedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    householdStatus?: NullableEnumHouseholdRelationshipStatusFieldUpdateOperationsInput | $Enums.HouseholdRelationshipStatus | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyStatus?: NullableEnumCompanyRelationshipStatusFieldUpdateOperationsInput | $Enums.CompanyRelationshipStatus | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenet?: TenetUpdateOneRequiredWithoutContactsNestedInput
    notes?: NoteUpdateManyWithoutContactNestedInput
    timelineEvents?: ContactTimelineEventContactJoinUpdateManyWithoutContactRelationNestedInput
    addresses?: AddressUpdateManyWithoutContactNestedInput
    emails?: ContactEmailUpdateManyWithoutContactNestedInput
    phones?: ContactPhoneUpdateManyWithoutContactNestedInput
    importantDates?: ImportantDateUpdateManyWithoutContactNestedInput
    activities?: ActivityContactJoinUpdateManyWithoutContactRelationNestedInput
    household?: ContactUpdateOneWithoutHouseholdMembersNestedInput
    headOfHouseholdFor?: ContactUpdateOneWithoutHeadOfHouseholdNestedInput
    company?: ContactUpdateOneWithoutEmployeesNestedInput
    primaryContactFor?: ContactUpdateOneWithoutPrimaryContactNestedInput
    headOfHousehold?: ContactUpdateOneWithoutHeadOfHouseholdForNestedInput
    householdMembers?: ContactUpdateManyWithoutHouseholdNestedInput
    employees?: ContactUpdateManyWithoutCompanyNestedInput
    opportunities?: ContactOpportunityJoinUpdateManyWithoutContactRelationNestedInput
    relationAsSource?: ContactRelationshipUpdateManyWithoutSourceNestedInput
    relationAsTarget?: ContactRelationshipUpdateManyWithoutTargetNestedInput
  }

  export type ContactUncheckedUpdateWithoutPrimaryContactInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    importantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    lifecycleStage?: NullableEnumLifecycleStageFieldUpdateOperationsInput | $Enums.LifecycleStage | null
    lastContactedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    householdId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    householdStatus?: NullableEnumHouseholdRelationshipStatusFieldUpdateOperationsInput | $Enums.HouseholdRelationshipStatus | null
    companyId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyStatus?: NullableEnumCompanyRelationshipStatusFieldUpdateOperationsInput | $Enums.CompanyRelationshipStatus | null
    headOfHouseholdId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NoteUncheckedUpdateManyWithoutContactNestedInput
    timelineEvents?: ContactTimelineEventContactJoinUncheckedUpdateManyWithoutContactRelationNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutContactNestedInput
    emails?: ContactEmailUncheckedUpdateManyWithoutContactNestedInput
    phones?: ContactPhoneUncheckedUpdateManyWithoutContactNestedInput
    importantDates?: ImportantDateUncheckedUpdateManyWithoutContactNestedInput
    activities?: ActivityContactJoinUncheckedUpdateManyWithoutContactRelationNestedInput
    headOfHouseholdFor?: ContactUncheckedUpdateOneWithoutHeadOfHouseholdNestedInput
    primaryContactFor?: ContactUncheckedUpdateOneWithoutPrimaryContactNestedInput
    householdMembers?: ContactUncheckedUpdateManyWithoutHouseholdNestedInput
    employees?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    opportunities?: ContactOpportunityJoinUncheckedUpdateManyWithoutContactRelationNestedInput
    relationAsSource?: ContactRelationshipUncheckedUpdateManyWithoutSourceNestedInput
    relationAsTarget?: ContactRelationshipUncheckedUpdateManyWithoutTargetNestedInput
  }

  export type ContactUpsertWithoutHeadOfHouseholdForInput = {
    update: XOR<ContactUpdateWithoutHeadOfHouseholdForInput, ContactUncheckedUpdateWithoutHeadOfHouseholdForInput>
    create: XOR<ContactCreateWithoutHeadOfHouseholdForInput, ContactUncheckedCreateWithoutHeadOfHouseholdForInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutHeadOfHouseholdForInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutHeadOfHouseholdForInput, ContactUncheckedUpdateWithoutHeadOfHouseholdForInput>
  }

  export type ContactUpdateWithoutHeadOfHouseholdForInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    importantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    lifecycleStage?: NullableEnumLifecycleStageFieldUpdateOperationsInput | $Enums.LifecycleStage | null
    lastContactedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    householdStatus?: NullableEnumHouseholdRelationshipStatusFieldUpdateOperationsInput | $Enums.HouseholdRelationshipStatus | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyStatus?: NullableEnumCompanyRelationshipStatusFieldUpdateOperationsInput | $Enums.CompanyRelationshipStatus | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenet?: TenetUpdateOneRequiredWithoutContactsNestedInput
    notes?: NoteUpdateManyWithoutContactNestedInput
    timelineEvents?: ContactTimelineEventContactJoinUpdateManyWithoutContactRelationNestedInput
    addresses?: AddressUpdateManyWithoutContactNestedInput
    emails?: ContactEmailUpdateManyWithoutContactNestedInput
    phones?: ContactPhoneUpdateManyWithoutContactNestedInput
    importantDates?: ImportantDateUpdateManyWithoutContactNestedInput
    activities?: ActivityContactJoinUpdateManyWithoutContactRelationNestedInput
    household?: ContactUpdateOneWithoutHouseholdMembersNestedInput
    company?: ContactUpdateOneWithoutEmployeesNestedInput
    primaryContactFor?: ContactUpdateOneWithoutPrimaryContactNestedInput
    headOfHousehold?: ContactUpdateOneWithoutHeadOfHouseholdForNestedInput
    householdMembers?: ContactUpdateManyWithoutHouseholdNestedInput
    employees?: ContactUpdateManyWithoutCompanyNestedInput
    primaryContact?: ContactUpdateOneWithoutPrimaryContactForNestedInput
    opportunities?: ContactOpportunityJoinUpdateManyWithoutContactRelationNestedInput
    relationAsSource?: ContactRelationshipUpdateManyWithoutSourceNestedInput
    relationAsTarget?: ContactRelationshipUpdateManyWithoutTargetNestedInput
  }

  export type ContactUncheckedUpdateWithoutHeadOfHouseholdForInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    importantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    lifecycleStage?: NullableEnumLifecycleStageFieldUpdateOperationsInput | $Enums.LifecycleStage | null
    lastContactedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    householdId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    householdStatus?: NullableEnumHouseholdRelationshipStatusFieldUpdateOperationsInput | $Enums.HouseholdRelationshipStatus | null
    companyId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyStatus?: NullableEnumCompanyRelationshipStatusFieldUpdateOperationsInput | $Enums.CompanyRelationshipStatus | null
    headOfHouseholdId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    primaryContactId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NoteUncheckedUpdateManyWithoutContactNestedInput
    timelineEvents?: ContactTimelineEventContactJoinUncheckedUpdateManyWithoutContactRelationNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutContactNestedInput
    emails?: ContactEmailUncheckedUpdateManyWithoutContactNestedInput
    phones?: ContactPhoneUncheckedUpdateManyWithoutContactNestedInput
    importantDates?: ImportantDateUncheckedUpdateManyWithoutContactNestedInput
    activities?: ActivityContactJoinUncheckedUpdateManyWithoutContactRelationNestedInput
    primaryContactFor?: ContactUncheckedUpdateOneWithoutPrimaryContactNestedInput
    householdMembers?: ContactUncheckedUpdateManyWithoutHouseholdNestedInput
    employees?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    opportunities?: ContactOpportunityJoinUncheckedUpdateManyWithoutContactRelationNestedInput
    relationAsSource?: ContactRelationshipUncheckedUpdateManyWithoutSourceNestedInput
    relationAsTarget?: ContactRelationshipUncheckedUpdateManyWithoutTargetNestedInput
  }

  export type ContactUpsertWithWhereUniqueWithoutHouseholdInput = {
    where: ContactWhereUniqueInput
    update: XOR<ContactUpdateWithoutHouseholdInput, ContactUncheckedUpdateWithoutHouseholdInput>
    create: XOR<ContactCreateWithoutHouseholdInput, ContactUncheckedCreateWithoutHouseholdInput>
  }

  export type ContactUpdateWithWhereUniqueWithoutHouseholdInput = {
    where: ContactWhereUniqueInput
    data: XOR<ContactUpdateWithoutHouseholdInput, ContactUncheckedUpdateWithoutHouseholdInput>
  }

  export type ContactUpdateManyWithWhereWithoutHouseholdInput = {
    where: ContactScalarWhereInput
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyWithoutHouseholdInput>
  }

  export type ContactUpsertWithWhereUniqueWithoutCompanyInput = {
    where: ContactWhereUniqueInput
    update: XOR<ContactUpdateWithoutCompanyInput, ContactUncheckedUpdateWithoutCompanyInput>
    create: XOR<ContactCreateWithoutCompanyInput, ContactUncheckedCreateWithoutCompanyInput>
  }

  export type ContactUpdateWithWhereUniqueWithoutCompanyInput = {
    where: ContactWhereUniqueInput
    data: XOR<ContactUpdateWithoutCompanyInput, ContactUncheckedUpdateWithoutCompanyInput>
  }

  export type ContactUpdateManyWithWhereWithoutCompanyInput = {
    where: ContactScalarWhereInput
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyWithoutCompanyInput>
  }

  export type ContactUpsertWithoutPrimaryContactForInput = {
    update: XOR<ContactUpdateWithoutPrimaryContactForInput, ContactUncheckedUpdateWithoutPrimaryContactForInput>
    create: XOR<ContactCreateWithoutPrimaryContactForInput, ContactUncheckedCreateWithoutPrimaryContactForInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutPrimaryContactForInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutPrimaryContactForInput, ContactUncheckedUpdateWithoutPrimaryContactForInput>
  }

  export type ContactUpdateWithoutPrimaryContactForInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    importantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    lifecycleStage?: NullableEnumLifecycleStageFieldUpdateOperationsInput | $Enums.LifecycleStage | null
    lastContactedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    householdStatus?: NullableEnumHouseholdRelationshipStatusFieldUpdateOperationsInput | $Enums.HouseholdRelationshipStatus | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyStatus?: NullableEnumCompanyRelationshipStatusFieldUpdateOperationsInput | $Enums.CompanyRelationshipStatus | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenet?: TenetUpdateOneRequiredWithoutContactsNestedInput
    notes?: NoteUpdateManyWithoutContactNestedInput
    timelineEvents?: ContactTimelineEventContactJoinUpdateManyWithoutContactRelationNestedInput
    addresses?: AddressUpdateManyWithoutContactNestedInput
    emails?: ContactEmailUpdateManyWithoutContactNestedInput
    phones?: ContactPhoneUpdateManyWithoutContactNestedInput
    importantDates?: ImportantDateUpdateManyWithoutContactNestedInput
    activities?: ActivityContactJoinUpdateManyWithoutContactRelationNestedInput
    household?: ContactUpdateOneWithoutHouseholdMembersNestedInput
    headOfHouseholdFor?: ContactUpdateOneWithoutHeadOfHouseholdNestedInput
    company?: ContactUpdateOneWithoutEmployeesNestedInput
    headOfHousehold?: ContactUpdateOneWithoutHeadOfHouseholdForNestedInput
    householdMembers?: ContactUpdateManyWithoutHouseholdNestedInput
    employees?: ContactUpdateManyWithoutCompanyNestedInput
    primaryContact?: ContactUpdateOneWithoutPrimaryContactForNestedInput
    opportunities?: ContactOpportunityJoinUpdateManyWithoutContactRelationNestedInput
    relationAsSource?: ContactRelationshipUpdateManyWithoutSourceNestedInput
    relationAsTarget?: ContactRelationshipUpdateManyWithoutTargetNestedInput
  }

  export type ContactUncheckedUpdateWithoutPrimaryContactForInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    importantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    lifecycleStage?: NullableEnumLifecycleStageFieldUpdateOperationsInput | $Enums.LifecycleStage | null
    lastContactedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    householdId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    householdStatus?: NullableEnumHouseholdRelationshipStatusFieldUpdateOperationsInput | $Enums.HouseholdRelationshipStatus | null
    companyId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyStatus?: NullableEnumCompanyRelationshipStatusFieldUpdateOperationsInput | $Enums.CompanyRelationshipStatus | null
    headOfHouseholdId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    primaryContactId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NoteUncheckedUpdateManyWithoutContactNestedInput
    timelineEvents?: ContactTimelineEventContactJoinUncheckedUpdateManyWithoutContactRelationNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutContactNestedInput
    emails?: ContactEmailUncheckedUpdateManyWithoutContactNestedInput
    phones?: ContactPhoneUncheckedUpdateManyWithoutContactNestedInput
    importantDates?: ImportantDateUncheckedUpdateManyWithoutContactNestedInput
    activities?: ActivityContactJoinUncheckedUpdateManyWithoutContactRelationNestedInput
    headOfHouseholdFor?: ContactUncheckedUpdateOneWithoutHeadOfHouseholdNestedInput
    householdMembers?: ContactUncheckedUpdateManyWithoutHouseholdNestedInput
    employees?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    opportunities?: ContactOpportunityJoinUncheckedUpdateManyWithoutContactRelationNestedInput
    relationAsSource?: ContactRelationshipUncheckedUpdateManyWithoutSourceNestedInput
    relationAsTarget?: ContactRelationshipUncheckedUpdateManyWithoutTargetNestedInput
  }

  export type ContactOpportunityJoinUpsertWithWhereUniqueWithoutContactRelationInput = {
    where: ContactOpportunityJoinWhereUniqueInput
    update: XOR<ContactOpportunityJoinUpdateWithoutContactRelationInput, ContactOpportunityJoinUncheckedUpdateWithoutContactRelationInput>
    create: XOR<ContactOpportunityJoinCreateWithoutContactRelationInput, ContactOpportunityJoinUncheckedCreateWithoutContactRelationInput>
  }

  export type ContactOpportunityJoinUpdateWithWhereUniqueWithoutContactRelationInput = {
    where: ContactOpportunityJoinWhereUniqueInput
    data: XOR<ContactOpportunityJoinUpdateWithoutContactRelationInput, ContactOpportunityJoinUncheckedUpdateWithoutContactRelationInput>
  }

  export type ContactOpportunityJoinUpdateManyWithWhereWithoutContactRelationInput = {
    where: ContactOpportunityJoinScalarWhereInput
    data: XOR<ContactOpportunityJoinUpdateManyMutationInput, ContactOpportunityJoinUncheckedUpdateManyWithoutContactRelationInput>
  }

  export type ContactOpportunityJoinScalarWhereInput = {
    AND?: ContactOpportunityJoinScalarWhereInput | ContactOpportunityJoinScalarWhereInput[]
    OR?: ContactOpportunityJoinScalarWhereInput[]
    NOT?: ContactOpportunityJoinScalarWhereInput | ContactOpportunityJoinScalarWhereInput[]
    contactId?: BytesFilter<"ContactOpportunityJoin"> | Uint8Array
    opportunityId?: BytesFilter<"ContactOpportunityJoin"> | Uint8Array
  }

  export type ContactRelationshipUpsertWithWhereUniqueWithoutSourceInput = {
    where: ContactRelationshipWhereUniqueInput
    update: XOR<ContactRelationshipUpdateWithoutSourceInput, ContactRelationshipUncheckedUpdateWithoutSourceInput>
    create: XOR<ContactRelationshipCreateWithoutSourceInput, ContactRelationshipUncheckedCreateWithoutSourceInput>
  }

  export type ContactRelationshipUpdateWithWhereUniqueWithoutSourceInput = {
    where: ContactRelationshipWhereUniqueInput
    data: XOR<ContactRelationshipUpdateWithoutSourceInput, ContactRelationshipUncheckedUpdateWithoutSourceInput>
  }

  export type ContactRelationshipUpdateManyWithWhereWithoutSourceInput = {
    where: ContactRelationshipScalarWhereInput
    data: XOR<ContactRelationshipUpdateManyMutationInput, ContactRelationshipUncheckedUpdateManyWithoutSourceInput>
  }

  export type ContactRelationshipScalarWhereInput = {
    AND?: ContactRelationshipScalarWhereInput | ContactRelationshipScalarWhereInput[]
    OR?: ContactRelationshipScalarWhereInput[]
    NOT?: ContactRelationshipScalarWhereInput | ContactRelationshipScalarWhereInput[]
    id?: BytesFilter<"ContactRelationship"> | Uint8Array
    sourceId?: BytesFilter<"ContactRelationship"> | Uint8Array
    targetId?: BytesFilter<"ContactRelationship"> | Uint8Array
    type?: StringFilter<"ContactRelationship"> | string
    established?: DateTimeNullableFilter<"ContactRelationship"> | Date | string | null
    notes?: StringNullableFilter<"ContactRelationship"> | string | null
  }

  export type ContactRelationshipUpsertWithWhereUniqueWithoutTargetInput = {
    where: ContactRelationshipWhereUniqueInput
    update: XOR<ContactRelationshipUpdateWithoutTargetInput, ContactRelationshipUncheckedUpdateWithoutTargetInput>
    create: XOR<ContactRelationshipCreateWithoutTargetInput, ContactRelationshipUncheckedCreateWithoutTargetInput>
  }

  export type ContactRelationshipUpdateWithWhereUniqueWithoutTargetInput = {
    where: ContactRelationshipWhereUniqueInput
    data: XOR<ContactRelationshipUpdateWithoutTargetInput, ContactRelationshipUncheckedUpdateWithoutTargetInput>
  }

  export type ContactRelationshipUpdateManyWithWhereWithoutTargetInput = {
    where: ContactRelationshipScalarWhereInput
    data: XOR<ContactRelationshipUpdateManyMutationInput, ContactRelationshipUncheckedUpdateManyWithoutTargetInput>
  }

  export type ContactCreateWithoutRelationAsSourceInput = {
    id: Uint8Array
    firstName?: string | null
    lastName: string
    fullName: string
    importantNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.ContactType
    status: $Enums.ContactStatus
    lifecycleStage?: $Enums.LifecycleStage | null
    lastContactedDate?: Date | string | null
    followUpDate?: Date | string | null
    householdStatus?: $Enums.HouseholdRelationshipStatus | null
    position?: string | null
    companyStatus?: $Enums.CompanyRelationshipStatus | null
    industry?: string | null
    website?: string | null
    size?: number | null
    deleted?: boolean
    deletedAt?: Date | string | null
    tenet: TenetCreateNestedOneWithoutContactsInput
    notes?: NoteCreateNestedManyWithoutContactInput
    timelineEvents?: ContactTimelineEventContactJoinCreateNestedManyWithoutContactRelationInput
    addresses?: AddressCreateNestedManyWithoutContactInput
    emails?: ContactEmailCreateNestedManyWithoutContactInput
    phones?: ContactPhoneCreateNestedManyWithoutContactInput
    importantDates?: ImportantDateCreateNestedManyWithoutContactInput
    activities?: ActivityContactJoinCreateNestedManyWithoutContactRelationInput
    household?: ContactCreateNestedOneWithoutHouseholdMembersInput
    headOfHouseholdFor?: ContactCreateNestedOneWithoutHeadOfHouseholdInput
    company?: ContactCreateNestedOneWithoutEmployeesInput
    primaryContactFor?: ContactCreateNestedOneWithoutPrimaryContactInput
    headOfHousehold?: ContactCreateNestedOneWithoutHeadOfHouseholdForInput
    householdMembers?: ContactCreateNestedManyWithoutHouseholdInput
    employees?: ContactCreateNestedManyWithoutCompanyInput
    primaryContact?: ContactCreateNestedOneWithoutPrimaryContactForInput
    opportunities?: ContactOpportunityJoinCreateNestedManyWithoutContactRelationInput
    relationAsTarget?: ContactRelationshipCreateNestedManyWithoutTargetInput
  }

  export type ContactUncheckedCreateWithoutRelationAsSourceInput = {
    id: Uint8Array
    firstName?: string | null
    lastName: string
    fullName: string
    tenetId: Uint8Array
    importantNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.ContactType
    status: $Enums.ContactStatus
    lifecycleStage?: $Enums.LifecycleStage | null
    lastContactedDate?: Date | string | null
    followUpDate?: Date | string | null
    householdId?: Uint8Array | null
    householdStatus?: $Enums.HouseholdRelationshipStatus | null
    companyId?: Uint8Array | null
    position?: string | null
    companyStatus?: $Enums.CompanyRelationshipStatus | null
    headOfHouseholdId?: Uint8Array | null
    industry?: string | null
    website?: string | null
    size?: number | null
    primaryContactId?: Uint8Array | null
    deleted?: boolean
    deletedAt?: Date | string | null
    notes?: NoteUncheckedCreateNestedManyWithoutContactInput
    timelineEvents?: ContactTimelineEventContactJoinUncheckedCreateNestedManyWithoutContactRelationInput
    addresses?: AddressUncheckedCreateNestedManyWithoutContactInput
    emails?: ContactEmailUncheckedCreateNestedManyWithoutContactInput
    phones?: ContactPhoneUncheckedCreateNestedManyWithoutContactInput
    importantDates?: ImportantDateUncheckedCreateNestedManyWithoutContactInput
    activities?: ActivityContactJoinUncheckedCreateNestedManyWithoutContactRelationInput
    headOfHouseholdFor?: ContactUncheckedCreateNestedOneWithoutHeadOfHouseholdInput
    primaryContactFor?: ContactUncheckedCreateNestedOneWithoutPrimaryContactInput
    householdMembers?: ContactUncheckedCreateNestedManyWithoutHouseholdInput
    employees?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    opportunities?: ContactOpportunityJoinUncheckedCreateNestedManyWithoutContactRelationInput
    relationAsTarget?: ContactRelationshipUncheckedCreateNestedManyWithoutTargetInput
  }

  export type ContactCreateOrConnectWithoutRelationAsSourceInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutRelationAsSourceInput, ContactUncheckedCreateWithoutRelationAsSourceInput>
  }

  export type ContactCreateWithoutRelationAsTargetInput = {
    id: Uint8Array
    firstName?: string | null
    lastName: string
    fullName: string
    importantNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.ContactType
    status: $Enums.ContactStatus
    lifecycleStage?: $Enums.LifecycleStage | null
    lastContactedDate?: Date | string | null
    followUpDate?: Date | string | null
    householdStatus?: $Enums.HouseholdRelationshipStatus | null
    position?: string | null
    companyStatus?: $Enums.CompanyRelationshipStatus | null
    industry?: string | null
    website?: string | null
    size?: number | null
    deleted?: boolean
    deletedAt?: Date | string | null
    tenet: TenetCreateNestedOneWithoutContactsInput
    notes?: NoteCreateNestedManyWithoutContactInput
    timelineEvents?: ContactTimelineEventContactJoinCreateNestedManyWithoutContactRelationInput
    addresses?: AddressCreateNestedManyWithoutContactInput
    emails?: ContactEmailCreateNestedManyWithoutContactInput
    phones?: ContactPhoneCreateNestedManyWithoutContactInput
    importantDates?: ImportantDateCreateNestedManyWithoutContactInput
    activities?: ActivityContactJoinCreateNestedManyWithoutContactRelationInput
    household?: ContactCreateNestedOneWithoutHouseholdMembersInput
    headOfHouseholdFor?: ContactCreateNestedOneWithoutHeadOfHouseholdInput
    company?: ContactCreateNestedOneWithoutEmployeesInput
    primaryContactFor?: ContactCreateNestedOneWithoutPrimaryContactInput
    headOfHousehold?: ContactCreateNestedOneWithoutHeadOfHouseholdForInput
    householdMembers?: ContactCreateNestedManyWithoutHouseholdInput
    employees?: ContactCreateNestedManyWithoutCompanyInput
    primaryContact?: ContactCreateNestedOneWithoutPrimaryContactForInput
    opportunities?: ContactOpportunityJoinCreateNestedManyWithoutContactRelationInput
    relationAsSource?: ContactRelationshipCreateNestedManyWithoutSourceInput
  }

  export type ContactUncheckedCreateWithoutRelationAsTargetInput = {
    id: Uint8Array
    firstName?: string | null
    lastName: string
    fullName: string
    tenetId: Uint8Array
    importantNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.ContactType
    status: $Enums.ContactStatus
    lifecycleStage?: $Enums.LifecycleStage | null
    lastContactedDate?: Date | string | null
    followUpDate?: Date | string | null
    householdId?: Uint8Array | null
    householdStatus?: $Enums.HouseholdRelationshipStatus | null
    companyId?: Uint8Array | null
    position?: string | null
    companyStatus?: $Enums.CompanyRelationshipStatus | null
    headOfHouseholdId?: Uint8Array | null
    industry?: string | null
    website?: string | null
    size?: number | null
    primaryContactId?: Uint8Array | null
    deleted?: boolean
    deletedAt?: Date | string | null
    notes?: NoteUncheckedCreateNestedManyWithoutContactInput
    timelineEvents?: ContactTimelineEventContactJoinUncheckedCreateNestedManyWithoutContactRelationInput
    addresses?: AddressUncheckedCreateNestedManyWithoutContactInput
    emails?: ContactEmailUncheckedCreateNestedManyWithoutContactInput
    phones?: ContactPhoneUncheckedCreateNestedManyWithoutContactInput
    importantDates?: ImportantDateUncheckedCreateNestedManyWithoutContactInput
    activities?: ActivityContactJoinUncheckedCreateNestedManyWithoutContactRelationInput
    headOfHouseholdFor?: ContactUncheckedCreateNestedOneWithoutHeadOfHouseholdInput
    primaryContactFor?: ContactUncheckedCreateNestedOneWithoutPrimaryContactInput
    householdMembers?: ContactUncheckedCreateNestedManyWithoutHouseholdInput
    employees?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    opportunities?: ContactOpportunityJoinUncheckedCreateNestedManyWithoutContactRelationInput
    relationAsSource?: ContactRelationshipUncheckedCreateNestedManyWithoutSourceInput
  }

  export type ContactCreateOrConnectWithoutRelationAsTargetInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutRelationAsTargetInput, ContactUncheckedCreateWithoutRelationAsTargetInput>
  }

  export type ContactUpsertWithoutRelationAsSourceInput = {
    update: XOR<ContactUpdateWithoutRelationAsSourceInput, ContactUncheckedUpdateWithoutRelationAsSourceInput>
    create: XOR<ContactCreateWithoutRelationAsSourceInput, ContactUncheckedCreateWithoutRelationAsSourceInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutRelationAsSourceInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutRelationAsSourceInput, ContactUncheckedUpdateWithoutRelationAsSourceInput>
  }

  export type ContactUpdateWithoutRelationAsSourceInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    importantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    lifecycleStage?: NullableEnumLifecycleStageFieldUpdateOperationsInput | $Enums.LifecycleStage | null
    lastContactedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    householdStatus?: NullableEnumHouseholdRelationshipStatusFieldUpdateOperationsInput | $Enums.HouseholdRelationshipStatus | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyStatus?: NullableEnumCompanyRelationshipStatusFieldUpdateOperationsInput | $Enums.CompanyRelationshipStatus | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenet?: TenetUpdateOneRequiredWithoutContactsNestedInput
    notes?: NoteUpdateManyWithoutContactNestedInput
    timelineEvents?: ContactTimelineEventContactJoinUpdateManyWithoutContactRelationNestedInput
    addresses?: AddressUpdateManyWithoutContactNestedInput
    emails?: ContactEmailUpdateManyWithoutContactNestedInput
    phones?: ContactPhoneUpdateManyWithoutContactNestedInput
    importantDates?: ImportantDateUpdateManyWithoutContactNestedInput
    activities?: ActivityContactJoinUpdateManyWithoutContactRelationNestedInput
    household?: ContactUpdateOneWithoutHouseholdMembersNestedInput
    headOfHouseholdFor?: ContactUpdateOneWithoutHeadOfHouseholdNestedInput
    company?: ContactUpdateOneWithoutEmployeesNestedInput
    primaryContactFor?: ContactUpdateOneWithoutPrimaryContactNestedInput
    headOfHousehold?: ContactUpdateOneWithoutHeadOfHouseholdForNestedInput
    householdMembers?: ContactUpdateManyWithoutHouseholdNestedInput
    employees?: ContactUpdateManyWithoutCompanyNestedInput
    primaryContact?: ContactUpdateOneWithoutPrimaryContactForNestedInput
    opportunities?: ContactOpportunityJoinUpdateManyWithoutContactRelationNestedInput
    relationAsTarget?: ContactRelationshipUpdateManyWithoutTargetNestedInput
  }

  export type ContactUncheckedUpdateWithoutRelationAsSourceInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    importantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    lifecycleStage?: NullableEnumLifecycleStageFieldUpdateOperationsInput | $Enums.LifecycleStage | null
    lastContactedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    householdId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    householdStatus?: NullableEnumHouseholdRelationshipStatusFieldUpdateOperationsInput | $Enums.HouseholdRelationshipStatus | null
    companyId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyStatus?: NullableEnumCompanyRelationshipStatusFieldUpdateOperationsInput | $Enums.CompanyRelationshipStatus | null
    headOfHouseholdId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    primaryContactId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NoteUncheckedUpdateManyWithoutContactNestedInput
    timelineEvents?: ContactTimelineEventContactJoinUncheckedUpdateManyWithoutContactRelationNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutContactNestedInput
    emails?: ContactEmailUncheckedUpdateManyWithoutContactNestedInput
    phones?: ContactPhoneUncheckedUpdateManyWithoutContactNestedInput
    importantDates?: ImportantDateUncheckedUpdateManyWithoutContactNestedInput
    activities?: ActivityContactJoinUncheckedUpdateManyWithoutContactRelationNestedInput
    headOfHouseholdFor?: ContactUncheckedUpdateOneWithoutHeadOfHouseholdNestedInput
    primaryContactFor?: ContactUncheckedUpdateOneWithoutPrimaryContactNestedInput
    householdMembers?: ContactUncheckedUpdateManyWithoutHouseholdNestedInput
    employees?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    opportunities?: ContactOpportunityJoinUncheckedUpdateManyWithoutContactRelationNestedInput
    relationAsTarget?: ContactRelationshipUncheckedUpdateManyWithoutTargetNestedInput
  }

  export type ContactUpsertWithoutRelationAsTargetInput = {
    update: XOR<ContactUpdateWithoutRelationAsTargetInput, ContactUncheckedUpdateWithoutRelationAsTargetInput>
    create: XOR<ContactCreateWithoutRelationAsTargetInput, ContactUncheckedCreateWithoutRelationAsTargetInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutRelationAsTargetInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutRelationAsTargetInput, ContactUncheckedUpdateWithoutRelationAsTargetInput>
  }

  export type ContactUpdateWithoutRelationAsTargetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    importantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    lifecycleStage?: NullableEnumLifecycleStageFieldUpdateOperationsInput | $Enums.LifecycleStage | null
    lastContactedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    householdStatus?: NullableEnumHouseholdRelationshipStatusFieldUpdateOperationsInput | $Enums.HouseholdRelationshipStatus | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyStatus?: NullableEnumCompanyRelationshipStatusFieldUpdateOperationsInput | $Enums.CompanyRelationshipStatus | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenet?: TenetUpdateOneRequiredWithoutContactsNestedInput
    notes?: NoteUpdateManyWithoutContactNestedInput
    timelineEvents?: ContactTimelineEventContactJoinUpdateManyWithoutContactRelationNestedInput
    addresses?: AddressUpdateManyWithoutContactNestedInput
    emails?: ContactEmailUpdateManyWithoutContactNestedInput
    phones?: ContactPhoneUpdateManyWithoutContactNestedInput
    importantDates?: ImportantDateUpdateManyWithoutContactNestedInput
    activities?: ActivityContactJoinUpdateManyWithoutContactRelationNestedInput
    household?: ContactUpdateOneWithoutHouseholdMembersNestedInput
    headOfHouseholdFor?: ContactUpdateOneWithoutHeadOfHouseholdNestedInput
    company?: ContactUpdateOneWithoutEmployeesNestedInput
    primaryContactFor?: ContactUpdateOneWithoutPrimaryContactNestedInput
    headOfHousehold?: ContactUpdateOneWithoutHeadOfHouseholdForNestedInput
    householdMembers?: ContactUpdateManyWithoutHouseholdNestedInput
    employees?: ContactUpdateManyWithoutCompanyNestedInput
    primaryContact?: ContactUpdateOneWithoutPrimaryContactForNestedInput
    opportunities?: ContactOpportunityJoinUpdateManyWithoutContactRelationNestedInput
    relationAsSource?: ContactRelationshipUpdateManyWithoutSourceNestedInput
  }

  export type ContactUncheckedUpdateWithoutRelationAsTargetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    importantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    lifecycleStage?: NullableEnumLifecycleStageFieldUpdateOperationsInput | $Enums.LifecycleStage | null
    lastContactedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    householdId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    householdStatus?: NullableEnumHouseholdRelationshipStatusFieldUpdateOperationsInput | $Enums.HouseholdRelationshipStatus | null
    companyId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyStatus?: NullableEnumCompanyRelationshipStatusFieldUpdateOperationsInput | $Enums.CompanyRelationshipStatus | null
    headOfHouseholdId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    primaryContactId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NoteUncheckedUpdateManyWithoutContactNestedInput
    timelineEvents?: ContactTimelineEventContactJoinUncheckedUpdateManyWithoutContactRelationNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutContactNestedInput
    emails?: ContactEmailUncheckedUpdateManyWithoutContactNestedInput
    phones?: ContactPhoneUncheckedUpdateManyWithoutContactNestedInput
    importantDates?: ImportantDateUncheckedUpdateManyWithoutContactNestedInput
    activities?: ActivityContactJoinUncheckedUpdateManyWithoutContactRelationNestedInput
    headOfHouseholdFor?: ContactUncheckedUpdateOneWithoutHeadOfHouseholdNestedInput
    primaryContactFor?: ContactUncheckedUpdateOneWithoutPrimaryContactNestedInput
    householdMembers?: ContactUncheckedUpdateManyWithoutHouseholdNestedInput
    employees?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    opportunities?: ContactOpportunityJoinUncheckedUpdateManyWithoutContactRelationNestedInput
    relationAsSource?: ContactRelationshipUncheckedUpdateManyWithoutSourceNestedInput
  }

  export type ActivityCreateWithoutStepsInput = {
    id: Uint8Array
    title: string
    type: $Enums.ActivityType
    taskScheduleType?: $Enums.TaskScheduleType | null
    startDate: Date | string
    endDate: Date | string
    completedAt?: Date | string | null
    description?: string | null
    priority?: $Enums.ActivityPriority
    status: $Enums.ActivityStatus
    phoneNumber?: string | null
    location?: string | null
    holdReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean
    deletedAt?: Date | string | null
    order?: number | null
    waypoints?: ActivityWaypointCreateNestedManyWithoutActivityInput
    activities?: ActivityCreateNestedManyWithoutParentActivityInput
    parentActivity?: ActivityCreateNestedOneWithoutActivitiesInput
    parentWaypoint?: ActivityWaypointCreateNestedOneWithoutChildActivitiesInput
    template?: ActivityTemplateCreateNestedOneWithoutActivitiesInput
    assignedBy: UserCreateNestedOneWithoutAssignedActivitiesInput
    contacts?: ActivityContactJoinCreateNestedManyWithoutActivityRelationInput
    users?: ActivityUserJoinCreateNestedManyWithoutActivityRelationInput
    tenet: TenetCreateNestedOneWithoutActivitiesInput
    attachments?: AttachmentCreateNestedManyWithoutActivityInput
    notes?: NoteCreateNestedManyWithoutActivityInput
    events?: ContactTimelineEventCreateNestedManyWithoutActivityInput
    opportunity?: OpportunityCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateWithoutStepsInput = {
    id: Uint8Array
    title: string
    type: $Enums.ActivityType
    parentActivityId?: Uint8Array | null
    parentWaypointId?: Uint8Array | null
    templateId?: Uint8Array | null
    taskScheduleType?: $Enums.TaskScheduleType | null
    startDate: Date | string
    endDate: Date | string
    completedAt?: Date | string | null
    description?: string | null
    priority?: $Enums.ActivityPriority
    status: $Enums.ActivityStatus
    assignedById: Uint8Array
    phoneNumber?: string | null
    location?: string | null
    holdReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
    deleted?: boolean
    deletedAt?: Date | string | null
    order?: number | null
    opportunityId?: Uint8Array | null
    waypoints?: ActivityWaypointUncheckedCreateNestedManyWithoutActivityInput
    activities?: ActivityUncheckedCreateNestedManyWithoutParentActivityInput
    contacts?: ActivityContactJoinUncheckedCreateNestedManyWithoutActivityRelationInput
    users?: ActivityUserJoinUncheckedCreateNestedManyWithoutActivityRelationInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutActivityInput
    notes?: NoteUncheckedCreateNestedManyWithoutActivityInput
    events?: ContactTimelineEventUncheckedCreateNestedManyWithoutActivityInput
  }

  export type ActivityCreateOrConnectWithoutStepsInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutStepsInput, ActivityUncheckedCreateWithoutStepsInput>
  }

  export type ActivityStepUserJoinCreateWithoutStepRelationInput = {
    userRelation: UserCreateNestedOneWithoutActivityStepsInput
  }

  export type ActivityStepUserJoinUncheckedCreateWithoutStepRelationInput = {
    userId: Uint8Array
  }

  export type ActivityStepUserJoinCreateOrConnectWithoutStepRelationInput = {
    where: ActivityStepUserJoinWhereUniqueInput
    create: XOR<ActivityStepUserJoinCreateWithoutStepRelationInput, ActivityStepUserJoinUncheckedCreateWithoutStepRelationInput>
  }

  export type ActivityStepUserJoinCreateManyStepRelationInputEnvelope = {
    data: ActivityStepUserJoinCreateManyStepRelationInput | ActivityStepUserJoinCreateManyStepRelationInput[]
    skipDuplicates?: boolean
  }

  export type TenetCreateWithoutActivityStepsInput = {
    id: Uint8Array
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenetInput
    logs?: LogCreateNestedManyWithoutTenetInput
    contacts?: ContactCreateNestedManyWithoutTenetInput
    activities?: ActivityCreateNestedManyWithoutTenetInput
    addresses?: AddressCreateNestedManyWithoutTenetInput
    contactEmails?: ContactEmailCreateNestedManyWithoutTenetInput
    contactPhones?: ContactPhoneCreateNestedManyWithoutTenetInput
    importantDates?: ImportantDateCreateNestedManyWithoutTenetInput
    attachments?: AttachmentCreateNestedManyWithoutTenetInput
    notes?: NoteCreateNestedManyWithoutTenetInput
    auditEvents?: AuditEventCreateNestedManyWithoutTenetInput
    contactTimelineEvents?: ContactTimelineEventCreateNestedManyWithoutTenetInput
    activityWaypoints?: ActivityWaypointCreateNestedManyWithoutTenetInput
    templateAssignments?: TemplateAssignmentCreateNestedManyWithoutTenetInput
    activityWaypointTemplates?: ActivityWaypointTemplateCreateNestedManyWithoutTenetInput
    activityTemplates?: ActivityTemplateCreateNestedManyWithoutTenetInput
    activityTemplateSteps?: ActivityTemplateStepCreateNestedManyWithoutTenetInput
    opportunities?: OpportunityCreateNestedManyWithoutTenetInput
    products?: ProductTypeCreateNestedManyWithoutTenetInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentCreateNestedManyWithoutTenetInput
  }

  export type TenetUncheckedCreateWithoutActivityStepsInput = {
    id: Uint8Array
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenetInput
    logs?: LogUncheckedCreateNestedManyWithoutTenetInput
    contacts?: ContactUncheckedCreateNestedManyWithoutTenetInput
    activities?: ActivityUncheckedCreateNestedManyWithoutTenetInput
    addresses?: AddressUncheckedCreateNestedManyWithoutTenetInput
    contactEmails?: ContactEmailUncheckedCreateNestedManyWithoutTenetInput
    contactPhones?: ContactPhoneUncheckedCreateNestedManyWithoutTenetInput
    importantDates?: ImportantDateUncheckedCreateNestedManyWithoutTenetInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTenetInput
    notes?: NoteUncheckedCreateNestedManyWithoutTenetInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutTenetInput
    contactTimelineEvents?: ContactTimelineEventUncheckedCreateNestedManyWithoutTenetInput
    activityWaypoints?: ActivityWaypointUncheckedCreateNestedManyWithoutTenetInput
    templateAssignments?: TemplateAssignmentUncheckedCreateNestedManyWithoutTenetInput
    activityWaypointTemplates?: ActivityWaypointTemplateUncheckedCreateNestedManyWithoutTenetInput
    activityTemplates?: ActivityTemplateUncheckedCreateNestedManyWithoutTenetInput
    activityTemplateSteps?: ActivityTemplateStepUncheckedCreateNestedManyWithoutTenetInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutTenetInput
    products?: ProductTypeUncheckedCreateNestedManyWithoutTenetInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentUncheckedCreateNestedManyWithoutTenetInput
  }

  export type TenetCreateOrConnectWithoutActivityStepsInput = {
    where: TenetWhereUniqueInput
    create: XOR<TenetCreateWithoutActivityStepsInput, TenetUncheckedCreateWithoutActivityStepsInput>
  }

  export type ActivityUpsertWithoutStepsInput = {
    update: XOR<ActivityUpdateWithoutStepsInput, ActivityUncheckedUpdateWithoutStepsInput>
    create: XOR<ActivityCreateWithoutStepsInput, ActivityUncheckedCreateWithoutStepsInput>
    where?: ActivityWhereInput
  }

  export type ActivityUpdateToOneWithWhereWithoutStepsInput = {
    where?: ActivityWhereInput
    data: XOR<ActivityUpdateWithoutStepsInput, ActivityUncheckedUpdateWithoutStepsInput>
  }

  export type ActivityUpdateWithoutStepsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    waypoints?: ActivityWaypointUpdateManyWithoutActivityNestedInput
    activities?: ActivityUpdateManyWithoutParentActivityNestedInput
    parentActivity?: ActivityUpdateOneWithoutActivitiesNestedInput
    parentWaypoint?: ActivityWaypointUpdateOneWithoutChildActivitiesNestedInput
    template?: ActivityTemplateUpdateOneWithoutActivitiesNestedInput
    assignedBy?: UserUpdateOneRequiredWithoutAssignedActivitiesNestedInput
    contacts?: ActivityContactJoinUpdateManyWithoutActivityRelationNestedInput
    users?: ActivityUserJoinUpdateManyWithoutActivityRelationNestedInput
    tenet?: TenetUpdateOneRequiredWithoutActivitiesNestedInput
    attachments?: AttachmentUpdateManyWithoutActivityNestedInput
    notes?: NoteUpdateManyWithoutActivityNestedInput
    events?: ContactTimelineEventUpdateManyWithoutActivityNestedInput
    opportunity?: OpportunityUpdateOneWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateWithoutStepsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    parentActivityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    parentWaypointId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    templateId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    assignedById?: BytesFieldUpdateOperationsInput | Uint8Array
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    opportunityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    waypoints?: ActivityWaypointUncheckedUpdateManyWithoutActivityNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutParentActivityNestedInput
    contacts?: ActivityContactJoinUncheckedUpdateManyWithoutActivityRelationNestedInput
    users?: ActivityUserJoinUncheckedUpdateManyWithoutActivityRelationNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutActivityNestedInput
    notes?: NoteUncheckedUpdateManyWithoutActivityNestedInput
    events?: ContactTimelineEventUncheckedUpdateManyWithoutActivityNestedInput
  }

  export type ActivityStepUserJoinUpsertWithWhereUniqueWithoutStepRelationInput = {
    where: ActivityStepUserJoinWhereUniqueInput
    update: XOR<ActivityStepUserJoinUpdateWithoutStepRelationInput, ActivityStepUserJoinUncheckedUpdateWithoutStepRelationInput>
    create: XOR<ActivityStepUserJoinCreateWithoutStepRelationInput, ActivityStepUserJoinUncheckedCreateWithoutStepRelationInput>
  }

  export type ActivityStepUserJoinUpdateWithWhereUniqueWithoutStepRelationInput = {
    where: ActivityStepUserJoinWhereUniqueInput
    data: XOR<ActivityStepUserJoinUpdateWithoutStepRelationInput, ActivityStepUserJoinUncheckedUpdateWithoutStepRelationInput>
  }

  export type ActivityStepUserJoinUpdateManyWithWhereWithoutStepRelationInput = {
    where: ActivityStepUserJoinScalarWhereInput
    data: XOR<ActivityStepUserJoinUpdateManyMutationInput, ActivityStepUserJoinUncheckedUpdateManyWithoutStepRelationInput>
  }

  export type TenetUpsertWithoutActivityStepsInput = {
    update: XOR<TenetUpdateWithoutActivityStepsInput, TenetUncheckedUpdateWithoutActivityStepsInput>
    create: XOR<TenetCreateWithoutActivityStepsInput, TenetUncheckedCreateWithoutActivityStepsInput>
    where?: TenetWhereInput
  }

  export type TenetUpdateToOneWithWhereWithoutActivityStepsInput = {
    where?: TenetWhereInput
    data: XOR<TenetUpdateWithoutActivityStepsInput, TenetUncheckedUpdateWithoutActivityStepsInput>
  }

  export type TenetUpdateWithoutActivityStepsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenetNestedInput
    logs?: LogUpdateManyWithoutTenetNestedInput
    contacts?: ContactUpdateManyWithoutTenetNestedInput
    activities?: ActivityUpdateManyWithoutTenetNestedInput
    addresses?: AddressUpdateManyWithoutTenetNestedInput
    contactEmails?: ContactEmailUpdateManyWithoutTenetNestedInput
    contactPhones?: ContactPhoneUpdateManyWithoutTenetNestedInput
    importantDates?: ImportantDateUpdateManyWithoutTenetNestedInput
    attachments?: AttachmentUpdateManyWithoutTenetNestedInput
    notes?: NoteUpdateManyWithoutTenetNestedInput
    auditEvents?: AuditEventUpdateManyWithoutTenetNestedInput
    contactTimelineEvents?: ContactTimelineEventUpdateManyWithoutTenetNestedInput
    activityWaypoints?: ActivityWaypointUpdateManyWithoutTenetNestedInput
    templateAssignments?: TemplateAssignmentUpdateManyWithoutTenetNestedInput
    activityWaypointTemplates?: ActivityWaypointTemplateUpdateManyWithoutTenetNestedInput
    activityTemplates?: ActivityTemplateUpdateManyWithoutTenetNestedInput
    activityTemplateSteps?: ActivityTemplateStepUpdateManyWithoutTenetNestedInput
    opportunities?: OpportunityUpdateManyWithoutTenetNestedInput
    products?: ProductTypeUpdateManyWithoutTenetNestedInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentUpdateManyWithoutTenetNestedInput
  }

  export type TenetUncheckedUpdateWithoutActivityStepsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenetNestedInput
    logs?: LogUncheckedUpdateManyWithoutTenetNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutTenetNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutTenetNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutTenetNestedInput
    contactEmails?: ContactEmailUncheckedUpdateManyWithoutTenetNestedInput
    contactPhones?: ContactPhoneUncheckedUpdateManyWithoutTenetNestedInput
    importantDates?: ImportantDateUncheckedUpdateManyWithoutTenetNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTenetNestedInput
    notes?: NoteUncheckedUpdateManyWithoutTenetNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutTenetNestedInput
    contactTimelineEvents?: ContactTimelineEventUncheckedUpdateManyWithoutTenetNestedInput
    activityWaypoints?: ActivityWaypointUncheckedUpdateManyWithoutTenetNestedInput
    templateAssignments?: TemplateAssignmentUncheckedUpdateManyWithoutTenetNestedInput
    activityWaypointTemplates?: ActivityWaypointTemplateUncheckedUpdateManyWithoutTenetNestedInput
    activityTemplates?: ActivityTemplateUncheckedUpdateManyWithoutTenetNestedInput
    activityTemplateSteps?: ActivityTemplateStepUncheckedUpdateManyWithoutTenetNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutTenetNestedInput
    products?: ProductTypeUncheckedUpdateManyWithoutTenetNestedInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentUncheckedUpdateManyWithoutTenetNestedInput
  }

  export type ActivityStepCreateWithoutAssignedToInput = {
    id: Uint8Array
    title: string
    completed: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    type?: $Enums.ActivityStepType
    order: number
    activity: ActivityCreateNestedOneWithoutStepsInput
    tenet: TenetCreateNestedOneWithoutActivityStepsInput
  }

  export type ActivityStepUncheckedCreateWithoutAssignedToInput = {
    id: Uint8Array
    title: string
    completed: boolean
    activityId: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
    type?: $Enums.ActivityStepType
    order: number
  }

  export type ActivityStepCreateOrConnectWithoutAssignedToInput = {
    where: ActivityStepWhereUniqueInput
    create: XOR<ActivityStepCreateWithoutAssignedToInput, ActivityStepUncheckedCreateWithoutAssignedToInput>
  }

  export type UserCreateWithoutActivityStepsInput = {
    id: Uint8Array
    email: string
    firstName: string
    lastName: string
    fullName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password: string
    enabled?: boolean
    type?: $Enums.AccessGroup
    system?: boolean
    deleted?: boolean
    deletedAt?: Date | string | null
    tokens?: TokenCreateNestedManyWithoutUserInput
    tenet?: TenetCreateNestedOneWithoutUsersInput
    activities?: ActivityUserJoinCreateNestedManyWithoutUserRelationInput
    notes?: NoteCreateNestedManyWithoutAuthorInput
    waypoints?: UserWaypointJoinCreateNestedManyWithoutUserRelationInput
    events?: ContactTimelineEventCreateNestedManyWithoutUserInput
    auditEvents?: AuditEventCreateNestedManyWithoutUserInput
    templateAssignments?: TemplateAssignmentCreateNestedManyWithoutSpecificUserInput
    assignedActivities?: ActivityCreateNestedManyWithoutAssignedByInput
    opportunities?: UserOpportunityJoinCreateNestedManyWithoutUserRelationInput
    templateStepAssignments?: ActivityTemplateStepAssignmentCreateNestedManyWithoutSpecificUserInput
  }

  export type UserUncheckedCreateWithoutActivityStepsInput = {
    id: Uint8Array
    email: string
    firstName: string
    lastName: string
    fullName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password: string
    enabled?: boolean
    type?: $Enums.AccessGroup
    tenetId?: Uint8Array | null
    system?: boolean
    deleted?: boolean
    deletedAt?: Date | string | null
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUserJoinUncheckedCreateNestedManyWithoutUserRelationInput
    notes?: NoteUncheckedCreateNestedManyWithoutAuthorInput
    waypoints?: UserWaypointJoinUncheckedCreateNestedManyWithoutUserRelationInput
    events?: ContactTimelineEventUncheckedCreateNestedManyWithoutUserInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutUserInput
    templateAssignments?: TemplateAssignmentUncheckedCreateNestedManyWithoutSpecificUserInput
    assignedActivities?: ActivityUncheckedCreateNestedManyWithoutAssignedByInput
    opportunities?: UserOpportunityJoinUncheckedCreateNestedManyWithoutUserRelationInput
    templateStepAssignments?: ActivityTemplateStepAssignmentUncheckedCreateNestedManyWithoutSpecificUserInput
  }

  export type UserCreateOrConnectWithoutActivityStepsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutActivityStepsInput, UserUncheckedCreateWithoutActivityStepsInput>
  }

  export type ActivityStepUpsertWithoutAssignedToInput = {
    update: XOR<ActivityStepUpdateWithoutAssignedToInput, ActivityStepUncheckedUpdateWithoutAssignedToInput>
    create: XOR<ActivityStepCreateWithoutAssignedToInput, ActivityStepUncheckedCreateWithoutAssignedToInput>
    where?: ActivityStepWhereInput
  }

  export type ActivityStepUpdateToOneWithWhereWithoutAssignedToInput = {
    where?: ActivityStepWhereInput
    data: XOR<ActivityStepUpdateWithoutAssignedToInput, ActivityStepUncheckedUpdateWithoutAssignedToInput>
  }

  export type ActivityStepUpdateWithoutAssignedToInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumActivityStepTypeFieldUpdateOperationsInput | $Enums.ActivityStepType
    order?: IntFieldUpdateOperationsInput | number
    activity?: ActivityUpdateOneRequiredWithoutStepsNestedInput
    tenet?: TenetUpdateOneRequiredWithoutActivityStepsNestedInput
  }

  export type ActivityStepUncheckedUpdateWithoutAssignedToInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    activityId?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    type?: EnumActivityStepTypeFieldUpdateOperationsInput | $Enums.ActivityStepType
    order?: IntFieldUpdateOperationsInput | number
  }

  export type UserUpsertWithoutActivityStepsInput = {
    update: XOR<UserUpdateWithoutActivityStepsInput, UserUncheckedUpdateWithoutActivityStepsInput>
    create: XOR<UserCreateWithoutActivityStepsInput, UserUncheckedCreateWithoutActivityStepsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutActivityStepsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutActivityStepsInput, UserUncheckedUpdateWithoutActivityStepsInput>
  }

  export type UserUpdateWithoutActivityStepsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumAccessGroupFieldUpdateOperationsInput | $Enums.AccessGroup
    system?: BoolFieldUpdateOperationsInput | boolean
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokens?: TokenUpdateManyWithoutUserNestedInput
    tenet?: TenetUpdateOneWithoutUsersNestedInput
    activities?: ActivityUserJoinUpdateManyWithoutUserRelationNestedInput
    notes?: NoteUpdateManyWithoutAuthorNestedInput
    waypoints?: UserWaypointJoinUpdateManyWithoutUserRelationNestedInput
    events?: ContactTimelineEventUpdateManyWithoutUserNestedInput
    auditEvents?: AuditEventUpdateManyWithoutUserNestedInput
    templateAssignments?: TemplateAssignmentUpdateManyWithoutSpecificUserNestedInput
    assignedActivities?: ActivityUpdateManyWithoutAssignedByNestedInput
    opportunities?: UserOpportunityJoinUpdateManyWithoutUserRelationNestedInput
    templateStepAssignments?: ActivityTemplateStepAssignmentUpdateManyWithoutSpecificUserNestedInput
  }

  export type UserUncheckedUpdateWithoutActivityStepsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumAccessGroupFieldUpdateOperationsInput | $Enums.AccessGroup
    tenetId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    system?: BoolFieldUpdateOperationsInput | boolean
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUserJoinUncheckedUpdateManyWithoutUserRelationNestedInput
    notes?: NoteUncheckedUpdateManyWithoutAuthorNestedInput
    waypoints?: UserWaypointJoinUncheckedUpdateManyWithoutUserRelationNestedInput
    events?: ContactTimelineEventUncheckedUpdateManyWithoutUserNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutUserNestedInput
    templateAssignments?: TemplateAssignmentUncheckedUpdateManyWithoutSpecificUserNestedInput
    assignedActivities?: ActivityUncheckedUpdateManyWithoutAssignedByNestedInput
    opportunities?: UserOpportunityJoinUncheckedUpdateManyWithoutUserRelationNestedInput
    templateStepAssignments?: ActivityTemplateStepAssignmentUncheckedUpdateManyWithoutSpecificUserNestedInput
  }

  export type UserCreateWithoutWaypointsInput = {
    id: Uint8Array
    email: string
    firstName: string
    lastName: string
    fullName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password: string
    enabled?: boolean
    type?: $Enums.AccessGroup
    system?: boolean
    deleted?: boolean
    deletedAt?: Date | string | null
    tokens?: TokenCreateNestedManyWithoutUserInput
    tenet?: TenetCreateNestedOneWithoutUsersInput
    activities?: ActivityUserJoinCreateNestedManyWithoutUserRelationInput
    notes?: NoteCreateNestedManyWithoutAuthorInput
    events?: ContactTimelineEventCreateNestedManyWithoutUserInput
    auditEvents?: AuditEventCreateNestedManyWithoutUserInput
    templateAssignments?: TemplateAssignmentCreateNestedManyWithoutSpecificUserInput
    assignedActivities?: ActivityCreateNestedManyWithoutAssignedByInput
    opportunities?: UserOpportunityJoinCreateNestedManyWithoutUserRelationInput
    activitySteps?: ActivityStepUserJoinCreateNestedManyWithoutUserRelationInput
    templateStepAssignments?: ActivityTemplateStepAssignmentCreateNestedManyWithoutSpecificUserInput
  }

  export type UserUncheckedCreateWithoutWaypointsInput = {
    id: Uint8Array
    email: string
    firstName: string
    lastName: string
    fullName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password: string
    enabled?: boolean
    type?: $Enums.AccessGroup
    tenetId?: Uint8Array | null
    system?: boolean
    deleted?: boolean
    deletedAt?: Date | string | null
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUserJoinUncheckedCreateNestedManyWithoutUserRelationInput
    notes?: NoteUncheckedCreateNestedManyWithoutAuthorInput
    events?: ContactTimelineEventUncheckedCreateNestedManyWithoutUserInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutUserInput
    templateAssignments?: TemplateAssignmentUncheckedCreateNestedManyWithoutSpecificUserInput
    assignedActivities?: ActivityUncheckedCreateNestedManyWithoutAssignedByInput
    opportunities?: UserOpportunityJoinUncheckedCreateNestedManyWithoutUserRelationInput
    activitySteps?: ActivityStepUserJoinUncheckedCreateNestedManyWithoutUserRelationInput
    templateStepAssignments?: ActivityTemplateStepAssignmentUncheckedCreateNestedManyWithoutSpecificUserInput
  }

  export type UserCreateOrConnectWithoutWaypointsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWaypointsInput, UserUncheckedCreateWithoutWaypointsInput>
  }

  export type ActivityWaypointCreateWithoutUsersInput = {
    id: Uint8Array
    title: string
    description?: string | null
    summary?: string | null
    status: $Enums.ActivityStatus
    order: number
    actualStart: Date | string
    dueDate: Date | string
    actualEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activity: ActivityCreateNestedOneWithoutWaypointsInput
    childActivities?: ActivityCreateNestedManyWithoutParentWaypointInput
    template?: ActivityWaypointTemplateCreateNestedOneWithoutWaypointsInput
    events?: ContactTimelineEventCreateNestedManyWithoutWaypointInput
    tenet: TenetCreateNestedOneWithoutActivityWaypointsInput
    Note?: NoteCreateNestedManyWithoutWaypointInput
  }

  export type ActivityWaypointUncheckedCreateWithoutUsersInput = {
    id: Uint8Array
    title: string
    description?: string | null
    summary?: string | null
    status: $Enums.ActivityStatus
    order: number
    actualStart: Date | string
    dueDate: Date | string
    actualEnd?: Date | string | null
    activityId: Uint8Array
    templateId?: Uint8Array | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
    childActivities?: ActivityUncheckedCreateNestedManyWithoutParentWaypointInput
    events?: ContactTimelineEventUncheckedCreateNestedManyWithoutWaypointInput
    Note?: NoteUncheckedCreateNestedManyWithoutWaypointInput
  }

  export type ActivityWaypointCreateOrConnectWithoutUsersInput = {
    where: ActivityWaypointWhereUniqueInput
    create: XOR<ActivityWaypointCreateWithoutUsersInput, ActivityWaypointUncheckedCreateWithoutUsersInput>
  }

  export type UserUpsertWithoutWaypointsInput = {
    update: XOR<UserUpdateWithoutWaypointsInput, UserUncheckedUpdateWithoutWaypointsInput>
    create: XOR<UserCreateWithoutWaypointsInput, UserUncheckedCreateWithoutWaypointsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWaypointsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWaypointsInput, UserUncheckedUpdateWithoutWaypointsInput>
  }

  export type UserUpdateWithoutWaypointsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumAccessGroupFieldUpdateOperationsInput | $Enums.AccessGroup
    system?: BoolFieldUpdateOperationsInput | boolean
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokens?: TokenUpdateManyWithoutUserNestedInput
    tenet?: TenetUpdateOneWithoutUsersNestedInput
    activities?: ActivityUserJoinUpdateManyWithoutUserRelationNestedInput
    notes?: NoteUpdateManyWithoutAuthorNestedInput
    events?: ContactTimelineEventUpdateManyWithoutUserNestedInput
    auditEvents?: AuditEventUpdateManyWithoutUserNestedInput
    templateAssignments?: TemplateAssignmentUpdateManyWithoutSpecificUserNestedInput
    assignedActivities?: ActivityUpdateManyWithoutAssignedByNestedInput
    opportunities?: UserOpportunityJoinUpdateManyWithoutUserRelationNestedInput
    activitySteps?: ActivityStepUserJoinUpdateManyWithoutUserRelationNestedInput
    templateStepAssignments?: ActivityTemplateStepAssignmentUpdateManyWithoutSpecificUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWaypointsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumAccessGroupFieldUpdateOperationsInput | $Enums.AccessGroup
    tenetId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    system?: BoolFieldUpdateOperationsInput | boolean
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUserJoinUncheckedUpdateManyWithoutUserRelationNestedInput
    notes?: NoteUncheckedUpdateManyWithoutAuthorNestedInput
    events?: ContactTimelineEventUncheckedUpdateManyWithoutUserNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutUserNestedInput
    templateAssignments?: TemplateAssignmentUncheckedUpdateManyWithoutSpecificUserNestedInput
    assignedActivities?: ActivityUncheckedUpdateManyWithoutAssignedByNestedInput
    opportunities?: UserOpportunityJoinUncheckedUpdateManyWithoutUserRelationNestedInput
    activitySteps?: ActivityStepUserJoinUncheckedUpdateManyWithoutUserRelationNestedInput
    templateStepAssignments?: ActivityTemplateStepAssignmentUncheckedUpdateManyWithoutSpecificUserNestedInput
  }

  export type ActivityWaypointUpsertWithoutUsersInput = {
    update: XOR<ActivityWaypointUpdateWithoutUsersInput, ActivityWaypointUncheckedUpdateWithoutUsersInput>
    create: XOR<ActivityWaypointCreateWithoutUsersInput, ActivityWaypointUncheckedCreateWithoutUsersInput>
    where?: ActivityWaypointWhereInput
  }

  export type ActivityWaypointUpdateToOneWithWhereWithoutUsersInput = {
    where?: ActivityWaypointWhereInput
    data: XOR<ActivityWaypointUpdateWithoutUsersInput, ActivityWaypointUncheckedUpdateWithoutUsersInput>
  }

  export type ActivityWaypointUpdateWithoutUsersInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    order?: IntFieldUpdateOperationsInput | number
    actualStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activity?: ActivityUpdateOneRequiredWithoutWaypointsNestedInput
    childActivities?: ActivityUpdateManyWithoutParentWaypointNestedInput
    template?: ActivityWaypointTemplateUpdateOneWithoutWaypointsNestedInput
    events?: ContactTimelineEventUpdateManyWithoutWaypointNestedInput
    tenet?: TenetUpdateOneRequiredWithoutActivityWaypointsNestedInput
    Note?: NoteUpdateManyWithoutWaypointNestedInput
  }

  export type ActivityWaypointUncheckedUpdateWithoutUsersInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    order?: IntFieldUpdateOperationsInput | number
    actualStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activityId?: BytesFieldUpdateOperationsInput | Uint8Array
    templateId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    childActivities?: ActivityUncheckedUpdateManyWithoutParentWaypointNestedInput
    events?: ContactTimelineEventUncheckedUpdateManyWithoutWaypointNestedInput
    Note?: NoteUncheckedUpdateManyWithoutWaypointNestedInput
  }

  export type UserWaypointJoinCreateWithoutWaypointRelationInput = {
    userRelation: UserCreateNestedOneWithoutWaypointsInput
  }

  export type UserWaypointJoinUncheckedCreateWithoutWaypointRelationInput = {
    userId: Uint8Array
  }

  export type UserWaypointJoinCreateOrConnectWithoutWaypointRelationInput = {
    where: UserWaypointJoinWhereUniqueInput
    create: XOR<UserWaypointJoinCreateWithoutWaypointRelationInput, UserWaypointJoinUncheckedCreateWithoutWaypointRelationInput>
  }

  export type UserWaypointJoinCreateManyWaypointRelationInputEnvelope = {
    data: UserWaypointJoinCreateManyWaypointRelationInput | UserWaypointJoinCreateManyWaypointRelationInput[]
    skipDuplicates?: boolean
  }

  export type ActivityCreateWithoutWaypointsInput = {
    id: Uint8Array
    title: string
    type: $Enums.ActivityType
    taskScheduleType?: $Enums.TaskScheduleType | null
    startDate: Date | string
    endDate: Date | string
    completedAt?: Date | string | null
    description?: string | null
    priority?: $Enums.ActivityPriority
    status: $Enums.ActivityStatus
    phoneNumber?: string | null
    location?: string | null
    holdReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean
    deletedAt?: Date | string | null
    order?: number | null
    steps?: ActivityStepCreateNestedManyWithoutActivityInput
    activities?: ActivityCreateNestedManyWithoutParentActivityInput
    parentActivity?: ActivityCreateNestedOneWithoutActivitiesInput
    parentWaypoint?: ActivityWaypointCreateNestedOneWithoutChildActivitiesInput
    template?: ActivityTemplateCreateNestedOneWithoutActivitiesInput
    assignedBy: UserCreateNestedOneWithoutAssignedActivitiesInput
    contacts?: ActivityContactJoinCreateNestedManyWithoutActivityRelationInput
    users?: ActivityUserJoinCreateNestedManyWithoutActivityRelationInput
    tenet: TenetCreateNestedOneWithoutActivitiesInput
    attachments?: AttachmentCreateNestedManyWithoutActivityInput
    notes?: NoteCreateNestedManyWithoutActivityInput
    events?: ContactTimelineEventCreateNestedManyWithoutActivityInput
    opportunity?: OpportunityCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateWithoutWaypointsInput = {
    id: Uint8Array
    title: string
    type: $Enums.ActivityType
    parentActivityId?: Uint8Array | null
    parentWaypointId?: Uint8Array | null
    templateId?: Uint8Array | null
    taskScheduleType?: $Enums.TaskScheduleType | null
    startDate: Date | string
    endDate: Date | string
    completedAt?: Date | string | null
    description?: string | null
    priority?: $Enums.ActivityPriority
    status: $Enums.ActivityStatus
    assignedById: Uint8Array
    phoneNumber?: string | null
    location?: string | null
    holdReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
    deleted?: boolean
    deletedAt?: Date | string | null
    order?: number | null
    opportunityId?: Uint8Array | null
    steps?: ActivityStepUncheckedCreateNestedManyWithoutActivityInput
    activities?: ActivityUncheckedCreateNestedManyWithoutParentActivityInput
    contacts?: ActivityContactJoinUncheckedCreateNestedManyWithoutActivityRelationInput
    users?: ActivityUserJoinUncheckedCreateNestedManyWithoutActivityRelationInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutActivityInput
    notes?: NoteUncheckedCreateNestedManyWithoutActivityInput
    events?: ContactTimelineEventUncheckedCreateNestedManyWithoutActivityInput
  }

  export type ActivityCreateOrConnectWithoutWaypointsInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutWaypointsInput, ActivityUncheckedCreateWithoutWaypointsInput>
  }

  export type ActivityCreateWithoutParentWaypointInput = {
    id: Uint8Array
    title: string
    type: $Enums.ActivityType
    taskScheduleType?: $Enums.TaskScheduleType | null
    startDate: Date | string
    endDate: Date | string
    completedAt?: Date | string | null
    description?: string | null
    priority?: $Enums.ActivityPriority
    status: $Enums.ActivityStatus
    phoneNumber?: string | null
    location?: string | null
    holdReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean
    deletedAt?: Date | string | null
    order?: number | null
    steps?: ActivityStepCreateNestedManyWithoutActivityInput
    waypoints?: ActivityWaypointCreateNestedManyWithoutActivityInput
    activities?: ActivityCreateNestedManyWithoutParentActivityInput
    parentActivity?: ActivityCreateNestedOneWithoutActivitiesInput
    template?: ActivityTemplateCreateNestedOneWithoutActivitiesInput
    assignedBy: UserCreateNestedOneWithoutAssignedActivitiesInput
    contacts?: ActivityContactJoinCreateNestedManyWithoutActivityRelationInput
    users?: ActivityUserJoinCreateNestedManyWithoutActivityRelationInput
    tenet: TenetCreateNestedOneWithoutActivitiesInput
    attachments?: AttachmentCreateNestedManyWithoutActivityInput
    notes?: NoteCreateNestedManyWithoutActivityInput
    events?: ContactTimelineEventCreateNestedManyWithoutActivityInput
    opportunity?: OpportunityCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateWithoutParentWaypointInput = {
    id: Uint8Array
    title: string
    type: $Enums.ActivityType
    parentActivityId?: Uint8Array | null
    templateId?: Uint8Array | null
    taskScheduleType?: $Enums.TaskScheduleType | null
    startDate: Date | string
    endDate: Date | string
    completedAt?: Date | string | null
    description?: string | null
    priority?: $Enums.ActivityPriority
    status: $Enums.ActivityStatus
    assignedById: Uint8Array
    phoneNumber?: string | null
    location?: string | null
    holdReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
    deleted?: boolean
    deletedAt?: Date | string | null
    order?: number | null
    opportunityId?: Uint8Array | null
    steps?: ActivityStepUncheckedCreateNestedManyWithoutActivityInput
    waypoints?: ActivityWaypointUncheckedCreateNestedManyWithoutActivityInput
    activities?: ActivityUncheckedCreateNestedManyWithoutParentActivityInput
    contacts?: ActivityContactJoinUncheckedCreateNestedManyWithoutActivityRelationInput
    users?: ActivityUserJoinUncheckedCreateNestedManyWithoutActivityRelationInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutActivityInput
    notes?: NoteUncheckedCreateNestedManyWithoutActivityInput
    events?: ContactTimelineEventUncheckedCreateNestedManyWithoutActivityInput
  }

  export type ActivityCreateOrConnectWithoutParentWaypointInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutParentWaypointInput, ActivityUncheckedCreateWithoutParentWaypointInput>
  }

  export type ActivityCreateManyParentWaypointInputEnvelope = {
    data: ActivityCreateManyParentWaypointInput | ActivityCreateManyParentWaypointInput[]
    skipDuplicates?: boolean
  }

  export type ActivityWaypointTemplateCreateWithoutWaypointsInput = {
    id: Uint8Array
    title: string
    description?: string | null
    defaultStatus: $Enums.ActivityStatus
    order: number
    dateOffsetType: $Enums.DateOffsetType
    dueDate: number
    createdAt?: Date | string
    updatedAt?: Date | string
    parentActivity: ActivityTemplateCreateNestedOneWithoutWaypointsInput
    activities?: ActivityTemplateCreateNestedManyWithoutParentWaypointInput
    assignments?: TemplateAssignmentCreateNestedManyWithoutWaypointTemplateInput
    tenet: TenetCreateNestedOneWithoutActivityWaypointTemplatesInput
  }

  export type ActivityWaypointTemplateUncheckedCreateWithoutWaypointsInput = {
    id: Uint8Array
    title: string
    description?: string | null
    defaultStatus: $Enums.ActivityStatus
    order: number
    dateOffsetType: $Enums.DateOffsetType
    dueDate: number
    parentActivityId: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
    activities?: ActivityTemplateUncheckedCreateNestedManyWithoutParentWaypointInput
    assignments?: TemplateAssignmentUncheckedCreateNestedManyWithoutWaypointTemplateInput
  }

  export type ActivityWaypointTemplateCreateOrConnectWithoutWaypointsInput = {
    where: ActivityWaypointTemplateWhereUniqueInput
    create: XOR<ActivityWaypointTemplateCreateWithoutWaypointsInput, ActivityWaypointTemplateUncheckedCreateWithoutWaypointsInput>
  }

  export type ContactTimelineEventCreateWithoutWaypointInput = {
    id: Uint8Array
    extraInfo?: string | null
    eventType: $Enums.ContactTimelineEventType
    relationshipType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activity?: ActivityCreateNestedOneWithoutEventsInput
    opportunity?: OpportunityCreateNestedOneWithoutEventsInput
    note?: NoteCreateNestedOneWithoutEventsInput
    contacts?: ContactTimelineEventContactJoinCreateNestedManyWithoutContactEventRelationInput
    user: UserCreateNestedOneWithoutEventsInput
    tenet: TenetCreateNestedOneWithoutContactTimelineEventsInput
  }

  export type ContactTimelineEventUncheckedCreateWithoutWaypointInput = {
    id: Uint8Array
    activityId?: Uint8Array | null
    opportunityId?: Uint8Array | null
    noteId?: Uint8Array | null
    extraInfo?: string | null
    userId: Uint8Array
    tenetId: Uint8Array
    eventType: $Enums.ContactTimelineEventType
    relationshipType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: ContactTimelineEventContactJoinUncheckedCreateNestedManyWithoutContactEventRelationInput
  }

  export type ContactTimelineEventCreateOrConnectWithoutWaypointInput = {
    where: ContactTimelineEventWhereUniqueInput
    create: XOR<ContactTimelineEventCreateWithoutWaypointInput, ContactTimelineEventUncheckedCreateWithoutWaypointInput>
  }

  export type ContactTimelineEventCreateManyWaypointInputEnvelope = {
    data: ContactTimelineEventCreateManyWaypointInput | ContactTimelineEventCreateManyWaypointInput[]
    skipDuplicates?: boolean
  }

  export type TenetCreateWithoutActivityWaypointsInput = {
    id: Uint8Array
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenetInput
    logs?: LogCreateNestedManyWithoutTenetInput
    contacts?: ContactCreateNestedManyWithoutTenetInput
    activities?: ActivityCreateNestedManyWithoutTenetInput
    addresses?: AddressCreateNestedManyWithoutTenetInput
    contactEmails?: ContactEmailCreateNestedManyWithoutTenetInput
    contactPhones?: ContactPhoneCreateNestedManyWithoutTenetInput
    importantDates?: ImportantDateCreateNestedManyWithoutTenetInput
    attachments?: AttachmentCreateNestedManyWithoutTenetInput
    notes?: NoteCreateNestedManyWithoutTenetInput
    auditEvents?: AuditEventCreateNestedManyWithoutTenetInput
    contactTimelineEvents?: ContactTimelineEventCreateNestedManyWithoutTenetInput
    activitySteps?: ActivityStepCreateNestedManyWithoutTenetInput
    templateAssignments?: TemplateAssignmentCreateNestedManyWithoutTenetInput
    activityWaypointTemplates?: ActivityWaypointTemplateCreateNestedManyWithoutTenetInput
    activityTemplates?: ActivityTemplateCreateNestedManyWithoutTenetInput
    activityTemplateSteps?: ActivityTemplateStepCreateNestedManyWithoutTenetInput
    opportunities?: OpportunityCreateNestedManyWithoutTenetInput
    products?: ProductTypeCreateNestedManyWithoutTenetInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentCreateNestedManyWithoutTenetInput
  }

  export type TenetUncheckedCreateWithoutActivityWaypointsInput = {
    id: Uint8Array
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenetInput
    logs?: LogUncheckedCreateNestedManyWithoutTenetInput
    contacts?: ContactUncheckedCreateNestedManyWithoutTenetInput
    activities?: ActivityUncheckedCreateNestedManyWithoutTenetInput
    addresses?: AddressUncheckedCreateNestedManyWithoutTenetInput
    contactEmails?: ContactEmailUncheckedCreateNestedManyWithoutTenetInput
    contactPhones?: ContactPhoneUncheckedCreateNestedManyWithoutTenetInput
    importantDates?: ImportantDateUncheckedCreateNestedManyWithoutTenetInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTenetInput
    notes?: NoteUncheckedCreateNestedManyWithoutTenetInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutTenetInput
    contactTimelineEvents?: ContactTimelineEventUncheckedCreateNestedManyWithoutTenetInput
    activitySteps?: ActivityStepUncheckedCreateNestedManyWithoutTenetInput
    templateAssignments?: TemplateAssignmentUncheckedCreateNestedManyWithoutTenetInput
    activityWaypointTemplates?: ActivityWaypointTemplateUncheckedCreateNestedManyWithoutTenetInput
    activityTemplates?: ActivityTemplateUncheckedCreateNestedManyWithoutTenetInput
    activityTemplateSteps?: ActivityTemplateStepUncheckedCreateNestedManyWithoutTenetInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutTenetInput
    products?: ProductTypeUncheckedCreateNestedManyWithoutTenetInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentUncheckedCreateNestedManyWithoutTenetInput
  }

  export type TenetCreateOrConnectWithoutActivityWaypointsInput = {
    where: TenetWhereUniqueInput
    create: XOR<TenetCreateWithoutActivityWaypointsInput, TenetUncheckedCreateWithoutActivityWaypointsInput>
  }

  export type NoteCreateWithoutWaypointInput = {
    id: Uint8Array
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean
    deletedAt?: Date | string | null
    noteType?: $Enums.NoteType
    activity?: ActivityCreateNestedOneWithoutNotesInput
    contact?: ContactCreateNestedOneWithoutNotesInput
    opportunity?: OpportunityCreateNestedOneWithoutNotesInput
    tenet: TenetCreateNestedOneWithoutNotesInput
    author: UserCreateNestedOneWithoutNotesInput
    events?: ContactTimelineEventCreateNestedManyWithoutNoteInput
  }

  export type NoteUncheckedCreateWithoutWaypointInput = {
    id: Uint8Array
    content: string
    activityId?: Uint8Array | null
    contactId?: Uint8Array | null
    opportunityId?: Uint8Array | null
    tenetId: Uint8Array
    authorId: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean
    deletedAt?: Date | string | null
    noteType?: $Enums.NoteType
    events?: ContactTimelineEventUncheckedCreateNestedManyWithoutNoteInput
  }

  export type NoteCreateOrConnectWithoutWaypointInput = {
    where: NoteWhereUniqueInput
    create: XOR<NoteCreateWithoutWaypointInput, NoteUncheckedCreateWithoutWaypointInput>
  }

  export type NoteCreateManyWaypointInputEnvelope = {
    data: NoteCreateManyWaypointInput | NoteCreateManyWaypointInput[]
    skipDuplicates?: boolean
  }

  export type UserWaypointJoinUpsertWithWhereUniqueWithoutWaypointRelationInput = {
    where: UserWaypointJoinWhereUniqueInput
    update: XOR<UserWaypointJoinUpdateWithoutWaypointRelationInput, UserWaypointJoinUncheckedUpdateWithoutWaypointRelationInput>
    create: XOR<UserWaypointJoinCreateWithoutWaypointRelationInput, UserWaypointJoinUncheckedCreateWithoutWaypointRelationInput>
  }

  export type UserWaypointJoinUpdateWithWhereUniqueWithoutWaypointRelationInput = {
    where: UserWaypointJoinWhereUniqueInput
    data: XOR<UserWaypointJoinUpdateWithoutWaypointRelationInput, UserWaypointJoinUncheckedUpdateWithoutWaypointRelationInput>
  }

  export type UserWaypointJoinUpdateManyWithWhereWithoutWaypointRelationInput = {
    where: UserWaypointJoinScalarWhereInput
    data: XOR<UserWaypointJoinUpdateManyMutationInput, UserWaypointJoinUncheckedUpdateManyWithoutWaypointRelationInput>
  }

  export type ActivityUpsertWithoutWaypointsInput = {
    update: XOR<ActivityUpdateWithoutWaypointsInput, ActivityUncheckedUpdateWithoutWaypointsInput>
    create: XOR<ActivityCreateWithoutWaypointsInput, ActivityUncheckedCreateWithoutWaypointsInput>
    where?: ActivityWhereInput
  }

  export type ActivityUpdateToOneWithWhereWithoutWaypointsInput = {
    where?: ActivityWhereInput
    data: XOR<ActivityUpdateWithoutWaypointsInput, ActivityUncheckedUpdateWithoutWaypointsInput>
  }

  export type ActivityUpdateWithoutWaypointsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    steps?: ActivityStepUpdateManyWithoutActivityNestedInput
    activities?: ActivityUpdateManyWithoutParentActivityNestedInput
    parentActivity?: ActivityUpdateOneWithoutActivitiesNestedInput
    parentWaypoint?: ActivityWaypointUpdateOneWithoutChildActivitiesNestedInput
    template?: ActivityTemplateUpdateOneWithoutActivitiesNestedInput
    assignedBy?: UserUpdateOneRequiredWithoutAssignedActivitiesNestedInput
    contacts?: ActivityContactJoinUpdateManyWithoutActivityRelationNestedInput
    users?: ActivityUserJoinUpdateManyWithoutActivityRelationNestedInput
    tenet?: TenetUpdateOneRequiredWithoutActivitiesNestedInput
    attachments?: AttachmentUpdateManyWithoutActivityNestedInput
    notes?: NoteUpdateManyWithoutActivityNestedInput
    events?: ContactTimelineEventUpdateManyWithoutActivityNestedInput
    opportunity?: OpportunityUpdateOneWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateWithoutWaypointsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    parentActivityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    parentWaypointId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    templateId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    assignedById?: BytesFieldUpdateOperationsInput | Uint8Array
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    opportunityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    steps?: ActivityStepUncheckedUpdateManyWithoutActivityNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutParentActivityNestedInput
    contacts?: ActivityContactJoinUncheckedUpdateManyWithoutActivityRelationNestedInput
    users?: ActivityUserJoinUncheckedUpdateManyWithoutActivityRelationNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutActivityNestedInput
    notes?: NoteUncheckedUpdateManyWithoutActivityNestedInput
    events?: ContactTimelineEventUncheckedUpdateManyWithoutActivityNestedInput
  }

  export type ActivityUpsertWithWhereUniqueWithoutParentWaypointInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutParentWaypointInput, ActivityUncheckedUpdateWithoutParentWaypointInput>
    create: XOR<ActivityCreateWithoutParentWaypointInput, ActivityUncheckedCreateWithoutParentWaypointInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutParentWaypointInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutParentWaypointInput, ActivityUncheckedUpdateWithoutParentWaypointInput>
  }

  export type ActivityUpdateManyWithWhereWithoutParentWaypointInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutParentWaypointInput>
  }

  export type ActivityWaypointTemplateUpsertWithoutWaypointsInput = {
    update: XOR<ActivityWaypointTemplateUpdateWithoutWaypointsInput, ActivityWaypointTemplateUncheckedUpdateWithoutWaypointsInput>
    create: XOR<ActivityWaypointTemplateCreateWithoutWaypointsInput, ActivityWaypointTemplateUncheckedCreateWithoutWaypointsInput>
    where?: ActivityWaypointTemplateWhereInput
  }

  export type ActivityWaypointTemplateUpdateToOneWithWhereWithoutWaypointsInput = {
    where?: ActivityWaypointTemplateWhereInput
    data: XOR<ActivityWaypointTemplateUpdateWithoutWaypointsInput, ActivityWaypointTemplateUncheckedUpdateWithoutWaypointsInput>
  }

  export type ActivityWaypointTemplateUpdateWithoutWaypointsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultStatus?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    order?: IntFieldUpdateOperationsInput | number
    dateOffsetType?: EnumDateOffsetTypeFieldUpdateOperationsInput | $Enums.DateOffsetType
    dueDate?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentActivity?: ActivityTemplateUpdateOneRequiredWithoutWaypointsNestedInput
    activities?: ActivityTemplateUpdateManyWithoutParentWaypointNestedInput
    assignments?: TemplateAssignmentUpdateManyWithoutWaypointTemplateNestedInput
    tenet?: TenetUpdateOneRequiredWithoutActivityWaypointTemplatesNestedInput
  }

  export type ActivityWaypointTemplateUncheckedUpdateWithoutWaypointsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultStatus?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    order?: IntFieldUpdateOperationsInput | number
    dateOffsetType?: EnumDateOffsetTypeFieldUpdateOperationsInput | $Enums.DateOffsetType
    dueDate?: IntFieldUpdateOperationsInput | number
    parentActivityId?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    activities?: ActivityTemplateUncheckedUpdateManyWithoutParentWaypointNestedInput
    assignments?: TemplateAssignmentUncheckedUpdateManyWithoutWaypointTemplateNestedInput
  }

  export type ContactTimelineEventUpsertWithWhereUniqueWithoutWaypointInput = {
    where: ContactTimelineEventWhereUniqueInput
    update: XOR<ContactTimelineEventUpdateWithoutWaypointInput, ContactTimelineEventUncheckedUpdateWithoutWaypointInput>
    create: XOR<ContactTimelineEventCreateWithoutWaypointInput, ContactTimelineEventUncheckedCreateWithoutWaypointInput>
  }

  export type ContactTimelineEventUpdateWithWhereUniqueWithoutWaypointInput = {
    where: ContactTimelineEventWhereUniqueInput
    data: XOR<ContactTimelineEventUpdateWithoutWaypointInput, ContactTimelineEventUncheckedUpdateWithoutWaypointInput>
  }

  export type ContactTimelineEventUpdateManyWithWhereWithoutWaypointInput = {
    where: ContactTimelineEventScalarWhereInput
    data: XOR<ContactTimelineEventUpdateManyMutationInput, ContactTimelineEventUncheckedUpdateManyWithoutWaypointInput>
  }

  export type TenetUpsertWithoutActivityWaypointsInput = {
    update: XOR<TenetUpdateWithoutActivityWaypointsInput, TenetUncheckedUpdateWithoutActivityWaypointsInput>
    create: XOR<TenetCreateWithoutActivityWaypointsInput, TenetUncheckedCreateWithoutActivityWaypointsInput>
    where?: TenetWhereInput
  }

  export type TenetUpdateToOneWithWhereWithoutActivityWaypointsInput = {
    where?: TenetWhereInput
    data: XOR<TenetUpdateWithoutActivityWaypointsInput, TenetUncheckedUpdateWithoutActivityWaypointsInput>
  }

  export type TenetUpdateWithoutActivityWaypointsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenetNestedInput
    logs?: LogUpdateManyWithoutTenetNestedInput
    contacts?: ContactUpdateManyWithoutTenetNestedInput
    activities?: ActivityUpdateManyWithoutTenetNestedInput
    addresses?: AddressUpdateManyWithoutTenetNestedInput
    contactEmails?: ContactEmailUpdateManyWithoutTenetNestedInput
    contactPhones?: ContactPhoneUpdateManyWithoutTenetNestedInput
    importantDates?: ImportantDateUpdateManyWithoutTenetNestedInput
    attachments?: AttachmentUpdateManyWithoutTenetNestedInput
    notes?: NoteUpdateManyWithoutTenetNestedInput
    auditEvents?: AuditEventUpdateManyWithoutTenetNestedInput
    contactTimelineEvents?: ContactTimelineEventUpdateManyWithoutTenetNestedInput
    activitySteps?: ActivityStepUpdateManyWithoutTenetNestedInput
    templateAssignments?: TemplateAssignmentUpdateManyWithoutTenetNestedInput
    activityWaypointTemplates?: ActivityWaypointTemplateUpdateManyWithoutTenetNestedInput
    activityTemplates?: ActivityTemplateUpdateManyWithoutTenetNestedInput
    activityTemplateSteps?: ActivityTemplateStepUpdateManyWithoutTenetNestedInput
    opportunities?: OpportunityUpdateManyWithoutTenetNestedInput
    products?: ProductTypeUpdateManyWithoutTenetNestedInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentUpdateManyWithoutTenetNestedInput
  }

  export type TenetUncheckedUpdateWithoutActivityWaypointsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenetNestedInput
    logs?: LogUncheckedUpdateManyWithoutTenetNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutTenetNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutTenetNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutTenetNestedInput
    contactEmails?: ContactEmailUncheckedUpdateManyWithoutTenetNestedInput
    contactPhones?: ContactPhoneUncheckedUpdateManyWithoutTenetNestedInput
    importantDates?: ImportantDateUncheckedUpdateManyWithoutTenetNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTenetNestedInput
    notes?: NoteUncheckedUpdateManyWithoutTenetNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutTenetNestedInput
    contactTimelineEvents?: ContactTimelineEventUncheckedUpdateManyWithoutTenetNestedInput
    activitySteps?: ActivityStepUncheckedUpdateManyWithoutTenetNestedInput
    templateAssignments?: TemplateAssignmentUncheckedUpdateManyWithoutTenetNestedInput
    activityWaypointTemplates?: ActivityWaypointTemplateUncheckedUpdateManyWithoutTenetNestedInput
    activityTemplates?: ActivityTemplateUncheckedUpdateManyWithoutTenetNestedInput
    activityTemplateSteps?: ActivityTemplateStepUncheckedUpdateManyWithoutTenetNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutTenetNestedInput
    products?: ProductTypeUncheckedUpdateManyWithoutTenetNestedInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentUncheckedUpdateManyWithoutTenetNestedInput
  }

  export type NoteUpsertWithWhereUniqueWithoutWaypointInput = {
    where: NoteWhereUniqueInput
    update: XOR<NoteUpdateWithoutWaypointInput, NoteUncheckedUpdateWithoutWaypointInput>
    create: XOR<NoteCreateWithoutWaypointInput, NoteUncheckedCreateWithoutWaypointInput>
  }

  export type NoteUpdateWithWhereUniqueWithoutWaypointInput = {
    where: NoteWhereUniqueInput
    data: XOR<NoteUpdateWithoutWaypointInput, NoteUncheckedUpdateWithoutWaypointInput>
  }

  export type NoteUpdateManyWithWhereWithoutWaypointInput = {
    where: NoteScalarWhereInput
    data: XOR<NoteUpdateManyMutationInput, NoteUncheckedUpdateManyWithoutWaypointInput>
  }

  export type UserCreateWithoutTemplateAssignmentsInput = {
    id: Uint8Array
    email: string
    firstName: string
    lastName: string
    fullName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password: string
    enabled?: boolean
    type?: $Enums.AccessGroup
    system?: boolean
    deleted?: boolean
    deletedAt?: Date | string | null
    tokens?: TokenCreateNestedManyWithoutUserInput
    tenet?: TenetCreateNestedOneWithoutUsersInput
    activities?: ActivityUserJoinCreateNestedManyWithoutUserRelationInput
    notes?: NoteCreateNestedManyWithoutAuthorInput
    waypoints?: UserWaypointJoinCreateNestedManyWithoutUserRelationInput
    events?: ContactTimelineEventCreateNestedManyWithoutUserInput
    auditEvents?: AuditEventCreateNestedManyWithoutUserInput
    assignedActivities?: ActivityCreateNestedManyWithoutAssignedByInput
    opportunities?: UserOpportunityJoinCreateNestedManyWithoutUserRelationInput
    activitySteps?: ActivityStepUserJoinCreateNestedManyWithoutUserRelationInput
    templateStepAssignments?: ActivityTemplateStepAssignmentCreateNestedManyWithoutSpecificUserInput
  }

  export type UserUncheckedCreateWithoutTemplateAssignmentsInput = {
    id: Uint8Array
    email: string
    firstName: string
    lastName: string
    fullName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password: string
    enabled?: boolean
    type?: $Enums.AccessGroup
    tenetId?: Uint8Array | null
    system?: boolean
    deleted?: boolean
    deletedAt?: Date | string | null
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUserJoinUncheckedCreateNestedManyWithoutUserRelationInput
    notes?: NoteUncheckedCreateNestedManyWithoutAuthorInput
    waypoints?: UserWaypointJoinUncheckedCreateNestedManyWithoutUserRelationInput
    events?: ContactTimelineEventUncheckedCreateNestedManyWithoutUserInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutUserInput
    assignedActivities?: ActivityUncheckedCreateNestedManyWithoutAssignedByInput
    opportunities?: UserOpportunityJoinUncheckedCreateNestedManyWithoutUserRelationInput
    activitySteps?: ActivityStepUserJoinUncheckedCreateNestedManyWithoutUserRelationInput
    templateStepAssignments?: ActivityTemplateStepAssignmentUncheckedCreateNestedManyWithoutSpecificUserInput
  }

  export type UserCreateOrConnectWithoutTemplateAssignmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTemplateAssignmentsInput, UserUncheckedCreateWithoutTemplateAssignmentsInput>
  }

  export type ActivityTemplateCreateWithoutAssignmentsInput = {
    id: Uint8Array
    title: string
    description?: string | null
    type: $Enums.ActivityType
    defaultPriority: $Enums.ActivityPriority
    defaultStatus: $Enums.ActivityStatus
    taskScheduleType?: $Enums.TaskScheduleType | null
    dateOffsetType: $Enums.DateOffsetType
    startDate: number
    endDate: number
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: number | null
    steps?: ActivityTemplateStepCreateNestedManyWithoutActivityTemplateInput
    startRelativeTo?: ActivityTemplateCreateNestedOneWithoutDependentsInput
    dependents?: ActivityTemplateCreateNestedManyWithoutStartRelativeToInput
    parentWaypoint?: ActivityWaypointTemplateCreateNestedOneWithoutActivitiesInput
    parentActivity?: ActivityTemplateCreateNestedOneWithoutChildActivitiesInput
    waypoints?: ActivityWaypointTemplateCreateNestedManyWithoutParentActivityInput
    childActivities?: ActivityTemplateCreateNestedManyWithoutParentActivityInput
    activities?: ActivityCreateNestedManyWithoutTemplateInput
    tenet: TenetCreateNestedOneWithoutActivityTemplatesInput
  }

  export type ActivityTemplateUncheckedCreateWithoutAssignmentsInput = {
    id: Uint8Array
    title: string
    description?: string | null
    type: $Enums.ActivityType
    defaultPriority: $Enums.ActivityPriority
    defaultStatus: $Enums.ActivityStatus
    taskScheduleType?: $Enums.TaskScheduleType | null
    dateOffsetType: $Enums.DateOffsetType
    startDate: number
    endDate: number
    startRelativeToId?: Uint8Array | null
    parentWaypointId?: Uint8Array | null
    parentActivityId?: Uint8Array | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
    order?: number | null
    steps?: ActivityTemplateStepUncheckedCreateNestedManyWithoutActivityTemplateInput
    dependents?: ActivityTemplateUncheckedCreateNestedManyWithoutStartRelativeToInput
    waypoints?: ActivityWaypointTemplateUncheckedCreateNestedManyWithoutParentActivityInput
    childActivities?: ActivityTemplateUncheckedCreateNestedManyWithoutParentActivityInput
    activities?: ActivityUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type ActivityTemplateCreateOrConnectWithoutAssignmentsInput = {
    where: ActivityTemplateWhereUniqueInput
    create: XOR<ActivityTemplateCreateWithoutAssignmentsInput, ActivityTemplateUncheckedCreateWithoutAssignmentsInput>
  }

  export type ActivityWaypointTemplateCreateWithoutAssignmentsInput = {
    id: Uint8Array
    title: string
    description?: string | null
    defaultStatus: $Enums.ActivityStatus
    order: number
    dateOffsetType: $Enums.DateOffsetType
    dueDate: number
    createdAt?: Date | string
    updatedAt?: Date | string
    parentActivity: ActivityTemplateCreateNestedOneWithoutWaypointsInput
    activities?: ActivityTemplateCreateNestedManyWithoutParentWaypointInput
    waypoints?: ActivityWaypointCreateNestedManyWithoutTemplateInput
    tenet: TenetCreateNestedOneWithoutActivityWaypointTemplatesInput
  }

  export type ActivityWaypointTemplateUncheckedCreateWithoutAssignmentsInput = {
    id: Uint8Array
    title: string
    description?: string | null
    defaultStatus: $Enums.ActivityStatus
    order: number
    dateOffsetType: $Enums.DateOffsetType
    dueDate: number
    parentActivityId: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
    activities?: ActivityTemplateUncheckedCreateNestedManyWithoutParentWaypointInput
    waypoints?: ActivityWaypointUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type ActivityWaypointTemplateCreateOrConnectWithoutAssignmentsInput = {
    where: ActivityWaypointTemplateWhereUniqueInput
    create: XOR<ActivityWaypointTemplateCreateWithoutAssignmentsInput, ActivityWaypointTemplateUncheckedCreateWithoutAssignmentsInput>
  }

  export type TenetCreateWithoutTemplateAssignmentsInput = {
    id: Uint8Array
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenetInput
    logs?: LogCreateNestedManyWithoutTenetInput
    contacts?: ContactCreateNestedManyWithoutTenetInput
    activities?: ActivityCreateNestedManyWithoutTenetInput
    addresses?: AddressCreateNestedManyWithoutTenetInput
    contactEmails?: ContactEmailCreateNestedManyWithoutTenetInput
    contactPhones?: ContactPhoneCreateNestedManyWithoutTenetInput
    importantDates?: ImportantDateCreateNestedManyWithoutTenetInput
    attachments?: AttachmentCreateNestedManyWithoutTenetInput
    notes?: NoteCreateNestedManyWithoutTenetInput
    auditEvents?: AuditEventCreateNestedManyWithoutTenetInput
    contactTimelineEvents?: ContactTimelineEventCreateNestedManyWithoutTenetInput
    activitySteps?: ActivityStepCreateNestedManyWithoutTenetInput
    activityWaypoints?: ActivityWaypointCreateNestedManyWithoutTenetInput
    activityWaypointTemplates?: ActivityWaypointTemplateCreateNestedManyWithoutTenetInput
    activityTemplates?: ActivityTemplateCreateNestedManyWithoutTenetInput
    activityTemplateSteps?: ActivityTemplateStepCreateNestedManyWithoutTenetInput
    opportunities?: OpportunityCreateNestedManyWithoutTenetInput
    products?: ProductTypeCreateNestedManyWithoutTenetInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentCreateNestedManyWithoutTenetInput
  }

  export type TenetUncheckedCreateWithoutTemplateAssignmentsInput = {
    id: Uint8Array
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenetInput
    logs?: LogUncheckedCreateNestedManyWithoutTenetInput
    contacts?: ContactUncheckedCreateNestedManyWithoutTenetInput
    activities?: ActivityUncheckedCreateNestedManyWithoutTenetInput
    addresses?: AddressUncheckedCreateNestedManyWithoutTenetInput
    contactEmails?: ContactEmailUncheckedCreateNestedManyWithoutTenetInput
    contactPhones?: ContactPhoneUncheckedCreateNestedManyWithoutTenetInput
    importantDates?: ImportantDateUncheckedCreateNestedManyWithoutTenetInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTenetInput
    notes?: NoteUncheckedCreateNestedManyWithoutTenetInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutTenetInput
    contactTimelineEvents?: ContactTimelineEventUncheckedCreateNestedManyWithoutTenetInput
    activitySteps?: ActivityStepUncheckedCreateNestedManyWithoutTenetInput
    activityWaypoints?: ActivityWaypointUncheckedCreateNestedManyWithoutTenetInput
    activityWaypointTemplates?: ActivityWaypointTemplateUncheckedCreateNestedManyWithoutTenetInput
    activityTemplates?: ActivityTemplateUncheckedCreateNestedManyWithoutTenetInput
    activityTemplateSteps?: ActivityTemplateStepUncheckedCreateNestedManyWithoutTenetInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutTenetInput
    products?: ProductTypeUncheckedCreateNestedManyWithoutTenetInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentUncheckedCreateNestedManyWithoutTenetInput
  }

  export type TenetCreateOrConnectWithoutTemplateAssignmentsInput = {
    where: TenetWhereUniqueInput
    create: XOR<TenetCreateWithoutTemplateAssignmentsInput, TenetUncheckedCreateWithoutTemplateAssignmentsInput>
  }

  export type UserUpsertWithoutTemplateAssignmentsInput = {
    update: XOR<UserUpdateWithoutTemplateAssignmentsInput, UserUncheckedUpdateWithoutTemplateAssignmentsInput>
    create: XOR<UserCreateWithoutTemplateAssignmentsInput, UserUncheckedCreateWithoutTemplateAssignmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTemplateAssignmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTemplateAssignmentsInput, UserUncheckedUpdateWithoutTemplateAssignmentsInput>
  }

  export type UserUpdateWithoutTemplateAssignmentsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumAccessGroupFieldUpdateOperationsInput | $Enums.AccessGroup
    system?: BoolFieldUpdateOperationsInput | boolean
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokens?: TokenUpdateManyWithoutUserNestedInput
    tenet?: TenetUpdateOneWithoutUsersNestedInput
    activities?: ActivityUserJoinUpdateManyWithoutUserRelationNestedInput
    notes?: NoteUpdateManyWithoutAuthorNestedInput
    waypoints?: UserWaypointJoinUpdateManyWithoutUserRelationNestedInput
    events?: ContactTimelineEventUpdateManyWithoutUserNestedInput
    auditEvents?: AuditEventUpdateManyWithoutUserNestedInput
    assignedActivities?: ActivityUpdateManyWithoutAssignedByNestedInput
    opportunities?: UserOpportunityJoinUpdateManyWithoutUserRelationNestedInput
    activitySteps?: ActivityStepUserJoinUpdateManyWithoutUserRelationNestedInput
    templateStepAssignments?: ActivityTemplateStepAssignmentUpdateManyWithoutSpecificUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTemplateAssignmentsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumAccessGroupFieldUpdateOperationsInput | $Enums.AccessGroup
    tenetId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    system?: BoolFieldUpdateOperationsInput | boolean
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUserJoinUncheckedUpdateManyWithoutUserRelationNestedInput
    notes?: NoteUncheckedUpdateManyWithoutAuthorNestedInput
    waypoints?: UserWaypointJoinUncheckedUpdateManyWithoutUserRelationNestedInput
    events?: ContactTimelineEventUncheckedUpdateManyWithoutUserNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutUserNestedInput
    assignedActivities?: ActivityUncheckedUpdateManyWithoutAssignedByNestedInput
    opportunities?: UserOpportunityJoinUncheckedUpdateManyWithoutUserRelationNestedInput
    activitySteps?: ActivityStepUserJoinUncheckedUpdateManyWithoutUserRelationNestedInput
    templateStepAssignments?: ActivityTemplateStepAssignmentUncheckedUpdateManyWithoutSpecificUserNestedInput
  }

  export type ActivityTemplateUpsertWithoutAssignmentsInput = {
    update: XOR<ActivityTemplateUpdateWithoutAssignmentsInput, ActivityTemplateUncheckedUpdateWithoutAssignmentsInput>
    create: XOR<ActivityTemplateCreateWithoutAssignmentsInput, ActivityTemplateUncheckedCreateWithoutAssignmentsInput>
    where?: ActivityTemplateWhereInput
  }

  export type ActivityTemplateUpdateToOneWithWhereWithoutAssignmentsInput = {
    where?: ActivityTemplateWhereInput
    data: XOR<ActivityTemplateUpdateWithoutAssignmentsInput, ActivityTemplateUncheckedUpdateWithoutAssignmentsInput>
  }

  export type ActivityTemplateUpdateWithoutAssignmentsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    defaultPriority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    defaultStatus?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    dateOffsetType?: EnumDateOffsetTypeFieldUpdateOperationsInput | $Enums.DateOffsetType
    startDate?: IntFieldUpdateOperationsInput | number
    endDate?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    steps?: ActivityTemplateStepUpdateManyWithoutActivityTemplateNestedInput
    startRelativeTo?: ActivityTemplateUpdateOneWithoutDependentsNestedInput
    dependents?: ActivityTemplateUpdateManyWithoutStartRelativeToNestedInput
    parentWaypoint?: ActivityWaypointTemplateUpdateOneWithoutActivitiesNestedInput
    parentActivity?: ActivityTemplateUpdateOneWithoutChildActivitiesNestedInput
    waypoints?: ActivityWaypointTemplateUpdateManyWithoutParentActivityNestedInput
    childActivities?: ActivityTemplateUpdateManyWithoutParentActivityNestedInput
    activities?: ActivityUpdateManyWithoutTemplateNestedInput
    tenet?: TenetUpdateOneRequiredWithoutActivityTemplatesNestedInput
  }

  export type ActivityTemplateUncheckedUpdateWithoutAssignmentsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    defaultPriority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    defaultStatus?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    dateOffsetType?: EnumDateOffsetTypeFieldUpdateOperationsInput | $Enums.DateOffsetType
    startDate?: IntFieldUpdateOperationsInput | number
    endDate?: IntFieldUpdateOperationsInput | number
    startRelativeToId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    parentWaypointId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    parentActivityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    order?: NullableIntFieldUpdateOperationsInput | number | null
    steps?: ActivityTemplateStepUncheckedUpdateManyWithoutActivityTemplateNestedInput
    dependents?: ActivityTemplateUncheckedUpdateManyWithoutStartRelativeToNestedInput
    waypoints?: ActivityWaypointTemplateUncheckedUpdateManyWithoutParentActivityNestedInput
    childActivities?: ActivityTemplateUncheckedUpdateManyWithoutParentActivityNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type ActivityWaypointTemplateUpsertWithoutAssignmentsInput = {
    update: XOR<ActivityWaypointTemplateUpdateWithoutAssignmentsInput, ActivityWaypointTemplateUncheckedUpdateWithoutAssignmentsInput>
    create: XOR<ActivityWaypointTemplateCreateWithoutAssignmentsInput, ActivityWaypointTemplateUncheckedCreateWithoutAssignmentsInput>
    where?: ActivityWaypointTemplateWhereInput
  }

  export type ActivityWaypointTemplateUpdateToOneWithWhereWithoutAssignmentsInput = {
    where?: ActivityWaypointTemplateWhereInput
    data: XOR<ActivityWaypointTemplateUpdateWithoutAssignmentsInput, ActivityWaypointTemplateUncheckedUpdateWithoutAssignmentsInput>
  }

  export type ActivityWaypointTemplateUpdateWithoutAssignmentsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultStatus?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    order?: IntFieldUpdateOperationsInput | number
    dateOffsetType?: EnumDateOffsetTypeFieldUpdateOperationsInput | $Enums.DateOffsetType
    dueDate?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentActivity?: ActivityTemplateUpdateOneRequiredWithoutWaypointsNestedInput
    activities?: ActivityTemplateUpdateManyWithoutParentWaypointNestedInput
    waypoints?: ActivityWaypointUpdateManyWithoutTemplateNestedInput
    tenet?: TenetUpdateOneRequiredWithoutActivityWaypointTemplatesNestedInput
  }

  export type ActivityWaypointTemplateUncheckedUpdateWithoutAssignmentsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultStatus?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    order?: IntFieldUpdateOperationsInput | number
    dateOffsetType?: EnumDateOffsetTypeFieldUpdateOperationsInput | $Enums.DateOffsetType
    dueDate?: IntFieldUpdateOperationsInput | number
    parentActivityId?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    activities?: ActivityTemplateUncheckedUpdateManyWithoutParentWaypointNestedInput
    waypoints?: ActivityWaypointUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type TenetUpsertWithoutTemplateAssignmentsInput = {
    update: XOR<TenetUpdateWithoutTemplateAssignmentsInput, TenetUncheckedUpdateWithoutTemplateAssignmentsInput>
    create: XOR<TenetCreateWithoutTemplateAssignmentsInput, TenetUncheckedCreateWithoutTemplateAssignmentsInput>
    where?: TenetWhereInput
  }

  export type TenetUpdateToOneWithWhereWithoutTemplateAssignmentsInput = {
    where?: TenetWhereInput
    data: XOR<TenetUpdateWithoutTemplateAssignmentsInput, TenetUncheckedUpdateWithoutTemplateAssignmentsInput>
  }

  export type TenetUpdateWithoutTemplateAssignmentsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenetNestedInput
    logs?: LogUpdateManyWithoutTenetNestedInput
    contacts?: ContactUpdateManyWithoutTenetNestedInput
    activities?: ActivityUpdateManyWithoutTenetNestedInput
    addresses?: AddressUpdateManyWithoutTenetNestedInput
    contactEmails?: ContactEmailUpdateManyWithoutTenetNestedInput
    contactPhones?: ContactPhoneUpdateManyWithoutTenetNestedInput
    importantDates?: ImportantDateUpdateManyWithoutTenetNestedInput
    attachments?: AttachmentUpdateManyWithoutTenetNestedInput
    notes?: NoteUpdateManyWithoutTenetNestedInput
    auditEvents?: AuditEventUpdateManyWithoutTenetNestedInput
    contactTimelineEvents?: ContactTimelineEventUpdateManyWithoutTenetNestedInput
    activitySteps?: ActivityStepUpdateManyWithoutTenetNestedInput
    activityWaypoints?: ActivityWaypointUpdateManyWithoutTenetNestedInput
    activityWaypointTemplates?: ActivityWaypointTemplateUpdateManyWithoutTenetNestedInput
    activityTemplates?: ActivityTemplateUpdateManyWithoutTenetNestedInput
    activityTemplateSteps?: ActivityTemplateStepUpdateManyWithoutTenetNestedInput
    opportunities?: OpportunityUpdateManyWithoutTenetNestedInput
    products?: ProductTypeUpdateManyWithoutTenetNestedInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentUpdateManyWithoutTenetNestedInput
  }

  export type TenetUncheckedUpdateWithoutTemplateAssignmentsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenetNestedInput
    logs?: LogUncheckedUpdateManyWithoutTenetNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutTenetNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutTenetNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutTenetNestedInput
    contactEmails?: ContactEmailUncheckedUpdateManyWithoutTenetNestedInput
    contactPhones?: ContactPhoneUncheckedUpdateManyWithoutTenetNestedInput
    importantDates?: ImportantDateUncheckedUpdateManyWithoutTenetNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTenetNestedInput
    notes?: NoteUncheckedUpdateManyWithoutTenetNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutTenetNestedInput
    contactTimelineEvents?: ContactTimelineEventUncheckedUpdateManyWithoutTenetNestedInput
    activitySteps?: ActivityStepUncheckedUpdateManyWithoutTenetNestedInput
    activityWaypoints?: ActivityWaypointUncheckedUpdateManyWithoutTenetNestedInput
    activityWaypointTemplates?: ActivityWaypointTemplateUncheckedUpdateManyWithoutTenetNestedInput
    activityTemplates?: ActivityTemplateUncheckedUpdateManyWithoutTenetNestedInput
    activityTemplateSteps?: ActivityTemplateStepUncheckedUpdateManyWithoutTenetNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutTenetNestedInput
    products?: ProductTypeUncheckedUpdateManyWithoutTenetNestedInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentUncheckedUpdateManyWithoutTenetNestedInput
  }

  export type ActivityTemplateCreateWithoutWaypointsInput = {
    id: Uint8Array
    title: string
    description?: string | null
    type: $Enums.ActivityType
    defaultPriority: $Enums.ActivityPriority
    defaultStatus: $Enums.ActivityStatus
    taskScheduleType?: $Enums.TaskScheduleType | null
    dateOffsetType: $Enums.DateOffsetType
    startDate: number
    endDate: number
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: number | null
    steps?: ActivityTemplateStepCreateNestedManyWithoutActivityTemplateInput
    startRelativeTo?: ActivityTemplateCreateNestedOneWithoutDependentsInput
    dependents?: ActivityTemplateCreateNestedManyWithoutStartRelativeToInput
    parentWaypoint?: ActivityWaypointTemplateCreateNestedOneWithoutActivitiesInput
    parentActivity?: ActivityTemplateCreateNestedOneWithoutChildActivitiesInput
    childActivities?: ActivityTemplateCreateNestedManyWithoutParentActivityInput
    activities?: ActivityCreateNestedManyWithoutTemplateInput
    assignments?: TemplateAssignmentCreateNestedManyWithoutActivityTemplateInput
    tenet: TenetCreateNestedOneWithoutActivityTemplatesInput
  }

  export type ActivityTemplateUncheckedCreateWithoutWaypointsInput = {
    id: Uint8Array
    title: string
    description?: string | null
    type: $Enums.ActivityType
    defaultPriority: $Enums.ActivityPriority
    defaultStatus: $Enums.ActivityStatus
    taskScheduleType?: $Enums.TaskScheduleType | null
    dateOffsetType: $Enums.DateOffsetType
    startDate: number
    endDate: number
    startRelativeToId?: Uint8Array | null
    parentWaypointId?: Uint8Array | null
    parentActivityId?: Uint8Array | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
    order?: number | null
    steps?: ActivityTemplateStepUncheckedCreateNestedManyWithoutActivityTemplateInput
    dependents?: ActivityTemplateUncheckedCreateNestedManyWithoutStartRelativeToInput
    childActivities?: ActivityTemplateUncheckedCreateNestedManyWithoutParentActivityInput
    activities?: ActivityUncheckedCreateNestedManyWithoutTemplateInput
    assignments?: TemplateAssignmentUncheckedCreateNestedManyWithoutActivityTemplateInput
  }

  export type ActivityTemplateCreateOrConnectWithoutWaypointsInput = {
    where: ActivityTemplateWhereUniqueInput
    create: XOR<ActivityTemplateCreateWithoutWaypointsInput, ActivityTemplateUncheckedCreateWithoutWaypointsInput>
  }

  export type ActivityTemplateCreateWithoutParentWaypointInput = {
    id: Uint8Array
    title: string
    description?: string | null
    type: $Enums.ActivityType
    defaultPriority: $Enums.ActivityPriority
    defaultStatus: $Enums.ActivityStatus
    taskScheduleType?: $Enums.TaskScheduleType | null
    dateOffsetType: $Enums.DateOffsetType
    startDate: number
    endDate: number
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: number | null
    steps?: ActivityTemplateStepCreateNestedManyWithoutActivityTemplateInput
    startRelativeTo?: ActivityTemplateCreateNestedOneWithoutDependentsInput
    dependents?: ActivityTemplateCreateNestedManyWithoutStartRelativeToInput
    parentActivity?: ActivityTemplateCreateNestedOneWithoutChildActivitiesInput
    waypoints?: ActivityWaypointTemplateCreateNestedManyWithoutParentActivityInput
    childActivities?: ActivityTemplateCreateNestedManyWithoutParentActivityInput
    activities?: ActivityCreateNestedManyWithoutTemplateInput
    assignments?: TemplateAssignmentCreateNestedManyWithoutActivityTemplateInput
    tenet: TenetCreateNestedOneWithoutActivityTemplatesInput
  }

  export type ActivityTemplateUncheckedCreateWithoutParentWaypointInput = {
    id: Uint8Array
    title: string
    description?: string | null
    type: $Enums.ActivityType
    defaultPriority: $Enums.ActivityPriority
    defaultStatus: $Enums.ActivityStatus
    taskScheduleType?: $Enums.TaskScheduleType | null
    dateOffsetType: $Enums.DateOffsetType
    startDate: number
    endDate: number
    startRelativeToId?: Uint8Array | null
    parentActivityId?: Uint8Array | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
    order?: number | null
    steps?: ActivityTemplateStepUncheckedCreateNestedManyWithoutActivityTemplateInput
    dependents?: ActivityTemplateUncheckedCreateNestedManyWithoutStartRelativeToInput
    waypoints?: ActivityWaypointTemplateUncheckedCreateNestedManyWithoutParentActivityInput
    childActivities?: ActivityTemplateUncheckedCreateNestedManyWithoutParentActivityInput
    activities?: ActivityUncheckedCreateNestedManyWithoutTemplateInput
    assignments?: TemplateAssignmentUncheckedCreateNestedManyWithoutActivityTemplateInput
  }

  export type ActivityTemplateCreateOrConnectWithoutParentWaypointInput = {
    where: ActivityTemplateWhereUniqueInput
    create: XOR<ActivityTemplateCreateWithoutParentWaypointInput, ActivityTemplateUncheckedCreateWithoutParentWaypointInput>
  }

  export type ActivityTemplateCreateManyParentWaypointInputEnvelope = {
    data: ActivityTemplateCreateManyParentWaypointInput | ActivityTemplateCreateManyParentWaypointInput[]
    skipDuplicates?: boolean
  }

  export type ActivityWaypointCreateWithoutTemplateInput = {
    id: Uint8Array
    title: string
    description?: string | null
    summary?: string | null
    status: $Enums.ActivityStatus
    order: number
    actualStart: Date | string
    dueDate: Date | string
    actualEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserWaypointJoinCreateNestedManyWithoutWaypointRelationInput
    activity: ActivityCreateNestedOneWithoutWaypointsInput
    childActivities?: ActivityCreateNestedManyWithoutParentWaypointInput
    events?: ContactTimelineEventCreateNestedManyWithoutWaypointInput
    tenet: TenetCreateNestedOneWithoutActivityWaypointsInput
    Note?: NoteCreateNestedManyWithoutWaypointInput
  }

  export type ActivityWaypointUncheckedCreateWithoutTemplateInput = {
    id: Uint8Array
    title: string
    description?: string | null
    summary?: string | null
    status: $Enums.ActivityStatus
    order: number
    actualStart: Date | string
    dueDate: Date | string
    actualEnd?: Date | string | null
    activityId: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
    users?: UserWaypointJoinUncheckedCreateNestedManyWithoutWaypointRelationInput
    childActivities?: ActivityUncheckedCreateNestedManyWithoutParentWaypointInput
    events?: ContactTimelineEventUncheckedCreateNestedManyWithoutWaypointInput
    Note?: NoteUncheckedCreateNestedManyWithoutWaypointInput
  }

  export type ActivityWaypointCreateOrConnectWithoutTemplateInput = {
    where: ActivityWaypointWhereUniqueInput
    create: XOR<ActivityWaypointCreateWithoutTemplateInput, ActivityWaypointUncheckedCreateWithoutTemplateInput>
  }

  export type ActivityWaypointCreateManyTemplateInputEnvelope = {
    data: ActivityWaypointCreateManyTemplateInput | ActivityWaypointCreateManyTemplateInput[]
    skipDuplicates?: boolean
  }

  export type TemplateAssignmentCreateWithoutWaypointTemplateInput = {
    id: Uint8Array
    specificRole?: $Enums.Role | null
    createdAt?: Date | string
    updatedAt?: Date | string
    specificUser?: UserCreateNestedOneWithoutTemplateAssignmentsInput
    activityTemplate?: ActivityTemplateCreateNestedOneWithoutAssignmentsInput
    tenet: TenetCreateNestedOneWithoutTemplateAssignmentsInput
  }

  export type TemplateAssignmentUncheckedCreateWithoutWaypointTemplateInput = {
    id: Uint8Array
    specificUserId?: Uint8Array | null
    specificRole?: $Enums.Role | null
    activityTemplateId?: Uint8Array | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
  }

  export type TemplateAssignmentCreateOrConnectWithoutWaypointTemplateInput = {
    where: TemplateAssignmentWhereUniqueInput
    create: XOR<TemplateAssignmentCreateWithoutWaypointTemplateInput, TemplateAssignmentUncheckedCreateWithoutWaypointTemplateInput>
  }

  export type TemplateAssignmentCreateManyWaypointTemplateInputEnvelope = {
    data: TemplateAssignmentCreateManyWaypointTemplateInput | TemplateAssignmentCreateManyWaypointTemplateInput[]
    skipDuplicates?: boolean
  }

  export type TenetCreateWithoutActivityWaypointTemplatesInput = {
    id: Uint8Array
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenetInput
    logs?: LogCreateNestedManyWithoutTenetInput
    contacts?: ContactCreateNestedManyWithoutTenetInput
    activities?: ActivityCreateNestedManyWithoutTenetInput
    addresses?: AddressCreateNestedManyWithoutTenetInput
    contactEmails?: ContactEmailCreateNestedManyWithoutTenetInput
    contactPhones?: ContactPhoneCreateNestedManyWithoutTenetInput
    importantDates?: ImportantDateCreateNestedManyWithoutTenetInput
    attachments?: AttachmentCreateNestedManyWithoutTenetInput
    notes?: NoteCreateNestedManyWithoutTenetInput
    auditEvents?: AuditEventCreateNestedManyWithoutTenetInput
    contactTimelineEvents?: ContactTimelineEventCreateNestedManyWithoutTenetInput
    activitySteps?: ActivityStepCreateNestedManyWithoutTenetInput
    activityWaypoints?: ActivityWaypointCreateNestedManyWithoutTenetInput
    templateAssignments?: TemplateAssignmentCreateNestedManyWithoutTenetInput
    activityTemplates?: ActivityTemplateCreateNestedManyWithoutTenetInput
    activityTemplateSteps?: ActivityTemplateStepCreateNestedManyWithoutTenetInput
    opportunities?: OpportunityCreateNestedManyWithoutTenetInput
    products?: ProductTypeCreateNestedManyWithoutTenetInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentCreateNestedManyWithoutTenetInput
  }

  export type TenetUncheckedCreateWithoutActivityWaypointTemplatesInput = {
    id: Uint8Array
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenetInput
    logs?: LogUncheckedCreateNestedManyWithoutTenetInput
    contacts?: ContactUncheckedCreateNestedManyWithoutTenetInput
    activities?: ActivityUncheckedCreateNestedManyWithoutTenetInput
    addresses?: AddressUncheckedCreateNestedManyWithoutTenetInput
    contactEmails?: ContactEmailUncheckedCreateNestedManyWithoutTenetInput
    contactPhones?: ContactPhoneUncheckedCreateNestedManyWithoutTenetInput
    importantDates?: ImportantDateUncheckedCreateNestedManyWithoutTenetInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTenetInput
    notes?: NoteUncheckedCreateNestedManyWithoutTenetInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutTenetInput
    contactTimelineEvents?: ContactTimelineEventUncheckedCreateNestedManyWithoutTenetInput
    activitySteps?: ActivityStepUncheckedCreateNestedManyWithoutTenetInput
    activityWaypoints?: ActivityWaypointUncheckedCreateNestedManyWithoutTenetInput
    templateAssignments?: TemplateAssignmentUncheckedCreateNestedManyWithoutTenetInput
    activityTemplates?: ActivityTemplateUncheckedCreateNestedManyWithoutTenetInput
    activityTemplateSteps?: ActivityTemplateStepUncheckedCreateNestedManyWithoutTenetInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutTenetInput
    products?: ProductTypeUncheckedCreateNestedManyWithoutTenetInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentUncheckedCreateNestedManyWithoutTenetInput
  }

  export type TenetCreateOrConnectWithoutActivityWaypointTemplatesInput = {
    where: TenetWhereUniqueInput
    create: XOR<TenetCreateWithoutActivityWaypointTemplatesInput, TenetUncheckedCreateWithoutActivityWaypointTemplatesInput>
  }

  export type ActivityTemplateUpsertWithoutWaypointsInput = {
    update: XOR<ActivityTemplateUpdateWithoutWaypointsInput, ActivityTemplateUncheckedUpdateWithoutWaypointsInput>
    create: XOR<ActivityTemplateCreateWithoutWaypointsInput, ActivityTemplateUncheckedCreateWithoutWaypointsInput>
    where?: ActivityTemplateWhereInput
  }

  export type ActivityTemplateUpdateToOneWithWhereWithoutWaypointsInput = {
    where?: ActivityTemplateWhereInput
    data: XOR<ActivityTemplateUpdateWithoutWaypointsInput, ActivityTemplateUncheckedUpdateWithoutWaypointsInput>
  }

  export type ActivityTemplateUpdateWithoutWaypointsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    defaultPriority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    defaultStatus?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    dateOffsetType?: EnumDateOffsetTypeFieldUpdateOperationsInput | $Enums.DateOffsetType
    startDate?: IntFieldUpdateOperationsInput | number
    endDate?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    steps?: ActivityTemplateStepUpdateManyWithoutActivityTemplateNestedInput
    startRelativeTo?: ActivityTemplateUpdateOneWithoutDependentsNestedInput
    dependents?: ActivityTemplateUpdateManyWithoutStartRelativeToNestedInput
    parentWaypoint?: ActivityWaypointTemplateUpdateOneWithoutActivitiesNestedInput
    parentActivity?: ActivityTemplateUpdateOneWithoutChildActivitiesNestedInput
    childActivities?: ActivityTemplateUpdateManyWithoutParentActivityNestedInput
    activities?: ActivityUpdateManyWithoutTemplateNestedInput
    assignments?: TemplateAssignmentUpdateManyWithoutActivityTemplateNestedInput
    tenet?: TenetUpdateOneRequiredWithoutActivityTemplatesNestedInput
  }

  export type ActivityTemplateUncheckedUpdateWithoutWaypointsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    defaultPriority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    defaultStatus?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    dateOffsetType?: EnumDateOffsetTypeFieldUpdateOperationsInput | $Enums.DateOffsetType
    startDate?: IntFieldUpdateOperationsInput | number
    endDate?: IntFieldUpdateOperationsInput | number
    startRelativeToId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    parentWaypointId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    parentActivityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    order?: NullableIntFieldUpdateOperationsInput | number | null
    steps?: ActivityTemplateStepUncheckedUpdateManyWithoutActivityTemplateNestedInput
    dependents?: ActivityTemplateUncheckedUpdateManyWithoutStartRelativeToNestedInput
    childActivities?: ActivityTemplateUncheckedUpdateManyWithoutParentActivityNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutTemplateNestedInput
    assignments?: TemplateAssignmentUncheckedUpdateManyWithoutActivityTemplateNestedInput
  }

  export type ActivityTemplateUpsertWithWhereUniqueWithoutParentWaypointInput = {
    where: ActivityTemplateWhereUniqueInput
    update: XOR<ActivityTemplateUpdateWithoutParentWaypointInput, ActivityTemplateUncheckedUpdateWithoutParentWaypointInput>
    create: XOR<ActivityTemplateCreateWithoutParentWaypointInput, ActivityTemplateUncheckedCreateWithoutParentWaypointInput>
  }

  export type ActivityTemplateUpdateWithWhereUniqueWithoutParentWaypointInput = {
    where: ActivityTemplateWhereUniqueInput
    data: XOR<ActivityTemplateUpdateWithoutParentWaypointInput, ActivityTemplateUncheckedUpdateWithoutParentWaypointInput>
  }

  export type ActivityTemplateUpdateManyWithWhereWithoutParentWaypointInput = {
    where: ActivityTemplateScalarWhereInput
    data: XOR<ActivityTemplateUpdateManyMutationInput, ActivityTemplateUncheckedUpdateManyWithoutParentWaypointInput>
  }

  export type ActivityWaypointUpsertWithWhereUniqueWithoutTemplateInput = {
    where: ActivityWaypointWhereUniqueInput
    update: XOR<ActivityWaypointUpdateWithoutTemplateInput, ActivityWaypointUncheckedUpdateWithoutTemplateInput>
    create: XOR<ActivityWaypointCreateWithoutTemplateInput, ActivityWaypointUncheckedCreateWithoutTemplateInput>
  }

  export type ActivityWaypointUpdateWithWhereUniqueWithoutTemplateInput = {
    where: ActivityWaypointWhereUniqueInput
    data: XOR<ActivityWaypointUpdateWithoutTemplateInput, ActivityWaypointUncheckedUpdateWithoutTemplateInput>
  }

  export type ActivityWaypointUpdateManyWithWhereWithoutTemplateInput = {
    where: ActivityWaypointScalarWhereInput
    data: XOR<ActivityWaypointUpdateManyMutationInput, ActivityWaypointUncheckedUpdateManyWithoutTemplateInput>
  }

  export type TemplateAssignmentUpsertWithWhereUniqueWithoutWaypointTemplateInput = {
    where: TemplateAssignmentWhereUniqueInput
    update: XOR<TemplateAssignmentUpdateWithoutWaypointTemplateInput, TemplateAssignmentUncheckedUpdateWithoutWaypointTemplateInput>
    create: XOR<TemplateAssignmentCreateWithoutWaypointTemplateInput, TemplateAssignmentUncheckedCreateWithoutWaypointTemplateInput>
  }

  export type TemplateAssignmentUpdateWithWhereUniqueWithoutWaypointTemplateInput = {
    where: TemplateAssignmentWhereUniqueInput
    data: XOR<TemplateAssignmentUpdateWithoutWaypointTemplateInput, TemplateAssignmentUncheckedUpdateWithoutWaypointTemplateInput>
  }

  export type TemplateAssignmentUpdateManyWithWhereWithoutWaypointTemplateInput = {
    where: TemplateAssignmentScalarWhereInput
    data: XOR<TemplateAssignmentUpdateManyMutationInput, TemplateAssignmentUncheckedUpdateManyWithoutWaypointTemplateInput>
  }

  export type TenetUpsertWithoutActivityWaypointTemplatesInput = {
    update: XOR<TenetUpdateWithoutActivityWaypointTemplatesInput, TenetUncheckedUpdateWithoutActivityWaypointTemplatesInput>
    create: XOR<TenetCreateWithoutActivityWaypointTemplatesInput, TenetUncheckedCreateWithoutActivityWaypointTemplatesInput>
    where?: TenetWhereInput
  }

  export type TenetUpdateToOneWithWhereWithoutActivityWaypointTemplatesInput = {
    where?: TenetWhereInput
    data: XOR<TenetUpdateWithoutActivityWaypointTemplatesInput, TenetUncheckedUpdateWithoutActivityWaypointTemplatesInput>
  }

  export type TenetUpdateWithoutActivityWaypointTemplatesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenetNestedInput
    logs?: LogUpdateManyWithoutTenetNestedInput
    contacts?: ContactUpdateManyWithoutTenetNestedInput
    activities?: ActivityUpdateManyWithoutTenetNestedInput
    addresses?: AddressUpdateManyWithoutTenetNestedInput
    contactEmails?: ContactEmailUpdateManyWithoutTenetNestedInput
    contactPhones?: ContactPhoneUpdateManyWithoutTenetNestedInput
    importantDates?: ImportantDateUpdateManyWithoutTenetNestedInput
    attachments?: AttachmentUpdateManyWithoutTenetNestedInput
    notes?: NoteUpdateManyWithoutTenetNestedInput
    auditEvents?: AuditEventUpdateManyWithoutTenetNestedInput
    contactTimelineEvents?: ContactTimelineEventUpdateManyWithoutTenetNestedInput
    activitySteps?: ActivityStepUpdateManyWithoutTenetNestedInput
    activityWaypoints?: ActivityWaypointUpdateManyWithoutTenetNestedInput
    templateAssignments?: TemplateAssignmentUpdateManyWithoutTenetNestedInput
    activityTemplates?: ActivityTemplateUpdateManyWithoutTenetNestedInput
    activityTemplateSteps?: ActivityTemplateStepUpdateManyWithoutTenetNestedInput
    opportunities?: OpportunityUpdateManyWithoutTenetNestedInput
    products?: ProductTypeUpdateManyWithoutTenetNestedInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentUpdateManyWithoutTenetNestedInput
  }

  export type TenetUncheckedUpdateWithoutActivityWaypointTemplatesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenetNestedInput
    logs?: LogUncheckedUpdateManyWithoutTenetNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutTenetNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutTenetNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutTenetNestedInput
    contactEmails?: ContactEmailUncheckedUpdateManyWithoutTenetNestedInput
    contactPhones?: ContactPhoneUncheckedUpdateManyWithoutTenetNestedInput
    importantDates?: ImportantDateUncheckedUpdateManyWithoutTenetNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTenetNestedInput
    notes?: NoteUncheckedUpdateManyWithoutTenetNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutTenetNestedInput
    contactTimelineEvents?: ContactTimelineEventUncheckedUpdateManyWithoutTenetNestedInput
    activitySteps?: ActivityStepUncheckedUpdateManyWithoutTenetNestedInput
    activityWaypoints?: ActivityWaypointUncheckedUpdateManyWithoutTenetNestedInput
    templateAssignments?: TemplateAssignmentUncheckedUpdateManyWithoutTenetNestedInput
    activityTemplates?: ActivityTemplateUncheckedUpdateManyWithoutTenetNestedInput
    activityTemplateSteps?: ActivityTemplateStepUncheckedUpdateManyWithoutTenetNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutTenetNestedInput
    products?: ProductTypeUncheckedUpdateManyWithoutTenetNestedInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentUncheckedUpdateManyWithoutTenetNestedInput
  }

  export type ActivityTemplateCreateWithoutStepsInput = {
    id: Uint8Array
    title: string
    description?: string | null
    type: $Enums.ActivityType
    defaultPriority: $Enums.ActivityPriority
    defaultStatus: $Enums.ActivityStatus
    taskScheduleType?: $Enums.TaskScheduleType | null
    dateOffsetType: $Enums.DateOffsetType
    startDate: number
    endDate: number
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: number | null
    startRelativeTo?: ActivityTemplateCreateNestedOneWithoutDependentsInput
    dependents?: ActivityTemplateCreateNestedManyWithoutStartRelativeToInput
    parentWaypoint?: ActivityWaypointTemplateCreateNestedOneWithoutActivitiesInput
    parentActivity?: ActivityTemplateCreateNestedOneWithoutChildActivitiesInput
    waypoints?: ActivityWaypointTemplateCreateNestedManyWithoutParentActivityInput
    childActivities?: ActivityTemplateCreateNestedManyWithoutParentActivityInput
    activities?: ActivityCreateNestedManyWithoutTemplateInput
    assignments?: TemplateAssignmentCreateNestedManyWithoutActivityTemplateInput
    tenet: TenetCreateNestedOneWithoutActivityTemplatesInput
  }

  export type ActivityTemplateUncheckedCreateWithoutStepsInput = {
    id: Uint8Array
    title: string
    description?: string | null
    type: $Enums.ActivityType
    defaultPriority: $Enums.ActivityPriority
    defaultStatus: $Enums.ActivityStatus
    taskScheduleType?: $Enums.TaskScheduleType | null
    dateOffsetType: $Enums.DateOffsetType
    startDate: number
    endDate: number
    startRelativeToId?: Uint8Array | null
    parentWaypointId?: Uint8Array | null
    parentActivityId?: Uint8Array | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
    order?: number | null
    dependents?: ActivityTemplateUncheckedCreateNestedManyWithoutStartRelativeToInput
    waypoints?: ActivityWaypointTemplateUncheckedCreateNestedManyWithoutParentActivityInput
    childActivities?: ActivityTemplateUncheckedCreateNestedManyWithoutParentActivityInput
    activities?: ActivityUncheckedCreateNestedManyWithoutTemplateInput
    assignments?: TemplateAssignmentUncheckedCreateNestedManyWithoutActivityTemplateInput
  }

  export type ActivityTemplateCreateOrConnectWithoutStepsInput = {
    where: ActivityTemplateWhereUniqueInput
    create: XOR<ActivityTemplateCreateWithoutStepsInput, ActivityTemplateUncheckedCreateWithoutStepsInput>
  }

  export type TenetCreateWithoutActivityTemplateStepsInput = {
    id: Uint8Array
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenetInput
    logs?: LogCreateNestedManyWithoutTenetInput
    contacts?: ContactCreateNestedManyWithoutTenetInput
    activities?: ActivityCreateNestedManyWithoutTenetInput
    addresses?: AddressCreateNestedManyWithoutTenetInput
    contactEmails?: ContactEmailCreateNestedManyWithoutTenetInput
    contactPhones?: ContactPhoneCreateNestedManyWithoutTenetInput
    importantDates?: ImportantDateCreateNestedManyWithoutTenetInput
    attachments?: AttachmentCreateNestedManyWithoutTenetInput
    notes?: NoteCreateNestedManyWithoutTenetInput
    auditEvents?: AuditEventCreateNestedManyWithoutTenetInput
    contactTimelineEvents?: ContactTimelineEventCreateNestedManyWithoutTenetInput
    activitySteps?: ActivityStepCreateNestedManyWithoutTenetInput
    activityWaypoints?: ActivityWaypointCreateNestedManyWithoutTenetInput
    templateAssignments?: TemplateAssignmentCreateNestedManyWithoutTenetInput
    activityWaypointTemplates?: ActivityWaypointTemplateCreateNestedManyWithoutTenetInput
    activityTemplates?: ActivityTemplateCreateNestedManyWithoutTenetInput
    opportunities?: OpportunityCreateNestedManyWithoutTenetInput
    products?: ProductTypeCreateNestedManyWithoutTenetInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentCreateNestedManyWithoutTenetInput
  }

  export type TenetUncheckedCreateWithoutActivityTemplateStepsInput = {
    id: Uint8Array
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenetInput
    logs?: LogUncheckedCreateNestedManyWithoutTenetInput
    contacts?: ContactUncheckedCreateNestedManyWithoutTenetInput
    activities?: ActivityUncheckedCreateNestedManyWithoutTenetInput
    addresses?: AddressUncheckedCreateNestedManyWithoutTenetInput
    contactEmails?: ContactEmailUncheckedCreateNestedManyWithoutTenetInput
    contactPhones?: ContactPhoneUncheckedCreateNestedManyWithoutTenetInput
    importantDates?: ImportantDateUncheckedCreateNestedManyWithoutTenetInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTenetInput
    notes?: NoteUncheckedCreateNestedManyWithoutTenetInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutTenetInput
    contactTimelineEvents?: ContactTimelineEventUncheckedCreateNestedManyWithoutTenetInput
    activitySteps?: ActivityStepUncheckedCreateNestedManyWithoutTenetInput
    activityWaypoints?: ActivityWaypointUncheckedCreateNestedManyWithoutTenetInput
    templateAssignments?: TemplateAssignmentUncheckedCreateNestedManyWithoutTenetInput
    activityWaypointTemplates?: ActivityWaypointTemplateUncheckedCreateNestedManyWithoutTenetInput
    activityTemplates?: ActivityTemplateUncheckedCreateNestedManyWithoutTenetInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutTenetInput
    products?: ProductTypeUncheckedCreateNestedManyWithoutTenetInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentUncheckedCreateNestedManyWithoutTenetInput
  }

  export type TenetCreateOrConnectWithoutActivityTemplateStepsInput = {
    where: TenetWhereUniqueInput
    create: XOR<TenetCreateWithoutActivityTemplateStepsInput, TenetUncheckedCreateWithoutActivityTemplateStepsInput>
  }

  export type ActivityTemplateStepAssignmentCreateWithoutActivityTemplateStepInput = {
    id: Uint8Array
    specificRole?: $Enums.Role | null
    specificUser?: UserCreateNestedOneWithoutTemplateStepAssignmentsInput
    tenet: TenetCreateNestedOneWithoutActivityTemplateStepAssignmentInput
  }

  export type ActivityTemplateStepAssignmentUncheckedCreateWithoutActivityTemplateStepInput = {
    id: Uint8Array
    specificUserId?: Uint8Array | null
    specificRole?: $Enums.Role | null
    tenetId: Uint8Array
  }

  export type ActivityTemplateStepAssignmentCreateOrConnectWithoutActivityTemplateStepInput = {
    where: ActivityTemplateStepAssignmentWhereUniqueInput
    create: XOR<ActivityTemplateStepAssignmentCreateWithoutActivityTemplateStepInput, ActivityTemplateStepAssignmentUncheckedCreateWithoutActivityTemplateStepInput>
  }

  export type ActivityTemplateStepAssignmentCreateManyActivityTemplateStepInputEnvelope = {
    data: ActivityTemplateStepAssignmentCreateManyActivityTemplateStepInput | ActivityTemplateStepAssignmentCreateManyActivityTemplateStepInput[]
    skipDuplicates?: boolean
  }

  export type ActivityTemplateUpsertWithoutStepsInput = {
    update: XOR<ActivityTemplateUpdateWithoutStepsInput, ActivityTemplateUncheckedUpdateWithoutStepsInput>
    create: XOR<ActivityTemplateCreateWithoutStepsInput, ActivityTemplateUncheckedCreateWithoutStepsInput>
    where?: ActivityTemplateWhereInput
  }

  export type ActivityTemplateUpdateToOneWithWhereWithoutStepsInput = {
    where?: ActivityTemplateWhereInput
    data: XOR<ActivityTemplateUpdateWithoutStepsInput, ActivityTemplateUncheckedUpdateWithoutStepsInput>
  }

  export type ActivityTemplateUpdateWithoutStepsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    defaultPriority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    defaultStatus?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    dateOffsetType?: EnumDateOffsetTypeFieldUpdateOperationsInput | $Enums.DateOffsetType
    startDate?: IntFieldUpdateOperationsInput | number
    endDate?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    startRelativeTo?: ActivityTemplateUpdateOneWithoutDependentsNestedInput
    dependents?: ActivityTemplateUpdateManyWithoutStartRelativeToNestedInput
    parentWaypoint?: ActivityWaypointTemplateUpdateOneWithoutActivitiesNestedInput
    parentActivity?: ActivityTemplateUpdateOneWithoutChildActivitiesNestedInput
    waypoints?: ActivityWaypointTemplateUpdateManyWithoutParentActivityNestedInput
    childActivities?: ActivityTemplateUpdateManyWithoutParentActivityNestedInput
    activities?: ActivityUpdateManyWithoutTemplateNestedInput
    assignments?: TemplateAssignmentUpdateManyWithoutActivityTemplateNestedInput
    tenet?: TenetUpdateOneRequiredWithoutActivityTemplatesNestedInput
  }

  export type ActivityTemplateUncheckedUpdateWithoutStepsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    defaultPriority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    defaultStatus?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    dateOffsetType?: EnumDateOffsetTypeFieldUpdateOperationsInput | $Enums.DateOffsetType
    startDate?: IntFieldUpdateOperationsInput | number
    endDate?: IntFieldUpdateOperationsInput | number
    startRelativeToId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    parentWaypointId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    parentActivityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    order?: NullableIntFieldUpdateOperationsInput | number | null
    dependents?: ActivityTemplateUncheckedUpdateManyWithoutStartRelativeToNestedInput
    waypoints?: ActivityWaypointTemplateUncheckedUpdateManyWithoutParentActivityNestedInput
    childActivities?: ActivityTemplateUncheckedUpdateManyWithoutParentActivityNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutTemplateNestedInput
    assignments?: TemplateAssignmentUncheckedUpdateManyWithoutActivityTemplateNestedInput
  }

  export type TenetUpsertWithoutActivityTemplateStepsInput = {
    update: XOR<TenetUpdateWithoutActivityTemplateStepsInput, TenetUncheckedUpdateWithoutActivityTemplateStepsInput>
    create: XOR<TenetCreateWithoutActivityTemplateStepsInput, TenetUncheckedCreateWithoutActivityTemplateStepsInput>
    where?: TenetWhereInput
  }

  export type TenetUpdateToOneWithWhereWithoutActivityTemplateStepsInput = {
    where?: TenetWhereInput
    data: XOR<TenetUpdateWithoutActivityTemplateStepsInput, TenetUncheckedUpdateWithoutActivityTemplateStepsInput>
  }

  export type TenetUpdateWithoutActivityTemplateStepsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenetNestedInput
    logs?: LogUpdateManyWithoutTenetNestedInput
    contacts?: ContactUpdateManyWithoutTenetNestedInput
    activities?: ActivityUpdateManyWithoutTenetNestedInput
    addresses?: AddressUpdateManyWithoutTenetNestedInput
    contactEmails?: ContactEmailUpdateManyWithoutTenetNestedInput
    contactPhones?: ContactPhoneUpdateManyWithoutTenetNestedInput
    importantDates?: ImportantDateUpdateManyWithoutTenetNestedInput
    attachments?: AttachmentUpdateManyWithoutTenetNestedInput
    notes?: NoteUpdateManyWithoutTenetNestedInput
    auditEvents?: AuditEventUpdateManyWithoutTenetNestedInput
    contactTimelineEvents?: ContactTimelineEventUpdateManyWithoutTenetNestedInput
    activitySteps?: ActivityStepUpdateManyWithoutTenetNestedInput
    activityWaypoints?: ActivityWaypointUpdateManyWithoutTenetNestedInput
    templateAssignments?: TemplateAssignmentUpdateManyWithoutTenetNestedInput
    activityWaypointTemplates?: ActivityWaypointTemplateUpdateManyWithoutTenetNestedInput
    activityTemplates?: ActivityTemplateUpdateManyWithoutTenetNestedInput
    opportunities?: OpportunityUpdateManyWithoutTenetNestedInput
    products?: ProductTypeUpdateManyWithoutTenetNestedInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentUpdateManyWithoutTenetNestedInput
  }

  export type TenetUncheckedUpdateWithoutActivityTemplateStepsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenetNestedInput
    logs?: LogUncheckedUpdateManyWithoutTenetNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutTenetNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutTenetNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutTenetNestedInput
    contactEmails?: ContactEmailUncheckedUpdateManyWithoutTenetNestedInput
    contactPhones?: ContactPhoneUncheckedUpdateManyWithoutTenetNestedInput
    importantDates?: ImportantDateUncheckedUpdateManyWithoutTenetNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTenetNestedInput
    notes?: NoteUncheckedUpdateManyWithoutTenetNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutTenetNestedInput
    contactTimelineEvents?: ContactTimelineEventUncheckedUpdateManyWithoutTenetNestedInput
    activitySteps?: ActivityStepUncheckedUpdateManyWithoutTenetNestedInput
    activityWaypoints?: ActivityWaypointUncheckedUpdateManyWithoutTenetNestedInput
    templateAssignments?: TemplateAssignmentUncheckedUpdateManyWithoutTenetNestedInput
    activityWaypointTemplates?: ActivityWaypointTemplateUncheckedUpdateManyWithoutTenetNestedInput
    activityTemplates?: ActivityTemplateUncheckedUpdateManyWithoutTenetNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutTenetNestedInput
    products?: ProductTypeUncheckedUpdateManyWithoutTenetNestedInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentUncheckedUpdateManyWithoutTenetNestedInput
  }

  export type ActivityTemplateStepAssignmentUpsertWithWhereUniqueWithoutActivityTemplateStepInput = {
    where: ActivityTemplateStepAssignmentWhereUniqueInput
    update: XOR<ActivityTemplateStepAssignmentUpdateWithoutActivityTemplateStepInput, ActivityTemplateStepAssignmentUncheckedUpdateWithoutActivityTemplateStepInput>
    create: XOR<ActivityTemplateStepAssignmentCreateWithoutActivityTemplateStepInput, ActivityTemplateStepAssignmentUncheckedCreateWithoutActivityTemplateStepInput>
  }

  export type ActivityTemplateStepAssignmentUpdateWithWhereUniqueWithoutActivityTemplateStepInput = {
    where: ActivityTemplateStepAssignmentWhereUniqueInput
    data: XOR<ActivityTemplateStepAssignmentUpdateWithoutActivityTemplateStepInput, ActivityTemplateStepAssignmentUncheckedUpdateWithoutActivityTemplateStepInput>
  }

  export type ActivityTemplateStepAssignmentUpdateManyWithWhereWithoutActivityTemplateStepInput = {
    where: ActivityTemplateStepAssignmentScalarWhereInput
    data: XOR<ActivityTemplateStepAssignmentUpdateManyMutationInput, ActivityTemplateStepAssignmentUncheckedUpdateManyWithoutActivityTemplateStepInput>
  }

  export type UserCreateWithoutTemplateStepAssignmentsInput = {
    id: Uint8Array
    email: string
    firstName: string
    lastName: string
    fullName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password: string
    enabled?: boolean
    type?: $Enums.AccessGroup
    system?: boolean
    deleted?: boolean
    deletedAt?: Date | string | null
    tokens?: TokenCreateNestedManyWithoutUserInput
    tenet?: TenetCreateNestedOneWithoutUsersInput
    activities?: ActivityUserJoinCreateNestedManyWithoutUserRelationInput
    notes?: NoteCreateNestedManyWithoutAuthorInput
    waypoints?: UserWaypointJoinCreateNestedManyWithoutUserRelationInput
    events?: ContactTimelineEventCreateNestedManyWithoutUserInput
    auditEvents?: AuditEventCreateNestedManyWithoutUserInput
    templateAssignments?: TemplateAssignmentCreateNestedManyWithoutSpecificUserInput
    assignedActivities?: ActivityCreateNestedManyWithoutAssignedByInput
    opportunities?: UserOpportunityJoinCreateNestedManyWithoutUserRelationInput
    activitySteps?: ActivityStepUserJoinCreateNestedManyWithoutUserRelationInput
  }

  export type UserUncheckedCreateWithoutTemplateStepAssignmentsInput = {
    id: Uint8Array
    email: string
    firstName: string
    lastName: string
    fullName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password: string
    enabled?: boolean
    type?: $Enums.AccessGroup
    tenetId?: Uint8Array | null
    system?: boolean
    deleted?: boolean
    deletedAt?: Date | string | null
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUserJoinUncheckedCreateNestedManyWithoutUserRelationInput
    notes?: NoteUncheckedCreateNestedManyWithoutAuthorInput
    waypoints?: UserWaypointJoinUncheckedCreateNestedManyWithoutUserRelationInput
    events?: ContactTimelineEventUncheckedCreateNestedManyWithoutUserInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutUserInput
    templateAssignments?: TemplateAssignmentUncheckedCreateNestedManyWithoutSpecificUserInput
    assignedActivities?: ActivityUncheckedCreateNestedManyWithoutAssignedByInput
    opportunities?: UserOpportunityJoinUncheckedCreateNestedManyWithoutUserRelationInput
    activitySteps?: ActivityStepUserJoinUncheckedCreateNestedManyWithoutUserRelationInput
  }

  export type UserCreateOrConnectWithoutTemplateStepAssignmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTemplateStepAssignmentsInput, UserUncheckedCreateWithoutTemplateStepAssignmentsInput>
  }

  export type ActivityTemplateStepCreateWithoutAssignedToInput = {
    id: Uint8Array
    order: number
    title: string
    type?: $Enums.ActivityStepType
    activityTemplate: ActivityTemplateCreateNestedOneWithoutStepsInput
    tenet: TenetCreateNestedOneWithoutActivityTemplateStepsInput
  }

  export type ActivityTemplateStepUncheckedCreateWithoutAssignedToInput = {
    id: Uint8Array
    order: number
    title: string
    type?: $Enums.ActivityStepType
    activityTemplateId: Uint8Array
    tenetId: Uint8Array
  }

  export type ActivityTemplateStepCreateOrConnectWithoutAssignedToInput = {
    where: ActivityTemplateStepWhereUniqueInput
    create: XOR<ActivityTemplateStepCreateWithoutAssignedToInput, ActivityTemplateStepUncheckedCreateWithoutAssignedToInput>
  }

  export type TenetCreateWithoutActivityTemplateStepAssignmentInput = {
    id: Uint8Array
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenetInput
    logs?: LogCreateNestedManyWithoutTenetInput
    contacts?: ContactCreateNestedManyWithoutTenetInput
    activities?: ActivityCreateNestedManyWithoutTenetInput
    addresses?: AddressCreateNestedManyWithoutTenetInput
    contactEmails?: ContactEmailCreateNestedManyWithoutTenetInput
    contactPhones?: ContactPhoneCreateNestedManyWithoutTenetInput
    importantDates?: ImportantDateCreateNestedManyWithoutTenetInput
    attachments?: AttachmentCreateNestedManyWithoutTenetInput
    notes?: NoteCreateNestedManyWithoutTenetInput
    auditEvents?: AuditEventCreateNestedManyWithoutTenetInput
    contactTimelineEvents?: ContactTimelineEventCreateNestedManyWithoutTenetInput
    activitySteps?: ActivityStepCreateNestedManyWithoutTenetInput
    activityWaypoints?: ActivityWaypointCreateNestedManyWithoutTenetInput
    templateAssignments?: TemplateAssignmentCreateNestedManyWithoutTenetInput
    activityWaypointTemplates?: ActivityWaypointTemplateCreateNestedManyWithoutTenetInput
    activityTemplates?: ActivityTemplateCreateNestedManyWithoutTenetInput
    activityTemplateSteps?: ActivityTemplateStepCreateNestedManyWithoutTenetInput
    opportunities?: OpportunityCreateNestedManyWithoutTenetInput
    products?: ProductTypeCreateNestedManyWithoutTenetInput
  }

  export type TenetUncheckedCreateWithoutActivityTemplateStepAssignmentInput = {
    id: Uint8Array
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenetInput
    logs?: LogUncheckedCreateNestedManyWithoutTenetInput
    contacts?: ContactUncheckedCreateNestedManyWithoutTenetInput
    activities?: ActivityUncheckedCreateNestedManyWithoutTenetInput
    addresses?: AddressUncheckedCreateNestedManyWithoutTenetInput
    contactEmails?: ContactEmailUncheckedCreateNestedManyWithoutTenetInput
    contactPhones?: ContactPhoneUncheckedCreateNestedManyWithoutTenetInput
    importantDates?: ImportantDateUncheckedCreateNestedManyWithoutTenetInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTenetInput
    notes?: NoteUncheckedCreateNestedManyWithoutTenetInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutTenetInput
    contactTimelineEvents?: ContactTimelineEventUncheckedCreateNestedManyWithoutTenetInput
    activitySteps?: ActivityStepUncheckedCreateNestedManyWithoutTenetInput
    activityWaypoints?: ActivityWaypointUncheckedCreateNestedManyWithoutTenetInput
    templateAssignments?: TemplateAssignmentUncheckedCreateNestedManyWithoutTenetInput
    activityWaypointTemplates?: ActivityWaypointTemplateUncheckedCreateNestedManyWithoutTenetInput
    activityTemplates?: ActivityTemplateUncheckedCreateNestedManyWithoutTenetInput
    activityTemplateSteps?: ActivityTemplateStepUncheckedCreateNestedManyWithoutTenetInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutTenetInput
    products?: ProductTypeUncheckedCreateNestedManyWithoutTenetInput
  }

  export type TenetCreateOrConnectWithoutActivityTemplateStepAssignmentInput = {
    where: TenetWhereUniqueInput
    create: XOR<TenetCreateWithoutActivityTemplateStepAssignmentInput, TenetUncheckedCreateWithoutActivityTemplateStepAssignmentInput>
  }

  export type UserUpsertWithoutTemplateStepAssignmentsInput = {
    update: XOR<UserUpdateWithoutTemplateStepAssignmentsInput, UserUncheckedUpdateWithoutTemplateStepAssignmentsInput>
    create: XOR<UserCreateWithoutTemplateStepAssignmentsInput, UserUncheckedCreateWithoutTemplateStepAssignmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTemplateStepAssignmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTemplateStepAssignmentsInput, UserUncheckedUpdateWithoutTemplateStepAssignmentsInput>
  }

  export type UserUpdateWithoutTemplateStepAssignmentsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumAccessGroupFieldUpdateOperationsInput | $Enums.AccessGroup
    system?: BoolFieldUpdateOperationsInput | boolean
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokens?: TokenUpdateManyWithoutUserNestedInput
    tenet?: TenetUpdateOneWithoutUsersNestedInput
    activities?: ActivityUserJoinUpdateManyWithoutUserRelationNestedInput
    notes?: NoteUpdateManyWithoutAuthorNestedInput
    waypoints?: UserWaypointJoinUpdateManyWithoutUserRelationNestedInput
    events?: ContactTimelineEventUpdateManyWithoutUserNestedInput
    auditEvents?: AuditEventUpdateManyWithoutUserNestedInput
    templateAssignments?: TemplateAssignmentUpdateManyWithoutSpecificUserNestedInput
    assignedActivities?: ActivityUpdateManyWithoutAssignedByNestedInput
    opportunities?: UserOpportunityJoinUpdateManyWithoutUserRelationNestedInput
    activitySteps?: ActivityStepUserJoinUpdateManyWithoutUserRelationNestedInput
  }

  export type UserUncheckedUpdateWithoutTemplateStepAssignmentsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumAccessGroupFieldUpdateOperationsInput | $Enums.AccessGroup
    tenetId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    system?: BoolFieldUpdateOperationsInput | boolean
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUserJoinUncheckedUpdateManyWithoutUserRelationNestedInput
    notes?: NoteUncheckedUpdateManyWithoutAuthorNestedInput
    waypoints?: UserWaypointJoinUncheckedUpdateManyWithoutUserRelationNestedInput
    events?: ContactTimelineEventUncheckedUpdateManyWithoutUserNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutUserNestedInput
    templateAssignments?: TemplateAssignmentUncheckedUpdateManyWithoutSpecificUserNestedInput
    assignedActivities?: ActivityUncheckedUpdateManyWithoutAssignedByNestedInput
    opportunities?: UserOpportunityJoinUncheckedUpdateManyWithoutUserRelationNestedInput
    activitySteps?: ActivityStepUserJoinUncheckedUpdateManyWithoutUserRelationNestedInput
  }

  export type ActivityTemplateStepUpsertWithoutAssignedToInput = {
    update: XOR<ActivityTemplateStepUpdateWithoutAssignedToInput, ActivityTemplateStepUncheckedUpdateWithoutAssignedToInput>
    create: XOR<ActivityTemplateStepCreateWithoutAssignedToInput, ActivityTemplateStepUncheckedCreateWithoutAssignedToInput>
    where?: ActivityTemplateStepWhereInput
  }

  export type ActivityTemplateStepUpdateToOneWithWhereWithoutAssignedToInput = {
    where?: ActivityTemplateStepWhereInput
    data: XOR<ActivityTemplateStepUpdateWithoutAssignedToInput, ActivityTemplateStepUncheckedUpdateWithoutAssignedToInput>
  }

  export type ActivityTemplateStepUpdateWithoutAssignedToInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityStepTypeFieldUpdateOperationsInput | $Enums.ActivityStepType
    activityTemplate?: ActivityTemplateUpdateOneRequiredWithoutStepsNestedInput
    tenet?: TenetUpdateOneRequiredWithoutActivityTemplateStepsNestedInput
  }

  export type ActivityTemplateStepUncheckedUpdateWithoutAssignedToInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityStepTypeFieldUpdateOperationsInput | $Enums.ActivityStepType
    activityTemplateId?: BytesFieldUpdateOperationsInput | Uint8Array
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type TenetUpsertWithoutActivityTemplateStepAssignmentInput = {
    update: XOR<TenetUpdateWithoutActivityTemplateStepAssignmentInput, TenetUncheckedUpdateWithoutActivityTemplateStepAssignmentInput>
    create: XOR<TenetCreateWithoutActivityTemplateStepAssignmentInput, TenetUncheckedCreateWithoutActivityTemplateStepAssignmentInput>
    where?: TenetWhereInput
  }

  export type TenetUpdateToOneWithWhereWithoutActivityTemplateStepAssignmentInput = {
    where?: TenetWhereInput
    data: XOR<TenetUpdateWithoutActivityTemplateStepAssignmentInput, TenetUncheckedUpdateWithoutActivityTemplateStepAssignmentInput>
  }

  export type TenetUpdateWithoutActivityTemplateStepAssignmentInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenetNestedInput
    logs?: LogUpdateManyWithoutTenetNestedInput
    contacts?: ContactUpdateManyWithoutTenetNestedInput
    activities?: ActivityUpdateManyWithoutTenetNestedInput
    addresses?: AddressUpdateManyWithoutTenetNestedInput
    contactEmails?: ContactEmailUpdateManyWithoutTenetNestedInput
    contactPhones?: ContactPhoneUpdateManyWithoutTenetNestedInput
    importantDates?: ImportantDateUpdateManyWithoutTenetNestedInput
    attachments?: AttachmentUpdateManyWithoutTenetNestedInput
    notes?: NoteUpdateManyWithoutTenetNestedInput
    auditEvents?: AuditEventUpdateManyWithoutTenetNestedInput
    contactTimelineEvents?: ContactTimelineEventUpdateManyWithoutTenetNestedInput
    activitySteps?: ActivityStepUpdateManyWithoutTenetNestedInput
    activityWaypoints?: ActivityWaypointUpdateManyWithoutTenetNestedInput
    templateAssignments?: TemplateAssignmentUpdateManyWithoutTenetNestedInput
    activityWaypointTemplates?: ActivityWaypointTemplateUpdateManyWithoutTenetNestedInput
    activityTemplates?: ActivityTemplateUpdateManyWithoutTenetNestedInput
    activityTemplateSteps?: ActivityTemplateStepUpdateManyWithoutTenetNestedInput
    opportunities?: OpportunityUpdateManyWithoutTenetNestedInput
    products?: ProductTypeUpdateManyWithoutTenetNestedInput
  }

  export type TenetUncheckedUpdateWithoutActivityTemplateStepAssignmentInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenetNestedInput
    logs?: LogUncheckedUpdateManyWithoutTenetNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutTenetNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutTenetNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutTenetNestedInput
    contactEmails?: ContactEmailUncheckedUpdateManyWithoutTenetNestedInput
    contactPhones?: ContactPhoneUncheckedUpdateManyWithoutTenetNestedInput
    importantDates?: ImportantDateUncheckedUpdateManyWithoutTenetNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTenetNestedInput
    notes?: NoteUncheckedUpdateManyWithoutTenetNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutTenetNestedInput
    contactTimelineEvents?: ContactTimelineEventUncheckedUpdateManyWithoutTenetNestedInput
    activitySteps?: ActivityStepUncheckedUpdateManyWithoutTenetNestedInput
    activityWaypoints?: ActivityWaypointUncheckedUpdateManyWithoutTenetNestedInput
    templateAssignments?: TemplateAssignmentUncheckedUpdateManyWithoutTenetNestedInput
    activityWaypointTemplates?: ActivityWaypointTemplateUncheckedUpdateManyWithoutTenetNestedInput
    activityTemplates?: ActivityTemplateUncheckedUpdateManyWithoutTenetNestedInput
    activityTemplateSteps?: ActivityTemplateStepUncheckedUpdateManyWithoutTenetNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutTenetNestedInput
    products?: ProductTypeUncheckedUpdateManyWithoutTenetNestedInput
  }

  export type ActivityTemplateStepCreateWithoutActivityTemplateInput = {
    id: Uint8Array
    order: number
    title: string
    type?: $Enums.ActivityStepType
    tenet: TenetCreateNestedOneWithoutActivityTemplateStepsInput
    assignedTo?: ActivityTemplateStepAssignmentCreateNestedManyWithoutActivityTemplateStepInput
  }

  export type ActivityTemplateStepUncheckedCreateWithoutActivityTemplateInput = {
    id: Uint8Array
    order: number
    title: string
    type?: $Enums.ActivityStepType
    tenetId: Uint8Array
    assignedTo?: ActivityTemplateStepAssignmentUncheckedCreateNestedManyWithoutActivityTemplateStepInput
  }

  export type ActivityTemplateStepCreateOrConnectWithoutActivityTemplateInput = {
    where: ActivityTemplateStepWhereUniqueInput
    create: XOR<ActivityTemplateStepCreateWithoutActivityTemplateInput, ActivityTemplateStepUncheckedCreateWithoutActivityTemplateInput>
  }

  export type ActivityTemplateStepCreateManyActivityTemplateInputEnvelope = {
    data: ActivityTemplateStepCreateManyActivityTemplateInput | ActivityTemplateStepCreateManyActivityTemplateInput[]
    skipDuplicates?: boolean
  }

  export type ActivityTemplateCreateWithoutDependentsInput = {
    id: Uint8Array
    title: string
    description?: string | null
    type: $Enums.ActivityType
    defaultPriority: $Enums.ActivityPriority
    defaultStatus: $Enums.ActivityStatus
    taskScheduleType?: $Enums.TaskScheduleType | null
    dateOffsetType: $Enums.DateOffsetType
    startDate: number
    endDate: number
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: number | null
    steps?: ActivityTemplateStepCreateNestedManyWithoutActivityTemplateInput
    startRelativeTo?: ActivityTemplateCreateNestedOneWithoutDependentsInput
    parentWaypoint?: ActivityWaypointTemplateCreateNestedOneWithoutActivitiesInput
    parentActivity?: ActivityTemplateCreateNestedOneWithoutChildActivitiesInput
    waypoints?: ActivityWaypointTemplateCreateNestedManyWithoutParentActivityInput
    childActivities?: ActivityTemplateCreateNestedManyWithoutParentActivityInput
    activities?: ActivityCreateNestedManyWithoutTemplateInput
    assignments?: TemplateAssignmentCreateNestedManyWithoutActivityTemplateInput
    tenet: TenetCreateNestedOneWithoutActivityTemplatesInput
  }

  export type ActivityTemplateUncheckedCreateWithoutDependentsInput = {
    id: Uint8Array
    title: string
    description?: string | null
    type: $Enums.ActivityType
    defaultPriority: $Enums.ActivityPriority
    defaultStatus: $Enums.ActivityStatus
    taskScheduleType?: $Enums.TaskScheduleType | null
    dateOffsetType: $Enums.DateOffsetType
    startDate: number
    endDate: number
    startRelativeToId?: Uint8Array | null
    parentWaypointId?: Uint8Array | null
    parentActivityId?: Uint8Array | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
    order?: number | null
    steps?: ActivityTemplateStepUncheckedCreateNestedManyWithoutActivityTemplateInput
    waypoints?: ActivityWaypointTemplateUncheckedCreateNestedManyWithoutParentActivityInput
    childActivities?: ActivityTemplateUncheckedCreateNestedManyWithoutParentActivityInput
    activities?: ActivityUncheckedCreateNestedManyWithoutTemplateInput
    assignments?: TemplateAssignmentUncheckedCreateNestedManyWithoutActivityTemplateInput
  }

  export type ActivityTemplateCreateOrConnectWithoutDependentsInput = {
    where: ActivityTemplateWhereUniqueInput
    create: XOR<ActivityTemplateCreateWithoutDependentsInput, ActivityTemplateUncheckedCreateWithoutDependentsInput>
  }

  export type ActivityTemplateCreateWithoutStartRelativeToInput = {
    id: Uint8Array
    title: string
    description?: string | null
    type: $Enums.ActivityType
    defaultPriority: $Enums.ActivityPriority
    defaultStatus: $Enums.ActivityStatus
    taskScheduleType?: $Enums.TaskScheduleType | null
    dateOffsetType: $Enums.DateOffsetType
    startDate: number
    endDate: number
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: number | null
    steps?: ActivityTemplateStepCreateNestedManyWithoutActivityTemplateInput
    dependents?: ActivityTemplateCreateNestedManyWithoutStartRelativeToInput
    parentWaypoint?: ActivityWaypointTemplateCreateNestedOneWithoutActivitiesInput
    parentActivity?: ActivityTemplateCreateNestedOneWithoutChildActivitiesInput
    waypoints?: ActivityWaypointTemplateCreateNestedManyWithoutParentActivityInput
    childActivities?: ActivityTemplateCreateNestedManyWithoutParentActivityInput
    activities?: ActivityCreateNestedManyWithoutTemplateInput
    assignments?: TemplateAssignmentCreateNestedManyWithoutActivityTemplateInput
    tenet: TenetCreateNestedOneWithoutActivityTemplatesInput
  }

  export type ActivityTemplateUncheckedCreateWithoutStartRelativeToInput = {
    id: Uint8Array
    title: string
    description?: string | null
    type: $Enums.ActivityType
    defaultPriority: $Enums.ActivityPriority
    defaultStatus: $Enums.ActivityStatus
    taskScheduleType?: $Enums.TaskScheduleType | null
    dateOffsetType: $Enums.DateOffsetType
    startDate: number
    endDate: number
    parentWaypointId?: Uint8Array | null
    parentActivityId?: Uint8Array | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
    order?: number | null
    steps?: ActivityTemplateStepUncheckedCreateNestedManyWithoutActivityTemplateInput
    dependents?: ActivityTemplateUncheckedCreateNestedManyWithoutStartRelativeToInput
    waypoints?: ActivityWaypointTemplateUncheckedCreateNestedManyWithoutParentActivityInput
    childActivities?: ActivityTemplateUncheckedCreateNestedManyWithoutParentActivityInput
    activities?: ActivityUncheckedCreateNestedManyWithoutTemplateInput
    assignments?: TemplateAssignmentUncheckedCreateNestedManyWithoutActivityTemplateInput
  }

  export type ActivityTemplateCreateOrConnectWithoutStartRelativeToInput = {
    where: ActivityTemplateWhereUniqueInput
    create: XOR<ActivityTemplateCreateWithoutStartRelativeToInput, ActivityTemplateUncheckedCreateWithoutStartRelativeToInput>
  }

  export type ActivityTemplateCreateManyStartRelativeToInputEnvelope = {
    data: ActivityTemplateCreateManyStartRelativeToInput | ActivityTemplateCreateManyStartRelativeToInput[]
    skipDuplicates?: boolean
  }

  export type ActivityWaypointTemplateCreateWithoutActivitiesInput = {
    id: Uint8Array
    title: string
    description?: string | null
    defaultStatus: $Enums.ActivityStatus
    order: number
    dateOffsetType: $Enums.DateOffsetType
    dueDate: number
    createdAt?: Date | string
    updatedAt?: Date | string
    parentActivity: ActivityTemplateCreateNestedOneWithoutWaypointsInput
    waypoints?: ActivityWaypointCreateNestedManyWithoutTemplateInput
    assignments?: TemplateAssignmentCreateNestedManyWithoutWaypointTemplateInput
    tenet: TenetCreateNestedOneWithoutActivityWaypointTemplatesInput
  }

  export type ActivityWaypointTemplateUncheckedCreateWithoutActivitiesInput = {
    id: Uint8Array
    title: string
    description?: string | null
    defaultStatus: $Enums.ActivityStatus
    order: number
    dateOffsetType: $Enums.DateOffsetType
    dueDate: number
    parentActivityId: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
    waypoints?: ActivityWaypointUncheckedCreateNestedManyWithoutTemplateInput
    assignments?: TemplateAssignmentUncheckedCreateNestedManyWithoutWaypointTemplateInput
  }

  export type ActivityWaypointTemplateCreateOrConnectWithoutActivitiesInput = {
    where: ActivityWaypointTemplateWhereUniqueInput
    create: XOR<ActivityWaypointTemplateCreateWithoutActivitiesInput, ActivityWaypointTemplateUncheckedCreateWithoutActivitiesInput>
  }

  export type ActivityTemplateCreateWithoutChildActivitiesInput = {
    id: Uint8Array
    title: string
    description?: string | null
    type: $Enums.ActivityType
    defaultPriority: $Enums.ActivityPriority
    defaultStatus: $Enums.ActivityStatus
    taskScheduleType?: $Enums.TaskScheduleType | null
    dateOffsetType: $Enums.DateOffsetType
    startDate: number
    endDate: number
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: number | null
    steps?: ActivityTemplateStepCreateNestedManyWithoutActivityTemplateInput
    startRelativeTo?: ActivityTemplateCreateNestedOneWithoutDependentsInput
    dependents?: ActivityTemplateCreateNestedManyWithoutStartRelativeToInput
    parentWaypoint?: ActivityWaypointTemplateCreateNestedOneWithoutActivitiesInput
    parentActivity?: ActivityTemplateCreateNestedOneWithoutChildActivitiesInput
    waypoints?: ActivityWaypointTemplateCreateNestedManyWithoutParentActivityInput
    activities?: ActivityCreateNestedManyWithoutTemplateInput
    assignments?: TemplateAssignmentCreateNestedManyWithoutActivityTemplateInput
    tenet: TenetCreateNestedOneWithoutActivityTemplatesInput
  }

  export type ActivityTemplateUncheckedCreateWithoutChildActivitiesInput = {
    id: Uint8Array
    title: string
    description?: string | null
    type: $Enums.ActivityType
    defaultPriority: $Enums.ActivityPriority
    defaultStatus: $Enums.ActivityStatus
    taskScheduleType?: $Enums.TaskScheduleType | null
    dateOffsetType: $Enums.DateOffsetType
    startDate: number
    endDate: number
    startRelativeToId?: Uint8Array | null
    parentWaypointId?: Uint8Array | null
    parentActivityId?: Uint8Array | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
    order?: number | null
    steps?: ActivityTemplateStepUncheckedCreateNestedManyWithoutActivityTemplateInput
    dependents?: ActivityTemplateUncheckedCreateNestedManyWithoutStartRelativeToInput
    waypoints?: ActivityWaypointTemplateUncheckedCreateNestedManyWithoutParentActivityInput
    activities?: ActivityUncheckedCreateNestedManyWithoutTemplateInput
    assignments?: TemplateAssignmentUncheckedCreateNestedManyWithoutActivityTemplateInput
  }

  export type ActivityTemplateCreateOrConnectWithoutChildActivitiesInput = {
    where: ActivityTemplateWhereUniqueInput
    create: XOR<ActivityTemplateCreateWithoutChildActivitiesInput, ActivityTemplateUncheckedCreateWithoutChildActivitiesInput>
  }

  export type ActivityWaypointTemplateCreateWithoutParentActivityInput = {
    id: Uint8Array
    title: string
    description?: string | null
    defaultStatus: $Enums.ActivityStatus
    order: number
    dateOffsetType: $Enums.DateOffsetType
    dueDate: number
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: ActivityTemplateCreateNestedManyWithoutParentWaypointInput
    waypoints?: ActivityWaypointCreateNestedManyWithoutTemplateInput
    assignments?: TemplateAssignmentCreateNestedManyWithoutWaypointTemplateInput
    tenet: TenetCreateNestedOneWithoutActivityWaypointTemplatesInput
  }

  export type ActivityWaypointTemplateUncheckedCreateWithoutParentActivityInput = {
    id: Uint8Array
    title: string
    description?: string | null
    defaultStatus: $Enums.ActivityStatus
    order: number
    dateOffsetType: $Enums.DateOffsetType
    dueDate: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
    activities?: ActivityTemplateUncheckedCreateNestedManyWithoutParentWaypointInput
    waypoints?: ActivityWaypointUncheckedCreateNestedManyWithoutTemplateInput
    assignments?: TemplateAssignmentUncheckedCreateNestedManyWithoutWaypointTemplateInput
  }

  export type ActivityWaypointTemplateCreateOrConnectWithoutParentActivityInput = {
    where: ActivityWaypointTemplateWhereUniqueInput
    create: XOR<ActivityWaypointTemplateCreateWithoutParentActivityInput, ActivityWaypointTemplateUncheckedCreateWithoutParentActivityInput>
  }

  export type ActivityWaypointTemplateCreateManyParentActivityInputEnvelope = {
    data: ActivityWaypointTemplateCreateManyParentActivityInput | ActivityWaypointTemplateCreateManyParentActivityInput[]
    skipDuplicates?: boolean
  }

  export type ActivityTemplateCreateWithoutParentActivityInput = {
    id: Uint8Array
    title: string
    description?: string | null
    type: $Enums.ActivityType
    defaultPriority: $Enums.ActivityPriority
    defaultStatus: $Enums.ActivityStatus
    taskScheduleType?: $Enums.TaskScheduleType | null
    dateOffsetType: $Enums.DateOffsetType
    startDate: number
    endDate: number
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: number | null
    steps?: ActivityTemplateStepCreateNestedManyWithoutActivityTemplateInput
    startRelativeTo?: ActivityTemplateCreateNestedOneWithoutDependentsInput
    dependents?: ActivityTemplateCreateNestedManyWithoutStartRelativeToInput
    parentWaypoint?: ActivityWaypointTemplateCreateNestedOneWithoutActivitiesInput
    waypoints?: ActivityWaypointTemplateCreateNestedManyWithoutParentActivityInput
    childActivities?: ActivityTemplateCreateNestedManyWithoutParentActivityInput
    activities?: ActivityCreateNestedManyWithoutTemplateInput
    assignments?: TemplateAssignmentCreateNestedManyWithoutActivityTemplateInput
    tenet: TenetCreateNestedOneWithoutActivityTemplatesInput
  }

  export type ActivityTemplateUncheckedCreateWithoutParentActivityInput = {
    id: Uint8Array
    title: string
    description?: string | null
    type: $Enums.ActivityType
    defaultPriority: $Enums.ActivityPriority
    defaultStatus: $Enums.ActivityStatus
    taskScheduleType?: $Enums.TaskScheduleType | null
    dateOffsetType: $Enums.DateOffsetType
    startDate: number
    endDate: number
    startRelativeToId?: Uint8Array | null
    parentWaypointId?: Uint8Array | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
    order?: number | null
    steps?: ActivityTemplateStepUncheckedCreateNestedManyWithoutActivityTemplateInput
    dependents?: ActivityTemplateUncheckedCreateNestedManyWithoutStartRelativeToInput
    waypoints?: ActivityWaypointTemplateUncheckedCreateNestedManyWithoutParentActivityInput
    childActivities?: ActivityTemplateUncheckedCreateNestedManyWithoutParentActivityInput
    activities?: ActivityUncheckedCreateNestedManyWithoutTemplateInput
    assignments?: TemplateAssignmentUncheckedCreateNestedManyWithoutActivityTemplateInput
  }

  export type ActivityTemplateCreateOrConnectWithoutParentActivityInput = {
    where: ActivityTemplateWhereUniqueInput
    create: XOR<ActivityTemplateCreateWithoutParentActivityInput, ActivityTemplateUncheckedCreateWithoutParentActivityInput>
  }

  export type ActivityTemplateCreateManyParentActivityInputEnvelope = {
    data: ActivityTemplateCreateManyParentActivityInput | ActivityTemplateCreateManyParentActivityInput[]
    skipDuplicates?: boolean
  }

  export type ActivityCreateWithoutTemplateInput = {
    id: Uint8Array
    title: string
    type: $Enums.ActivityType
    taskScheduleType?: $Enums.TaskScheduleType | null
    startDate: Date | string
    endDate: Date | string
    completedAt?: Date | string | null
    description?: string | null
    priority?: $Enums.ActivityPriority
    status: $Enums.ActivityStatus
    phoneNumber?: string | null
    location?: string | null
    holdReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean
    deletedAt?: Date | string | null
    order?: number | null
    steps?: ActivityStepCreateNestedManyWithoutActivityInput
    waypoints?: ActivityWaypointCreateNestedManyWithoutActivityInput
    activities?: ActivityCreateNestedManyWithoutParentActivityInput
    parentActivity?: ActivityCreateNestedOneWithoutActivitiesInput
    parentWaypoint?: ActivityWaypointCreateNestedOneWithoutChildActivitiesInput
    assignedBy: UserCreateNestedOneWithoutAssignedActivitiesInput
    contacts?: ActivityContactJoinCreateNestedManyWithoutActivityRelationInput
    users?: ActivityUserJoinCreateNestedManyWithoutActivityRelationInput
    tenet: TenetCreateNestedOneWithoutActivitiesInput
    attachments?: AttachmentCreateNestedManyWithoutActivityInput
    notes?: NoteCreateNestedManyWithoutActivityInput
    events?: ContactTimelineEventCreateNestedManyWithoutActivityInput
    opportunity?: OpportunityCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateWithoutTemplateInput = {
    id: Uint8Array
    title: string
    type: $Enums.ActivityType
    parentActivityId?: Uint8Array | null
    parentWaypointId?: Uint8Array | null
    taskScheduleType?: $Enums.TaskScheduleType | null
    startDate: Date | string
    endDate: Date | string
    completedAt?: Date | string | null
    description?: string | null
    priority?: $Enums.ActivityPriority
    status: $Enums.ActivityStatus
    assignedById: Uint8Array
    phoneNumber?: string | null
    location?: string | null
    holdReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
    deleted?: boolean
    deletedAt?: Date | string | null
    order?: number | null
    opportunityId?: Uint8Array | null
    steps?: ActivityStepUncheckedCreateNestedManyWithoutActivityInput
    waypoints?: ActivityWaypointUncheckedCreateNestedManyWithoutActivityInput
    activities?: ActivityUncheckedCreateNestedManyWithoutParentActivityInput
    contacts?: ActivityContactJoinUncheckedCreateNestedManyWithoutActivityRelationInput
    users?: ActivityUserJoinUncheckedCreateNestedManyWithoutActivityRelationInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutActivityInput
    notes?: NoteUncheckedCreateNestedManyWithoutActivityInput
    events?: ContactTimelineEventUncheckedCreateNestedManyWithoutActivityInput
  }

  export type ActivityCreateOrConnectWithoutTemplateInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutTemplateInput, ActivityUncheckedCreateWithoutTemplateInput>
  }

  export type ActivityCreateManyTemplateInputEnvelope = {
    data: ActivityCreateManyTemplateInput | ActivityCreateManyTemplateInput[]
    skipDuplicates?: boolean
  }

  export type TemplateAssignmentCreateWithoutActivityTemplateInput = {
    id: Uint8Array
    specificRole?: $Enums.Role | null
    createdAt?: Date | string
    updatedAt?: Date | string
    specificUser?: UserCreateNestedOneWithoutTemplateAssignmentsInput
    waypointTemplate?: ActivityWaypointTemplateCreateNestedOneWithoutAssignmentsInput
    tenet: TenetCreateNestedOneWithoutTemplateAssignmentsInput
  }

  export type TemplateAssignmentUncheckedCreateWithoutActivityTemplateInput = {
    id: Uint8Array
    specificUserId?: Uint8Array | null
    specificRole?: $Enums.Role | null
    waypointTemplateId?: Uint8Array | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
  }

  export type TemplateAssignmentCreateOrConnectWithoutActivityTemplateInput = {
    where: TemplateAssignmentWhereUniqueInput
    create: XOR<TemplateAssignmentCreateWithoutActivityTemplateInput, TemplateAssignmentUncheckedCreateWithoutActivityTemplateInput>
  }

  export type TemplateAssignmentCreateManyActivityTemplateInputEnvelope = {
    data: TemplateAssignmentCreateManyActivityTemplateInput | TemplateAssignmentCreateManyActivityTemplateInput[]
    skipDuplicates?: boolean
  }

  export type TenetCreateWithoutActivityTemplatesInput = {
    id: Uint8Array
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenetInput
    logs?: LogCreateNestedManyWithoutTenetInput
    contacts?: ContactCreateNestedManyWithoutTenetInput
    activities?: ActivityCreateNestedManyWithoutTenetInput
    addresses?: AddressCreateNestedManyWithoutTenetInput
    contactEmails?: ContactEmailCreateNestedManyWithoutTenetInput
    contactPhones?: ContactPhoneCreateNestedManyWithoutTenetInput
    importantDates?: ImportantDateCreateNestedManyWithoutTenetInput
    attachments?: AttachmentCreateNestedManyWithoutTenetInput
    notes?: NoteCreateNestedManyWithoutTenetInput
    auditEvents?: AuditEventCreateNestedManyWithoutTenetInput
    contactTimelineEvents?: ContactTimelineEventCreateNestedManyWithoutTenetInput
    activitySteps?: ActivityStepCreateNestedManyWithoutTenetInput
    activityWaypoints?: ActivityWaypointCreateNestedManyWithoutTenetInput
    templateAssignments?: TemplateAssignmentCreateNestedManyWithoutTenetInput
    activityWaypointTemplates?: ActivityWaypointTemplateCreateNestedManyWithoutTenetInput
    activityTemplateSteps?: ActivityTemplateStepCreateNestedManyWithoutTenetInput
    opportunities?: OpportunityCreateNestedManyWithoutTenetInput
    products?: ProductTypeCreateNestedManyWithoutTenetInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentCreateNestedManyWithoutTenetInput
  }

  export type TenetUncheckedCreateWithoutActivityTemplatesInput = {
    id: Uint8Array
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenetInput
    logs?: LogUncheckedCreateNestedManyWithoutTenetInput
    contacts?: ContactUncheckedCreateNestedManyWithoutTenetInput
    activities?: ActivityUncheckedCreateNestedManyWithoutTenetInput
    addresses?: AddressUncheckedCreateNestedManyWithoutTenetInput
    contactEmails?: ContactEmailUncheckedCreateNestedManyWithoutTenetInput
    contactPhones?: ContactPhoneUncheckedCreateNestedManyWithoutTenetInput
    importantDates?: ImportantDateUncheckedCreateNestedManyWithoutTenetInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTenetInput
    notes?: NoteUncheckedCreateNestedManyWithoutTenetInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutTenetInput
    contactTimelineEvents?: ContactTimelineEventUncheckedCreateNestedManyWithoutTenetInput
    activitySteps?: ActivityStepUncheckedCreateNestedManyWithoutTenetInput
    activityWaypoints?: ActivityWaypointUncheckedCreateNestedManyWithoutTenetInput
    templateAssignments?: TemplateAssignmentUncheckedCreateNestedManyWithoutTenetInput
    activityWaypointTemplates?: ActivityWaypointTemplateUncheckedCreateNestedManyWithoutTenetInput
    activityTemplateSteps?: ActivityTemplateStepUncheckedCreateNestedManyWithoutTenetInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutTenetInput
    products?: ProductTypeUncheckedCreateNestedManyWithoutTenetInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentUncheckedCreateNestedManyWithoutTenetInput
  }

  export type TenetCreateOrConnectWithoutActivityTemplatesInput = {
    where: TenetWhereUniqueInput
    create: XOR<TenetCreateWithoutActivityTemplatesInput, TenetUncheckedCreateWithoutActivityTemplatesInput>
  }

  export type ActivityTemplateStepUpsertWithWhereUniqueWithoutActivityTemplateInput = {
    where: ActivityTemplateStepWhereUniqueInput
    update: XOR<ActivityTemplateStepUpdateWithoutActivityTemplateInput, ActivityTemplateStepUncheckedUpdateWithoutActivityTemplateInput>
    create: XOR<ActivityTemplateStepCreateWithoutActivityTemplateInput, ActivityTemplateStepUncheckedCreateWithoutActivityTemplateInput>
  }

  export type ActivityTemplateStepUpdateWithWhereUniqueWithoutActivityTemplateInput = {
    where: ActivityTemplateStepWhereUniqueInput
    data: XOR<ActivityTemplateStepUpdateWithoutActivityTemplateInput, ActivityTemplateStepUncheckedUpdateWithoutActivityTemplateInput>
  }

  export type ActivityTemplateStepUpdateManyWithWhereWithoutActivityTemplateInput = {
    where: ActivityTemplateStepScalarWhereInput
    data: XOR<ActivityTemplateStepUpdateManyMutationInput, ActivityTemplateStepUncheckedUpdateManyWithoutActivityTemplateInput>
  }

  export type ActivityTemplateUpsertWithoutDependentsInput = {
    update: XOR<ActivityTemplateUpdateWithoutDependentsInput, ActivityTemplateUncheckedUpdateWithoutDependentsInput>
    create: XOR<ActivityTemplateCreateWithoutDependentsInput, ActivityTemplateUncheckedCreateWithoutDependentsInput>
    where?: ActivityTemplateWhereInput
  }

  export type ActivityTemplateUpdateToOneWithWhereWithoutDependentsInput = {
    where?: ActivityTemplateWhereInput
    data: XOR<ActivityTemplateUpdateWithoutDependentsInput, ActivityTemplateUncheckedUpdateWithoutDependentsInput>
  }

  export type ActivityTemplateUpdateWithoutDependentsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    defaultPriority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    defaultStatus?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    dateOffsetType?: EnumDateOffsetTypeFieldUpdateOperationsInput | $Enums.DateOffsetType
    startDate?: IntFieldUpdateOperationsInput | number
    endDate?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    steps?: ActivityTemplateStepUpdateManyWithoutActivityTemplateNestedInput
    startRelativeTo?: ActivityTemplateUpdateOneWithoutDependentsNestedInput
    parentWaypoint?: ActivityWaypointTemplateUpdateOneWithoutActivitiesNestedInput
    parentActivity?: ActivityTemplateUpdateOneWithoutChildActivitiesNestedInput
    waypoints?: ActivityWaypointTemplateUpdateManyWithoutParentActivityNestedInput
    childActivities?: ActivityTemplateUpdateManyWithoutParentActivityNestedInput
    activities?: ActivityUpdateManyWithoutTemplateNestedInput
    assignments?: TemplateAssignmentUpdateManyWithoutActivityTemplateNestedInput
    tenet?: TenetUpdateOneRequiredWithoutActivityTemplatesNestedInput
  }

  export type ActivityTemplateUncheckedUpdateWithoutDependentsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    defaultPriority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    defaultStatus?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    dateOffsetType?: EnumDateOffsetTypeFieldUpdateOperationsInput | $Enums.DateOffsetType
    startDate?: IntFieldUpdateOperationsInput | number
    endDate?: IntFieldUpdateOperationsInput | number
    startRelativeToId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    parentWaypointId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    parentActivityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    order?: NullableIntFieldUpdateOperationsInput | number | null
    steps?: ActivityTemplateStepUncheckedUpdateManyWithoutActivityTemplateNestedInput
    waypoints?: ActivityWaypointTemplateUncheckedUpdateManyWithoutParentActivityNestedInput
    childActivities?: ActivityTemplateUncheckedUpdateManyWithoutParentActivityNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutTemplateNestedInput
    assignments?: TemplateAssignmentUncheckedUpdateManyWithoutActivityTemplateNestedInput
  }

  export type ActivityTemplateUpsertWithWhereUniqueWithoutStartRelativeToInput = {
    where: ActivityTemplateWhereUniqueInput
    update: XOR<ActivityTemplateUpdateWithoutStartRelativeToInput, ActivityTemplateUncheckedUpdateWithoutStartRelativeToInput>
    create: XOR<ActivityTemplateCreateWithoutStartRelativeToInput, ActivityTemplateUncheckedCreateWithoutStartRelativeToInput>
  }

  export type ActivityTemplateUpdateWithWhereUniqueWithoutStartRelativeToInput = {
    where: ActivityTemplateWhereUniqueInput
    data: XOR<ActivityTemplateUpdateWithoutStartRelativeToInput, ActivityTemplateUncheckedUpdateWithoutStartRelativeToInput>
  }

  export type ActivityTemplateUpdateManyWithWhereWithoutStartRelativeToInput = {
    where: ActivityTemplateScalarWhereInput
    data: XOR<ActivityTemplateUpdateManyMutationInput, ActivityTemplateUncheckedUpdateManyWithoutStartRelativeToInput>
  }

  export type ActivityWaypointTemplateUpsertWithoutActivitiesInput = {
    update: XOR<ActivityWaypointTemplateUpdateWithoutActivitiesInput, ActivityWaypointTemplateUncheckedUpdateWithoutActivitiesInput>
    create: XOR<ActivityWaypointTemplateCreateWithoutActivitiesInput, ActivityWaypointTemplateUncheckedCreateWithoutActivitiesInput>
    where?: ActivityWaypointTemplateWhereInput
  }

  export type ActivityWaypointTemplateUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: ActivityWaypointTemplateWhereInput
    data: XOR<ActivityWaypointTemplateUpdateWithoutActivitiesInput, ActivityWaypointTemplateUncheckedUpdateWithoutActivitiesInput>
  }

  export type ActivityWaypointTemplateUpdateWithoutActivitiesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultStatus?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    order?: IntFieldUpdateOperationsInput | number
    dateOffsetType?: EnumDateOffsetTypeFieldUpdateOperationsInput | $Enums.DateOffsetType
    dueDate?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentActivity?: ActivityTemplateUpdateOneRequiredWithoutWaypointsNestedInput
    waypoints?: ActivityWaypointUpdateManyWithoutTemplateNestedInput
    assignments?: TemplateAssignmentUpdateManyWithoutWaypointTemplateNestedInput
    tenet?: TenetUpdateOneRequiredWithoutActivityWaypointTemplatesNestedInput
  }

  export type ActivityWaypointTemplateUncheckedUpdateWithoutActivitiesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultStatus?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    order?: IntFieldUpdateOperationsInput | number
    dateOffsetType?: EnumDateOffsetTypeFieldUpdateOperationsInput | $Enums.DateOffsetType
    dueDate?: IntFieldUpdateOperationsInput | number
    parentActivityId?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    waypoints?: ActivityWaypointUncheckedUpdateManyWithoutTemplateNestedInput
    assignments?: TemplateAssignmentUncheckedUpdateManyWithoutWaypointTemplateNestedInput
  }

  export type ActivityTemplateUpsertWithoutChildActivitiesInput = {
    update: XOR<ActivityTemplateUpdateWithoutChildActivitiesInput, ActivityTemplateUncheckedUpdateWithoutChildActivitiesInput>
    create: XOR<ActivityTemplateCreateWithoutChildActivitiesInput, ActivityTemplateUncheckedCreateWithoutChildActivitiesInput>
    where?: ActivityTemplateWhereInput
  }

  export type ActivityTemplateUpdateToOneWithWhereWithoutChildActivitiesInput = {
    where?: ActivityTemplateWhereInput
    data: XOR<ActivityTemplateUpdateWithoutChildActivitiesInput, ActivityTemplateUncheckedUpdateWithoutChildActivitiesInput>
  }

  export type ActivityTemplateUpdateWithoutChildActivitiesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    defaultPriority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    defaultStatus?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    dateOffsetType?: EnumDateOffsetTypeFieldUpdateOperationsInput | $Enums.DateOffsetType
    startDate?: IntFieldUpdateOperationsInput | number
    endDate?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    steps?: ActivityTemplateStepUpdateManyWithoutActivityTemplateNestedInput
    startRelativeTo?: ActivityTemplateUpdateOneWithoutDependentsNestedInput
    dependents?: ActivityTemplateUpdateManyWithoutStartRelativeToNestedInput
    parentWaypoint?: ActivityWaypointTemplateUpdateOneWithoutActivitiesNestedInput
    parentActivity?: ActivityTemplateUpdateOneWithoutChildActivitiesNestedInput
    waypoints?: ActivityWaypointTemplateUpdateManyWithoutParentActivityNestedInput
    activities?: ActivityUpdateManyWithoutTemplateNestedInput
    assignments?: TemplateAssignmentUpdateManyWithoutActivityTemplateNestedInput
    tenet?: TenetUpdateOneRequiredWithoutActivityTemplatesNestedInput
  }

  export type ActivityTemplateUncheckedUpdateWithoutChildActivitiesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    defaultPriority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    defaultStatus?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    dateOffsetType?: EnumDateOffsetTypeFieldUpdateOperationsInput | $Enums.DateOffsetType
    startDate?: IntFieldUpdateOperationsInput | number
    endDate?: IntFieldUpdateOperationsInput | number
    startRelativeToId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    parentWaypointId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    parentActivityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    order?: NullableIntFieldUpdateOperationsInput | number | null
    steps?: ActivityTemplateStepUncheckedUpdateManyWithoutActivityTemplateNestedInput
    dependents?: ActivityTemplateUncheckedUpdateManyWithoutStartRelativeToNestedInput
    waypoints?: ActivityWaypointTemplateUncheckedUpdateManyWithoutParentActivityNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutTemplateNestedInput
    assignments?: TemplateAssignmentUncheckedUpdateManyWithoutActivityTemplateNestedInput
  }

  export type ActivityWaypointTemplateUpsertWithWhereUniqueWithoutParentActivityInput = {
    where: ActivityWaypointTemplateWhereUniqueInput
    update: XOR<ActivityWaypointTemplateUpdateWithoutParentActivityInput, ActivityWaypointTemplateUncheckedUpdateWithoutParentActivityInput>
    create: XOR<ActivityWaypointTemplateCreateWithoutParentActivityInput, ActivityWaypointTemplateUncheckedCreateWithoutParentActivityInput>
  }

  export type ActivityWaypointTemplateUpdateWithWhereUniqueWithoutParentActivityInput = {
    where: ActivityWaypointTemplateWhereUniqueInput
    data: XOR<ActivityWaypointTemplateUpdateWithoutParentActivityInput, ActivityWaypointTemplateUncheckedUpdateWithoutParentActivityInput>
  }

  export type ActivityWaypointTemplateUpdateManyWithWhereWithoutParentActivityInput = {
    where: ActivityWaypointTemplateScalarWhereInput
    data: XOR<ActivityWaypointTemplateUpdateManyMutationInput, ActivityWaypointTemplateUncheckedUpdateManyWithoutParentActivityInput>
  }

  export type ActivityTemplateUpsertWithWhereUniqueWithoutParentActivityInput = {
    where: ActivityTemplateWhereUniqueInput
    update: XOR<ActivityTemplateUpdateWithoutParentActivityInput, ActivityTemplateUncheckedUpdateWithoutParentActivityInput>
    create: XOR<ActivityTemplateCreateWithoutParentActivityInput, ActivityTemplateUncheckedCreateWithoutParentActivityInput>
  }

  export type ActivityTemplateUpdateWithWhereUniqueWithoutParentActivityInput = {
    where: ActivityTemplateWhereUniqueInput
    data: XOR<ActivityTemplateUpdateWithoutParentActivityInput, ActivityTemplateUncheckedUpdateWithoutParentActivityInput>
  }

  export type ActivityTemplateUpdateManyWithWhereWithoutParentActivityInput = {
    where: ActivityTemplateScalarWhereInput
    data: XOR<ActivityTemplateUpdateManyMutationInput, ActivityTemplateUncheckedUpdateManyWithoutParentActivityInput>
  }

  export type ActivityUpsertWithWhereUniqueWithoutTemplateInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutTemplateInput, ActivityUncheckedUpdateWithoutTemplateInput>
    create: XOR<ActivityCreateWithoutTemplateInput, ActivityUncheckedCreateWithoutTemplateInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutTemplateInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutTemplateInput, ActivityUncheckedUpdateWithoutTemplateInput>
  }

  export type ActivityUpdateManyWithWhereWithoutTemplateInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutTemplateInput>
  }

  export type TemplateAssignmentUpsertWithWhereUniqueWithoutActivityTemplateInput = {
    where: TemplateAssignmentWhereUniqueInput
    update: XOR<TemplateAssignmentUpdateWithoutActivityTemplateInput, TemplateAssignmentUncheckedUpdateWithoutActivityTemplateInput>
    create: XOR<TemplateAssignmentCreateWithoutActivityTemplateInput, TemplateAssignmentUncheckedCreateWithoutActivityTemplateInput>
  }

  export type TemplateAssignmentUpdateWithWhereUniqueWithoutActivityTemplateInput = {
    where: TemplateAssignmentWhereUniqueInput
    data: XOR<TemplateAssignmentUpdateWithoutActivityTemplateInput, TemplateAssignmentUncheckedUpdateWithoutActivityTemplateInput>
  }

  export type TemplateAssignmentUpdateManyWithWhereWithoutActivityTemplateInput = {
    where: TemplateAssignmentScalarWhereInput
    data: XOR<TemplateAssignmentUpdateManyMutationInput, TemplateAssignmentUncheckedUpdateManyWithoutActivityTemplateInput>
  }

  export type TenetUpsertWithoutActivityTemplatesInput = {
    update: XOR<TenetUpdateWithoutActivityTemplatesInput, TenetUncheckedUpdateWithoutActivityTemplatesInput>
    create: XOR<TenetCreateWithoutActivityTemplatesInput, TenetUncheckedCreateWithoutActivityTemplatesInput>
    where?: TenetWhereInput
  }

  export type TenetUpdateToOneWithWhereWithoutActivityTemplatesInput = {
    where?: TenetWhereInput
    data: XOR<TenetUpdateWithoutActivityTemplatesInput, TenetUncheckedUpdateWithoutActivityTemplatesInput>
  }

  export type TenetUpdateWithoutActivityTemplatesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenetNestedInput
    logs?: LogUpdateManyWithoutTenetNestedInput
    contacts?: ContactUpdateManyWithoutTenetNestedInput
    activities?: ActivityUpdateManyWithoutTenetNestedInput
    addresses?: AddressUpdateManyWithoutTenetNestedInput
    contactEmails?: ContactEmailUpdateManyWithoutTenetNestedInput
    contactPhones?: ContactPhoneUpdateManyWithoutTenetNestedInput
    importantDates?: ImportantDateUpdateManyWithoutTenetNestedInput
    attachments?: AttachmentUpdateManyWithoutTenetNestedInput
    notes?: NoteUpdateManyWithoutTenetNestedInput
    auditEvents?: AuditEventUpdateManyWithoutTenetNestedInput
    contactTimelineEvents?: ContactTimelineEventUpdateManyWithoutTenetNestedInput
    activitySteps?: ActivityStepUpdateManyWithoutTenetNestedInput
    activityWaypoints?: ActivityWaypointUpdateManyWithoutTenetNestedInput
    templateAssignments?: TemplateAssignmentUpdateManyWithoutTenetNestedInput
    activityWaypointTemplates?: ActivityWaypointTemplateUpdateManyWithoutTenetNestedInput
    activityTemplateSteps?: ActivityTemplateStepUpdateManyWithoutTenetNestedInput
    opportunities?: OpportunityUpdateManyWithoutTenetNestedInput
    products?: ProductTypeUpdateManyWithoutTenetNestedInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentUpdateManyWithoutTenetNestedInput
  }

  export type TenetUncheckedUpdateWithoutActivityTemplatesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenetNestedInput
    logs?: LogUncheckedUpdateManyWithoutTenetNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutTenetNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutTenetNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutTenetNestedInput
    contactEmails?: ContactEmailUncheckedUpdateManyWithoutTenetNestedInput
    contactPhones?: ContactPhoneUncheckedUpdateManyWithoutTenetNestedInput
    importantDates?: ImportantDateUncheckedUpdateManyWithoutTenetNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTenetNestedInput
    notes?: NoteUncheckedUpdateManyWithoutTenetNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutTenetNestedInput
    contactTimelineEvents?: ContactTimelineEventUncheckedUpdateManyWithoutTenetNestedInput
    activitySteps?: ActivityStepUncheckedUpdateManyWithoutTenetNestedInput
    activityWaypoints?: ActivityWaypointUncheckedUpdateManyWithoutTenetNestedInput
    templateAssignments?: TemplateAssignmentUncheckedUpdateManyWithoutTenetNestedInput
    activityWaypointTemplates?: ActivityWaypointTemplateUncheckedUpdateManyWithoutTenetNestedInput
    activityTemplateSteps?: ActivityTemplateStepUncheckedUpdateManyWithoutTenetNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutTenetNestedInput
    products?: ProductTypeUncheckedUpdateManyWithoutTenetNestedInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentUncheckedUpdateManyWithoutTenetNestedInput
  }

  export type ActivityStepCreateWithoutActivityInput = {
    id: Uint8Array
    title: string
    completed: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    type?: $Enums.ActivityStepType
    order: number
    assignedTo?: ActivityStepUserJoinCreateNestedManyWithoutStepRelationInput
    tenet: TenetCreateNestedOneWithoutActivityStepsInput
  }

  export type ActivityStepUncheckedCreateWithoutActivityInput = {
    id: Uint8Array
    title: string
    completed: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
    type?: $Enums.ActivityStepType
    order: number
    assignedTo?: ActivityStepUserJoinUncheckedCreateNestedManyWithoutStepRelationInput
  }

  export type ActivityStepCreateOrConnectWithoutActivityInput = {
    where: ActivityStepWhereUniqueInput
    create: XOR<ActivityStepCreateWithoutActivityInput, ActivityStepUncheckedCreateWithoutActivityInput>
  }

  export type ActivityStepCreateManyActivityInputEnvelope = {
    data: ActivityStepCreateManyActivityInput | ActivityStepCreateManyActivityInput[]
    skipDuplicates?: boolean
  }

  export type ActivityWaypointCreateWithoutActivityInput = {
    id: Uint8Array
    title: string
    description?: string | null
    summary?: string | null
    status: $Enums.ActivityStatus
    order: number
    actualStart: Date | string
    dueDate: Date | string
    actualEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserWaypointJoinCreateNestedManyWithoutWaypointRelationInput
    childActivities?: ActivityCreateNestedManyWithoutParentWaypointInput
    template?: ActivityWaypointTemplateCreateNestedOneWithoutWaypointsInput
    events?: ContactTimelineEventCreateNestedManyWithoutWaypointInput
    tenet: TenetCreateNestedOneWithoutActivityWaypointsInput
    Note?: NoteCreateNestedManyWithoutWaypointInput
  }

  export type ActivityWaypointUncheckedCreateWithoutActivityInput = {
    id: Uint8Array
    title: string
    description?: string | null
    summary?: string | null
    status: $Enums.ActivityStatus
    order: number
    actualStart: Date | string
    dueDate: Date | string
    actualEnd?: Date | string | null
    templateId?: Uint8Array | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
    users?: UserWaypointJoinUncheckedCreateNestedManyWithoutWaypointRelationInput
    childActivities?: ActivityUncheckedCreateNestedManyWithoutParentWaypointInput
    events?: ContactTimelineEventUncheckedCreateNestedManyWithoutWaypointInput
    Note?: NoteUncheckedCreateNestedManyWithoutWaypointInput
  }

  export type ActivityWaypointCreateOrConnectWithoutActivityInput = {
    where: ActivityWaypointWhereUniqueInput
    create: XOR<ActivityWaypointCreateWithoutActivityInput, ActivityWaypointUncheckedCreateWithoutActivityInput>
  }

  export type ActivityWaypointCreateManyActivityInputEnvelope = {
    data: ActivityWaypointCreateManyActivityInput | ActivityWaypointCreateManyActivityInput[]
    skipDuplicates?: boolean
  }

  export type ActivityCreateWithoutParentActivityInput = {
    id: Uint8Array
    title: string
    type: $Enums.ActivityType
    taskScheduleType?: $Enums.TaskScheduleType | null
    startDate: Date | string
    endDate: Date | string
    completedAt?: Date | string | null
    description?: string | null
    priority?: $Enums.ActivityPriority
    status: $Enums.ActivityStatus
    phoneNumber?: string | null
    location?: string | null
    holdReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean
    deletedAt?: Date | string | null
    order?: number | null
    steps?: ActivityStepCreateNestedManyWithoutActivityInput
    waypoints?: ActivityWaypointCreateNestedManyWithoutActivityInput
    activities?: ActivityCreateNestedManyWithoutParentActivityInput
    parentWaypoint?: ActivityWaypointCreateNestedOneWithoutChildActivitiesInput
    template?: ActivityTemplateCreateNestedOneWithoutActivitiesInput
    assignedBy: UserCreateNestedOneWithoutAssignedActivitiesInput
    contacts?: ActivityContactJoinCreateNestedManyWithoutActivityRelationInput
    users?: ActivityUserJoinCreateNestedManyWithoutActivityRelationInput
    tenet: TenetCreateNestedOneWithoutActivitiesInput
    attachments?: AttachmentCreateNestedManyWithoutActivityInput
    notes?: NoteCreateNestedManyWithoutActivityInput
    events?: ContactTimelineEventCreateNestedManyWithoutActivityInput
    opportunity?: OpportunityCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateWithoutParentActivityInput = {
    id: Uint8Array
    title: string
    type: $Enums.ActivityType
    parentWaypointId?: Uint8Array | null
    templateId?: Uint8Array | null
    taskScheduleType?: $Enums.TaskScheduleType | null
    startDate: Date | string
    endDate: Date | string
    completedAt?: Date | string | null
    description?: string | null
    priority?: $Enums.ActivityPriority
    status: $Enums.ActivityStatus
    assignedById: Uint8Array
    phoneNumber?: string | null
    location?: string | null
    holdReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
    deleted?: boolean
    deletedAt?: Date | string | null
    order?: number | null
    opportunityId?: Uint8Array | null
    steps?: ActivityStepUncheckedCreateNestedManyWithoutActivityInput
    waypoints?: ActivityWaypointUncheckedCreateNestedManyWithoutActivityInput
    activities?: ActivityUncheckedCreateNestedManyWithoutParentActivityInput
    contacts?: ActivityContactJoinUncheckedCreateNestedManyWithoutActivityRelationInput
    users?: ActivityUserJoinUncheckedCreateNestedManyWithoutActivityRelationInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutActivityInput
    notes?: NoteUncheckedCreateNestedManyWithoutActivityInput
    events?: ContactTimelineEventUncheckedCreateNestedManyWithoutActivityInput
  }

  export type ActivityCreateOrConnectWithoutParentActivityInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutParentActivityInput, ActivityUncheckedCreateWithoutParentActivityInput>
  }

  export type ActivityCreateManyParentActivityInputEnvelope = {
    data: ActivityCreateManyParentActivityInput | ActivityCreateManyParentActivityInput[]
    skipDuplicates?: boolean
  }

  export type ActivityCreateWithoutActivitiesInput = {
    id: Uint8Array
    title: string
    type: $Enums.ActivityType
    taskScheduleType?: $Enums.TaskScheduleType | null
    startDate: Date | string
    endDate: Date | string
    completedAt?: Date | string | null
    description?: string | null
    priority?: $Enums.ActivityPriority
    status: $Enums.ActivityStatus
    phoneNumber?: string | null
    location?: string | null
    holdReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean
    deletedAt?: Date | string | null
    order?: number | null
    steps?: ActivityStepCreateNestedManyWithoutActivityInput
    waypoints?: ActivityWaypointCreateNestedManyWithoutActivityInput
    parentActivity?: ActivityCreateNestedOneWithoutActivitiesInput
    parentWaypoint?: ActivityWaypointCreateNestedOneWithoutChildActivitiesInput
    template?: ActivityTemplateCreateNestedOneWithoutActivitiesInput
    assignedBy: UserCreateNestedOneWithoutAssignedActivitiesInput
    contacts?: ActivityContactJoinCreateNestedManyWithoutActivityRelationInput
    users?: ActivityUserJoinCreateNestedManyWithoutActivityRelationInput
    tenet: TenetCreateNestedOneWithoutActivitiesInput
    attachments?: AttachmentCreateNestedManyWithoutActivityInput
    notes?: NoteCreateNestedManyWithoutActivityInput
    events?: ContactTimelineEventCreateNestedManyWithoutActivityInput
    opportunity?: OpportunityCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateWithoutActivitiesInput = {
    id: Uint8Array
    title: string
    type: $Enums.ActivityType
    parentActivityId?: Uint8Array | null
    parentWaypointId?: Uint8Array | null
    templateId?: Uint8Array | null
    taskScheduleType?: $Enums.TaskScheduleType | null
    startDate: Date | string
    endDate: Date | string
    completedAt?: Date | string | null
    description?: string | null
    priority?: $Enums.ActivityPriority
    status: $Enums.ActivityStatus
    assignedById: Uint8Array
    phoneNumber?: string | null
    location?: string | null
    holdReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
    deleted?: boolean
    deletedAt?: Date | string | null
    order?: number | null
    opportunityId?: Uint8Array | null
    steps?: ActivityStepUncheckedCreateNestedManyWithoutActivityInput
    waypoints?: ActivityWaypointUncheckedCreateNestedManyWithoutActivityInput
    contacts?: ActivityContactJoinUncheckedCreateNestedManyWithoutActivityRelationInput
    users?: ActivityUserJoinUncheckedCreateNestedManyWithoutActivityRelationInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutActivityInput
    notes?: NoteUncheckedCreateNestedManyWithoutActivityInput
    events?: ContactTimelineEventUncheckedCreateNestedManyWithoutActivityInput
  }

  export type ActivityCreateOrConnectWithoutActivitiesInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutActivitiesInput, ActivityUncheckedCreateWithoutActivitiesInput>
  }

  export type ActivityWaypointCreateWithoutChildActivitiesInput = {
    id: Uint8Array
    title: string
    description?: string | null
    summary?: string | null
    status: $Enums.ActivityStatus
    order: number
    actualStart: Date | string
    dueDate: Date | string
    actualEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserWaypointJoinCreateNestedManyWithoutWaypointRelationInput
    activity: ActivityCreateNestedOneWithoutWaypointsInput
    template?: ActivityWaypointTemplateCreateNestedOneWithoutWaypointsInput
    events?: ContactTimelineEventCreateNestedManyWithoutWaypointInput
    tenet: TenetCreateNestedOneWithoutActivityWaypointsInput
    Note?: NoteCreateNestedManyWithoutWaypointInput
  }

  export type ActivityWaypointUncheckedCreateWithoutChildActivitiesInput = {
    id: Uint8Array
    title: string
    description?: string | null
    summary?: string | null
    status: $Enums.ActivityStatus
    order: number
    actualStart: Date | string
    dueDate: Date | string
    actualEnd?: Date | string | null
    activityId: Uint8Array
    templateId?: Uint8Array | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
    users?: UserWaypointJoinUncheckedCreateNestedManyWithoutWaypointRelationInput
    events?: ContactTimelineEventUncheckedCreateNestedManyWithoutWaypointInput
    Note?: NoteUncheckedCreateNestedManyWithoutWaypointInput
  }

  export type ActivityWaypointCreateOrConnectWithoutChildActivitiesInput = {
    where: ActivityWaypointWhereUniqueInput
    create: XOR<ActivityWaypointCreateWithoutChildActivitiesInput, ActivityWaypointUncheckedCreateWithoutChildActivitiesInput>
  }

  export type ActivityTemplateCreateWithoutActivitiesInput = {
    id: Uint8Array
    title: string
    description?: string | null
    type: $Enums.ActivityType
    defaultPriority: $Enums.ActivityPriority
    defaultStatus: $Enums.ActivityStatus
    taskScheduleType?: $Enums.TaskScheduleType | null
    dateOffsetType: $Enums.DateOffsetType
    startDate: number
    endDate: number
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: number | null
    steps?: ActivityTemplateStepCreateNestedManyWithoutActivityTemplateInput
    startRelativeTo?: ActivityTemplateCreateNestedOneWithoutDependentsInput
    dependents?: ActivityTemplateCreateNestedManyWithoutStartRelativeToInput
    parentWaypoint?: ActivityWaypointTemplateCreateNestedOneWithoutActivitiesInput
    parentActivity?: ActivityTemplateCreateNestedOneWithoutChildActivitiesInput
    waypoints?: ActivityWaypointTemplateCreateNestedManyWithoutParentActivityInput
    childActivities?: ActivityTemplateCreateNestedManyWithoutParentActivityInput
    assignments?: TemplateAssignmentCreateNestedManyWithoutActivityTemplateInput
    tenet: TenetCreateNestedOneWithoutActivityTemplatesInput
  }

  export type ActivityTemplateUncheckedCreateWithoutActivitiesInput = {
    id: Uint8Array
    title: string
    description?: string | null
    type: $Enums.ActivityType
    defaultPriority: $Enums.ActivityPriority
    defaultStatus: $Enums.ActivityStatus
    taskScheduleType?: $Enums.TaskScheduleType | null
    dateOffsetType: $Enums.DateOffsetType
    startDate: number
    endDate: number
    startRelativeToId?: Uint8Array | null
    parentWaypointId?: Uint8Array | null
    parentActivityId?: Uint8Array | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
    order?: number | null
    steps?: ActivityTemplateStepUncheckedCreateNestedManyWithoutActivityTemplateInput
    dependents?: ActivityTemplateUncheckedCreateNestedManyWithoutStartRelativeToInput
    waypoints?: ActivityWaypointTemplateUncheckedCreateNestedManyWithoutParentActivityInput
    childActivities?: ActivityTemplateUncheckedCreateNestedManyWithoutParentActivityInput
    assignments?: TemplateAssignmentUncheckedCreateNestedManyWithoutActivityTemplateInput
  }

  export type ActivityTemplateCreateOrConnectWithoutActivitiesInput = {
    where: ActivityTemplateWhereUniqueInput
    create: XOR<ActivityTemplateCreateWithoutActivitiesInput, ActivityTemplateUncheckedCreateWithoutActivitiesInput>
  }

  export type UserCreateWithoutAssignedActivitiesInput = {
    id: Uint8Array
    email: string
    firstName: string
    lastName: string
    fullName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password: string
    enabled?: boolean
    type?: $Enums.AccessGroup
    system?: boolean
    deleted?: boolean
    deletedAt?: Date | string | null
    tokens?: TokenCreateNestedManyWithoutUserInput
    tenet?: TenetCreateNestedOneWithoutUsersInput
    activities?: ActivityUserJoinCreateNestedManyWithoutUserRelationInput
    notes?: NoteCreateNestedManyWithoutAuthorInput
    waypoints?: UserWaypointJoinCreateNestedManyWithoutUserRelationInput
    events?: ContactTimelineEventCreateNestedManyWithoutUserInput
    auditEvents?: AuditEventCreateNestedManyWithoutUserInput
    templateAssignments?: TemplateAssignmentCreateNestedManyWithoutSpecificUserInput
    opportunities?: UserOpportunityJoinCreateNestedManyWithoutUserRelationInput
    activitySteps?: ActivityStepUserJoinCreateNestedManyWithoutUserRelationInput
    templateStepAssignments?: ActivityTemplateStepAssignmentCreateNestedManyWithoutSpecificUserInput
  }

  export type UserUncheckedCreateWithoutAssignedActivitiesInput = {
    id: Uint8Array
    email: string
    firstName: string
    lastName: string
    fullName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password: string
    enabled?: boolean
    type?: $Enums.AccessGroup
    tenetId?: Uint8Array | null
    system?: boolean
    deleted?: boolean
    deletedAt?: Date | string | null
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUserJoinUncheckedCreateNestedManyWithoutUserRelationInput
    notes?: NoteUncheckedCreateNestedManyWithoutAuthorInput
    waypoints?: UserWaypointJoinUncheckedCreateNestedManyWithoutUserRelationInput
    events?: ContactTimelineEventUncheckedCreateNestedManyWithoutUserInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutUserInput
    templateAssignments?: TemplateAssignmentUncheckedCreateNestedManyWithoutSpecificUserInput
    opportunities?: UserOpportunityJoinUncheckedCreateNestedManyWithoutUserRelationInput
    activitySteps?: ActivityStepUserJoinUncheckedCreateNestedManyWithoutUserRelationInput
    templateStepAssignments?: ActivityTemplateStepAssignmentUncheckedCreateNestedManyWithoutSpecificUserInput
  }

  export type UserCreateOrConnectWithoutAssignedActivitiesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedActivitiesInput, UserUncheckedCreateWithoutAssignedActivitiesInput>
  }

  export type ActivityContactJoinCreateWithoutActivityRelationInput = {
    contactRelation: ContactCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityContactJoinUncheckedCreateWithoutActivityRelationInput = {
    contactId: Uint8Array
  }

  export type ActivityContactJoinCreateOrConnectWithoutActivityRelationInput = {
    where: ActivityContactJoinWhereUniqueInput
    create: XOR<ActivityContactJoinCreateWithoutActivityRelationInput, ActivityContactJoinUncheckedCreateWithoutActivityRelationInput>
  }

  export type ActivityContactJoinCreateManyActivityRelationInputEnvelope = {
    data: ActivityContactJoinCreateManyActivityRelationInput | ActivityContactJoinCreateManyActivityRelationInput[]
    skipDuplicates?: boolean
  }

  export type ActivityUserJoinCreateWithoutActivityRelationInput = {
    userRelation: UserCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityUserJoinUncheckedCreateWithoutActivityRelationInput = {
    userId: Uint8Array
  }

  export type ActivityUserJoinCreateOrConnectWithoutActivityRelationInput = {
    where: ActivityUserJoinWhereUniqueInput
    create: XOR<ActivityUserJoinCreateWithoutActivityRelationInput, ActivityUserJoinUncheckedCreateWithoutActivityRelationInput>
  }

  export type ActivityUserJoinCreateManyActivityRelationInputEnvelope = {
    data: ActivityUserJoinCreateManyActivityRelationInput | ActivityUserJoinCreateManyActivityRelationInput[]
    skipDuplicates?: boolean
  }

  export type TenetCreateWithoutActivitiesInput = {
    id: Uint8Array
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenetInput
    logs?: LogCreateNestedManyWithoutTenetInput
    contacts?: ContactCreateNestedManyWithoutTenetInput
    addresses?: AddressCreateNestedManyWithoutTenetInput
    contactEmails?: ContactEmailCreateNestedManyWithoutTenetInput
    contactPhones?: ContactPhoneCreateNestedManyWithoutTenetInput
    importantDates?: ImportantDateCreateNestedManyWithoutTenetInput
    attachments?: AttachmentCreateNestedManyWithoutTenetInput
    notes?: NoteCreateNestedManyWithoutTenetInput
    auditEvents?: AuditEventCreateNestedManyWithoutTenetInput
    contactTimelineEvents?: ContactTimelineEventCreateNestedManyWithoutTenetInput
    activitySteps?: ActivityStepCreateNestedManyWithoutTenetInput
    activityWaypoints?: ActivityWaypointCreateNestedManyWithoutTenetInput
    templateAssignments?: TemplateAssignmentCreateNestedManyWithoutTenetInput
    activityWaypointTemplates?: ActivityWaypointTemplateCreateNestedManyWithoutTenetInput
    activityTemplates?: ActivityTemplateCreateNestedManyWithoutTenetInput
    activityTemplateSteps?: ActivityTemplateStepCreateNestedManyWithoutTenetInput
    opportunities?: OpportunityCreateNestedManyWithoutTenetInput
    products?: ProductTypeCreateNestedManyWithoutTenetInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentCreateNestedManyWithoutTenetInput
  }

  export type TenetUncheckedCreateWithoutActivitiesInput = {
    id: Uint8Array
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenetInput
    logs?: LogUncheckedCreateNestedManyWithoutTenetInput
    contacts?: ContactUncheckedCreateNestedManyWithoutTenetInput
    addresses?: AddressUncheckedCreateNestedManyWithoutTenetInput
    contactEmails?: ContactEmailUncheckedCreateNestedManyWithoutTenetInput
    contactPhones?: ContactPhoneUncheckedCreateNestedManyWithoutTenetInput
    importantDates?: ImportantDateUncheckedCreateNestedManyWithoutTenetInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTenetInput
    notes?: NoteUncheckedCreateNestedManyWithoutTenetInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutTenetInput
    contactTimelineEvents?: ContactTimelineEventUncheckedCreateNestedManyWithoutTenetInput
    activitySteps?: ActivityStepUncheckedCreateNestedManyWithoutTenetInput
    activityWaypoints?: ActivityWaypointUncheckedCreateNestedManyWithoutTenetInput
    templateAssignments?: TemplateAssignmentUncheckedCreateNestedManyWithoutTenetInput
    activityWaypointTemplates?: ActivityWaypointTemplateUncheckedCreateNestedManyWithoutTenetInput
    activityTemplates?: ActivityTemplateUncheckedCreateNestedManyWithoutTenetInput
    activityTemplateSteps?: ActivityTemplateStepUncheckedCreateNestedManyWithoutTenetInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutTenetInput
    products?: ProductTypeUncheckedCreateNestedManyWithoutTenetInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentUncheckedCreateNestedManyWithoutTenetInput
  }

  export type TenetCreateOrConnectWithoutActivitiesInput = {
    where: TenetWhereUniqueInput
    create: XOR<TenetCreateWithoutActivitiesInput, TenetUncheckedCreateWithoutActivitiesInput>
  }

  export type AttachmentCreateWithoutActivityInput = {
    id: Uint8Array
    name: string
    location: string
    tenet: TenetCreateNestedOneWithoutAttachmentsInput
  }

  export type AttachmentUncheckedCreateWithoutActivityInput = {
    id: Uint8Array
    name: string
    location: string
    tenetId: Uint8Array
  }

  export type AttachmentCreateOrConnectWithoutActivityInput = {
    where: AttachmentWhereUniqueInput
    create: XOR<AttachmentCreateWithoutActivityInput, AttachmentUncheckedCreateWithoutActivityInput>
  }

  export type AttachmentCreateManyActivityInputEnvelope = {
    data: AttachmentCreateManyActivityInput | AttachmentCreateManyActivityInput[]
    skipDuplicates?: boolean
  }

  export type NoteCreateWithoutActivityInput = {
    id: Uint8Array
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean
    deletedAt?: Date | string | null
    noteType?: $Enums.NoteType
    waypoint?: ActivityWaypointCreateNestedOneWithoutNoteInput
    contact?: ContactCreateNestedOneWithoutNotesInput
    opportunity?: OpportunityCreateNestedOneWithoutNotesInput
    tenet: TenetCreateNestedOneWithoutNotesInput
    author: UserCreateNestedOneWithoutNotesInput
    events?: ContactTimelineEventCreateNestedManyWithoutNoteInput
  }

  export type NoteUncheckedCreateWithoutActivityInput = {
    id: Uint8Array
    content: string
    waypointId?: Uint8Array | null
    contactId?: Uint8Array | null
    opportunityId?: Uint8Array | null
    tenetId: Uint8Array
    authorId: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean
    deletedAt?: Date | string | null
    noteType?: $Enums.NoteType
    events?: ContactTimelineEventUncheckedCreateNestedManyWithoutNoteInput
  }

  export type NoteCreateOrConnectWithoutActivityInput = {
    where: NoteWhereUniqueInput
    create: XOR<NoteCreateWithoutActivityInput, NoteUncheckedCreateWithoutActivityInput>
  }

  export type NoteCreateManyActivityInputEnvelope = {
    data: NoteCreateManyActivityInput | NoteCreateManyActivityInput[]
    skipDuplicates?: boolean
  }

  export type ContactTimelineEventCreateWithoutActivityInput = {
    id: Uint8Array
    extraInfo?: string | null
    eventType: $Enums.ContactTimelineEventType
    relationshipType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    waypoint?: ActivityWaypointCreateNestedOneWithoutEventsInput
    opportunity?: OpportunityCreateNestedOneWithoutEventsInput
    note?: NoteCreateNestedOneWithoutEventsInput
    contacts?: ContactTimelineEventContactJoinCreateNestedManyWithoutContactEventRelationInput
    user: UserCreateNestedOneWithoutEventsInput
    tenet: TenetCreateNestedOneWithoutContactTimelineEventsInput
  }

  export type ContactTimelineEventUncheckedCreateWithoutActivityInput = {
    id: Uint8Array
    waypointId?: Uint8Array | null
    opportunityId?: Uint8Array | null
    noteId?: Uint8Array | null
    extraInfo?: string | null
    userId: Uint8Array
    tenetId: Uint8Array
    eventType: $Enums.ContactTimelineEventType
    relationshipType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: ContactTimelineEventContactJoinUncheckedCreateNestedManyWithoutContactEventRelationInput
  }

  export type ContactTimelineEventCreateOrConnectWithoutActivityInput = {
    where: ContactTimelineEventWhereUniqueInput
    create: XOR<ContactTimelineEventCreateWithoutActivityInput, ContactTimelineEventUncheckedCreateWithoutActivityInput>
  }

  export type ContactTimelineEventCreateManyActivityInputEnvelope = {
    data: ContactTimelineEventCreateManyActivityInput | ContactTimelineEventCreateManyActivityInput[]
    skipDuplicates?: boolean
  }

  export type OpportunityCreateWithoutActivitiesInput = {
    id: Uint8Array
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    value: number
    probability: number
    expectedCloseDate: Date | string
    actualCloseDate?: Date | string | null
    status: $Enums.OpportunityStatus
    statusHistory?: OpportunityCreatestatusHistoryInput | $Enums.OpportunityStatus[]
    deleted?: boolean
    deletedAt?: Date | string | null
    expectedValue: number
    contacts?: ContactOpportunityJoinCreateNestedManyWithoutOpportunityRelationInput
    teamMembers?: UserOpportunityJoinCreateNestedManyWithoutOpportunityRelationInput
    products?: OpportunityProductCreateNestedManyWithoutOpportunityInput
    tenet: TenetCreateNestedOneWithoutOpportunitiesInput
    events?: ContactTimelineEventCreateNestedManyWithoutOpportunityInput
    notes?: NoteCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityUncheckedCreateWithoutActivitiesInput = {
    id: Uint8Array
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    value: number
    probability: number
    expectedCloseDate: Date | string
    actualCloseDate?: Date | string | null
    status: $Enums.OpportunityStatus
    statusHistory?: OpportunityCreatestatusHistoryInput | $Enums.OpportunityStatus[]
    deleted?: boolean
    deletedAt?: Date | string | null
    tenetId: Uint8Array
    expectedValue: number
    contacts?: ContactOpportunityJoinUncheckedCreateNestedManyWithoutOpportunityRelationInput
    teamMembers?: UserOpportunityJoinUncheckedCreateNestedManyWithoutOpportunityRelationInput
    products?: OpportunityProductUncheckedCreateNestedManyWithoutOpportunityInput
    events?: ContactTimelineEventUncheckedCreateNestedManyWithoutOpportunityInput
    notes?: NoteUncheckedCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityCreateOrConnectWithoutActivitiesInput = {
    where: OpportunityWhereUniqueInput
    create: XOR<OpportunityCreateWithoutActivitiesInput, OpportunityUncheckedCreateWithoutActivitiesInput>
  }

  export type ActivityStepUpsertWithWhereUniqueWithoutActivityInput = {
    where: ActivityStepWhereUniqueInput
    update: XOR<ActivityStepUpdateWithoutActivityInput, ActivityStepUncheckedUpdateWithoutActivityInput>
    create: XOR<ActivityStepCreateWithoutActivityInput, ActivityStepUncheckedCreateWithoutActivityInput>
  }

  export type ActivityStepUpdateWithWhereUniqueWithoutActivityInput = {
    where: ActivityStepWhereUniqueInput
    data: XOR<ActivityStepUpdateWithoutActivityInput, ActivityStepUncheckedUpdateWithoutActivityInput>
  }

  export type ActivityStepUpdateManyWithWhereWithoutActivityInput = {
    where: ActivityStepScalarWhereInput
    data: XOR<ActivityStepUpdateManyMutationInput, ActivityStepUncheckedUpdateManyWithoutActivityInput>
  }

  export type ActivityWaypointUpsertWithWhereUniqueWithoutActivityInput = {
    where: ActivityWaypointWhereUniqueInput
    update: XOR<ActivityWaypointUpdateWithoutActivityInput, ActivityWaypointUncheckedUpdateWithoutActivityInput>
    create: XOR<ActivityWaypointCreateWithoutActivityInput, ActivityWaypointUncheckedCreateWithoutActivityInput>
  }

  export type ActivityWaypointUpdateWithWhereUniqueWithoutActivityInput = {
    where: ActivityWaypointWhereUniqueInput
    data: XOR<ActivityWaypointUpdateWithoutActivityInput, ActivityWaypointUncheckedUpdateWithoutActivityInput>
  }

  export type ActivityWaypointUpdateManyWithWhereWithoutActivityInput = {
    where: ActivityWaypointScalarWhereInput
    data: XOR<ActivityWaypointUpdateManyMutationInput, ActivityWaypointUncheckedUpdateManyWithoutActivityInput>
  }

  export type ActivityUpsertWithWhereUniqueWithoutParentActivityInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutParentActivityInput, ActivityUncheckedUpdateWithoutParentActivityInput>
    create: XOR<ActivityCreateWithoutParentActivityInput, ActivityUncheckedCreateWithoutParentActivityInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutParentActivityInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutParentActivityInput, ActivityUncheckedUpdateWithoutParentActivityInput>
  }

  export type ActivityUpdateManyWithWhereWithoutParentActivityInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutParentActivityInput>
  }

  export type ActivityUpsertWithoutActivitiesInput = {
    update: XOR<ActivityUpdateWithoutActivitiesInput, ActivityUncheckedUpdateWithoutActivitiesInput>
    create: XOR<ActivityCreateWithoutActivitiesInput, ActivityUncheckedCreateWithoutActivitiesInput>
    where?: ActivityWhereInput
  }

  export type ActivityUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: ActivityWhereInput
    data: XOR<ActivityUpdateWithoutActivitiesInput, ActivityUncheckedUpdateWithoutActivitiesInput>
  }

  export type ActivityUpdateWithoutActivitiesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    steps?: ActivityStepUpdateManyWithoutActivityNestedInput
    waypoints?: ActivityWaypointUpdateManyWithoutActivityNestedInput
    parentActivity?: ActivityUpdateOneWithoutActivitiesNestedInput
    parentWaypoint?: ActivityWaypointUpdateOneWithoutChildActivitiesNestedInput
    template?: ActivityTemplateUpdateOneWithoutActivitiesNestedInput
    assignedBy?: UserUpdateOneRequiredWithoutAssignedActivitiesNestedInput
    contacts?: ActivityContactJoinUpdateManyWithoutActivityRelationNestedInput
    users?: ActivityUserJoinUpdateManyWithoutActivityRelationNestedInput
    tenet?: TenetUpdateOneRequiredWithoutActivitiesNestedInput
    attachments?: AttachmentUpdateManyWithoutActivityNestedInput
    notes?: NoteUpdateManyWithoutActivityNestedInput
    events?: ContactTimelineEventUpdateManyWithoutActivityNestedInput
    opportunity?: OpportunityUpdateOneWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateWithoutActivitiesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    parentActivityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    parentWaypointId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    templateId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    assignedById?: BytesFieldUpdateOperationsInput | Uint8Array
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    opportunityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    steps?: ActivityStepUncheckedUpdateManyWithoutActivityNestedInput
    waypoints?: ActivityWaypointUncheckedUpdateManyWithoutActivityNestedInput
    contacts?: ActivityContactJoinUncheckedUpdateManyWithoutActivityRelationNestedInput
    users?: ActivityUserJoinUncheckedUpdateManyWithoutActivityRelationNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutActivityNestedInput
    notes?: NoteUncheckedUpdateManyWithoutActivityNestedInput
    events?: ContactTimelineEventUncheckedUpdateManyWithoutActivityNestedInput
  }

  export type ActivityWaypointUpsertWithoutChildActivitiesInput = {
    update: XOR<ActivityWaypointUpdateWithoutChildActivitiesInput, ActivityWaypointUncheckedUpdateWithoutChildActivitiesInput>
    create: XOR<ActivityWaypointCreateWithoutChildActivitiesInput, ActivityWaypointUncheckedCreateWithoutChildActivitiesInput>
    where?: ActivityWaypointWhereInput
  }

  export type ActivityWaypointUpdateToOneWithWhereWithoutChildActivitiesInput = {
    where?: ActivityWaypointWhereInput
    data: XOR<ActivityWaypointUpdateWithoutChildActivitiesInput, ActivityWaypointUncheckedUpdateWithoutChildActivitiesInput>
  }

  export type ActivityWaypointUpdateWithoutChildActivitiesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    order?: IntFieldUpdateOperationsInput | number
    actualStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserWaypointJoinUpdateManyWithoutWaypointRelationNestedInput
    activity?: ActivityUpdateOneRequiredWithoutWaypointsNestedInput
    template?: ActivityWaypointTemplateUpdateOneWithoutWaypointsNestedInput
    events?: ContactTimelineEventUpdateManyWithoutWaypointNestedInput
    tenet?: TenetUpdateOneRequiredWithoutActivityWaypointsNestedInput
    Note?: NoteUpdateManyWithoutWaypointNestedInput
  }

  export type ActivityWaypointUncheckedUpdateWithoutChildActivitiesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    order?: IntFieldUpdateOperationsInput | number
    actualStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activityId?: BytesFieldUpdateOperationsInput | Uint8Array
    templateId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    users?: UserWaypointJoinUncheckedUpdateManyWithoutWaypointRelationNestedInput
    events?: ContactTimelineEventUncheckedUpdateManyWithoutWaypointNestedInput
    Note?: NoteUncheckedUpdateManyWithoutWaypointNestedInput
  }

  export type ActivityTemplateUpsertWithoutActivitiesInput = {
    update: XOR<ActivityTemplateUpdateWithoutActivitiesInput, ActivityTemplateUncheckedUpdateWithoutActivitiesInput>
    create: XOR<ActivityTemplateCreateWithoutActivitiesInput, ActivityTemplateUncheckedCreateWithoutActivitiesInput>
    where?: ActivityTemplateWhereInput
  }

  export type ActivityTemplateUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: ActivityTemplateWhereInput
    data: XOR<ActivityTemplateUpdateWithoutActivitiesInput, ActivityTemplateUncheckedUpdateWithoutActivitiesInput>
  }

  export type ActivityTemplateUpdateWithoutActivitiesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    defaultPriority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    defaultStatus?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    dateOffsetType?: EnumDateOffsetTypeFieldUpdateOperationsInput | $Enums.DateOffsetType
    startDate?: IntFieldUpdateOperationsInput | number
    endDate?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    steps?: ActivityTemplateStepUpdateManyWithoutActivityTemplateNestedInput
    startRelativeTo?: ActivityTemplateUpdateOneWithoutDependentsNestedInput
    dependents?: ActivityTemplateUpdateManyWithoutStartRelativeToNestedInput
    parentWaypoint?: ActivityWaypointTemplateUpdateOneWithoutActivitiesNestedInput
    parentActivity?: ActivityTemplateUpdateOneWithoutChildActivitiesNestedInput
    waypoints?: ActivityWaypointTemplateUpdateManyWithoutParentActivityNestedInput
    childActivities?: ActivityTemplateUpdateManyWithoutParentActivityNestedInput
    assignments?: TemplateAssignmentUpdateManyWithoutActivityTemplateNestedInput
    tenet?: TenetUpdateOneRequiredWithoutActivityTemplatesNestedInput
  }

  export type ActivityTemplateUncheckedUpdateWithoutActivitiesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    defaultPriority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    defaultStatus?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    dateOffsetType?: EnumDateOffsetTypeFieldUpdateOperationsInput | $Enums.DateOffsetType
    startDate?: IntFieldUpdateOperationsInput | number
    endDate?: IntFieldUpdateOperationsInput | number
    startRelativeToId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    parentWaypointId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    parentActivityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    order?: NullableIntFieldUpdateOperationsInput | number | null
    steps?: ActivityTemplateStepUncheckedUpdateManyWithoutActivityTemplateNestedInput
    dependents?: ActivityTemplateUncheckedUpdateManyWithoutStartRelativeToNestedInput
    waypoints?: ActivityWaypointTemplateUncheckedUpdateManyWithoutParentActivityNestedInput
    childActivities?: ActivityTemplateUncheckedUpdateManyWithoutParentActivityNestedInput
    assignments?: TemplateAssignmentUncheckedUpdateManyWithoutActivityTemplateNestedInput
  }

  export type UserUpsertWithoutAssignedActivitiesInput = {
    update: XOR<UserUpdateWithoutAssignedActivitiesInput, UserUncheckedUpdateWithoutAssignedActivitiesInput>
    create: XOR<UserCreateWithoutAssignedActivitiesInput, UserUncheckedCreateWithoutAssignedActivitiesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignedActivitiesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignedActivitiesInput, UserUncheckedUpdateWithoutAssignedActivitiesInput>
  }

  export type UserUpdateWithoutAssignedActivitiesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumAccessGroupFieldUpdateOperationsInput | $Enums.AccessGroup
    system?: BoolFieldUpdateOperationsInput | boolean
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokens?: TokenUpdateManyWithoutUserNestedInput
    tenet?: TenetUpdateOneWithoutUsersNestedInput
    activities?: ActivityUserJoinUpdateManyWithoutUserRelationNestedInput
    notes?: NoteUpdateManyWithoutAuthorNestedInput
    waypoints?: UserWaypointJoinUpdateManyWithoutUserRelationNestedInput
    events?: ContactTimelineEventUpdateManyWithoutUserNestedInput
    auditEvents?: AuditEventUpdateManyWithoutUserNestedInput
    templateAssignments?: TemplateAssignmentUpdateManyWithoutSpecificUserNestedInput
    opportunities?: UserOpportunityJoinUpdateManyWithoutUserRelationNestedInput
    activitySteps?: ActivityStepUserJoinUpdateManyWithoutUserRelationNestedInput
    templateStepAssignments?: ActivityTemplateStepAssignmentUpdateManyWithoutSpecificUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedActivitiesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumAccessGroupFieldUpdateOperationsInput | $Enums.AccessGroup
    tenetId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    system?: BoolFieldUpdateOperationsInput | boolean
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUserJoinUncheckedUpdateManyWithoutUserRelationNestedInput
    notes?: NoteUncheckedUpdateManyWithoutAuthorNestedInput
    waypoints?: UserWaypointJoinUncheckedUpdateManyWithoutUserRelationNestedInput
    events?: ContactTimelineEventUncheckedUpdateManyWithoutUserNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutUserNestedInput
    templateAssignments?: TemplateAssignmentUncheckedUpdateManyWithoutSpecificUserNestedInput
    opportunities?: UserOpportunityJoinUncheckedUpdateManyWithoutUserRelationNestedInput
    activitySteps?: ActivityStepUserJoinUncheckedUpdateManyWithoutUserRelationNestedInput
    templateStepAssignments?: ActivityTemplateStepAssignmentUncheckedUpdateManyWithoutSpecificUserNestedInput
  }

  export type ActivityContactJoinUpsertWithWhereUniqueWithoutActivityRelationInput = {
    where: ActivityContactJoinWhereUniqueInput
    update: XOR<ActivityContactJoinUpdateWithoutActivityRelationInput, ActivityContactJoinUncheckedUpdateWithoutActivityRelationInput>
    create: XOR<ActivityContactJoinCreateWithoutActivityRelationInput, ActivityContactJoinUncheckedCreateWithoutActivityRelationInput>
  }

  export type ActivityContactJoinUpdateWithWhereUniqueWithoutActivityRelationInput = {
    where: ActivityContactJoinWhereUniqueInput
    data: XOR<ActivityContactJoinUpdateWithoutActivityRelationInput, ActivityContactJoinUncheckedUpdateWithoutActivityRelationInput>
  }

  export type ActivityContactJoinUpdateManyWithWhereWithoutActivityRelationInput = {
    where: ActivityContactJoinScalarWhereInput
    data: XOR<ActivityContactJoinUpdateManyMutationInput, ActivityContactJoinUncheckedUpdateManyWithoutActivityRelationInput>
  }

  export type ActivityUserJoinUpsertWithWhereUniqueWithoutActivityRelationInput = {
    where: ActivityUserJoinWhereUniqueInput
    update: XOR<ActivityUserJoinUpdateWithoutActivityRelationInput, ActivityUserJoinUncheckedUpdateWithoutActivityRelationInput>
    create: XOR<ActivityUserJoinCreateWithoutActivityRelationInput, ActivityUserJoinUncheckedCreateWithoutActivityRelationInput>
  }

  export type ActivityUserJoinUpdateWithWhereUniqueWithoutActivityRelationInput = {
    where: ActivityUserJoinWhereUniqueInput
    data: XOR<ActivityUserJoinUpdateWithoutActivityRelationInput, ActivityUserJoinUncheckedUpdateWithoutActivityRelationInput>
  }

  export type ActivityUserJoinUpdateManyWithWhereWithoutActivityRelationInput = {
    where: ActivityUserJoinScalarWhereInput
    data: XOR<ActivityUserJoinUpdateManyMutationInput, ActivityUserJoinUncheckedUpdateManyWithoutActivityRelationInput>
  }

  export type TenetUpsertWithoutActivitiesInput = {
    update: XOR<TenetUpdateWithoutActivitiesInput, TenetUncheckedUpdateWithoutActivitiesInput>
    create: XOR<TenetCreateWithoutActivitiesInput, TenetUncheckedCreateWithoutActivitiesInput>
    where?: TenetWhereInput
  }

  export type TenetUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: TenetWhereInput
    data: XOR<TenetUpdateWithoutActivitiesInput, TenetUncheckedUpdateWithoutActivitiesInput>
  }

  export type TenetUpdateWithoutActivitiesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenetNestedInput
    logs?: LogUpdateManyWithoutTenetNestedInput
    contacts?: ContactUpdateManyWithoutTenetNestedInput
    addresses?: AddressUpdateManyWithoutTenetNestedInput
    contactEmails?: ContactEmailUpdateManyWithoutTenetNestedInput
    contactPhones?: ContactPhoneUpdateManyWithoutTenetNestedInput
    importantDates?: ImportantDateUpdateManyWithoutTenetNestedInput
    attachments?: AttachmentUpdateManyWithoutTenetNestedInput
    notes?: NoteUpdateManyWithoutTenetNestedInput
    auditEvents?: AuditEventUpdateManyWithoutTenetNestedInput
    contactTimelineEvents?: ContactTimelineEventUpdateManyWithoutTenetNestedInput
    activitySteps?: ActivityStepUpdateManyWithoutTenetNestedInput
    activityWaypoints?: ActivityWaypointUpdateManyWithoutTenetNestedInput
    templateAssignments?: TemplateAssignmentUpdateManyWithoutTenetNestedInput
    activityWaypointTemplates?: ActivityWaypointTemplateUpdateManyWithoutTenetNestedInput
    activityTemplates?: ActivityTemplateUpdateManyWithoutTenetNestedInput
    activityTemplateSteps?: ActivityTemplateStepUpdateManyWithoutTenetNestedInput
    opportunities?: OpportunityUpdateManyWithoutTenetNestedInput
    products?: ProductTypeUpdateManyWithoutTenetNestedInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentUpdateManyWithoutTenetNestedInput
  }

  export type TenetUncheckedUpdateWithoutActivitiesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenetNestedInput
    logs?: LogUncheckedUpdateManyWithoutTenetNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutTenetNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutTenetNestedInput
    contactEmails?: ContactEmailUncheckedUpdateManyWithoutTenetNestedInput
    contactPhones?: ContactPhoneUncheckedUpdateManyWithoutTenetNestedInput
    importantDates?: ImportantDateUncheckedUpdateManyWithoutTenetNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTenetNestedInput
    notes?: NoteUncheckedUpdateManyWithoutTenetNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutTenetNestedInput
    contactTimelineEvents?: ContactTimelineEventUncheckedUpdateManyWithoutTenetNestedInput
    activitySteps?: ActivityStepUncheckedUpdateManyWithoutTenetNestedInput
    activityWaypoints?: ActivityWaypointUncheckedUpdateManyWithoutTenetNestedInput
    templateAssignments?: TemplateAssignmentUncheckedUpdateManyWithoutTenetNestedInput
    activityWaypointTemplates?: ActivityWaypointTemplateUncheckedUpdateManyWithoutTenetNestedInput
    activityTemplates?: ActivityTemplateUncheckedUpdateManyWithoutTenetNestedInput
    activityTemplateSteps?: ActivityTemplateStepUncheckedUpdateManyWithoutTenetNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutTenetNestedInput
    products?: ProductTypeUncheckedUpdateManyWithoutTenetNestedInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentUncheckedUpdateManyWithoutTenetNestedInput
  }

  export type AttachmentUpsertWithWhereUniqueWithoutActivityInput = {
    where: AttachmentWhereUniqueInput
    update: XOR<AttachmentUpdateWithoutActivityInput, AttachmentUncheckedUpdateWithoutActivityInput>
    create: XOR<AttachmentCreateWithoutActivityInput, AttachmentUncheckedCreateWithoutActivityInput>
  }

  export type AttachmentUpdateWithWhereUniqueWithoutActivityInput = {
    where: AttachmentWhereUniqueInput
    data: XOR<AttachmentUpdateWithoutActivityInput, AttachmentUncheckedUpdateWithoutActivityInput>
  }

  export type AttachmentUpdateManyWithWhereWithoutActivityInput = {
    where: AttachmentScalarWhereInput
    data: XOR<AttachmentUpdateManyMutationInput, AttachmentUncheckedUpdateManyWithoutActivityInput>
  }

  export type NoteUpsertWithWhereUniqueWithoutActivityInput = {
    where: NoteWhereUniqueInput
    update: XOR<NoteUpdateWithoutActivityInput, NoteUncheckedUpdateWithoutActivityInput>
    create: XOR<NoteCreateWithoutActivityInput, NoteUncheckedCreateWithoutActivityInput>
  }

  export type NoteUpdateWithWhereUniqueWithoutActivityInput = {
    where: NoteWhereUniqueInput
    data: XOR<NoteUpdateWithoutActivityInput, NoteUncheckedUpdateWithoutActivityInput>
  }

  export type NoteUpdateManyWithWhereWithoutActivityInput = {
    where: NoteScalarWhereInput
    data: XOR<NoteUpdateManyMutationInput, NoteUncheckedUpdateManyWithoutActivityInput>
  }

  export type ContactTimelineEventUpsertWithWhereUniqueWithoutActivityInput = {
    where: ContactTimelineEventWhereUniqueInput
    update: XOR<ContactTimelineEventUpdateWithoutActivityInput, ContactTimelineEventUncheckedUpdateWithoutActivityInput>
    create: XOR<ContactTimelineEventCreateWithoutActivityInput, ContactTimelineEventUncheckedCreateWithoutActivityInput>
  }

  export type ContactTimelineEventUpdateWithWhereUniqueWithoutActivityInput = {
    where: ContactTimelineEventWhereUniqueInput
    data: XOR<ContactTimelineEventUpdateWithoutActivityInput, ContactTimelineEventUncheckedUpdateWithoutActivityInput>
  }

  export type ContactTimelineEventUpdateManyWithWhereWithoutActivityInput = {
    where: ContactTimelineEventScalarWhereInput
    data: XOR<ContactTimelineEventUpdateManyMutationInput, ContactTimelineEventUncheckedUpdateManyWithoutActivityInput>
  }

  export type OpportunityUpsertWithoutActivitiesInput = {
    update: XOR<OpportunityUpdateWithoutActivitiesInput, OpportunityUncheckedUpdateWithoutActivitiesInput>
    create: XOR<OpportunityCreateWithoutActivitiesInput, OpportunityUncheckedCreateWithoutActivitiesInput>
    where?: OpportunityWhereInput
  }

  export type OpportunityUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: OpportunityWhereInput
    data: XOR<OpportunityUpdateWithoutActivitiesInput, OpportunityUncheckedUpdateWithoutActivitiesInput>
  }

  export type OpportunityUpdateWithoutActivitiesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    probability?: FloatFieldUpdateOperationsInput | number
    expectedCloseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumOpportunityStatusFieldUpdateOperationsInput | $Enums.OpportunityStatus
    statusHistory?: OpportunityUpdatestatusHistoryInput | $Enums.OpportunityStatus[]
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedValue?: FloatFieldUpdateOperationsInput | number
    contacts?: ContactOpportunityJoinUpdateManyWithoutOpportunityRelationNestedInput
    teamMembers?: UserOpportunityJoinUpdateManyWithoutOpportunityRelationNestedInput
    products?: OpportunityProductUpdateManyWithoutOpportunityNestedInput
    tenet?: TenetUpdateOneRequiredWithoutOpportunitiesNestedInput
    events?: ContactTimelineEventUpdateManyWithoutOpportunityNestedInput
    notes?: NoteUpdateManyWithoutOpportunityNestedInput
  }

  export type OpportunityUncheckedUpdateWithoutActivitiesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    probability?: FloatFieldUpdateOperationsInput | number
    expectedCloseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumOpportunityStatusFieldUpdateOperationsInput | $Enums.OpportunityStatus
    statusHistory?: OpportunityUpdatestatusHistoryInput | $Enums.OpportunityStatus[]
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    expectedValue?: FloatFieldUpdateOperationsInput | number
    contacts?: ContactOpportunityJoinUncheckedUpdateManyWithoutOpportunityRelationNestedInput
    teamMembers?: UserOpportunityJoinUncheckedUpdateManyWithoutOpportunityRelationNestedInput
    products?: OpportunityProductUncheckedUpdateManyWithoutOpportunityNestedInput
    events?: ContactTimelineEventUncheckedUpdateManyWithoutOpportunityNestedInput
    notes?: NoteUncheckedUpdateManyWithoutOpportunityNestedInput
  }

  export type ActivityCreateWithoutEventsInput = {
    id: Uint8Array
    title: string
    type: $Enums.ActivityType
    taskScheduleType?: $Enums.TaskScheduleType | null
    startDate: Date | string
    endDate: Date | string
    completedAt?: Date | string | null
    description?: string | null
    priority?: $Enums.ActivityPriority
    status: $Enums.ActivityStatus
    phoneNumber?: string | null
    location?: string | null
    holdReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean
    deletedAt?: Date | string | null
    order?: number | null
    steps?: ActivityStepCreateNestedManyWithoutActivityInput
    waypoints?: ActivityWaypointCreateNestedManyWithoutActivityInput
    activities?: ActivityCreateNestedManyWithoutParentActivityInput
    parentActivity?: ActivityCreateNestedOneWithoutActivitiesInput
    parentWaypoint?: ActivityWaypointCreateNestedOneWithoutChildActivitiesInput
    template?: ActivityTemplateCreateNestedOneWithoutActivitiesInput
    assignedBy: UserCreateNestedOneWithoutAssignedActivitiesInput
    contacts?: ActivityContactJoinCreateNestedManyWithoutActivityRelationInput
    users?: ActivityUserJoinCreateNestedManyWithoutActivityRelationInput
    tenet: TenetCreateNestedOneWithoutActivitiesInput
    attachments?: AttachmentCreateNestedManyWithoutActivityInput
    notes?: NoteCreateNestedManyWithoutActivityInput
    opportunity?: OpportunityCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateWithoutEventsInput = {
    id: Uint8Array
    title: string
    type: $Enums.ActivityType
    parentActivityId?: Uint8Array | null
    parentWaypointId?: Uint8Array | null
    templateId?: Uint8Array | null
    taskScheduleType?: $Enums.TaskScheduleType | null
    startDate: Date | string
    endDate: Date | string
    completedAt?: Date | string | null
    description?: string | null
    priority?: $Enums.ActivityPriority
    status: $Enums.ActivityStatus
    assignedById: Uint8Array
    phoneNumber?: string | null
    location?: string | null
    holdReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
    deleted?: boolean
    deletedAt?: Date | string | null
    order?: number | null
    opportunityId?: Uint8Array | null
    steps?: ActivityStepUncheckedCreateNestedManyWithoutActivityInput
    waypoints?: ActivityWaypointUncheckedCreateNestedManyWithoutActivityInput
    activities?: ActivityUncheckedCreateNestedManyWithoutParentActivityInput
    contacts?: ActivityContactJoinUncheckedCreateNestedManyWithoutActivityRelationInput
    users?: ActivityUserJoinUncheckedCreateNestedManyWithoutActivityRelationInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutActivityInput
    notes?: NoteUncheckedCreateNestedManyWithoutActivityInput
  }

  export type ActivityCreateOrConnectWithoutEventsInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutEventsInput, ActivityUncheckedCreateWithoutEventsInput>
  }

  export type ActivityWaypointCreateWithoutEventsInput = {
    id: Uint8Array
    title: string
    description?: string | null
    summary?: string | null
    status: $Enums.ActivityStatus
    order: number
    actualStart: Date | string
    dueDate: Date | string
    actualEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserWaypointJoinCreateNestedManyWithoutWaypointRelationInput
    activity: ActivityCreateNestedOneWithoutWaypointsInput
    childActivities?: ActivityCreateNestedManyWithoutParentWaypointInput
    template?: ActivityWaypointTemplateCreateNestedOneWithoutWaypointsInput
    tenet: TenetCreateNestedOneWithoutActivityWaypointsInput
    Note?: NoteCreateNestedManyWithoutWaypointInput
  }

  export type ActivityWaypointUncheckedCreateWithoutEventsInput = {
    id: Uint8Array
    title: string
    description?: string | null
    summary?: string | null
    status: $Enums.ActivityStatus
    order: number
    actualStart: Date | string
    dueDate: Date | string
    actualEnd?: Date | string | null
    activityId: Uint8Array
    templateId?: Uint8Array | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
    users?: UserWaypointJoinUncheckedCreateNestedManyWithoutWaypointRelationInput
    childActivities?: ActivityUncheckedCreateNestedManyWithoutParentWaypointInput
    Note?: NoteUncheckedCreateNestedManyWithoutWaypointInput
  }

  export type ActivityWaypointCreateOrConnectWithoutEventsInput = {
    where: ActivityWaypointWhereUniqueInput
    create: XOR<ActivityWaypointCreateWithoutEventsInput, ActivityWaypointUncheckedCreateWithoutEventsInput>
  }

  export type OpportunityCreateWithoutEventsInput = {
    id: Uint8Array
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    value: number
    probability: number
    expectedCloseDate: Date | string
    actualCloseDate?: Date | string | null
    status: $Enums.OpportunityStatus
    statusHistory?: OpportunityCreatestatusHistoryInput | $Enums.OpportunityStatus[]
    deleted?: boolean
    deletedAt?: Date | string | null
    expectedValue: number
    contacts?: ContactOpportunityJoinCreateNestedManyWithoutOpportunityRelationInput
    teamMembers?: UserOpportunityJoinCreateNestedManyWithoutOpportunityRelationInput
    activities?: ActivityCreateNestedManyWithoutOpportunityInput
    products?: OpportunityProductCreateNestedManyWithoutOpportunityInput
    tenet: TenetCreateNestedOneWithoutOpportunitiesInput
    notes?: NoteCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityUncheckedCreateWithoutEventsInput = {
    id: Uint8Array
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    value: number
    probability: number
    expectedCloseDate: Date | string
    actualCloseDate?: Date | string | null
    status: $Enums.OpportunityStatus
    statusHistory?: OpportunityCreatestatusHistoryInput | $Enums.OpportunityStatus[]
    deleted?: boolean
    deletedAt?: Date | string | null
    tenetId: Uint8Array
    expectedValue: number
    contacts?: ContactOpportunityJoinUncheckedCreateNestedManyWithoutOpportunityRelationInput
    teamMembers?: UserOpportunityJoinUncheckedCreateNestedManyWithoutOpportunityRelationInput
    activities?: ActivityUncheckedCreateNestedManyWithoutOpportunityInput
    products?: OpportunityProductUncheckedCreateNestedManyWithoutOpportunityInput
    notes?: NoteUncheckedCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityCreateOrConnectWithoutEventsInput = {
    where: OpportunityWhereUniqueInput
    create: XOR<OpportunityCreateWithoutEventsInput, OpportunityUncheckedCreateWithoutEventsInput>
  }

  export type NoteCreateWithoutEventsInput = {
    id: Uint8Array
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean
    deletedAt?: Date | string | null
    noteType?: $Enums.NoteType
    waypoint?: ActivityWaypointCreateNestedOneWithoutNoteInput
    activity?: ActivityCreateNestedOneWithoutNotesInput
    contact?: ContactCreateNestedOneWithoutNotesInput
    opportunity?: OpportunityCreateNestedOneWithoutNotesInput
    tenet: TenetCreateNestedOneWithoutNotesInput
    author: UserCreateNestedOneWithoutNotesInput
  }

  export type NoteUncheckedCreateWithoutEventsInput = {
    id: Uint8Array
    content: string
    waypointId?: Uint8Array | null
    activityId?: Uint8Array | null
    contactId?: Uint8Array | null
    opportunityId?: Uint8Array | null
    tenetId: Uint8Array
    authorId: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean
    deletedAt?: Date | string | null
    noteType?: $Enums.NoteType
  }

  export type NoteCreateOrConnectWithoutEventsInput = {
    where: NoteWhereUniqueInput
    create: XOR<NoteCreateWithoutEventsInput, NoteUncheckedCreateWithoutEventsInput>
  }

  export type ContactTimelineEventContactJoinCreateWithoutContactEventRelationInput = {
    type: $Enums.ContactTimelineEventJoinType
    contactRelation: ContactCreateNestedOneWithoutTimelineEventsInput
  }

  export type ContactTimelineEventContactJoinUncheckedCreateWithoutContactEventRelationInput = {
    contactId: Uint8Array
    type: $Enums.ContactTimelineEventJoinType
  }

  export type ContactTimelineEventContactJoinCreateOrConnectWithoutContactEventRelationInput = {
    where: ContactTimelineEventContactJoinWhereUniqueInput
    create: XOR<ContactTimelineEventContactJoinCreateWithoutContactEventRelationInput, ContactTimelineEventContactJoinUncheckedCreateWithoutContactEventRelationInput>
  }

  export type ContactTimelineEventContactJoinCreateManyContactEventRelationInputEnvelope = {
    data: ContactTimelineEventContactJoinCreateManyContactEventRelationInput | ContactTimelineEventContactJoinCreateManyContactEventRelationInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutEventsInput = {
    id: Uint8Array
    email: string
    firstName: string
    lastName: string
    fullName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password: string
    enabled?: boolean
    type?: $Enums.AccessGroup
    system?: boolean
    deleted?: boolean
    deletedAt?: Date | string | null
    tokens?: TokenCreateNestedManyWithoutUserInput
    tenet?: TenetCreateNestedOneWithoutUsersInput
    activities?: ActivityUserJoinCreateNestedManyWithoutUserRelationInput
    notes?: NoteCreateNestedManyWithoutAuthorInput
    waypoints?: UserWaypointJoinCreateNestedManyWithoutUserRelationInput
    auditEvents?: AuditEventCreateNestedManyWithoutUserInput
    templateAssignments?: TemplateAssignmentCreateNestedManyWithoutSpecificUserInput
    assignedActivities?: ActivityCreateNestedManyWithoutAssignedByInput
    opportunities?: UserOpportunityJoinCreateNestedManyWithoutUserRelationInput
    activitySteps?: ActivityStepUserJoinCreateNestedManyWithoutUserRelationInput
    templateStepAssignments?: ActivityTemplateStepAssignmentCreateNestedManyWithoutSpecificUserInput
  }

  export type UserUncheckedCreateWithoutEventsInput = {
    id: Uint8Array
    email: string
    firstName: string
    lastName: string
    fullName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password: string
    enabled?: boolean
    type?: $Enums.AccessGroup
    tenetId?: Uint8Array | null
    system?: boolean
    deleted?: boolean
    deletedAt?: Date | string | null
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUserJoinUncheckedCreateNestedManyWithoutUserRelationInput
    notes?: NoteUncheckedCreateNestedManyWithoutAuthorInput
    waypoints?: UserWaypointJoinUncheckedCreateNestedManyWithoutUserRelationInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutUserInput
    templateAssignments?: TemplateAssignmentUncheckedCreateNestedManyWithoutSpecificUserInput
    assignedActivities?: ActivityUncheckedCreateNestedManyWithoutAssignedByInput
    opportunities?: UserOpportunityJoinUncheckedCreateNestedManyWithoutUserRelationInput
    activitySteps?: ActivityStepUserJoinUncheckedCreateNestedManyWithoutUserRelationInput
    templateStepAssignments?: ActivityTemplateStepAssignmentUncheckedCreateNestedManyWithoutSpecificUserInput
  }

  export type UserCreateOrConnectWithoutEventsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEventsInput, UserUncheckedCreateWithoutEventsInput>
  }

  export type TenetCreateWithoutContactTimelineEventsInput = {
    id: Uint8Array
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenetInput
    logs?: LogCreateNestedManyWithoutTenetInput
    contacts?: ContactCreateNestedManyWithoutTenetInput
    activities?: ActivityCreateNestedManyWithoutTenetInput
    addresses?: AddressCreateNestedManyWithoutTenetInput
    contactEmails?: ContactEmailCreateNestedManyWithoutTenetInput
    contactPhones?: ContactPhoneCreateNestedManyWithoutTenetInput
    importantDates?: ImportantDateCreateNestedManyWithoutTenetInput
    attachments?: AttachmentCreateNestedManyWithoutTenetInput
    notes?: NoteCreateNestedManyWithoutTenetInput
    auditEvents?: AuditEventCreateNestedManyWithoutTenetInput
    activitySteps?: ActivityStepCreateNestedManyWithoutTenetInput
    activityWaypoints?: ActivityWaypointCreateNestedManyWithoutTenetInput
    templateAssignments?: TemplateAssignmentCreateNestedManyWithoutTenetInput
    activityWaypointTemplates?: ActivityWaypointTemplateCreateNestedManyWithoutTenetInput
    activityTemplates?: ActivityTemplateCreateNestedManyWithoutTenetInput
    activityTemplateSteps?: ActivityTemplateStepCreateNestedManyWithoutTenetInput
    opportunities?: OpportunityCreateNestedManyWithoutTenetInput
    products?: ProductTypeCreateNestedManyWithoutTenetInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentCreateNestedManyWithoutTenetInput
  }

  export type TenetUncheckedCreateWithoutContactTimelineEventsInput = {
    id: Uint8Array
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenetInput
    logs?: LogUncheckedCreateNestedManyWithoutTenetInput
    contacts?: ContactUncheckedCreateNestedManyWithoutTenetInput
    activities?: ActivityUncheckedCreateNestedManyWithoutTenetInput
    addresses?: AddressUncheckedCreateNestedManyWithoutTenetInput
    contactEmails?: ContactEmailUncheckedCreateNestedManyWithoutTenetInput
    contactPhones?: ContactPhoneUncheckedCreateNestedManyWithoutTenetInput
    importantDates?: ImportantDateUncheckedCreateNestedManyWithoutTenetInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTenetInput
    notes?: NoteUncheckedCreateNestedManyWithoutTenetInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutTenetInput
    activitySteps?: ActivityStepUncheckedCreateNestedManyWithoutTenetInput
    activityWaypoints?: ActivityWaypointUncheckedCreateNestedManyWithoutTenetInput
    templateAssignments?: TemplateAssignmentUncheckedCreateNestedManyWithoutTenetInput
    activityWaypointTemplates?: ActivityWaypointTemplateUncheckedCreateNestedManyWithoutTenetInput
    activityTemplates?: ActivityTemplateUncheckedCreateNestedManyWithoutTenetInput
    activityTemplateSteps?: ActivityTemplateStepUncheckedCreateNestedManyWithoutTenetInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutTenetInput
    products?: ProductTypeUncheckedCreateNestedManyWithoutTenetInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentUncheckedCreateNestedManyWithoutTenetInput
  }

  export type TenetCreateOrConnectWithoutContactTimelineEventsInput = {
    where: TenetWhereUniqueInput
    create: XOR<TenetCreateWithoutContactTimelineEventsInput, TenetUncheckedCreateWithoutContactTimelineEventsInput>
  }

  export type ActivityUpsertWithoutEventsInput = {
    update: XOR<ActivityUpdateWithoutEventsInput, ActivityUncheckedUpdateWithoutEventsInput>
    create: XOR<ActivityCreateWithoutEventsInput, ActivityUncheckedCreateWithoutEventsInput>
    where?: ActivityWhereInput
  }

  export type ActivityUpdateToOneWithWhereWithoutEventsInput = {
    where?: ActivityWhereInput
    data: XOR<ActivityUpdateWithoutEventsInput, ActivityUncheckedUpdateWithoutEventsInput>
  }

  export type ActivityUpdateWithoutEventsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    steps?: ActivityStepUpdateManyWithoutActivityNestedInput
    waypoints?: ActivityWaypointUpdateManyWithoutActivityNestedInput
    activities?: ActivityUpdateManyWithoutParentActivityNestedInput
    parentActivity?: ActivityUpdateOneWithoutActivitiesNestedInput
    parentWaypoint?: ActivityWaypointUpdateOneWithoutChildActivitiesNestedInput
    template?: ActivityTemplateUpdateOneWithoutActivitiesNestedInput
    assignedBy?: UserUpdateOneRequiredWithoutAssignedActivitiesNestedInput
    contacts?: ActivityContactJoinUpdateManyWithoutActivityRelationNestedInput
    users?: ActivityUserJoinUpdateManyWithoutActivityRelationNestedInput
    tenet?: TenetUpdateOneRequiredWithoutActivitiesNestedInput
    attachments?: AttachmentUpdateManyWithoutActivityNestedInput
    notes?: NoteUpdateManyWithoutActivityNestedInput
    opportunity?: OpportunityUpdateOneWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateWithoutEventsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    parentActivityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    parentWaypointId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    templateId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    assignedById?: BytesFieldUpdateOperationsInput | Uint8Array
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    opportunityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    steps?: ActivityStepUncheckedUpdateManyWithoutActivityNestedInput
    waypoints?: ActivityWaypointUncheckedUpdateManyWithoutActivityNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutParentActivityNestedInput
    contacts?: ActivityContactJoinUncheckedUpdateManyWithoutActivityRelationNestedInput
    users?: ActivityUserJoinUncheckedUpdateManyWithoutActivityRelationNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutActivityNestedInput
    notes?: NoteUncheckedUpdateManyWithoutActivityNestedInput
  }

  export type ActivityWaypointUpsertWithoutEventsInput = {
    update: XOR<ActivityWaypointUpdateWithoutEventsInput, ActivityWaypointUncheckedUpdateWithoutEventsInput>
    create: XOR<ActivityWaypointCreateWithoutEventsInput, ActivityWaypointUncheckedCreateWithoutEventsInput>
    where?: ActivityWaypointWhereInput
  }

  export type ActivityWaypointUpdateToOneWithWhereWithoutEventsInput = {
    where?: ActivityWaypointWhereInput
    data: XOR<ActivityWaypointUpdateWithoutEventsInput, ActivityWaypointUncheckedUpdateWithoutEventsInput>
  }

  export type ActivityWaypointUpdateWithoutEventsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    order?: IntFieldUpdateOperationsInput | number
    actualStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserWaypointJoinUpdateManyWithoutWaypointRelationNestedInput
    activity?: ActivityUpdateOneRequiredWithoutWaypointsNestedInput
    childActivities?: ActivityUpdateManyWithoutParentWaypointNestedInput
    template?: ActivityWaypointTemplateUpdateOneWithoutWaypointsNestedInput
    tenet?: TenetUpdateOneRequiredWithoutActivityWaypointsNestedInput
    Note?: NoteUpdateManyWithoutWaypointNestedInput
  }

  export type ActivityWaypointUncheckedUpdateWithoutEventsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    order?: IntFieldUpdateOperationsInput | number
    actualStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activityId?: BytesFieldUpdateOperationsInput | Uint8Array
    templateId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    users?: UserWaypointJoinUncheckedUpdateManyWithoutWaypointRelationNestedInput
    childActivities?: ActivityUncheckedUpdateManyWithoutParentWaypointNestedInput
    Note?: NoteUncheckedUpdateManyWithoutWaypointNestedInput
  }

  export type OpportunityUpsertWithoutEventsInput = {
    update: XOR<OpportunityUpdateWithoutEventsInput, OpportunityUncheckedUpdateWithoutEventsInput>
    create: XOR<OpportunityCreateWithoutEventsInput, OpportunityUncheckedCreateWithoutEventsInput>
    where?: OpportunityWhereInput
  }

  export type OpportunityUpdateToOneWithWhereWithoutEventsInput = {
    where?: OpportunityWhereInput
    data: XOR<OpportunityUpdateWithoutEventsInput, OpportunityUncheckedUpdateWithoutEventsInput>
  }

  export type OpportunityUpdateWithoutEventsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    probability?: FloatFieldUpdateOperationsInput | number
    expectedCloseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumOpportunityStatusFieldUpdateOperationsInput | $Enums.OpportunityStatus
    statusHistory?: OpportunityUpdatestatusHistoryInput | $Enums.OpportunityStatus[]
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedValue?: FloatFieldUpdateOperationsInput | number
    contacts?: ContactOpportunityJoinUpdateManyWithoutOpportunityRelationNestedInput
    teamMembers?: UserOpportunityJoinUpdateManyWithoutOpportunityRelationNestedInput
    activities?: ActivityUpdateManyWithoutOpportunityNestedInput
    products?: OpportunityProductUpdateManyWithoutOpportunityNestedInput
    tenet?: TenetUpdateOneRequiredWithoutOpportunitiesNestedInput
    notes?: NoteUpdateManyWithoutOpportunityNestedInput
  }

  export type OpportunityUncheckedUpdateWithoutEventsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    probability?: FloatFieldUpdateOperationsInput | number
    expectedCloseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumOpportunityStatusFieldUpdateOperationsInput | $Enums.OpportunityStatus
    statusHistory?: OpportunityUpdatestatusHistoryInput | $Enums.OpportunityStatus[]
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    expectedValue?: FloatFieldUpdateOperationsInput | number
    contacts?: ContactOpportunityJoinUncheckedUpdateManyWithoutOpportunityRelationNestedInput
    teamMembers?: UserOpportunityJoinUncheckedUpdateManyWithoutOpportunityRelationNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutOpportunityNestedInput
    products?: OpportunityProductUncheckedUpdateManyWithoutOpportunityNestedInput
    notes?: NoteUncheckedUpdateManyWithoutOpportunityNestedInput
  }

  export type NoteUpsertWithoutEventsInput = {
    update: XOR<NoteUpdateWithoutEventsInput, NoteUncheckedUpdateWithoutEventsInput>
    create: XOR<NoteCreateWithoutEventsInput, NoteUncheckedCreateWithoutEventsInput>
    where?: NoteWhereInput
  }

  export type NoteUpdateToOneWithWhereWithoutEventsInput = {
    where?: NoteWhereInput
    data: XOR<NoteUpdateWithoutEventsInput, NoteUncheckedUpdateWithoutEventsInput>
  }

  export type NoteUpdateWithoutEventsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noteType?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    waypoint?: ActivityWaypointUpdateOneWithoutNoteNestedInput
    activity?: ActivityUpdateOneWithoutNotesNestedInput
    contact?: ContactUpdateOneWithoutNotesNestedInput
    opportunity?: OpportunityUpdateOneWithoutNotesNestedInput
    tenet?: TenetUpdateOneRequiredWithoutNotesNestedInput
    author?: UserUpdateOneRequiredWithoutNotesNestedInput
  }

  export type NoteUncheckedUpdateWithoutEventsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    content?: StringFieldUpdateOperationsInput | string
    waypointId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    activityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    contactId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    opportunityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    authorId?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noteType?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
  }

  export type ContactTimelineEventContactJoinUpsertWithWhereUniqueWithoutContactEventRelationInput = {
    where: ContactTimelineEventContactJoinWhereUniqueInput
    update: XOR<ContactTimelineEventContactJoinUpdateWithoutContactEventRelationInput, ContactTimelineEventContactJoinUncheckedUpdateWithoutContactEventRelationInput>
    create: XOR<ContactTimelineEventContactJoinCreateWithoutContactEventRelationInput, ContactTimelineEventContactJoinUncheckedCreateWithoutContactEventRelationInput>
  }

  export type ContactTimelineEventContactJoinUpdateWithWhereUniqueWithoutContactEventRelationInput = {
    where: ContactTimelineEventContactJoinWhereUniqueInput
    data: XOR<ContactTimelineEventContactJoinUpdateWithoutContactEventRelationInput, ContactTimelineEventContactJoinUncheckedUpdateWithoutContactEventRelationInput>
  }

  export type ContactTimelineEventContactJoinUpdateManyWithWhereWithoutContactEventRelationInput = {
    where: ContactTimelineEventContactJoinScalarWhereInput
    data: XOR<ContactTimelineEventContactJoinUpdateManyMutationInput, ContactTimelineEventContactJoinUncheckedUpdateManyWithoutContactEventRelationInput>
  }

  export type UserUpsertWithoutEventsInput = {
    update: XOR<UserUpdateWithoutEventsInput, UserUncheckedUpdateWithoutEventsInput>
    create: XOR<UserCreateWithoutEventsInput, UserUncheckedCreateWithoutEventsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEventsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEventsInput, UserUncheckedUpdateWithoutEventsInput>
  }

  export type UserUpdateWithoutEventsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumAccessGroupFieldUpdateOperationsInput | $Enums.AccessGroup
    system?: BoolFieldUpdateOperationsInput | boolean
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokens?: TokenUpdateManyWithoutUserNestedInput
    tenet?: TenetUpdateOneWithoutUsersNestedInput
    activities?: ActivityUserJoinUpdateManyWithoutUserRelationNestedInput
    notes?: NoteUpdateManyWithoutAuthorNestedInput
    waypoints?: UserWaypointJoinUpdateManyWithoutUserRelationNestedInput
    auditEvents?: AuditEventUpdateManyWithoutUserNestedInput
    templateAssignments?: TemplateAssignmentUpdateManyWithoutSpecificUserNestedInput
    assignedActivities?: ActivityUpdateManyWithoutAssignedByNestedInput
    opportunities?: UserOpportunityJoinUpdateManyWithoutUserRelationNestedInput
    activitySteps?: ActivityStepUserJoinUpdateManyWithoutUserRelationNestedInput
    templateStepAssignments?: ActivityTemplateStepAssignmentUpdateManyWithoutSpecificUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEventsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumAccessGroupFieldUpdateOperationsInput | $Enums.AccessGroup
    tenetId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    system?: BoolFieldUpdateOperationsInput | boolean
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUserJoinUncheckedUpdateManyWithoutUserRelationNestedInput
    notes?: NoteUncheckedUpdateManyWithoutAuthorNestedInput
    waypoints?: UserWaypointJoinUncheckedUpdateManyWithoutUserRelationNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutUserNestedInput
    templateAssignments?: TemplateAssignmentUncheckedUpdateManyWithoutSpecificUserNestedInput
    assignedActivities?: ActivityUncheckedUpdateManyWithoutAssignedByNestedInput
    opportunities?: UserOpportunityJoinUncheckedUpdateManyWithoutUserRelationNestedInput
    activitySteps?: ActivityStepUserJoinUncheckedUpdateManyWithoutUserRelationNestedInput
    templateStepAssignments?: ActivityTemplateStepAssignmentUncheckedUpdateManyWithoutSpecificUserNestedInput
  }

  export type TenetUpsertWithoutContactTimelineEventsInput = {
    update: XOR<TenetUpdateWithoutContactTimelineEventsInput, TenetUncheckedUpdateWithoutContactTimelineEventsInput>
    create: XOR<TenetCreateWithoutContactTimelineEventsInput, TenetUncheckedCreateWithoutContactTimelineEventsInput>
    where?: TenetWhereInput
  }

  export type TenetUpdateToOneWithWhereWithoutContactTimelineEventsInput = {
    where?: TenetWhereInput
    data: XOR<TenetUpdateWithoutContactTimelineEventsInput, TenetUncheckedUpdateWithoutContactTimelineEventsInput>
  }

  export type TenetUpdateWithoutContactTimelineEventsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenetNestedInput
    logs?: LogUpdateManyWithoutTenetNestedInput
    contacts?: ContactUpdateManyWithoutTenetNestedInput
    activities?: ActivityUpdateManyWithoutTenetNestedInput
    addresses?: AddressUpdateManyWithoutTenetNestedInput
    contactEmails?: ContactEmailUpdateManyWithoutTenetNestedInput
    contactPhones?: ContactPhoneUpdateManyWithoutTenetNestedInput
    importantDates?: ImportantDateUpdateManyWithoutTenetNestedInput
    attachments?: AttachmentUpdateManyWithoutTenetNestedInput
    notes?: NoteUpdateManyWithoutTenetNestedInput
    auditEvents?: AuditEventUpdateManyWithoutTenetNestedInput
    activitySteps?: ActivityStepUpdateManyWithoutTenetNestedInput
    activityWaypoints?: ActivityWaypointUpdateManyWithoutTenetNestedInput
    templateAssignments?: TemplateAssignmentUpdateManyWithoutTenetNestedInput
    activityWaypointTemplates?: ActivityWaypointTemplateUpdateManyWithoutTenetNestedInput
    activityTemplates?: ActivityTemplateUpdateManyWithoutTenetNestedInput
    activityTemplateSteps?: ActivityTemplateStepUpdateManyWithoutTenetNestedInput
    opportunities?: OpportunityUpdateManyWithoutTenetNestedInput
    products?: ProductTypeUpdateManyWithoutTenetNestedInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentUpdateManyWithoutTenetNestedInput
  }

  export type TenetUncheckedUpdateWithoutContactTimelineEventsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenetNestedInput
    logs?: LogUncheckedUpdateManyWithoutTenetNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutTenetNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutTenetNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutTenetNestedInput
    contactEmails?: ContactEmailUncheckedUpdateManyWithoutTenetNestedInput
    contactPhones?: ContactPhoneUncheckedUpdateManyWithoutTenetNestedInput
    importantDates?: ImportantDateUncheckedUpdateManyWithoutTenetNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTenetNestedInput
    notes?: NoteUncheckedUpdateManyWithoutTenetNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutTenetNestedInput
    activitySteps?: ActivityStepUncheckedUpdateManyWithoutTenetNestedInput
    activityWaypoints?: ActivityWaypointUncheckedUpdateManyWithoutTenetNestedInput
    templateAssignments?: TemplateAssignmentUncheckedUpdateManyWithoutTenetNestedInput
    activityWaypointTemplates?: ActivityWaypointTemplateUncheckedUpdateManyWithoutTenetNestedInput
    activityTemplates?: ActivityTemplateUncheckedUpdateManyWithoutTenetNestedInput
    activityTemplateSteps?: ActivityTemplateStepUncheckedUpdateManyWithoutTenetNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutTenetNestedInput
    products?: ProductTypeUncheckedUpdateManyWithoutTenetNestedInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentUncheckedUpdateManyWithoutTenetNestedInput
  }

  export type UserCreateWithoutAuditEventsInput = {
    id: Uint8Array
    email: string
    firstName: string
    lastName: string
    fullName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password: string
    enabled?: boolean
    type?: $Enums.AccessGroup
    system?: boolean
    deleted?: boolean
    deletedAt?: Date | string | null
    tokens?: TokenCreateNestedManyWithoutUserInput
    tenet?: TenetCreateNestedOneWithoutUsersInput
    activities?: ActivityUserJoinCreateNestedManyWithoutUserRelationInput
    notes?: NoteCreateNestedManyWithoutAuthorInput
    waypoints?: UserWaypointJoinCreateNestedManyWithoutUserRelationInput
    events?: ContactTimelineEventCreateNestedManyWithoutUserInput
    templateAssignments?: TemplateAssignmentCreateNestedManyWithoutSpecificUserInput
    assignedActivities?: ActivityCreateNestedManyWithoutAssignedByInput
    opportunities?: UserOpportunityJoinCreateNestedManyWithoutUserRelationInput
    activitySteps?: ActivityStepUserJoinCreateNestedManyWithoutUserRelationInput
    templateStepAssignments?: ActivityTemplateStepAssignmentCreateNestedManyWithoutSpecificUserInput
  }

  export type UserUncheckedCreateWithoutAuditEventsInput = {
    id: Uint8Array
    email: string
    firstName: string
    lastName: string
    fullName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password: string
    enabled?: boolean
    type?: $Enums.AccessGroup
    tenetId?: Uint8Array | null
    system?: boolean
    deleted?: boolean
    deletedAt?: Date | string | null
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUserJoinUncheckedCreateNestedManyWithoutUserRelationInput
    notes?: NoteUncheckedCreateNestedManyWithoutAuthorInput
    waypoints?: UserWaypointJoinUncheckedCreateNestedManyWithoutUserRelationInput
    events?: ContactTimelineEventUncheckedCreateNestedManyWithoutUserInput
    templateAssignments?: TemplateAssignmentUncheckedCreateNestedManyWithoutSpecificUserInput
    assignedActivities?: ActivityUncheckedCreateNestedManyWithoutAssignedByInput
    opportunities?: UserOpportunityJoinUncheckedCreateNestedManyWithoutUserRelationInput
    activitySteps?: ActivityStepUserJoinUncheckedCreateNestedManyWithoutUserRelationInput
    templateStepAssignments?: ActivityTemplateStepAssignmentUncheckedCreateNestedManyWithoutSpecificUserInput
  }

  export type UserCreateOrConnectWithoutAuditEventsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditEventsInput, UserUncheckedCreateWithoutAuditEventsInput>
  }

  export type TenetCreateWithoutAuditEventsInput = {
    id: Uint8Array
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenetInput
    logs?: LogCreateNestedManyWithoutTenetInput
    contacts?: ContactCreateNestedManyWithoutTenetInput
    activities?: ActivityCreateNestedManyWithoutTenetInput
    addresses?: AddressCreateNestedManyWithoutTenetInput
    contactEmails?: ContactEmailCreateNestedManyWithoutTenetInput
    contactPhones?: ContactPhoneCreateNestedManyWithoutTenetInput
    importantDates?: ImportantDateCreateNestedManyWithoutTenetInput
    attachments?: AttachmentCreateNestedManyWithoutTenetInput
    notes?: NoteCreateNestedManyWithoutTenetInput
    contactTimelineEvents?: ContactTimelineEventCreateNestedManyWithoutTenetInput
    activitySteps?: ActivityStepCreateNestedManyWithoutTenetInput
    activityWaypoints?: ActivityWaypointCreateNestedManyWithoutTenetInput
    templateAssignments?: TemplateAssignmentCreateNestedManyWithoutTenetInput
    activityWaypointTemplates?: ActivityWaypointTemplateCreateNestedManyWithoutTenetInput
    activityTemplates?: ActivityTemplateCreateNestedManyWithoutTenetInput
    activityTemplateSteps?: ActivityTemplateStepCreateNestedManyWithoutTenetInput
    opportunities?: OpportunityCreateNestedManyWithoutTenetInput
    products?: ProductTypeCreateNestedManyWithoutTenetInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentCreateNestedManyWithoutTenetInput
  }

  export type TenetUncheckedCreateWithoutAuditEventsInput = {
    id: Uint8Array
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenetInput
    logs?: LogUncheckedCreateNestedManyWithoutTenetInput
    contacts?: ContactUncheckedCreateNestedManyWithoutTenetInput
    activities?: ActivityUncheckedCreateNestedManyWithoutTenetInput
    addresses?: AddressUncheckedCreateNestedManyWithoutTenetInput
    contactEmails?: ContactEmailUncheckedCreateNestedManyWithoutTenetInput
    contactPhones?: ContactPhoneUncheckedCreateNestedManyWithoutTenetInput
    importantDates?: ImportantDateUncheckedCreateNestedManyWithoutTenetInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTenetInput
    notes?: NoteUncheckedCreateNestedManyWithoutTenetInput
    contactTimelineEvents?: ContactTimelineEventUncheckedCreateNestedManyWithoutTenetInput
    activitySteps?: ActivityStepUncheckedCreateNestedManyWithoutTenetInput
    activityWaypoints?: ActivityWaypointUncheckedCreateNestedManyWithoutTenetInput
    templateAssignments?: TemplateAssignmentUncheckedCreateNestedManyWithoutTenetInput
    activityWaypointTemplates?: ActivityWaypointTemplateUncheckedCreateNestedManyWithoutTenetInput
    activityTemplates?: ActivityTemplateUncheckedCreateNestedManyWithoutTenetInput
    activityTemplateSteps?: ActivityTemplateStepUncheckedCreateNestedManyWithoutTenetInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutTenetInput
    products?: ProductTypeUncheckedCreateNestedManyWithoutTenetInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentUncheckedCreateNestedManyWithoutTenetInput
  }

  export type TenetCreateOrConnectWithoutAuditEventsInput = {
    where: TenetWhereUniqueInput
    create: XOR<TenetCreateWithoutAuditEventsInput, TenetUncheckedCreateWithoutAuditEventsInput>
  }

  export type UserUpsertWithoutAuditEventsInput = {
    update: XOR<UserUpdateWithoutAuditEventsInput, UserUncheckedUpdateWithoutAuditEventsInput>
    create: XOR<UserCreateWithoutAuditEventsInput, UserUncheckedCreateWithoutAuditEventsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditEventsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditEventsInput, UserUncheckedUpdateWithoutAuditEventsInput>
  }

  export type UserUpdateWithoutAuditEventsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumAccessGroupFieldUpdateOperationsInput | $Enums.AccessGroup
    system?: BoolFieldUpdateOperationsInput | boolean
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokens?: TokenUpdateManyWithoutUserNestedInput
    tenet?: TenetUpdateOneWithoutUsersNestedInput
    activities?: ActivityUserJoinUpdateManyWithoutUserRelationNestedInput
    notes?: NoteUpdateManyWithoutAuthorNestedInput
    waypoints?: UserWaypointJoinUpdateManyWithoutUserRelationNestedInput
    events?: ContactTimelineEventUpdateManyWithoutUserNestedInput
    templateAssignments?: TemplateAssignmentUpdateManyWithoutSpecificUserNestedInput
    assignedActivities?: ActivityUpdateManyWithoutAssignedByNestedInput
    opportunities?: UserOpportunityJoinUpdateManyWithoutUserRelationNestedInput
    activitySteps?: ActivityStepUserJoinUpdateManyWithoutUserRelationNestedInput
    templateStepAssignments?: ActivityTemplateStepAssignmentUpdateManyWithoutSpecificUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditEventsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumAccessGroupFieldUpdateOperationsInput | $Enums.AccessGroup
    tenetId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    system?: BoolFieldUpdateOperationsInput | boolean
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUserJoinUncheckedUpdateManyWithoutUserRelationNestedInput
    notes?: NoteUncheckedUpdateManyWithoutAuthorNestedInput
    waypoints?: UserWaypointJoinUncheckedUpdateManyWithoutUserRelationNestedInput
    events?: ContactTimelineEventUncheckedUpdateManyWithoutUserNestedInput
    templateAssignments?: TemplateAssignmentUncheckedUpdateManyWithoutSpecificUserNestedInput
    assignedActivities?: ActivityUncheckedUpdateManyWithoutAssignedByNestedInput
    opportunities?: UserOpportunityJoinUncheckedUpdateManyWithoutUserRelationNestedInput
    activitySteps?: ActivityStepUserJoinUncheckedUpdateManyWithoutUserRelationNestedInput
    templateStepAssignments?: ActivityTemplateStepAssignmentUncheckedUpdateManyWithoutSpecificUserNestedInput
  }

  export type TenetUpsertWithoutAuditEventsInput = {
    update: XOR<TenetUpdateWithoutAuditEventsInput, TenetUncheckedUpdateWithoutAuditEventsInput>
    create: XOR<TenetCreateWithoutAuditEventsInput, TenetUncheckedCreateWithoutAuditEventsInput>
    where?: TenetWhereInput
  }

  export type TenetUpdateToOneWithWhereWithoutAuditEventsInput = {
    where?: TenetWhereInput
    data: XOR<TenetUpdateWithoutAuditEventsInput, TenetUncheckedUpdateWithoutAuditEventsInput>
  }

  export type TenetUpdateWithoutAuditEventsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenetNestedInput
    logs?: LogUpdateManyWithoutTenetNestedInput
    contacts?: ContactUpdateManyWithoutTenetNestedInput
    activities?: ActivityUpdateManyWithoutTenetNestedInput
    addresses?: AddressUpdateManyWithoutTenetNestedInput
    contactEmails?: ContactEmailUpdateManyWithoutTenetNestedInput
    contactPhones?: ContactPhoneUpdateManyWithoutTenetNestedInput
    importantDates?: ImportantDateUpdateManyWithoutTenetNestedInput
    attachments?: AttachmentUpdateManyWithoutTenetNestedInput
    notes?: NoteUpdateManyWithoutTenetNestedInput
    contactTimelineEvents?: ContactTimelineEventUpdateManyWithoutTenetNestedInput
    activitySteps?: ActivityStepUpdateManyWithoutTenetNestedInput
    activityWaypoints?: ActivityWaypointUpdateManyWithoutTenetNestedInput
    templateAssignments?: TemplateAssignmentUpdateManyWithoutTenetNestedInput
    activityWaypointTemplates?: ActivityWaypointTemplateUpdateManyWithoutTenetNestedInput
    activityTemplates?: ActivityTemplateUpdateManyWithoutTenetNestedInput
    activityTemplateSteps?: ActivityTemplateStepUpdateManyWithoutTenetNestedInput
    opportunities?: OpportunityUpdateManyWithoutTenetNestedInput
    products?: ProductTypeUpdateManyWithoutTenetNestedInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentUpdateManyWithoutTenetNestedInput
  }

  export type TenetUncheckedUpdateWithoutAuditEventsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenetNestedInput
    logs?: LogUncheckedUpdateManyWithoutTenetNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutTenetNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutTenetNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutTenetNestedInput
    contactEmails?: ContactEmailUncheckedUpdateManyWithoutTenetNestedInput
    contactPhones?: ContactPhoneUncheckedUpdateManyWithoutTenetNestedInput
    importantDates?: ImportantDateUncheckedUpdateManyWithoutTenetNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTenetNestedInput
    notes?: NoteUncheckedUpdateManyWithoutTenetNestedInput
    contactTimelineEvents?: ContactTimelineEventUncheckedUpdateManyWithoutTenetNestedInput
    activitySteps?: ActivityStepUncheckedUpdateManyWithoutTenetNestedInput
    activityWaypoints?: ActivityWaypointUncheckedUpdateManyWithoutTenetNestedInput
    templateAssignments?: TemplateAssignmentUncheckedUpdateManyWithoutTenetNestedInput
    activityWaypointTemplates?: ActivityWaypointTemplateUncheckedUpdateManyWithoutTenetNestedInput
    activityTemplates?: ActivityTemplateUncheckedUpdateManyWithoutTenetNestedInput
    activityTemplateSteps?: ActivityTemplateStepUncheckedUpdateManyWithoutTenetNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutTenetNestedInput
    products?: ProductTypeUncheckedUpdateManyWithoutTenetNestedInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentUncheckedUpdateManyWithoutTenetNestedInput
  }

  export type ContactTimelineEventCreateWithoutContactsInput = {
    id: Uint8Array
    extraInfo?: string | null
    eventType: $Enums.ContactTimelineEventType
    relationshipType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activity?: ActivityCreateNestedOneWithoutEventsInput
    waypoint?: ActivityWaypointCreateNestedOneWithoutEventsInput
    opportunity?: OpportunityCreateNestedOneWithoutEventsInput
    note?: NoteCreateNestedOneWithoutEventsInput
    user: UserCreateNestedOneWithoutEventsInput
    tenet: TenetCreateNestedOneWithoutContactTimelineEventsInput
  }

  export type ContactTimelineEventUncheckedCreateWithoutContactsInput = {
    id: Uint8Array
    activityId?: Uint8Array | null
    waypointId?: Uint8Array | null
    opportunityId?: Uint8Array | null
    noteId?: Uint8Array | null
    extraInfo?: string | null
    userId: Uint8Array
    tenetId: Uint8Array
    eventType: $Enums.ContactTimelineEventType
    relationshipType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactTimelineEventCreateOrConnectWithoutContactsInput = {
    where: ContactTimelineEventWhereUniqueInput
    create: XOR<ContactTimelineEventCreateWithoutContactsInput, ContactTimelineEventUncheckedCreateWithoutContactsInput>
  }

  export type ContactCreateWithoutTimelineEventsInput = {
    id: Uint8Array
    firstName?: string | null
    lastName: string
    fullName: string
    importantNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.ContactType
    status: $Enums.ContactStatus
    lifecycleStage?: $Enums.LifecycleStage | null
    lastContactedDate?: Date | string | null
    followUpDate?: Date | string | null
    householdStatus?: $Enums.HouseholdRelationshipStatus | null
    position?: string | null
    companyStatus?: $Enums.CompanyRelationshipStatus | null
    industry?: string | null
    website?: string | null
    size?: number | null
    deleted?: boolean
    deletedAt?: Date | string | null
    tenet: TenetCreateNestedOneWithoutContactsInput
    notes?: NoteCreateNestedManyWithoutContactInput
    addresses?: AddressCreateNestedManyWithoutContactInput
    emails?: ContactEmailCreateNestedManyWithoutContactInput
    phones?: ContactPhoneCreateNestedManyWithoutContactInput
    importantDates?: ImportantDateCreateNestedManyWithoutContactInput
    activities?: ActivityContactJoinCreateNestedManyWithoutContactRelationInput
    household?: ContactCreateNestedOneWithoutHouseholdMembersInput
    headOfHouseholdFor?: ContactCreateNestedOneWithoutHeadOfHouseholdInput
    company?: ContactCreateNestedOneWithoutEmployeesInput
    primaryContactFor?: ContactCreateNestedOneWithoutPrimaryContactInput
    headOfHousehold?: ContactCreateNestedOneWithoutHeadOfHouseholdForInput
    householdMembers?: ContactCreateNestedManyWithoutHouseholdInput
    employees?: ContactCreateNestedManyWithoutCompanyInput
    primaryContact?: ContactCreateNestedOneWithoutPrimaryContactForInput
    opportunities?: ContactOpportunityJoinCreateNestedManyWithoutContactRelationInput
    relationAsSource?: ContactRelationshipCreateNestedManyWithoutSourceInput
    relationAsTarget?: ContactRelationshipCreateNestedManyWithoutTargetInput
  }

  export type ContactUncheckedCreateWithoutTimelineEventsInput = {
    id: Uint8Array
    firstName?: string | null
    lastName: string
    fullName: string
    tenetId: Uint8Array
    importantNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.ContactType
    status: $Enums.ContactStatus
    lifecycleStage?: $Enums.LifecycleStage | null
    lastContactedDate?: Date | string | null
    followUpDate?: Date | string | null
    householdId?: Uint8Array | null
    householdStatus?: $Enums.HouseholdRelationshipStatus | null
    companyId?: Uint8Array | null
    position?: string | null
    companyStatus?: $Enums.CompanyRelationshipStatus | null
    headOfHouseholdId?: Uint8Array | null
    industry?: string | null
    website?: string | null
    size?: number | null
    primaryContactId?: Uint8Array | null
    deleted?: boolean
    deletedAt?: Date | string | null
    notes?: NoteUncheckedCreateNestedManyWithoutContactInput
    addresses?: AddressUncheckedCreateNestedManyWithoutContactInput
    emails?: ContactEmailUncheckedCreateNestedManyWithoutContactInput
    phones?: ContactPhoneUncheckedCreateNestedManyWithoutContactInput
    importantDates?: ImportantDateUncheckedCreateNestedManyWithoutContactInput
    activities?: ActivityContactJoinUncheckedCreateNestedManyWithoutContactRelationInput
    headOfHouseholdFor?: ContactUncheckedCreateNestedOneWithoutHeadOfHouseholdInput
    primaryContactFor?: ContactUncheckedCreateNestedOneWithoutPrimaryContactInput
    householdMembers?: ContactUncheckedCreateNestedManyWithoutHouseholdInput
    employees?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    opportunities?: ContactOpportunityJoinUncheckedCreateNestedManyWithoutContactRelationInput
    relationAsSource?: ContactRelationshipUncheckedCreateNestedManyWithoutSourceInput
    relationAsTarget?: ContactRelationshipUncheckedCreateNestedManyWithoutTargetInput
  }

  export type ContactCreateOrConnectWithoutTimelineEventsInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutTimelineEventsInput, ContactUncheckedCreateWithoutTimelineEventsInput>
  }

  export type ContactTimelineEventUpsertWithoutContactsInput = {
    update: XOR<ContactTimelineEventUpdateWithoutContactsInput, ContactTimelineEventUncheckedUpdateWithoutContactsInput>
    create: XOR<ContactTimelineEventCreateWithoutContactsInput, ContactTimelineEventUncheckedCreateWithoutContactsInput>
    where?: ContactTimelineEventWhereInput
  }

  export type ContactTimelineEventUpdateToOneWithWhereWithoutContactsInput = {
    where?: ContactTimelineEventWhereInput
    data: XOR<ContactTimelineEventUpdateWithoutContactsInput, ContactTimelineEventUncheckedUpdateWithoutContactsInput>
  }

  export type ContactTimelineEventUpdateWithoutContactsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    extraInfo?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: EnumContactTimelineEventTypeFieldUpdateOperationsInput | $Enums.ContactTimelineEventType
    relationshipType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activity?: ActivityUpdateOneWithoutEventsNestedInput
    waypoint?: ActivityWaypointUpdateOneWithoutEventsNestedInput
    opportunity?: OpportunityUpdateOneWithoutEventsNestedInput
    note?: NoteUpdateOneWithoutEventsNestedInput
    user?: UserUpdateOneRequiredWithoutEventsNestedInput
    tenet?: TenetUpdateOneRequiredWithoutContactTimelineEventsNestedInput
  }

  export type ContactTimelineEventUncheckedUpdateWithoutContactsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    activityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    waypointId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    opportunityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    noteId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    extraInfo?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: BytesFieldUpdateOperationsInput | Uint8Array
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    eventType?: EnumContactTimelineEventTypeFieldUpdateOperationsInput | $Enums.ContactTimelineEventType
    relationshipType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUpsertWithoutTimelineEventsInput = {
    update: XOR<ContactUpdateWithoutTimelineEventsInput, ContactUncheckedUpdateWithoutTimelineEventsInput>
    create: XOR<ContactCreateWithoutTimelineEventsInput, ContactUncheckedCreateWithoutTimelineEventsInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutTimelineEventsInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutTimelineEventsInput, ContactUncheckedUpdateWithoutTimelineEventsInput>
  }

  export type ContactUpdateWithoutTimelineEventsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    importantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    lifecycleStage?: NullableEnumLifecycleStageFieldUpdateOperationsInput | $Enums.LifecycleStage | null
    lastContactedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    householdStatus?: NullableEnumHouseholdRelationshipStatusFieldUpdateOperationsInput | $Enums.HouseholdRelationshipStatus | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyStatus?: NullableEnumCompanyRelationshipStatusFieldUpdateOperationsInput | $Enums.CompanyRelationshipStatus | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenet?: TenetUpdateOneRequiredWithoutContactsNestedInput
    notes?: NoteUpdateManyWithoutContactNestedInput
    addresses?: AddressUpdateManyWithoutContactNestedInput
    emails?: ContactEmailUpdateManyWithoutContactNestedInput
    phones?: ContactPhoneUpdateManyWithoutContactNestedInput
    importantDates?: ImportantDateUpdateManyWithoutContactNestedInput
    activities?: ActivityContactJoinUpdateManyWithoutContactRelationNestedInput
    household?: ContactUpdateOneWithoutHouseholdMembersNestedInput
    headOfHouseholdFor?: ContactUpdateOneWithoutHeadOfHouseholdNestedInput
    company?: ContactUpdateOneWithoutEmployeesNestedInput
    primaryContactFor?: ContactUpdateOneWithoutPrimaryContactNestedInput
    headOfHousehold?: ContactUpdateOneWithoutHeadOfHouseholdForNestedInput
    householdMembers?: ContactUpdateManyWithoutHouseholdNestedInput
    employees?: ContactUpdateManyWithoutCompanyNestedInput
    primaryContact?: ContactUpdateOneWithoutPrimaryContactForNestedInput
    opportunities?: ContactOpportunityJoinUpdateManyWithoutContactRelationNestedInput
    relationAsSource?: ContactRelationshipUpdateManyWithoutSourceNestedInput
    relationAsTarget?: ContactRelationshipUpdateManyWithoutTargetNestedInput
  }

  export type ContactUncheckedUpdateWithoutTimelineEventsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    importantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    lifecycleStage?: NullableEnumLifecycleStageFieldUpdateOperationsInput | $Enums.LifecycleStage | null
    lastContactedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    householdId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    householdStatus?: NullableEnumHouseholdRelationshipStatusFieldUpdateOperationsInput | $Enums.HouseholdRelationshipStatus | null
    companyId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyStatus?: NullableEnumCompanyRelationshipStatusFieldUpdateOperationsInput | $Enums.CompanyRelationshipStatus | null
    headOfHouseholdId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    primaryContactId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NoteUncheckedUpdateManyWithoutContactNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutContactNestedInput
    emails?: ContactEmailUncheckedUpdateManyWithoutContactNestedInput
    phones?: ContactPhoneUncheckedUpdateManyWithoutContactNestedInput
    importantDates?: ImportantDateUncheckedUpdateManyWithoutContactNestedInput
    activities?: ActivityContactJoinUncheckedUpdateManyWithoutContactRelationNestedInput
    headOfHouseholdFor?: ContactUncheckedUpdateOneWithoutHeadOfHouseholdNestedInput
    primaryContactFor?: ContactUncheckedUpdateOneWithoutPrimaryContactNestedInput
    householdMembers?: ContactUncheckedUpdateManyWithoutHouseholdNestedInput
    employees?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    opportunities?: ContactOpportunityJoinUncheckedUpdateManyWithoutContactRelationNestedInput
    relationAsSource?: ContactRelationshipUncheckedUpdateManyWithoutSourceNestedInput
    relationAsTarget?: ContactRelationshipUncheckedUpdateManyWithoutTargetNestedInput
  }

  export type ActivityWaypointCreateWithoutNoteInput = {
    id: Uint8Array
    title: string
    description?: string | null
    summary?: string | null
    status: $Enums.ActivityStatus
    order: number
    actualStart: Date | string
    dueDate: Date | string
    actualEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserWaypointJoinCreateNestedManyWithoutWaypointRelationInput
    activity: ActivityCreateNestedOneWithoutWaypointsInput
    childActivities?: ActivityCreateNestedManyWithoutParentWaypointInput
    template?: ActivityWaypointTemplateCreateNestedOneWithoutWaypointsInput
    events?: ContactTimelineEventCreateNestedManyWithoutWaypointInput
    tenet: TenetCreateNestedOneWithoutActivityWaypointsInput
  }

  export type ActivityWaypointUncheckedCreateWithoutNoteInput = {
    id: Uint8Array
    title: string
    description?: string | null
    summary?: string | null
    status: $Enums.ActivityStatus
    order: number
    actualStart: Date | string
    dueDate: Date | string
    actualEnd?: Date | string | null
    activityId: Uint8Array
    templateId?: Uint8Array | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
    users?: UserWaypointJoinUncheckedCreateNestedManyWithoutWaypointRelationInput
    childActivities?: ActivityUncheckedCreateNestedManyWithoutParentWaypointInput
    events?: ContactTimelineEventUncheckedCreateNestedManyWithoutWaypointInput
  }

  export type ActivityWaypointCreateOrConnectWithoutNoteInput = {
    where: ActivityWaypointWhereUniqueInput
    create: XOR<ActivityWaypointCreateWithoutNoteInput, ActivityWaypointUncheckedCreateWithoutNoteInput>
  }

  export type ActivityCreateWithoutNotesInput = {
    id: Uint8Array
    title: string
    type: $Enums.ActivityType
    taskScheduleType?: $Enums.TaskScheduleType | null
    startDate: Date | string
    endDate: Date | string
    completedAt?: Date | string | null
    description?: string | null
    priority?: $Enums.ActivityPriority
    status: $Enums.ActivityStatus
    phoneNumber?: string | null
    location?: string | null
    holdReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean
    deletedAt?: Date | string | null
    order?: number | null
    steps?: ActivityStepCreateNestedManyWithoutActivityInput
    waypoints?: ActivityWaypointCreateNestedManyWithoutActivityInput
    activities?: ActivityCreateNestedManyWithoutParentActivityInput
    parentActivity?: ActivityCreateNestedOneWithoutActivitiesInput
    parentWaypoint?: ActivityWaypointCreateNestedOneWithoutChildActivitiesInput
    template?: ActivityTemplateCreateNestedOneWithoutActivitiesInput
    assignedBy: UserCreateNestedOneWithoutAssignedActivitiesInput
    contacts?: ActivityContactJoinCreateNestedManyWithoutActivityRelationInput
    users?: ActivityUserJoinCreateNestedManyWithoutActivityRelationInput
    tenet: TenetCreateNestedOneWithoutActivitiesInput
    attachments?: AttachmentCreateNestedManyWithoutActivityInput
    events?: ContactTimelineEventCreateNestedManyWithoutActivityInput
    opportunity?: OpportunityCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateWithoutNotesInput = {
    id: Uint8Array
    title: string
    type: $Enums.ActivityType
    parentActivityId?: Uint8Array | null
    parentWaypointId?: Uint8Array | null
    templateId?: Uint8Array | null
    taskScheduleType?: $Enums.TaskScheduleType | null
    startDate: Date | string
    endDate: Date | string
    completedAt?: Date | string | null
    description?: string | null
    priority?: $Enums.ActivityPriority
    status: $Enums.ActivityStatus
    assignedById: Uint8Array
    phoneNumber?: string | null
    location?: string | null
    holdReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
    deleted?: boolean
    deletedAt?: Date | string | null
    order?: number | null
    opportunityId?: Uint8Array | null
    steps?: ActivityStepUncheckedCreateNestedManyWithoutActivityInput
    waypoints?: ActivityWaypointUncheckedCreateNestedManyWithoutActivityInput
    activities?: ActivityUncheckedCreateNestedManyWithoutParentActivityInput
    contacts?: ActivityContactJoinUncheckedCreateNestedManyWithoutActivityRelationInput
    users?: ActivityUserJoinUncheckedCreateNestedManyWithoutActivityRelationInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutActivityInput
    events?: ContactTimelineEventUncheckedCreateNestedManyWithoutActivityInput
  }

  export type ActivityCreateOrConnectWithoutNotesInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutNotesInput, ActivityUncheckedCreateWithoutNotesInput>
  }

  export type ContactCreateWithoutNotesInput = {
    id: Uint8Array
    firstName?: string | null
    lastName: string
    fullName: string
    importantNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.ContactType
    status: $Enums.ContactStatus
    lifecycleStage?: $Enums.LifecycleStage | null
    lastContactedDate?: Date | string | null
    followUpDate?: Date | string | null
    householdStatus?: $Enums.HouseholdRelationshipStatus | null
    position?: string | null
    companyStatus?: $Enums.CompanyRelationshipStatus | null
    industry?: string | null
    website?: string | null
    size?: number | null
    deleted?: boolean
    deletedAt?: Date | string | null
    tenet: TenetCreateNestedOneWithoutContactsInput
    timelineEvents?: ContactTimelineEventContactJoinCreateNestedManyWithoutContactRelationInput
    addresses?: AddressCreateNestedManyWithoutContactInput
    emails?: ContactEmailCreateNestedManyWithoutContactInput
    phones?: ContactPhoneCreateNestedManyWithoutContactInput
    importantDates?: ImportantDateCreateNestedManyWithoutContactInput
    activities?: ActivityContactJoinCreateNestedManyWithoutContactRelationInput
    household?: ContactCreateNestedOneWithoutHouseholdMembersInput
    headOfHouseholdFor?: ContactCreateNestedOneWithoutHeadOfHouseholdInput
    company?: ContactCreateNestedOneWithoutEmployeesInput
    primaryContactFor?: ContactCreateNestedOneWithoutPrimaryContactInput
    headOfHousehold?: ContactCreateNestedOneWithoutHeadOfHouseholdForInput
    householdMembers?: ContactCreateNestedManyWithoutHouseholdInput
    employees?: ContactCreateNestedManyWithoutCompanyInput
    primaryContact?: ContactCreateNestedOneWithoutPrimaryContactForInput
    opportunities?: ContactOpportunityJoinCreateNestedManyWithoutContactRelationInput
    relationAsSource?: ContactRelationshipCreateNestedManyWithoutSourceInput
    relationAsTarget?: ContactRelationshipCreateNestedManyWithoutTargetInput
  }

  export type ContactUncheckedCreateWithoutNotesInput = {
    id: Uint8Array
    firstName?: string | null
    lastName: string
    fullName: string
    tenetId: Uint8Array
    importantNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.ContactType
    status: $Enums.ContactStatus
    lifecycleStage?: $Enums.LifecycleStage | null
    lastContactedDate?: Date | string | null
    followUpDate?: Date | string | null
    householdId?: Uint8Array | null
    householdStatus?: $Enums.HouseholdRelationshipStatus | null
    companyId?: Uint8Array | null
    position?: string | null
    companyStatus?: $Enums.CompanyRelationshipStatus | null
    headOfHouseholdId?: Uint8Array | null
    industry?: string | null
    website?: string | null
    size?: number | null
    primaryContactId?: Uint8Array | null
    deleted?: boolean
    deletedAt?: Date | string | null
    timelineEvents?: ContactTimelineEventContactJoinUncheckedCreateNestedManyWithoutContactRelationInput
    addresses?: AddressUncheckedCreateNestedManyWithoutContactInput
    emails?: ContactEmailUncheckedCreateNestedManyWithoutContactInput
    phones?: ContactPhoneUncheckedCreateNestedManyWithoutContactInput
    importantDates?: ImportantDateUncheckedCreateNestedManyWithoutContactInput
    activities?: ActivityContactJoinUncheckedCreateNestedManyWithoutContactRelationInput
    headOfHouseholdFor?: ContactUncheckedCreateNestedOneWithoutHeadOfHouseholdInput
    primaryContactFor?: ContactUncheckedCreateNestedOneWithoutPrimaryContactInput
    householdMembers?: ContactUncheckedCreateNestedManyWithoutHouseholdInput
    employees?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    opportunities?: ContactOpportunityJoinUncheckedCreateNestedManyWithoutContactRelationInput
    relationAsSource?: ContactRelationshipUncheckedCreateNestedManyWithoutSourceInput
    relationAsTarget?: ContactRelationshipUncheckedCreateNestedManyWithoutTargetInput
  }

  export type ContactCreateOrConnectWithoutNotesInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutNotesInput, ContactUncheckedCreateWithoutNotesInput>
  }

  export type OpportunityCreateWithoutNotesInput = {
    id: Uint8Array
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    value: number
    probability: number
    expectedCloseDate: Date | string
    actualCloseDate?: Date | string | null
    status: $Enums.OpportunityStatus
    statusHistory?: OpportunityCreatestatusHistoryInput | $Enums.OpportunityStatus[]
    deleted?: boolean
    deletedAt?: Date | string | null
    expectedValue: number
    contacts?: ContactOpportunityJoinCreateNestedManyWithoutOpportunityRelationInput
    teamMembers?: UserOpportunityJoinCreateNestedManyWithoutOpportunityRelationInput
    activities?: ActivityCreateNestedManyWithoutOpportunityInput
    products?: OpportunityProductCreateNestedManyWithoutOpportunityInput
    tenet: TenetCreateNestedOneWithoutOpportunitiesInput
    events?: ContactTimelineEventCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityUncheckedCreateWithoutNotesInput = {
    id: Uint8Array
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    value: number
    probability: number
    expectedCloseDate: Date | string
    actualCloseDate?: Date | string | null
    status: $Enums.OpportunityStatus
    statusHistory?: OpportunityCreatestatusHistoryInput | $Enums.OpportunityStatus[]
    deleted?: boolean
    deletedAt?: Date | string | null
    tenetId: Uint8Array
    expectedValue: number
    contacts?: ContactOpportunityJoinUncheckedCreateNestedManyWithoutOpportunityRelationInput
    teamMembers?: UserOpportunityJoinUncheckedCreateNestedManyWithoutOpportunityRelationInput
    activities?: ActivityUncheckedCreateNestedManyWithoutOpportunityInput
    products?: OpportunityProductUncheckedCreateNestedManyWithoutOpportunityInput
    events?: ContactTimelineEventUncheckedCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityCreateOrConnectWithoutNotesInput = {
    where: OpportunityWhereUniqueInput
    create: XOR<OpportunityCreateWithoutNotesInput, OpportunityUncheckedCreateWithoutNotesInput>
  }

  export type TenetCreateWithoutNotesInput = {
    id: Uint8Array
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenetInput
    logs?: LogCreateNestedManyWithoutTenetInput
    contacts?: ContactCreateNestedManyWithoutTenetInput
    activities?: ActivityCreateNestedManyWithoutTenetInput
    addresses?: AddressCreateNestedManyWithoutTenetInput
    contactEmails?: ContactEmailCreateNestedManyWithoutTenetInput
    contactPhones?: ContactPhoneCreateNestedManyWithoutTenetInput
    importantDates?: ImportantDateCreateNestedManyWithoutTenetInput
    attachments?: AttachmentCreateNestedManyWithoutTenetInput
    auditEvents?: AuditEventCreateNestedManyWithoutTenetInput
    contactTimelineEvents?: ContactTimelineEventCreateNestedManyWithoutTenetInput
    activitySteps?: ActivityStepCreateNestedManyWithoutTenetInput
    activityWaypoints?: ActivityWaypointCreateNestedManyWithoutTenetInput
    templateAssignments?: TemplateAssignmentCreateNestedManyWithoutTenetInput
    activityWaypointTemplates?: ActivityWaypointTemplateCreateNestedManyWithoutTenetInput
    activityTemplates?: ActivityTemplateCreateNestedManyWithoutTenetInput
    activityTemplateSteps?: ActivityTemplateStepCreateNestedManyWithoutTenetInput
    opportunities?: OpportunityCreateNestedManyWithoutTenetInput
    products?: ProductTypeCreateNestedManyWithoutTenetInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentCreateNestedManyWithoutTenetInput
  }

  export type TenetUncheckedCreateWithoutNotesInput = {
    id: Uint8Array
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenetInput
    logs?: LogUncheckedCreateNestedManyWithoutTenetInput
    contacts?: ContactUncheckedCreateNestedManyWithoutTenetInput
    activities?: ActivityUncheckedCreateNestedManyWithoutTenetInput
    addresses?: AddressUncheckedCreateNestedManyWithoutTenetInput
    contactEmails?: ContactEmailUncheckedCreateNestedManyWithoutTenetInput
    contactPhones?: ContactPhoneUncheckedCreateNestedManyWithoutTenetInput
    importantDates?: ImportantDateUncheckedCreateNestedManyWithoutTenetInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTenetInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutTenetInput
    contactTimelineEvents?: ContactTimelineEventUncheckedCreateNestedManyWithoutTenetInput
    activitySteps?: ActivityStepUncheckedCreateNestedManyWithoutTenetInput
    activityWaypoints?: ActivityWaypointUncheckedCreateNestedManyWithoutTenetInput
    templateAssignments?: TemplateAssignmentUncheckedCreateNestedManyWithoutTenetInput
    activityWaypointTemplates?: ActivityWaypointTemplateUncheckedCreateNestedManyWithoutTenetInput
    activityTemplates?: ActivityTemplateUncheckedCreateNestedManyWithoutTenetInput
    activityTemplateSteps?: ActivityTemplateStepUncheckedCreateNestedManyWithoutTenetInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutTenetInput
    products?: ProductTypeUncheckedCreateNestedManyWithoutTenetInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentUncheckedCreateNestedManyWithoutTenetInput
  }

  export type TenetCreateOrConnectWithoutNotesInput = {
    where: TenetWhereUniqueInput
    create: XOR<TenetCreateWithoutNotesInput, TenetUncheckedCreateWithoutNotesInput>
  }

  export type UserCreateWithoutNotesInput = {
    id: Uint8Array
    email: string
    firstName: string
    lastName: string
    fullName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password: string
    enabled?: boolean
    type?: $Enums.AccessGroup
    system?: boolean
    deleted?: boolean
    deletedAt?: Date | string | null
    tokens?: TokenCreateNestedManyWithoutUserInput
    tenet?: TenetCreateNestedOneWithoutUsersInput
    activities?: ActivityUserJoinCreateNestedManyWithoutUserRelationInput
    waypoints?: UserWaypointJoinCreateNestedManyWithoutUserRelationInput
    events?: ContactTimelineEventCreateNestedManyWithoutUserInput
    auditEvents?: AuditEventCreateNestedManyWithoutUserInput
    templateAssignments?: TemplateAssignmentCreateNestedManyWithoutSpecificUserInput
    assignedActivities?: ActivityCreateNestedManyWithoutAssignedByInput
    opportunities?: UserOpportunityJoinCreateNestedManyWithoutUserRelationInput
    activitySteps?: ActivityStepUserJoinCreateNestedManyWithoutUserRelationInput
    templateStepAssignments?: ActivityTemplateStepAssignmentCreateNestedManyWithoutSpecificUserInput
  }

  export type UserUncheckedCreateWithoutNotesInput = {
    id: Uint8Array
    email: string
    firstName: string
    lastName: string
    fullName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password: string
    enabled?: boolean
    type?: $Enums.AccessGroup
    tenetId?: Uint8Array | null
    system?: boolean
    deleted?: boolean
    deletedAt?: Date | string | null
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUserJoinUncheckedCreateNestedManyWithoutUserRelationInput
    waypoints?: UserWaypointJoinUncheckedCreateNestedManyWithoutUserRelationInput
    events?: ContactTimelineEventUncheckedCreateNestedManyWithoutUserInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutUserInput
    templateAssignments?: TemplateAssignmentUncheckedCreateNestedManyWithoutSpecificUserInput
    assignedActivities?: ActivityUncheckedCreateNestedManyWithoutAssignedByInput
    opportunities?: UserOpportunityJoinUncheckedCreateNestedManyWithoutUserRelationInput
    activitySteps?: ActivityStepUserJoinUncheckedCreateNestedManyWithoutUserRelationInput
    templateStepAssignments?: ActivityTemplateStepAssignmentUncheckedCreateNestedManyWithoutSpecificUserInput
  }

  export type UserCreateOrConnectWithoutNotesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotesInput, UserUncheckedCreateWithoutNotesInput>
  }

  export type ContactTimelineEventCreateWithoutNoteInput = {
    id: Uint8Array
    extraInfo?: string | null
    eventType: $Enums.ContactTimelineEventType
    relationshipType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activity?: ActivityCreateNestedOneWithoutEventsInput
    waypoint?: ActivityWaypointCreateNestedOneWithoutEventsInput
    opportunity?: OpportunityCreateNestedOneWithoutEventsInput
    contacts?: ContactTimelineEventContactJoinCreateNestedManyWithoutContactEventRelationInput
    user: UserCreateNestedOneWithoutEventsInput
    tenet: TenetCreateNestedOneWithoutContactTimelineEventsInput
  }

  export type ContactTimelineEventUncheckedCreateWithoutNoteInput = {
    id: Uint8Array
    activityId?: Uint8Array | null
    waypointId?: Uint8Array | null
    opportunityId?: Uint8Array | null
    extraInfo?: string | null
    userId: Uint8Array
    tenetId: Uint8Array
    eventType: $Enums.ContactTimelineEventType
    relationshipType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: ContactTimelineEventContactJoinUncheckedCreateNestedManyWithoutContactEventRelationInput
  }

  export type ContactTimelineEventCreateOrConnectWithoutNoteInput = {
    where: ContactTimelineEventWhereUniqueInput
    create: XOR<ContactTimelineEventCreateWithoutNoteInput, ContactTimelineEventUncheckedCreateWithoutNoteInput>
  }

  export type ContactTimelineEventCreateManyNoteInputEnvelope = {
    data: ContactTimelineEventCreateManyNoteInput | ContactTimelineEventCreateManyNoteInput[]
    skipDuplicates?: boolean
  }

  export type ActivityWaypointUpsertWithoutNoteInput = {
    update: XOR<ActivityWaypointUpdateWithoutNoteInput, ActivityWaypointUncheckedUpdateWithoutNoteInput>
    create: XOR<ActivityWaypointCreateWithoutNoteInput, ActivityWaypointUncheckedCreateWithoutNoteInput>
    where?: ActivityWaypointWhereInput
  }

  export type ActivityWaypointUpdateToOneWithWhereWithoutNoteInput = {
    where?: ActivityWaypointWhereInput
    data: XOR<ActivityWaypointUpdateWithoutNoteInput, ActivityWaypointUncheckedUpdateWithoutNoteInput>
  }

  export type ActivityWaypointUpdateWithoutNoteInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    order?: IntFieldUpdateOperationsInput | number
    actualStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserWaypointJoinUpdateManyWithoutWaypointRelationNestedInput
    activity?: ActivityUpdateOneRequiredWithoutWaypointsNestedInput
    childActivities?: ActivityUpdateManyWithoutParentWaypointNestedInput
    template?: ActivityWaypointTemplateUpdateOneWithoutWaypointsNestedInput
    events?: ContactTimelineEventUpdateManyWithoutWaypointNestedInput
    tenet?: TenetUpdateOneRequiredWithoutActivityWaypointsNestedInput
  }

  export type ActivityWaypointUncheckedUpdateWithoutNoteInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    order?: IntFieldUpdateOperationsInput | number
    actualStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activityId?: BytesFieldUpdateOperationsInput | Uint8Array
    templateId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    users?: UserWaypointJoinUncheckedUpdateManyWithoutWaypointRelationNestedInput
    childActivities?: ActivityUncheckedUpdateManyWithoutParentWaypointNestedInput
    events?: ContactTimelineEventUncheckedUpdateManyWithoutWaypointNestedInput
  }

  export type ActivityUpsertWithoutNotesInput = {
    update: XOR<ActivityUpdateWithoutNotesInput, ActivityUncheckedUpdateWithoutNotesInput>
    create: XOR<ActivityCreateWithoutNotesInput, ActivityUncheckedCreateWithoutNotesInput>
    where?: ActivityWhereInput
  }

  export type ActivityUpdateToOneWithWhereWithoutNotesInput = {
    where?: ActivityWhereInput
    data: XOR<ActivityUpdateWithoutNotesInput, ActivityUncheckedUpdateWithoutNotesInput>
  }

  export type ActivityUpdateWithoutNotesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    steps?: ActivityStepUpdateManyWithoutActivityNestedInput
    waypoints?: ActivityWaypointUpdateManyWithoutActivityNestedInput
    activities?: ActivityUpdateManyWithoutParentActivityNestedInput
    parentActivity?: ActivityUpdateOneWithoutActivitiesNestedInput
    parentWaypoint?: ActivityWaypointUpdateOneWithoutChildActivitiesNestedInput
    template?: ActivityTemplateUpdateOneWithoutActivitiesNestedInput
    assignedBy?: UserUpdateOneRequiredWithoutAssignedActivitiesNestedInput
    contacts?: ActivityContactJoinUpdateManyWithoutActivityRelationNestedInput
    users?: ActivityUserJoinUpdateManyWithoutActivityRelationNestedInput
    tenet?: TenetUpdateOneRequiredWithoutActivitiesNestedInput
    attachments?: AttachmentUpdateManyWithoutActivityNestedInput
    events?: ContactTimelineEventUpdateManyWithoutActivityNestedInput
    opportunity?: OpportunityUpdateOneWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateWithoutNotesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    parentActivityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    parentWaypointId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    templateId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    assignedById?: BytesFieldUpdateOperationsInput | Uint8Array
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    opportunityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    steps?: ActivityStepUncheckedUpdateManyWithoutActivityNestedInput
    waypoints?: ActivityWaypointUncheckedUpdateManyWithoutActivityNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutParentActivityNestedInput
    contacts?: ActivityContactJoinUncheckedUpdateManyWithoutActivityRelationNestedInput
    users?: ActivityUserJoinUncheckedUpdateManyWithoutActivityRelationNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutActivityNestedInput
    events?: ContactTimelineEventUncheckedUpdateManyWithoutActivityNestedInput
  }

  export type ContactUpsertWithoutNotesInput = {
    update: XOR<ContactUpdateWithoutNotesInput, ContactUncheckedUpdateWithoutNotesInput>
    create: XOR<ContactCreateWithoutNotesInput, ContactUncheckedCreateWithoutNotesInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutNotesInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutNotesInput, ContactUncheckedUpdateWithoutNotesInput>
  }

  export type ContactUpdateWithoutNotesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    importantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    lifecycleStage?: NullableEnumLifecycleStageFieldUpdateOperationsInput | $Enums.LifecycleStage | null
    lastContactedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    householdStatus?: NullableEnumHouseholdRelationshipStatusFieldUpdateOperationsInput | $Enums.HouseholdRelationshipStatus | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyStatus?: NullableEnumCompanyRelationshipStatusFieldUpdateOperationsInput | $Enums.CompanyRelationshipStatus | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenet?: TenetUpdateOneRequiredWithoutContactsNestedInput
    timelineEvents?: ContactTimelineEventContactJoinUpdateManyWithoutContactRelationNestedInput
    addresses?: AddressUpdateManyWithoutContactNestedInput
    emails?: ContactEmailUpdateManyWithoutContactNestedInput
    phones?: ContactPhoneUpdateManyWithoutContactNestedInput
    importantDates?: ImportantDateUpdateManyWithoutContactNestedInput
    activities?: ActivityContactJoinUpdateManyWithoutContactRelationNestedInput
    household?: ContactUpdateOneWithoutHouseholdMembersNestedInput
    headOfHouseholdFor?: ContactUpdateOneWithoutHeadOfHouseholdNestedInput
    company?: ContactUpdateOneWithoutEmployeesNestedInput
    primaryContactFor?: ContactUpdateOneWithoutPrimaryContactNestedInput
    headOfHousehold?: ContactUpdateOneWithoutHeadOfHouseholdForNestedInput
    householdMembers?: ContactUpdateManyWithoutHouseholdNestedInput
    employees?: ContactUpdateManyWithoutCompanyNestedInput
    primaryContact?: ContactUpdateOneWithoutPrimaryContactForNestedInput
    opportunities?: ContactOpportunityJoinUpdateManyWithoutContactRelationNestedInput
    relationAsSource?: ContactRelationshipUpdateManyWithoutSourceNestedInput
    relationAsTarget?: ContactRelationshipUpdateManyWithoutTargetNestedInput
  }

  export type ContactUncheckedUpdateWithoutNotesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    importantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    lifecycleStage?: NullableEnumLifecycleStageFieldUpdateOperationsInput | $Enums.LifecycleStage | null
    lastContactedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    householdId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    householdStatus?: NullableEnumHouseholdRelationshipStatusFieldUpdateOperationsInput | $Enums.HouseholdRelationshipStatus | null
    companyId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyStatus?: NullableEnumCompanyRelationshipStatusFieldUpdateOperationsInput | $Enums.CompanyRelationshipStatus | null
    headOfHouseholdId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    primaryContactId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timelineEvents?: ContactTimelineEventContactJoinUncheckedUpdateManyWithoutContactRelationNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutContactNestedInput
    emails?: ContactEmailUncheckedUpdateManyWithoutContactNestedInput
    phones?: ContactPhoneUncheckedUpdateManyWithoutContactNestedInput
    importantDates?: ImportantDateUncheckedUpdateManyWithoutContactNestedInput
    activities?: ActivityContactJoinUncheckedUpdateManyWithoutContactRelationNestedInput
    headOfHouseholdFor?: ContactUncheckedUpdateOneWithoutHeadOfHouseholdNestedInput
    primaryContactFor?: ContactUncheckedUpdateOneWithoutPrimaryContactNestedInput
    householdMembers?: ContactUncheckedUpdateManyWithoutHouseholdNestedInput
    employees?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    opportunities?: ContactOpportunityJoinUncheckedUpdateManyWithoutContactRelationNestedInput
    relationAsSource?: ContactRelationshipUncheckedUpdateManyWithoutSourceNestedInput
    relationAsTarget?: ContactRelationshipUncheckedUpdateManyWithoutTargetNestedInput
  }

  export type OpportunityUpsertWithoutNotesInput = {
    update: XOR<OpportunityUpdateWithoutNotesInput, OpportunityUncheckedUpdateWithoutNotesInput>
    create: XOR<OpportunityCreateWithoutNotesInput, OpportunityUncheckedCreateWithoutNotesInput>
    where?: OpportunityWhereInput
  }

  export type OpportunityUpdateToOneWithWhereWithoutNotesInput = {
    where?: OpportunityWhereInput
    data: XOR<OpportunityUpdateWithoutNotesInput, OpportunityUncheckedUpdateWithoutNotesInput>
  }

  export type OpportunityUpdateWithoutNotesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    probability?: FloatFieldUpdateOperationsInput | number
    expectedCloseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumOpportunityStatusFieldUpdateOperationsInput | $Enums.OpportunityStatus
    statusHistory?: OpportunityUpdatestatusHistoryInput | $Enums.OpportunityStatus[]
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedValue?: FloatFieldUpdateOperationsInput | number
    contacts?: ContactOpportunityJoinUpdateManyWithoutOpportunityRelationNestedInput
    teamMembers?: UserOpportunityJoinUpdateManyWithoutOpportunityRelationNestedInput
    activities?: ActivityUpdateManyWithoutOpportunityNestedInput
    products?: OpportunityProductUpdateManyWithoutOpportunityNestedInput
    tenet?: TenetUpdateOneRequiredWithoutOpportunitiesNestedInput
    events?: ContactTimelineEventUpdateManyWithoutOpportunityNestedInput
  }

  export type OpportunityUncheckedUpdateWithoutNotesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    probability?: FloatFieldUpdateOperationsInput | number
    expectedCloseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumOpportunityStatusFieldUpdateOperationsInput | $Enums.OpportunityStatus
    statusHistory?: OpportunityUpdatestatusHistoryInput | $Enums.OpportunityStatus[]
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    expectedValue?: FloatFieldUpdateOperationsInput | number
    contacts?: ContactOpportunityJoinUncheckedUpdateManyWithoutOpportunityRelationNestedInput
    teamMembers?: UserOpportunityJoinUncheckedUpdateManyWithoutOpportunityRelationNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutOpportunityNestedInput
    products?: OpportunityProductUncheckedUpdateManyWithoutOpportunityNestedInput
    events?: ContactTimelineEventUncheckedUpdateManyWithoutOpportunityNestedInput
  }

  export type TenetUpsertWithoutNotesInput = {
    update: XOR<TenetUpdateWithoutNotesInput, TenetUncheckedUpdateWithoutNotesInput>
    create: XOR<TenetCreateWithoutNotesInput, TenetUncheckedCreateWithoutNotesInput>
    where?: TenetWhereInput
  }

  export type TenetUpdateToOneWithWhereWithoutNotesInput = {
    where?: TenetWhereInput
    data: XOR<TenetUpdateWithoutNotesInput, TenetUncheckedUpdateWithoutNotesInput>
  }

  export type TenetUpdateWithoutNotesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenetNestedInput
    logs?: LogUpdateManyWithoutTenetNestedInput
    contacts?: ContactUpdateManyWithoutTenetNestedInput
    activities?: ActivityUpdateManyWithoutTenetNestedInput
    addresses?: AddressUpdateManyWithoutTenetNestedInput
    contactEmails?: ContactEmailUpdateManyWithoutTenetNestedInput
    contactPhones?: ContactPhoneUpdateManyWithoutTenetNestedInput
    importantDates?: ImportantDateUpdateManyWithoutTenetNestedInput
    attachments?: AttachmentUpdateManyWithoutTenetNestedInput
    auditEvents?: AuditEventUpdateManyWithoutTenetNestedInput
    contactTimelineEvents?: ContactTimelineEventUpdateManyWithoutTenetNestedInput
    activitySteps?: ActivityStepUpdateManyWithoutTenetNestedInput
    activityWaypoints?: ActivityWaypointUpdateManyWithoutTenetNestedInput
    templateAssignments?: TemplateAssignmentUpdateManyWithoutTenetNestedInput
    activityWaypointTemplates?: ActivityWaypointTemplateUpdateManyWithoutTenetNestedInput
    activityTemplates?: ActivityTemplateUpdateManyWithoutTenetNestedInput
    activityTemplateSteps?: ActivityTemplateStepUpdateManyWithoutTenetNestedInput
    opportunities?: OpportunityUpdateManyWithoutTenetNestedInput
    products?: ProductTypeUpdateManyWithoutTenetNestedInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentUpdateManyWithoutTenetNestedInput
  }

  export type TenetUncheckedUpdateWithoutNotesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenetNestedInput
    logs?: LogUncheckedUpdateManyWithoutTenetNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutTenetNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutTenetNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutTenetNestedInput
    contactEmails?: ContactEmailUncheckedUpdateManyWithoutTenetNestedInput
    contactPhones?: ContactPhoneUncheckedUpdateManyWithoutTenetNestedInput
    importantDates?: ImportantDateUncheckedUpdateManyWithoutTenetNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTenetNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutTenetNestedInput
    contactTimelineEvents?: ContactTimelineEventUncheckedUpdateManyWithoutTenetNestedInput
    activitySteps?: ActivityStepUncheckedUpdateManyWithoutTenetNestedInput
    activityWaypoints?: ActivityWaypointUncheckedUpdateManyWithoutTenetNestedInput
    templateAssignments?: TemplateAssignmentUncheckedUpdateManyWithoutTenetNestedInput
    activityWaypointTemplates?: ActivityWaypointTemplateUncheckedUpdateManyWithoutTenetNestedInput
    activityTemplates?: ActivityTemplateUncheckedUpdateManyWithoutTenetNestedInput
    activityTemplateSteps?: ActivityTemplateStepUncheckedUpdateManyWithoutTenetNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutTenetNestedInput
    products?: ProductTypeUncheckedUpdateManyWithoutTenetNestedInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentUncheckedUpdateManyWithoutTenetNestedInput
  }

  export type UserUpsertWithoutNotesInput = {
    update: XOR<UserUpdateWithoutNotesInput, UserUncheckedUpdateWithoutNotesInput>
    create: XOR<UserCreateWithoutNotesInput, UserUncheckedCreateWithoutNotesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotesInput, UserUncheckedUpdateWithoutNotesInput>
  }

  export type UserUpdateWithoutNotesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumAccessGroupFieldUpdateOperationsInput | $Enums.AccessGroup
    system?: BoolFieldUpdateOperationsInput | boolean
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokens?: TokenUpdateManyWithoutUserNestedInput
    tenet?: TenetUpdateOneWithoutUsersNestedInput
    activities?: ActivityUserJoinUpdateManyWithoutUserRelationNestedInput
    waypoints?: UserWaypointJoinUpdateManyWithoutUserRelationNestedInput
    events?: ContactTimelineEventUpdateManyWithoutUserNestedInput
    auditEvents?: AuditEventUpdateManyWithoutUserNestedInput
    templateAssignments?: TemplateAssignmentUpdateManyWithoutSpecificUserNestedInput
    assignedActivities?: ActivityUpdateManyWithoutAssignedByNestedInput
    opportunities?: UserOpportunityJoinUpdateManyWithoutUserRelationNestedInput
    activitySteps?: ActivityStepUserJoinUpdateManyWithoutUserRelationNestedInput
    templateStepAssignments?: ActivityTemplateStepAssignmentUpdateManyWithoutSpecificUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumAccessGroupFieldUpdateOperationsInput | $Enums.AccessGroup
    tenetId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    system?: BoolFieldUpdateOperationsInput | boolean
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUserJoinUncheckedUpdateManyWithoutUserRelationNestedInput
    waypoints?: UserWaypointJoinUncheckedUpdateManyWithoutUserRelationNestedInput
    events?: ContactTimelineEventUncheckedUpdateManyWithoutUserNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutUserNestedInput
    templateAssignments?: TemplateAssignmentUncheckedUpdateManyWithoutSpecificUserNestedInput
    assignedActivities?: ActivityUncheckedUpdateManyWithoutAssignedByNestedInput
    opportunities?: UserOpportunityJoinUncheckedUpdateManyWithoutUserRelationNestedInput
    activitySteps?: ActivityStepUserJoinUncheckedUpdateManyWithoutUserRelationNestedInput
    templateStepAssignments?: ActivityTemplateStepAssignmentUncheckedUpdateManyWithoutSpecificUserNestedInput
  }

  export type ContactTimelineEventUpsertWithWhereUniqueWithoutNoteInput = {
    where: ContactTimelineEventWhereUniqueInput
    update: XOR<ContactTimelineEventUpdateWithoutNoteInput, ContactTimelineEventUncheckedUpdateWithoutNoteInput>
    create: XOR<ContactTimelineEventCreateWithoutNoteInput, ContactTimelineEventUncheckedCreateWithoutNoteInput>
  }

  export type ContactTimelineEventUpdateWithWhereUniqueWithoutNoteInput = {
    where: ContactTimelineEventWhereUniqueInput
    data: XOR<ContactTimelineEventUpdateWithoutNoteInput, ContactTimelineEventUncheckedUpdateWithoutNoteInput>
  }

  export type ContactTimelineEventUpdateManyWithWhereWithoutNoteInput = {
    where: ContactTimelineEventScalarWhereInput
    data: XOR<ContactTimelineEventUpdateManyMutationInput, ContactTimelineEventUncheckedUpdateManyWithoutNoteInput>
  }

  export type ActivityCreateWithoutAttachmentsInput = {
    id: Uint8Array
    title: string
    type: $Enums.ActivityType
    taskScheduleType?: $Enums.TaskScheduleType | null
    startDate: Date | string
    endDate: Date | string
    completedAt?: Date | string | null
    description?: string | null
    priority?: $Enums.ActivityPriority
    status: $Enums.ActivityStatus
    phoneNumber?: string | null
    location?: string | null
    holdReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean
    deletedAt?: Date | string | null
    order?: number | null
    steps?: ActivityStepCreateNestedManyWithoutActivityInput
    waypoints?: ActivityWaypointCreateNestedManyWithoutActivityInput
    activities?: ActivityCreateNestedManyWithoutParentActivityInput
    parentActivity?: ActivityCreateNestedOneWithoutActivitiesInput
    parentWaypoint?: ActivityWaypointCreateNestedOneWithoutChildActivitiesInput
    template?: ActivityTemplateCreateNestedOneWithoutActivitiesInput
    assignedBy: UserCreateNestedOneWithoutAssignedActivitiesInput
    contacts?: ActivityContactJoinCreateNestedManyWithoutActivityRelationInput
    users?: ActivityUserJoinCreateNestedManyWithoutActivityRelationInput
    tenet: TenetCreateNestedOneWithoutActivitiesInput
    notes?: NoteCreateNestedManyWithoutActivityInput
    events?: ContactTimelineEventCreateNestedManyWithoutActivityInput
    opportunity?: OpportunityCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateWithoutAttachmentsInput = {
    id: Uint8Array
    title: string
    type: $Enums.ActivityType
    parentActivityId?: Uint8Array | null
    parentWaypointId?: Uint8Array | null
    templateId?: Uint8Array | null
    taskScheduleType?: $Enums.TaskScheduleType | null
    startDate: Date | string
    endDate: Date | string
    completedAt?: Date | string | null
    description?: string | null
    priority?: $Enums.ActivityPriority
    status: $Enums.ActivityStatus
    assignedById: Uint8Array
    phoneNumber?: string | null
    location?: string | null
    holdReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
    deleted?: boolean
    deletedAt?: Date | string | null
    order?: number | null
    opportunityId?: Uint8Array | null
    steps?: ActivityStepUncheckedCreateNestedManyWithoutActivityInput
    waypoints?: ActivityWaypointUncheckedCreateNestedManyWithoutActivityInput
    activities?: ActivityUncheckedCreateNestedManyWithoutParentActivityInput
    contacts?: ActivityContactJoinUncheckedCreateNestedManyWithoutActivityRelationInput
    users?: ActivityUserJoinUncheckedCreateNestedManyWithoutActivityRelationInput
    notes?: NoteUncheckedCreateNestedManyWithoutActivityInput
    events?: ContactTimelineEventUncheckedCreateNestedManyWithoutActivityInput
  }

  export type ActivityCreateOrConnectWithoutAttachmentsInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutAttachmentsInput, ActivityUncheckedCreateWithoutAttachmentsInput>
  }

  export type TenetCreateWithoutAttachmentsInput = {
    id: Uint8Array
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenetInput
    logs?: LogCreateNestedManyWithoutTenetInput
    contacts?: ContactCreateNestedManyWithoutTenetInput
    activities?: ActivityCreateNestedManyWithoutTenetInput
    addresses?: AddressCreateNestedManyWithoutTenetInput
    contactEmails?: ContactEmailCreateNestedManyWithoutTenetInput
    contactPhones?: ContactPhoneCreateNestedManyWithoutTenetInput
    importantDates?: ImportantDateCreateNestedManyWithoutTenetInput
    notes?: NoteCreateNestedManyWithoutTenetInput
    auditEvents?: AuditEventCreateNestedManyWithoutTenetInput
    contactTimelineEvents?: ContactTimelineEventCreateNestedManyWithoutTenetInput
    activitySteps?: ActivityStepCreateNestedManyWithoutTenetInput
    activityWaypoints?: ActivityWaypointCreateNestedManyWithoutTenetInput
    templateAssignments?: TemplateAssignmentCreateNestedManyWithoutTenetInput
    activityWaypointTemplates?: ActivityWaypointTemplateCreateNestedManyWithoutTenetInput
    activityTemplates?: ActivityTemplateCreateNestedManyWithoutTenetInput
    activityTemplateSteps?: ActivityTemplateStepCreateNestedManyWithoutTenetInput
    opportunities?: OpportunityCreateNestedManyWithoutTenetInput
    products?: ProductTypeCreateNestedManyWithoutTenetInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentCreateNestedManyWithoutTenetInput
  }

  export type TenetUncheckedCreateWithoutAttachmentsInput = {
    id: Uint8Array
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenetInput
    logs?: LogUncheckedCreateNestedManyWithoutTenetInput
    contacts?: ContactUncheckedCreateNestedManyWithoutTenetInput
    activities?: ActivityUncheckedCreateNestedManyWithoutTenetInput
    addresses?: AddressUncheckedCreateNestedManyWithoutTenetInput
    contactEmails?: ContactEmailUncheckedCreateNestedManyWithoutTenetInput
    contactPhones?: ContactPhoneUncheckedCreateNestedManyWithoutTenetInput
    importantDates?: ImportantDateUncheckedCreateNestedManyWithoutTenetInput
    notes?: NoteUncheckedCreateNestedManyWithoutTenetInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutTenetInput
    contactTimelineEvents?: ContactTimelineEventUncheckedCreateNestedManyWithoutTenetInput
    activitySteps?: ActivityStepUncheckedCreateNestedManyWithoutTenetInput
    activityWaypoints?: ActivityWaypointUncheckedCreateNestedManyWithoutTenetInput
    templateAssignments?: TemplateAssignmentUncheckedCreateNestedManyWithoutTenetInput
    activityWaypointTemplates?: ActivityWaypointTemplateUncheckedCreateNestedManyWithoutTenetInput
    activityTemplates?: ActivityTemplateUncheckedCreateNestedManyWithoutTenetInput
    activityTemplateSteps?: ActivityTemplateStepUncheckedCreateNestedManyWithoutTenetInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutTenetInput
    products?: ProductTypeUncheckedCreateNestedManyWithoutTenetInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentUncheckedCreateNestedManyWithoutTenetInput
  }

  export type TenetCreateOrConnectWithoutAttachmentsInput = {
    where: TenetWhereUniqueInput
    create: XOR<TenetCreateWithoutAttachmentsInput, TenetUncheckedCreateWithoutAttachmentsInput>
  }

  export type ActivityUpsertWithoutAttachmentsInput = {
    update: XOR<ActivityUpdateWithoutAttachmentsInput, ActivityUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<ActivityCreateWithoutAttachmentsInput, ActivityUncheckedCreateWithoutAttachmentsInput>
    where?: ActivityWhereInput
  }

  export type ActivityUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: ActivityWhereInput
    data: XOR<ActivityUpdateWithoutAttachmentsInput, ActivityUncheckedUpdateWithoutAttachmentsInput>
  }

  export type ActivityUpdateWithoutAttachmentsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    steps?: ActivityStepUpdateManyWithoutActivityNestedInput
    waypoints?: ActivityWaypointUpdateManyWithoutActivityNestedInput
    activities?: ActivityUpdateManyWithoutParentActivityNestedInput
    parentActivity?: ActivityUpdateOneWithoutActivitiesNestedInput
    parentWaypoint?: ActivityWaypointUpdateOneWithoutChildActivitiesNestedInput
    template?: ActivityTemplateUpdateOneWithoutActivitiesNestedInput
    assignedBy?: UserUpdateOneRequiredWithoutAssignedActivitiesNestedInput
    contacts?: ActivityContactJoinUpdateManyWithoutActivityRelationNestedInput
    users?: ActivityUserJoinUpdateManyWithoutActivityRelationNestedInput
    tenet?: TenetUpdateOneRequiredWithoutActivitiesNestedInput
    notes?: NoteUpdateManyWithoutActivityNestedInput
    events?: ContactTimelineEventUpdateManyWithoutActivityNestedInput
    opportunity?: OpportunityUpdateOneWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateWithoutAttachmentsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    parentActivityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    parentWaypointId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    templateId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    assignedById?: BytesFieldUpdateOperationsInput | Uint8Array
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    opportunityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    steps?: ActivityStepUncheckedUpdateManyWithoutActivityNestedInput
    waypoints?: ActivityWaypointUncheckedUpdateManyWithoutActivityNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutParentActivityNestedInput
    contacts?: ActivityContactJoinUncheckedUpdateManyWithoutActivityRelationNestedInput
    users?: ActivityUserJoinUncheckedUpdateManyWithoutActivityRelationNestedInput
    notes?: NoteUncheckedUpdateManyWithoutActivityNestedInput
    events?: ContactTimelineEventUncheckedUpdateManyWithoutActivityNestedInput
  }

  export type TenetUpsertWithoutAttachmentsInput = {
    update: XOR<TenetUpdateWithoutAttachmentsInput, TenetUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<TenetCreateWithoutAttachmentsInput, TenetUncheckedCreateWithoutAttachmentsInput>
    where?: TenetWhereInput
  }

  export type TenetUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: TenetWhereInput
    data: XOR<TenetUpdateWithoutAttachmentsInput, TenetUncheckedUpdateWithoutAttachmentsInput>
  }

  export type TenetUpdateWithoutAttachmentsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenetNestedInput
    logs?: LogUpdateManyWithoutTenetNestedInput
    contacts?: ContactUpdateManyWithoutTenetNestedInput
    activities?: ActivityUpdateManyWithoutTenetNestedInput
    addresses?: AddressUpdateManyWithoutTenetNestedInput
    contactEmails?: ContactEmailUpdateManyWithoutTenetNestedInput
    contactPhones?: ContactPhoneUpdateManyWithoutTenetNestedInput
    importantDates?: ImportantDateUpdateManyWithoutTenetNestedInput
    notes?: NoteUpdateManyWithoutTenetNestedInput
    auditEvents?: AuditEventUpdateManyWithoutTenetNestedInput
    contactTimelineEvents?: ContactTimelineEventUpdateManyWithoutTenetNestedInput
    activitySteps?: ActivityStepUpdateManyWithoutTenetNestedInput
    activityWaypoints?: ActivityWaypointUpdateManyWithoutTenetNestedInput
    templateAssignments?: TemplateAssignmentUpdateManyWithoutTenetNestedInput
    activityWaypointTemplates?: ActivityWaypointTemplateUpdateManyWithoutTenetNestedInput
    activityTemplates?: ActivityTemplateUpdateManyWithoutTenetNestedInput
    activityTemplateSteps?: ActivityTemplateStepUpdateManyWithoutTenetNestedInput
    opportunities?: OpportunityUpdateManyWithoutTenetNestedInput
    products?: ProductTypeUpdateManyWithoutTenetNestedInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentUpdateManyWithoutTenetNestedInput
  }

  export type TenetUncheckedUpdateWithoutAttachmentsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenetNestedInput
    logs?: LogUncheckedUpdateManyWithoutTenetNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutTenetNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutTenetNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutTenetNestedInput
    contactEmails?: ContactEmailUncheckedUpdateManyWithoutTenetNestedInput
    contactPhones?: ContactPhoneUncheckedUpdateManyWithoutTenetNestedInput
    importantDates?: ImportantDateUncheckedUpdateManyWithoutTenetNestedInput
    notes?: NoteUncheckedUpdateManyWithoutTenetNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutTenetNestedInput
    contactTimelineEvents?: ContactTimelineEventUncheckedUpdateManyWithoutTenetNestedInput
    activitySteps?: ActivityStepUncheckedUpdateManyWithoutTenetNestedInput
    activityWaypoints?: ActivityWaypointUncheckedUpdateManyWithoutTenetNestedInput
    templateAssignments?: TemplateAssignmentUncheckedUpdateManyWithoutTenetNestedInput
    activityWaypointTemplates?: ActivityWaypointTemplateUncheckedUpdateManyWithoutTenetNestedInput
    activityTemplates?: ActivityTemplateUncheckedUpdateManyWithoutTenetNestedInput
    activityTemplateSteps?: ActivityTemplateStepUncheckedUpdateManyWithoutTenetNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutTenetNestedInput
    products?: ProductTypeUncheckedUpdateManyWithoutTenetNestedInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentUncheckedUpdateManyWithoutTenetNestedInput
  }

  export type ActivityCreateWithoutContactsInput = {
    id: Uint8Array
    title: string
    type: $Enums.ActivityType
    taskScheduleType?: $Enums.TaskScheduleType | null
    startDate: Date | string
    endDate: Date | string
    completedAt?: Date | string | null
    description?: string | null
    priority?: $Enums.ActivityPriority
    status: $Enums.ActivityStatus
    phoneNumber?: string | null
    location?: string | null
    holdReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean
    deletedAt?: Date | string | null
    order?: number | null
    steps?: ActivityStepCreateNestedManyWithoutActivityInput
    waypoints?: ActivityWaypointCreateNestedManyWithoutActivityInput
    activities?: ActivityCreateNestedManyWithoutParentActivityInput
    parentActivity?: ActivityCreateNestedOneWithoutActivitiesInput
    parentWaypoint?: ActivityWaypointCreateNestedOneWithoutChildActivitiesInput
    template?: ActivityTemplateCreateNestedOneWithoutActivitiesInput
    assignedBy: UserCreateNestedOneWithoutAssignedActivitiesInput
    users?: ActivityUserJoinCreateNestedManyWithoutActivityRelationInput
    tenet: TenetCreateNestedOneWithoutActivitiesInput
    attachments?: AttachmentCreateNestedManyWithoutActivityInput
    notes?: NoteCreateNestedManyWithoutActivityInput
    events?: ContactTimelineEventCreateNestedManyWithoutActivityInput
    opportunity?: OpportunityCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateWithoutContactsInput = {
    id: Uint8Array
    title: string
    type: $Enums.ActivityType
    parentActivityId?: Uint8Array | null
    parentWaypointId?: Uint8Array | null
    templateId?: Uint8Array | null
    taskScheduleType?: $Enums.TaskScheduleType | null
    startDate: Date | string
    endDate: Date | string
    completedAt?: Date | string | null
    description?: string | null
    priority?: $Enums.ActivityPriority
    status: $Enums.ActivityStatus
    assignedById: Uint8Array
    phoneNumber?: string | null
    location?: string | null
    holdReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
    deleted?: boolean
    deletedAt?: Date | string | null
    order?: number | null
    opportunityId?: Uint8Array | null
    steps?: ActivityStepUncheckedCreateNestedManyWithoutActivityInput
    waypoints?: ActivityWaypointUncheckedCreateNestedManyWithoutActivityInput
    activities?: ActivityUncheckedCreateNestedManyWithoutParentActivityInput
    users?: ActivityUserJoinUncheckedCreateNestedManyWithoutActivityRelationInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutActivityInput
    notes?: NoteUncheckedCreateNestedManyWithoutActivityInput
    events?: ContactTimelineEventUncheckedCreateNestedManyWithoutActivityInput
  }

  export type ActivityCreateOrConnectWithoutContactsInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutContactsInput, ActivityUncheckedCreateWithoutContactsInput>
  }

  export type ContactCreateWithoutActivitiesInput = {
    id: Uint8Array
    firstName?: string | null
    lastName: string
    fullName: string
    importantNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.ContactType
    status: $Enums.ContactStatus
    lifecycleStage?: $Enums.LifecycleStage | null
    lastContactedDate?: Date | string | null
    followUpDate?: Date | string | null
    householdStatus?: $Enums.HouseholdRelationshipStatus | null
    position?: string | null
    companyStatus?: $Enums.CompanyRelationshipStatus | null
    industry?: string | null
    website?: string | null
    size?: number | null
    deleted?: boolean
    deletedAt?: Date | string | null
    tenet: TenetCreateNestedOneWithoutContactsInput
    notes?: NoteCreateNestedManyWithoutContactInput
    timelineEvents?: ContactTimelineEventContactJoinCreateNestedManyWithoutContactRelationInput
    addresses?: AddressCreateNestedManyWithoutContactInput
    emails?: ContactEmailCreateNestedManyWithoutContactInput
    phones?: ContactPhoneCreateNestedManyWithoutContactInput
    importantDates?: ImportantDateCreateNestedManyWithoutContactInput
    household?: ContactCreateNestedOneWithoutHouseholdMembersInput
    headOfHouseholdFor?: ContactCreateNestedOneWithoutHeadOfHouseholdInput
    company?: ContactCreateNestedOneWithoutEmployeesInput
    primaryContactFor?: ContactCreateNestedOneWithoutPrimaryContactInput
    headOfHousehold?: ContactCreateNestedOneWithoutHeadOfHouseholdForInput
    householdMembers?: ContactCreateNestedManyWithoutHouseholdInput
    employees?: ContactCreateNestedManyWithoutCompanyInput
    primaryContact?: ContactCreateNestedOneWithoutPrimaryContactForInput
    opportunities?: ContactOpportunityJoinCreateNestedManyWithoutContactRelationInput
    relationAsSource?: ContactRelationshipCreateNestedManyWithoutSourceInput
    relationAsTarget?: ContactRelationshipCreateNestedManyWithoutTargetInput
  }

  export type ContactUncheckedCreateWithoutActivitiesInput = {
    id: Uint8Array
    firstName?: string | null
    lastName: string
    fullName: string
    tenetId: Uint8Array
    importantNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.ContactType
    status: $Enums.ContactStatus
    lifecycleStage?: $Enums.LifecycleStage | null
    lastContactedDate?: Date | string | null
    followUpDate?: Date | string | null
    householdId?: Uint8Array | null
    householdStatus?: $Enums.HouseholdRelationshipStatus | null
    companyId?: Uint8Array | null
    position?: string | null
    companyStatus?: $Enums.CompanyRelationshipStatus | null
    headOfHouseholdId?: Uint8Array | null
    industry?: string | null
    website?: string | null
    size?: number | null
    primaryContactId?: Uint8Array | null
    deleted?: boolean
    deletedAt?: Date | string | null
    notes?: NoteUncheckedCreateNestedManyWithoutContactInput
    timelineEvents?: ContactTimelineEventContactJoinUncheckedCreateNestedManyWithoutContactRelationInput
    addresses?: AddressUncheckedCreateNestedManyWithoutContactInput
    emails?: ContactEmailUncheckedCreateNestedManyWithoutContactInput
    phones?: ContactPhoneUncheckedCreateNestedManyWithoutContactInput
    importantDates?: ImportantDateUncheckedCreateNestedManyWithoutContactInput
    headOfHouseholdFor?: ContactUncheckedCreateNestedOneWithoutHeadOfHouseholdInput
    primaryContactFor?: ContactUncheckedCreateNestedOneWithoutPrimaryContactInput
    householdMembers?: ContactUncheckedCreateNestedManyWithoutHouseholdInput
    employees?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    opportunities?: ContactOpportunityJoinUncheckedCreateNestedManyWithoutContactRelationInput
    relationAsSource?: ContactRelationshipUncheckedCreateNestedManyWithoutSourceInput
    relationAsTarget?: ContactRelationshipUncheckedCreateNestedManyWithoutTargetInput
  }

  export type ContactCreateOrConnectWithoutActivitiesInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutActivitiesInput, ContactUncheckedCreateWithoutActivitiesInput>
  }

  export type ActivityUpsertWithoutContactsInput = {
    update: XOR<ActivityUpdateWithoutContactsInput, ActivityUncheckedUpdateWithoutContactsInput>
    create: XOR<ActivityCreateWithoutContactsInput, ActivityUncheckedCreateWithoutContactsInput>
    where?: ActivityWhereInput
  }

  export type ActivityUpdateToOneWithWhereWithoutContactsInput = {
    where?: ActivityWhereInput
    data: XOR<ActivityUpdateWithoutContactsInput, ActivityUncheckedUpdateWithoutContactsInput>
  }

  export type ActivityUpdateWithoutContactsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    steps?: ActivityStepUpdateManyWithoutActivityNestedInput
    waypoints?: ActivityWaypointUpdateManyWithoutActivityNestedInput
    activities?: ActivityUpdateManyWithoutParentActivityNestedInput
    parentActivity?: ActivityUpdateOneWithoutActivitiesNestedInput
    parentWaypoint?: ActivityWaypointUpdateOneWithoutChildActivitiesNestedInput
    template?: ActivityTemplateUpdateOneWithoutActivitiesNestedInput
    assignedBy?: UserUpdateOneRequiredWithoutAssignedActivitiesNestedInput
    users?: ActivityUserJoinUpdateManyWithoutActivityRelationNestedInput
    tenet?: TenetUpdateOneRequiredWithoutActivitiesNestedInput
    attachments?: AttachmentUpdateManyWithoutActivityNestedInput
    notes?: NoteUpdateManyWithoutActivityNestedInput
    events?: ContactTimelineEventUpdateManyWithoutActivityNestedInput
    opportunity?: OpportunityUpdateOneWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateWithoutContactsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    parentActivityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    parentWaypointId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    templateId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    assignedById?: BytesFieldUpdateOperationsInput | Uint8Array
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    opportunityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    steps?: ActivityStepUncheckedUpdateManyWithoutActivityNestedInput
    waypoints?: ActivityWaypointUncheckedUpdateManyWithoutActivityNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutParentActivityNestedInput
    users?: ActivityUserJoinUncheckedUpdateManyWithoutActivityRelationNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutActivityNestedInput
    notes?: NoteUncheckedUpdateManyWithoutActivityNestedInput
    events?: ContactTimelineEventUncheckedUpdateManyWithoutActivityNestedInput
  }

  export type ContactUpsertWithoutActivitiesInput = {
    update: XOR<ContactUpdateWithoutActivitiesInput, ContactUncheckedUpdateWithoutActivitiesInput>
    create: XOR<ContactCreateWithoutActivitiesInput, ContactUncheckedCreateWithoutActivitiesInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutActivitiesInput, ContactUncheckedUpdateWithoutActivitiesInput>
  }

  export type ContactUpdateWithoutActivitiesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    importantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    lifecycleStage?: NullableEnumLifecycleStageFieldUpdateOperationsInput | $Enums.LifecycleStage | null
    lastContactedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    householdStatus?: NullableEnumHouseholdRelationshipStatusFieldUpdateOperationsInput | $Enums.HouseholdRelationshipStatus | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyStatus?: NullableEnumCompanyRelationshipStatusFieldUpdateOperationsInput | $Enums.CompanyRelationshipStatus | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenet?: TenetUpdateOneRequiredWithoutContactsNestedInput
    notes?: NoteUpdateManyWithoutContactNestedInput
    timelineEvents?: ContactTimelineEventContactJoinUpdateManyWithoutContactRelationNestedInput
    addresses?: AddressUpdateManyWithoutContactNestedInput
    emails?: ContactEmailUpdateManyWithoutContactNestedInput
    phones?: ContactPhoneUpdateManyWithoutContactNestedInput
    importantDates?: ImportantDateUpdateManyWithoutContactNestedInput
    household?: ContactUpdateOneWithoutHouseholdMembersNestedInput
    headOfHouseholdFor?: ContactUpdateOneWithoutHeadOfHouseholdNestedInput
    company?: ContactUpdateOneWithoutEmployeesNestedInput
    primaryContactFor?: ContactUpdateOneWithoutPrimaryContactNestedInput
    headOfHousehold?: ContactUpdateOneWithoutHeadOfHouseholdForNestedInput
    householdMembers?: ContactUpdateManyWithoutHouseholdNestedInput
    employees?: ContactUpdateManyWithoutCompanyNestedInput
    primaryContact?: ContactUpdateOneWithoutPrimaryContactForNestedInput
    opportunities?: ContactOpportunityJoinUpdateManyWithoutContactRelationNestedInput
    relationAsSource?: ContactRelationshipUpdateManyWithoutSourceNestedInput
    relationAsTarget?: ContactRelationshipUpdateManyWithoutTargetNestedInput
  }

  export type ContactUncheckedUpdateWithoutActivitiesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    importantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    lifecycleStage?: NullableEnumLifecycleStageFieldUpdateOperationsInput | $Enums.LifecycleStage | null
    lastContactedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    householdId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    householdStatus?: NullableEnumHouseholdRelationshipStatusFieldUpdateOperationsInput | $Enums.HouseholdRelationshipStatus | null
    companyId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyStatus?: NullableEnumCompanyRelationshipStatusFieldUpdateOperationsInput | $Enums.CompanyRelationshipStatus | null
    headOfHouseholdId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    primaryContactId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NoteUncheckedUpdateManyWithoutContactNestedInput
    timelineEvents?: ContactTimelineEventContactJoinUncheckedUpdateManyWithoutContactRelationNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutContactNestedInput
    emails?: ContactEmailUncheckedUpdateManyWithoutContactNestedInput
    phones?: ContactPhoneUncheckedUpdateManyWithoutContactNestedInput
    importantDates?: ImportantDateUncheckedUpdateManyWithoutContactNestedInput
    headOfHouseholdFor?: ContactUncheckedUpdateOneWithoutHeadOfHouseholdNestedInput
    primaryContactFor?: ContactUncheckedUpdateOneWithoutPrimaryContactNestedInput
    householdMembers?: ContactUncheckedUpdateManyWithoutHouseholdNestedInput
    employees?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    opportunities?: ContactOpportunityJoinUncheckedUpdateManyWithoutContactRelationNestedInput
    relationAsSource?: ContactRelationshipUncheckedUpdateManyWithoutSourceNestedInput
    relationAsTarget?: ContactRelationshipUncheckedUpdateManyWithoutTargetNestedInput
  }

  export type ActivityCreateWithoutUsersInput = {
    id: Uint8Array
    title: string
    type: $Enums.ActivityType
    taskScheduleType?: $Enums.TaskScheduleType | null
    startDate: Date | string
    endDate: Date | string
    completedAt?: Date | string | null
    description?: string | null
    priority?: $Enums.ActivityPriority
    status: $Enums.ActivityStatus
    phoneNumber?: string | null
    location?: string | null
    holdReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean
    deletedAt?: Date | string | null
    order?: number | null
    steps?: ActivityStepCreateNestedManyWithoutActivityInput
    waypoints?: ActivityWaypointCreateNestedManyWithoutActivityInput
    activities?: ActivityCreateNestedManyWithoutParentActivityInput
    parentActivity?: ActivityCreateNestedOneWithoutActivitiesInput
    parentWaypoint?: ActivityWaypointCreateNestedOneWithoutChildActivitiesInput
    template?: ActivityTemplateCreateNestedOneWithoutActivitiesInput
    assignedBy: UserCreateNestedOneWithoutAssignedActivitiesInput
    contacts?: ActivityContactJoinCreateNestedManyWithoutActivityRelationInput
    tenet: TenetCreateNestedOneWithoutActivitiesInput
    attachments?: AttachmentCreateNestedManyWithoutActivityInput
    notes?: NoteCreateNestedManyWithoutActivityInput
    events?: ContactTimelineEventCreateNestedManyWithoutActivityInput
    opportunity?: OpportunityCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateWithoutUsersInput = {
    id: Uint8Array
    title: string
    type: $Enums.ActivityType
    parentActivityId?: Uint8Array | null
    parentWaypointId?: Uint8Array | null
    templateId?: Uint8Array | null
    taskScheduleType?: $Enums.TaskScheduleType | null
    startDate: Date | string
    endDate: Date | string
    completedAt?: Date | string | null
    description?: string | null
    priority?: $Enums.ActivityPriority
    status: $Enums.ActivityStatus
    assignedById: Uint8Array
    phoneNumber?: string | null
    location?: string | null
    holdReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
    deleted?: boolean
    deletedAt?: Date | string | null
    order?: number | null
    opportunityId?: Uint8Array | null
    steps?: ActivityStepUncheckedCreateNestedManyWithoutActivityInput
    waypoints?: ActivityWaypointUncheckedCreateNestedManyWithoutActivityInput
    activities?: ActivityUncheckedCreateNestedManyWithoutParentActivityInput
    contacts?: ActivityContactJoinUncheckedCreateNestedManyWithoutActivityRelationInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutActivityInput
    notes?: NoteUncheckedCreateNestedManyWithoutActivityInput
    events?: ContactTimelineEventUncheckedCreateNestedManyWithoutActivityInput
  }

  export type ActivityCreateOrConnectWithoutUsersInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutUsersInput, ActivityUncheckedCreateWithoutUsersInput>
  }

  export type UserCreateWithoutActivitiesInput = {
    id: Uint8Array
    email: string
    firstName: string
    lastName: string
    fullName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password: string
    enabled?: boolean
    type?: $Enums.AccessGroup
    system?: boolean
    deleted?: boolean
    deletedAt?: Date | string | null
    tokens?: TokenCreateNestedManyWithoutUserInput
    tenet?: TenetCreateNestedOneWithoutUsersInput
    notes?: NoteCreateNestedManyWithoutAuthorInput
    waypoints?: UserWaypointJoinCreateNestedManyWithoutUserRelationInput
    events?: ContactTimelineEventCreateNestedManyWithoutUserInput
    auditEvents?: AuditEventCreateNestedManyWithoutUserInput
    templateAssignments?: TemplateAssignmentCreateNestedManyWithoutSpecificUserInput
    assignedActivities?: ActivityCreateNestedManyWithoutAssignedByInput
    opportunities?: UserOpportunityJoinCreateNestedManyWithoutUserRelationInput
    activitySteps?: ActivityStepUserJoinCreateNestedManyWithoutUserRelationInput
    templateStepAssignments?: ActivityTemplateStepAssignmentCreateNestedManyWithoutSpecificUserInput
  }

  export type UserUncheckedCreateWithoutActivitiesInput = {
    id: Uint8Array
    email: string
    firstName: string
    lastName: string
    fullName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password: string
    enabled?: boolean
    type?: $Enums.AccessGroup
    tenetId?: Uint8Array | null
    system?: boolean
    deleted?: boolean
    deletedAt?: Date | string | null
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    notes?: NoteUncheckedCreateNestedManyWithoutAuthorInput
    waypoints?: UserWaypointJoinUncheckedCreateNestedManyWithoutUserRelationInput
    events?: ContactTimelineEventUncheckedCreateNestedManyWithoutUserInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutUserInput
    templateAssignments?: TemplateAssignmentUncheckedCreateNestedManyWithoutSpecificUserInput
    assignedActivities?: ActivityUncheckedCreateNestedManyWithoutAssignedByInput
    opportunities?: UserOpportunityJoinUncheckedCreateNestedManyWithoutUserRelationInput
    activitySteps?: ActivityStepUserJoinUncheckedCreateNestedManyWithoutUserRelationInput
    templateStepAssignments?: ActivityTemplateStepAssignmentUncheckedCreateNestedManyWithoutSpecificUserInput
  }

  export type UserCreateOrConnectWithoutActivitiesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
  }

  export type ActivityUpsertWithoutUsersInput = {
    update: XOR<ActivityUpdateWithoutUsersInput, ActivityUncheckedUpdateWithoutUsersInput>
    create: XOR<ActivityCreateWithoutUsersInput, ActivityUncheckedCreateWithoutUsersInput>
    where?: ActivityWhereInput
  }

  export type ActivityUpdateToOneWithWhereWithoutUsersInput = {
    where?: ActivityWhereInput
    data: XOR<ActivityUpdateWithoutUsersInput, ActivityUncheckedUpdateWithoutUsersInput>
  }

  export type ActivityUpdateWithoutUsersInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    steps?: ActivityStepUpdateManyWithoutActivityNestedInput
    waypoints?: ActivityWaypointUpdateManyWithoutActivityNestedInput
    activities?: ActivityUpdateManyWithoutParentActivityNestedInput
    parentActivity?: ActivityUpdateOneWithoutActivitiesNestedInput
    parentWaypoint?: ActivityWaypointUpdateOneWithoutChildActivitiesNestedInput
    template?: ActivityTemplateUpdateOneWithoutActivitiesNestedInput
    assignedBy?: UserUpdateOneRequiredWithoutAssignedActivitiesNestedInput
    contacts?: ActivityContactJoinUpdateManyWithoutActivityRelationNestedInput
    tenet?: TenetUpdateOneRequiredWithoutActivitiesNestedInput
    attachments?: AttachmentUpdateManyWithoutActivityNestedInput
    notes?: NoteUpdateManyWithoutActivityNestedInput
    events?: ContactTimelineEventUpdateManyWithoutActivityNestedInput
    opportunity?: OpportunityUpdateOneWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateWithoutUsersInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    parentActivityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    parentWaypointId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    templateId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    assignedById?: BytesFieldUpdateOperationsInput | Uint8Array
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    opportunityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    steps?: ActivityStepUncheckedUpdateManyWithoutActivityNestedInput
    waypoints?: ActivityWaypointUncheckedUpdateManyWithoutActivityNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutParentActivityNestedInput
    contacts?: ActivityContactJoinUncheckedUpdateManyWithoutActivityRelationNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutActivityNestedInput
    notes?: NoteUncheckedUpdateManyWithoutActivityNestedInput
    events?: ContactTimelineEventUncheckedUpdateManyWithoutActivityNestedInput
  }

  export type UserUpsertWithoutActivitiesInput = {
    update: XOR<UserUpdateWithoutActivitiesInput, UserUncheckedUpdateWithoutActivitiesInput>
    create: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutActivitiesInput, UserUncheckedUpdateWithoutActivitiesInput>
  }

  export type UserUpdateWithoutActivitiesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumAccessGroupFieldUpdateOperationsInput | $Enums.AccessGroup
    system?: BoolFieldUpdateOperationsInput | boolean
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokens?: TokenUpdateManyWithoutUserNestedInput
    tenet?: TenetUpdateOneWithoutUsersNestedInput
    notes?: NoteUpdateManyWithoutAuthorNestedInput
    waypoints?: UserWaypointJoinUpdateManyWithoutUserRelationNestedInput
    events?: ContactTimelineEventUpdateManyWithoutUserNestedInput
    auditEvents?: AuditEventUpdateManyWithoutUserNestedInput
    templateAssignments?: TemplateAssignmentUpdateManyWithoutSpecificUserNestedInput
    assignedActivities?: ActivityUpdateManyWithoutAssignedByNestedInput
    opportunities?: UserOpportunityJoinUpdateManyWithoutUserRelationNestedInput
    activitySteps?: ActivityStepUserJoinUpdateManyWithoutUserRelationNestedInput
    templateStepAssignments?: ActivityTemplateStepAssignmentUpdateManyWithoutSpecificUserNestedInput
  }

  export type UserUncheckedUpdateWithoutActivitiesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumAccessGroupFieldUpdateOperationsInput | $Enums.AccessGroup
    tenetId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    system?: BoolFieldUpdateOperationsInput | boolean
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    notes?: NoteUncheckedUpdateManyWithoutAuthorNestedInput
    waypoints?: UserWaypointJoinUncheckedUpdateManyWithoutUserRelationNestedInput
    events?: ContactTimelineEventUncheckedUpdateManyWithoutUserNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutUserNestedInput
    templateAssignments?: TemplateAssignmentUncheckedUpdateManyWithoutSpecificUserNestedInput
    assignedActivities?: ActivityUncheckedUpdateManyWithoutAssignedByNestedInput
    opportunities?: UserOpportunityJoinUncheckedUpdateManyWithoutUserRelationNestedInput
    activitySteps?: ActivityStepUserJoinUncheckedUpdateManyWithoutUserRelationNestedInput
    templateStepAssignments?: ActivityTemplateStepAssignmentUncheckedUpdateManyWithoutSpecificUserNestedInput
  }

  export type ContactCreateWithoutEmailsInput = {
    id: Uint8Array
    firstName?: string | null
    lastName: string
    fullName: string
    importantNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.ContactType
    status: $Enums.ContactStatus
    lifecycleStage?: $Enums.LifecycleStage | null
    lastContactedDate?: Date | string | null
    followUpDate?: Date | string | null
    householdStatus?: $Enums.HouseholdRelationshipStatus | null
    position?: string | null
    companyStatus?: $Enums.CompanyRelationshipStatus | null
    industry?: string | null
    website?: string | null
    size?: number | null
    deleted?: boolean
    deletedAt?: Date | string | null
    tenet: TenetCreateNestedOneWithoutContactsInput
    notes?: NoteCreateNestedManyWithoutContactInput
    timelineEvents?: ContactTimelineEventContactJoinCreateNestedManyWithoutContactRelationInput
    addresses?: AddressCreateNestedManyWithoutContactInput
    phones?: ContactPhoneCreateNestedManyWithoutContactInput
    importantDates?: ImportantDateCreateNestedManyWithoutContactInput
    activities?: ActivityContactJoinCreateNestedManyWithoutContactRelationInput
    household?: ContactCreateNestedOneWithoutHouseholdMembersInput
    headOfHouseholdFor?: ContactCreateNestedOneWithoutHeadOfHouseholdInput
    company?: ContactCreateNestedOneWithoutEmployeesInput
    primaryContactFor?: ContactCreateNestedOneWithoutPrimaryContactInput
    headOfHousehold?: ContactCreateNestedOneWithoutHeadOfHouseholdForInput
    householdMembers?: ContactCreateNestedManyWithoutHouseholdInput
    employees?: ContactCreateNestedManyWithoutCompanyInput
    primaryContact?: ContactCreateNestedOneWithoutPrimaryContactForInput
    opportunities?: ContactOpportunityJoinCreateNestedManyWithoutContactRelationInput
    relationAsSource?: ContactRelationshipCreateNestedManyWithoutSourceInput
    relationAsTarget?: ContactRelationshipCreateNestedManyWithoutTargetInput
  }

  export type ContactUncheckedCreateWithoutEmailsInput = {
    id: Uint8Array
    firstName?: string | null
    lastName: string
    fullName: string
    tenetId: Uint8Array
    importantNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.ContactType
    status: $Enums.ContactStatus
    lifecycleStage?: $Enums.LifecycleStage | null
    lastContactedDate?: Date | string | null
    followUpDate?: Date | string | null
    householdId?: Uint8Array | null
    householdStatus?: $Enums.HouseholdRelationshipStatus | null
    companyId?: Uint8Array | null
    position?: string | null
    companyStatus?: $Enums.CompanyRelationshipStatus | null
    headOfHouseholdId?: Uint8Array | null
    industry?: string | null
    website?: string | null
    size?: number | null
    primaryContactId?: Uint8Array | null
    deleted?: boolean
    deletedAt?: Date | string | null
    notes?: NoteUncheckedCreateNestedManyWithoutContactInput
    timelineEvents?: ContactTimelineEventContactJoinUncheckedCreateNestedManyWithoutContactRelationInput
    addresses?: AddressUncheckedCreateNestedManyWithoutContactInput
    phones?: ContactPhoneUncheckedCreateNestedManyWithoutContactInput
    importantDates?: ImportantDateUncheckedCreateNestedManyWithoutContactInput
    activities?: ActivityContactJoinUncheckedCreateNestedManyWithoutContactRelationInput
    headOfHouseholdFor?: ContactUncheckedCreateNestedOneWithoutHeadOfHouseholdInput
    primaryContactFor?: ContactUncheckedCreateNestedOneWithoutPrimaryContactInput
    householdMembers?: ContactUncheckedCreateNestedManyWithoutHouseholdInput
    employees?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    opportunities?: ContactOpportunityJoinUncheckedCreateNestedManyWithoutContactRelationInput
    relationAsSource?: ContactRelationshipUncheckedCreateNestedManyWithoutSourceInput
    relationAsTarget?: ContactRelationshipUncheckedCreateNestedManyWithoutTargetInput
  }

  export type ContactCreateOrConnectWithoutEmailsInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutEmailsInput, ContactUncheckedCreateWithoutEmailsInput>
  }

  export type TenetCreateWithoutContactEmailsInput = {
    id: Uint8Array
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenetInput
    logs?: LogCreateNestedManyWithoutTenetInput
    contacts?: ContactCreateNestedManyWithoutTenetInput
    activities?: ActivityCreateNestedManyWithoutTenetInput
    addresses?: AddressCreateNestedManyWithoutTenetInput
    contactPhones?: ContactPhoneCreateNestedManyWithoutTenetInput
    importantDates?: ImportantDateCreateNestedManyWithoutTenetInput
    attachments?: AttachmentCreateNestedManyWithoutTenetInput
    notes?: NoteCreateNestedManyWithoutTenetInput
    auditEvents?: AuditEventCreateNestedManyWithoutTenetInput
    contactTimelineEvents?: ContactTimelineEventCreateNestedManyWithoutTenetInput
    activitySteps?: ActivityStepCreateNestedManyWithoutTenetInput
    activityWaypoints?: ActivityWaypointCreateNestedManyWithoutTenetInput
    templateAssignments?: TemplateAssignmentCreateNestedManyWithoutTenetInput
    activityWaypointTemplates?: ActivityWaypointTemplateCreateNestedManyWithoutTenetInput
    activityTemplates?: ActivityTemplateCreateNestedManyWithoutTenetInput
    activityTemplateSteps?: ActivityTemplateStepCreateNestedManyWithoutTenetInput
    opportunities?: OpportunityCreateNestedManyWithoutTenetInput
    products?: ProductTypeCreateNestedManyWithoutTenetInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentCreateNestedManyWithoutTenetInput
  }

  export type TenetUncheckedCreateWithoutContactEmailsInput = {
    id: Uint8Array
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenetInput
    logs?: LogUncheckedCreateNestedManyWithoutTenetInput
    contacts?: ContactUncheckedCreateNestedManyWithoutTenetInput
    activities?: ActivityUncheckedCreateNestedManyWithoutTenetInput
    addresses?: AddressUncheckedCreateNestedManyWithoutTenetInput
    contactPhones?: ContactPhoneUncheckedCreateNestedManyWithoutTenetInput
    importantDates?: ImportantDateUncheckedCreateNestedManyWithoutTenetInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTenetInput
    notes?: NoteUncheckedCreateNestedManyWithoutTenetInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutTenetInput
    contactTimelineEvents?: ContactTimelineEventUncheckedCreateNestedManyWithoutTenetInput
    activitySteps?: ActivityStepUncheckedCreateNestedManyWithoutTenetInput
    activityWaypoints?: ActivityWaypointUncheckedCreateNestedManyWithoutTenetInput
    templateAssignments?: TemplateAssignmentUncheckedCreateNestedManyWithoutTenetInput
    activityWaypointTemplates?: ActivityWaypointTemplateUncheckedCreateNestedManyWithoutTenetInput
    activityTemplates?: ActivityTemplateUncheckedCreateNestedManyWithoutTenetInput
    activityTemplateSteps?: ActivityTemplateStepUncheckedCreateNestedManyWithoutTenetInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutTenetInput
    products?: ProductTypeUncheckedCreateNestedManyWithoutTenetInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentUncheckedCreateNestedManyWithoutTenetInput
  }

  export type TenetCreateOrConnectWithoutContactEmailsInput = {
    where: TenetWhereUniqueInput
    create: XOR<TenetCreateWithoutContactEmailsInput, TenetUncheckedCreateWithoutContactEmailsInput>
  }

  export type ContactUpsertWithoutEmailsInput = {
    update: XOR<ContactUpdateWithoutEmailsInput, ContactUncheckedUpdateWithoutEmailsInput>
    create: XOR<ContactCreateWithoutEmailsInput, ContactUncheckedCreateWithoutEmailsInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutEmailsInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutEmailsInput, ContactUncheckedUpdateWithoutEmailsInput>
  }

  export type ContactUpdateWithoutEmailsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    importantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    lifecycleStage?: NullableEnumLifecycleStageFieldUpdateOperationsInput | $Enums.LifecycleStage | null
    lastContactedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    householdStatus?: NullableEnumHouseholdRelationshipStatusFieldUpdateOperationsInput | $Enums.HouseholdRelationshipStatus | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyStatus?: NullableEnumCompanyRelationshipStatusFieldUpdateOperationsInput | $Enums.CompanyRelationshipStatus | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenet?: TenetUpdateOneRequiredWithoutContactsNestedInput
    notes?: NoteUpdateManyWithoutContactNestedInput
    timelineEvents?: ContactTimelineEventContactJoinUpdateManyWithoutContactRelationNestedInput
    addresses?: AddressUpdateManyWithoutContactNestedInput
    phones?: ContactPhoneUpdateManyWithoutContactNestedInput
    importantDates?: ImportantDateUpdateManyWithoutContactNestedInput
    activities?: ActivityContactJoinUpdateManyWithoutContactRelationNestedInput
    household?: ContactUpdateOneWithoutHouseholdMembersNestedInput
    headOfHouseholdFor?: ContactUpdateOneWithoutHeadOfHouseholdNestedInput
    company?: ContactUpdateOneWithoutEmployeesNestedInput
    primaryContactFor?: ContactUpdateOneWithoutPrimaryContactNestedInput
    headOfHousehold?: ContactUpdateOneWithoutHeadOfHouseholdForNestedInput
    householdMembers?: ContactUpdateManyWithoutHouseholdNestedInput
    employees?: ContactUpdateManyWithoutCompanyNestedInput
    primaryContact?: ContactUpdateOneWithoutPrimaryContactForNestedInput
    opportunities?: ContactOpportunityJoinUpdateManyWithoutContactRelationNestedInput
    relationAsSource?: ContactRelationshipUpdateManyWithoutSourceNestedInput
    relationAsTarget?: ContactRelationshipUpdateManyWithoutTargetNestedInput
  }

  export type ContactUncheckedUpdateWithoutEmailsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    importantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    lifecycleStage?: NullableEnumLifecycleStageFieldUpdateOperationsInput | $Enums.LifecycleStage | null
    lastContactedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    householdId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    householdStatus?: NullableEnumHouseholdRelationshipStatusFieldUpdateOperationsInput | $Enums.HouseholdRelationshipStatus | null
    companyId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyStatus?: NullableEnumCompanyRelationshipStatusFieldUpdateOperationsInput | $Enums.CompanyRelationshipStatus | null
    headOfHouseholdId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    primaryContactId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NoteUncheckedUpdateManyWithoutContactNestedInput
    timelineEvents?: ContactTimelineEventContactJoinUncheckedUpdateManyWithoutContactRelationNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutContactNestedInput
    phones?: ContactPhoneUncheckedUpdateManyWithoutContactNestedInput
    importantDates?: ImportantDateUncheckedUpdateManyWithoutContactNestedInput
    activities?: ActivityContactJoinUncheckedUpdateManyWithoutContactRelationNestedInput
    headOfHouseholdFor?: ContactUncheckedUpdateOneWithoutHeadOfHouseholdNestedInput
    primaryContactFor?: ContactUncheckedUpdateOneWithoutPrimaryContactNestedInput
    householdMembers?: ContactUncheckedUpdateManyWithoutHouseholdNestedInput
    employees?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    opportunities?: ContactOpportunityJoinUncheckedUpdateManyWithoutContactRelationNestedInput
    relationAsSource?: ContactRelationshipUncheckedUpdateManyWithoutSourceNestedInput
    relationAsTarget?: ContactRelationshipUncheckedUpdateManyWithoutTargetNestedInput
  }

  export type TenetUpsertWithoutContactEmailsInput = {
    update: XOR<TenetUpdateWithoutContactEmailsInput, TenetUncheckedUpdateWithoutContactEmailsInput>
    create: XOR<TenetCreateWithoutContactEmailsInput, TenetUncheckedCreateWithoutContactEmailsInput>
    where?: TenetWhereInput
  }

  export type TenetUpdateToOneWithWhereWithoutContactEmailsInput = {
    where?: TenetWhereInput
    data: XOR<TenetUpdateWithoutContactEmailsInput, TenetUncheckedUpdateWithoutContactEmailsInput>
  }

  export type TenetUpdateWithoutContactEmailsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenetNestedInput
    logs?: LogUpdateManyWithoutTenetNestedInput
    contacts?: ContactUpdateManyWithoutTenetNestedInput
    activities?: ActivityUpdateManyWithoutTenetNestedInput
    addresses?: AddressUpdateManyWithoutTenetNestedInput
    contactPhones?: ContactPhoneUpdateManyWithoutTenetNestedInput
    importantDates?: ImportantDateUpdateManyWithoutTenetNestedInput
    attachments?: AttachmentUpdateManyWithoutTenetNestedInput
    notes?: NoteUpdateManyWithoutTenetNestedInput
    auditEvents?: AuditEventUpdateManyWithoutTenetNestedInput
    contactTimelineEvents?: ContactTimelineEventUpdateManyWithoutTenetNestedInput
    activitySteps?: ActivityStepUpdateManyWithoutTenetNestedInput
    activityWaypoints?: ActivityWaypointUpdateManyWithoutTenetNestedInput
    templateAssignments?: TemplateAssignmentUpdateManyWithoutTenetNestedInput
    activityWaypointTemplates?: ActivityWaypointTemplateUpdateManyWithoutTenetNestedInput
    activityTemplates?: ActivityTemplateUpdateManyWithoutTenetNestedInput
    activityTemplateSteps?: ActivityTemplateStepUpdateManyWithoutTenetNestedInput
    opportunities?: OpportunityUpdateManyWithoutTenetNestedInput
    products?: ProductTypeUpdateManyWithoutTenetNestedInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentUpdateManyWithoutTenetNestedInput
  }

  export type TenetUncheckedUpdateWithoutContactEmailsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenetNestedInput
    logs?: LogUncheckedUpdateManyWithoutTenetNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutTenetNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutTenetNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutTenetNestedInput
    contactPhones?: ContactPhoneUncheckedUpdateManyWithoutTenetNestedInput
    importantDates?: ImportantDateUncheckedUpdateManyWithoutTenetNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTenetNestedInput
    notes?: NoteUncheckedUpdateManyWithoutTenetNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutTenetNestedInput
    contactTimelineEvents?: ContactTimelineEventUncheckedUpdateManyWithoutTenetNestedInput
    activitySteps?: ActivityStepUncheckedUpdateManyWithoutTenetNestedInput
    activityWaypoints?: ActivityWaypointUncheckedUpdateManyWithoutTenetNestedInput
    templateAssignments?: TemplateAssignmentUncheckedUpdateManyWithoutTenetNestedInput
    activityWaypointTemplates?: ActivityWaypointTemplateUncheckedUpdateManyWithoutTenetNestedInput
    activityTemplates?: ActivityTemplateUncheckedUpdateManyWithoutTenetNestedInput
    activityTemplateSteps?: ActivityTemplateStepUncheckedUpdateManyWithoutTenetNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutTenetNestedInput
    products?: ProductTypeUncheckedUpdateManyWithoutTenetNestedInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentUncheckedUpdateManyWithoutTenetNestedInput
  }

  export type ContactCreateWithoutPhonesInput = {
    id: Uint8Array
    firstName?: string | null
    lastName: string
    fullName: string
    importantNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.ContactType
    status: $Enums.ContactStatus
    lifecycleStage?: $Enums.LifecycleStage | null
    lastContactedDate?: Date | string | null
    followUpDate?: Date | string | null
    householdStatus?: $Enums.HouseholdRelationshipStatus | null
    position?: string | null
    companyStatus?: $Enums.CompanyRelationshipStatus | null
    industry?: string | null
    website?: string | null
    size?: number | null
    deleted?: boolean
    deletedAt?: Date | string | null
    tenet: TenetCreateNestedOneWithoutContactsInput
    notes?: NoteCreateNestedManyWithoutContactInput
    timelineEvents?: ContactTimelineEventContactJoinCreateNestedManyWithoutContactRelationInput
    addresses?: AddressCreateNestedManyWithoutContactInput
    emails?: ContactEmailCreateNestedManyWithoutContactInput
    importantDates?: ImportantDateCreateNestedManyWithoutContactInput
    activities?: ActivityContactJoinCreateNestedManyWithoutContactRelationInput
    household?: ContactCreateNestedOneWithoutHouseholdMembersInput
    headOfHouseholdFor?: ContactCreateNestedOneWithoutHeadOfHouseholdInput
    company?: ContactCreateNestedOneWithoutEmployeesInput
    primaryContactFor?: ContactCreateNestedOneWithoutPrimaryContactInput
    headOfHousehold?: ContactCreateNestedOneWithoutHeadOfHouseholdForInput
    householdMembers?: ContactCreateNestedManyWithoutHouseholdInput
    employees?: ContactCreateNestedManyWithoutCompanyInput
    primaryContact?: ContactCreateNestedOneWithoutPrimaryContactForInput
    opportunities?: ContactOpportunityJoinCreateNestedManyWithoutContactRelationInput
    relationAsSource?: ContactRelationshipCreateNestedManyWithoutSourceInput
    relationAsTarget?: ContactRelationshipCreateNestedManyWithoutTargetInput
  }

  export type ContactUncheckedCreateWithoutPhonesInput = {
    id: Uint8Array
    firstName?: string | null
    lastName: string
    fullName: string
    tenetId: Uint8Array
    importantNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.ContactType
    status: $Enums.ContactStatus
    lifecycleStage?: $Enums.LifecycleStage | null
    lastContactedDate?: Date | string | null
    followUpDate?: Date | string | null
    householdId?: Uint8Array | null
    householdStatus?: $Enums.HouseholdRelationshipStatus | null
    companyId?: Uint8Array | null
    position?: string | null
    companyStatus?: $Enums.CompanyRelationshipStatus | null
    headOfHouseholdId?: Uint8Array | null
    industry?: string | null
    website?: string | null
    size?: number | null
    primaryContactId?: Uint8Array | null
    deleted?: boolean
    deletedAt?: Date | string | null
    notes?: NoteUncheckedCreateNestedManyWithoutContactInput
    timelineEvents?: ContactTimelineEventContactJoinUncheckedCreateNestedManyWithoutContactRelationInput
    addresses?: AddressUncheckedCreateNestedManyWithoutContactInput
    emails?: ContactEmailUncheckedCreateNestedManyWithoutContactInput
    importantDates?: ImportantDateUncheckedCreateNestedManyWithoutContactInput
    activities?: ActivityContactJoinUncheckedCreateNestedManyWithoutContactRelationInput
    headOfHouseholdFor?: ContactUncheckedCreateNestedOneWithoutHeadOfHouseholdInput
    primaryContactFor?: ContactUncheckedCreateNestedOneWithoutPrimaryContactInput
    householdMembers?: ContactUncheckedCreateNestedManyWithoutHouseholdInput
    employees?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    opportunities?: ContactOpportunityJoinUncheckedCreateNestedManyWithoutContactRelationInput
    relationAsSource?: ContactRelationshipUncheckedCreateNestedManyWithoutSourceInput
    relationAsTarget?: ContactRelationshipUncheckedCreateNestedManyWithoutTargetInput
  }

  export type ContactCreateOrConnectWithoutPhonesInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutPhonesInput, ContactUncheckedCreateWithoutPhonesInput>
  }

  export type TenetCreateWithoutContactPhonesInput = {
    id: Uint8Array
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenetInput
    logs?: LogCreateNestedManyWithoutTenetInput
    contacts?: ContactCreateNestedManyWithoutTenetInput
    activities?: ActivityCreateNestedManyWithoutTenetInput
    addresses?: AddressCreateNestedManyWithoutTenetInput
    contactEmails?: ContactEmailCreateNestedManyWithoutTenetInput
    importantDates?: ImportantDateCreateNestedManyWithoutTenetInput
    attachments?: AttachmentCreateNestedManyWithoutTenetInput
    notes?: NoteCreateNestedManyWithoutTenetInput
    auditEvents?: AuditEventCreateNestedManyWithoutTenetInput
    contactTimelineEvents?: ContactTimelineEventCreateNestedManyWithoutTenetInput
    activitySteps?: ActivityStepCreateNestedManyWithoutTenetInput
    activityWaypoints?: ActivityWaypointCreateNestedManyWithoutTenetInput
    templateAssignments?: TemplateAssignmentCreateNestedManyWithoutTenetInput
    activityWaypointTemplates?: ActivityWaypointTemplateCreateNestedManyWithoutTenetInput
    activityTemplates?: ActivityTemplateCreateNestedManyWithoutTenetInput
    activityTemplateSteps?: ActivityTemplateStepCreateNestedManyWithoutTenetInput
    opportunities?: OpportunityCreateNestedManyWithoutTenetInput
    products?: ProductTypeCreateNestedManyWithoutTenetInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentCreateNestedManyWithoutTenetInput
  }

  export type TenetUncheckedCreateWithoutContactPhonesInput = {
    id: Uint8Array
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenetInput
    logs?: LogUncheckedCreateNestedManyWithoutTenetInput
    contacts?: ContactUncheckedCreateNestedManyWithoutTenetInput
    activities?: ActivityUncheckedCreateNestedManyWithoutTenetInput
    addresses?: AddressUncheckedCreateNestedManyWithoutTenetInput
    contactEmails?: ContactEmailUncheckedCreateNestedManyWithoutTenetInput
    importantDates?: ImportantDateUncheckedCreateNestedManyWithoutTenetInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTenetInput
    notes?: NoteUncheckedCreateNestedManyWithoutTenetInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutTenetInput
    contactTimelineEvents?: ContactTimelineEventUncheckedCreateNestedManyWithoutTenetInput
    activitySteps?: ActivityStepUncheckedCreateNestedManyWithoutTenetInput
    activityWaypoints?: ActivityWaypointUncheckedCreateNestedManyWithoutTenetInput
    templateAssignments?: TemplateAssignmentUncheckedCreateNestedManyWithoutTenetInput
    activityWaypointTemplates?: ActivityWaypointTemplateUncheckedCreateNestedManyWithoutTenetInput
    activityTemplates?: ActivityTemplateUncheckedCreateNestedManyWithoutTenetInput
    activityTemplateSteps?: ActivityTemplateStepUncheckedCreateNestedManyWithoutTenetInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutTenetInput
    products?: ProductTypeUncheckedCreateNestedManyWithoutTenetInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentUncheckedCreateNestedManyWithoutTenetInput
  }

  export type TenetCreateOrConnectWithoutContactPhonesInput = {
    where: TenetWhereUniqueInput
    create: XOR<TenetCreateWithoutContactPhonesInput, TenetUncheckedCreateWithoutContactPhonesInput>
  }

  export type ContactUpsertWithoutPhonesInput = {
    update: XOR<ContactUpdateWithoutPhonesInput, ContactUncheckedUpdateWithoutPhonesInput>
    create: XOR<ContactCreateWithoutPhonesInput, ContactUncheckedCreateWithoutPhonesInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutPhonesInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutPhonesInput, ContactUncheckedUpdateWithoutPhonesInput>
  }

  export type ContactUpdateWithoutPhonesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    importantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    lifecycleStage?: NullableEnumLifecycleStageFieldUpdateOperationsInput | $Enums.LifecycleStage | null
    lastContactedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    householdStatus?: NullableEnumHouseholdRelationshipStatusFieldUpdateOperationsInput | $Enums.HouseholdRelationshipStatus | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyStatus?: NullableEnumCompanyRelationshipStatusFieldUpdateOperationsInput | $Enums.CompanyRelationshipStatus | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenet?: TenetUpdateOneRequiredWithoutContactsNestedInput
    notes?: NoteUpdateManyWithoutContactNestedInput
    timelineEvents?: ContactTimelineEventContactJoinUpdateManyWithoutContactRelationNestedInput
    addresses?: AddressUpdateManyWithoutContactNestedInput
    emails?: ContactEmailUpdateManyWithoutContactNestedInput
    importantDates?: ImportantDateUpdateManyWithoutContactNestedInput
    activities?: ActivityContactJoinUpdateManyWithoutContactRelationNestedInput
    household?: ContactUpdateOneWithoutHouseholdMembersNestedInput
    headOfHouseholdFor?: ContactUpdateOneWithoutHeadOfHouseholdNestedInput
    company?: ContactUpdateOneWithoutEmployeesNestedInput
    primaryContactFor?: ContactUpdateOneWithoutPrimaryContactNestedInput
    headOfHousehold?: ContactUpdateOneWithoutHeadOfHouseholdForNestedInput
    householdMembers?: ContactUpdateManyWithoutHouseholdNestedInput
    employees?: ContactUpdateManyWithoutCompanyNestedInput
    primaryContact?: ContactUpdateOneWithoutPrimaryContactForNestedInput
    opportunities?: ContactOpportunityJoinUpdateManyWithoutContactRelationNestedInput
    relationAsSource?: ContactRelationshipUpdateManyWithoutSourceNestedInput
    relationAsTarget?: ContactRelationshipUpdateManyWithoutTargetNestedInput
  }

  export type ContactUncheckedUpdateWithoutPhonesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    importantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    lifecycleStage?: NullableEnumLifecycleStageFieldUpdateOperationsInput | $Enums.LifecycleStage | null
    lastContactedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    householdId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    householdStatus?: NullableEnumHouseholdRelationshipStatusFieldUpdateOperationsInput | $Enums.HouseholdRelationshipStatus | null
    companyId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyStatus?: NullableEnumCompanyRelationshipStatusFieldUpdateOperationsInput | $Enums.CompanyRelationshipStatus | null
    headOfHouseholdId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    primaryContactId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NoteUncheckedUpdateManyWithoutContactNestedInput
    timelineEvents?: ContactTimelineEventContactJoinUncheckedUpdateManyWithoutContactRelationNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutContactNestedInput
    emails?: ContactEmailUncheckedUpdateManyWithoutContactNestedInput
    importantDates?: ImportantDateUncheckedUpdateManyWithoutContactNestedInput
    activities?: ActivityContactJoinUncheckedUpdateManyWithoutContactRelationNestedInput
    headOfHouseholdFor?: ContactUncheckedUpdateOneWithoutHeadOfHouseholdNestedInput
    primaryContactFor?: ContactUncheckedUpdateOneWithoutPrimaryContactNestedInput
    householdMembers?: ContactUncheckedUpdateManyWithoutHouseholdNestedInput
    employees?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    opportunities?: ContactOpportunityJoinUncheckedUpdateManyWithoutContactRelationNestedInput
    relationAsSource?: ContactRelationshipUncheckedUpdateManyWithoutSourceNestedInput
    relationAsTarget?: ContactRelationshipUncheckedUpdateManyWithoutTargetNestedInput
  }

  export type TenetUpsertWithoutContactPhonesInput = {
    update: XOR<TenetUpdateWithoutContactPhonesInput, TenetUncheckedUpdateWithoutContactPhonesInput>
    create: XOR<TenetCreateWithoutContactPhonesInput, TenetUncheckedCreateWithoutContactPhonesInput>
    where?: TenetWhereInput
  }

  export type TenetUpdateToOneWithWhereWithoutContactPhonesInput = {
    where?: TenetWhereInput
    data: XOR<TenetUpdateWithoutContactPhonesInput, TenetUncheckedUpdateWithoutContactPhonesInput>
  }

  export type TenetUpdateWithoutContactPhonesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenetNestedInput
    logs?: LogUpdateManyWithoutTenetNestedInput
    contacts?: ContactUpdateManyWithoutTenetNestedInput
    activities?: ActivityUpdateManyWithoutTenetNestedInput
    addresses?: AddressUpdateManyWithoutTenetNestedInput
    contactEmails?: ContactEmailUpdateManyWithoutTenetNestedInput
    importantDates?: ImportantDateUpdateManyWithoutTenetNestedInput
    attachments?: AttachmentUpdateManyWithoutTenetNestedInput
    notes?: NoteUpdateManyWithoutTenetNestedInput
    auditEvents?: AuditEventUpdateManyWithoutTenetNestedInput
    contactTimelineEvents?: ContactTimelineEventUpdateManyWithoutTenetNestedInput
    activitySteps?: ActivityStepUpdateManyWithoutTenetNestedInput
    activityWaypoints?: ActivityWaypointUpdateManyWithoutTenetNestedInput
    templateAssignments?: TemplateAssignmentUpdateManyWithoutTenetNestedInput
    activityWaypointTemplates?: ActivityWaypointTemplateUpdateManyWithoutTenetNestedInput
    activityTemplates?: ActivityTemplateUpdateManyWithoutTenetNestedInput
    activityTemplateSteps?: ActivityTemplateStepUpdateManyWithoutTenetNestedInput
    opportunities?: OpportunityUpdateManyWithoutTenetNestedInput
    products?: ProductTypeUpdateManyWithoutTenetNestedInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentUpdateManyWithoutTenetNestedInput
  }

  export type TenetUncheckedUpdateWithoutContactPhonesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenetNestedInput
    logs?: LogUncheckedUpdateManyWithoutTenetNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutTenetNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutTenetNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutTenetNestedInput
    contactEmails?: ContactEmailUncheckedUpdateManyWithoutTenetNestedInput
    importantDates?: ImportantDateUncheckedUpdateManyWithoutTenetNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTenetNestedInput
    notes?: NoteUncheckedUpdateManyWithoutTenetNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutTenetNestedInput
    contactTimelineEvents?: ContactTimelineEventUncheckedUpdateManyWithoutTenetNestedInput
    activitySteps?: ActivityStepUncheckedUpdateManyWithoutTenetNestedInput
    activityWaypoints?: ActivityWaypointUncheckedUpdateManyWithoutTenetNestedInput
    templateAssignments?: TemplateAssignmentUncheckedUpdateManyWithoutTenetNestedInput
    activityWaypointTemplates?: ActivityWaypointTemplateUncheckedUpdateManyWithoutTenetNestedInput
    activityTemplates?: ActivityTemplateUncheckedUpdateManyWithoutTenetNestedInput
    activityTemplateSteps?: ActivityTemplateStepUncheckedUpdateManyWithoutTenetNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutTenetNestedInput
    products?: ProductTypeUncheckedUpdateManyWithoutTenetNestedInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentUncheckedUpdateManyWithoutTenetNestedInput
  }

  export type ContactCreateWithoutAddressesInput = {
    id: Uint8Array
    firstName?: string | null
    lastName: string
    fullName: string
    importantNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.ContactType
    status: $Enums.ContactStatus
    lifecycleStage?: $Enums.LifecycleStage | null
    lastContactedDate?: Date | string | null
    followUpDate?: Date | string | null
    householdStatus?: $Enums.HouseholdRelationshipStatus | null
    position?: string | null
    companyStatus?: $Enums.CompanyRelationshipStatus | null
    industry?: string | null
    website?: string | null
    size?: number | null
    deleted?: boolean
    deletedAt?: Date | string | null
    tenet: TenetCreateNestedOneWithoutContactsInput
    notes?: NoteCreateNestedManyWithoutContactInput
    timelineEvents?: ContactTimelineEventContactJoinCreateNestedManyWithoutContactRelationInput
    emails?: ContactEmailCreateNestedManyWithoutContactInput
    phones?: ContactPhoneCreateNestedManyWithoutContactInput
    importantDates?: ImportantDateCreateNestedManyWithoutContactInput
    activities?: ActivityContactJoinCreateNestedManyWithoutContactRelationInput
    household?: ContactCreateNestedOneWithoutHouseholdMembersInput
    headOfHouseholdFor?: ContactCreateNestedOneWithoutHeadOfHouseholdInput
    company?: ContactCreateNestedOneWithoutEmployeesInput
    primaryContactFor?: ContactCreateNestedOneWithoutPrimaryContactInput
    headOfHousehold?: ContactCreateNestedOneWithoutHeadOfHouseholdForInput
    householdMembers?: ContactCreateNestedManyWithoutHouseholdInput
    employees?: ContactCreateNestedManyWithoutCompanyInput
    primaryContact?: ContactCreateNestedOneWithoutPrimaryContactForInput
    opportunities?: ContactOpportunityJoinCreateNestedManyWithoutContactRelationInput
    relationAsSource?: ContactRelationshipCreateNestedManyWithoutSourceInput
    relationAsTarget?: ContactRelationshipCreateNestedManyWithoutTargetInput
  }

  export type ContactUncheckedCreateWithoutAddressesInput = {
    id: Uint8Array
    firstName?: string | null
    lastName: string
    fullName: string
    tenetId: Uint8Array
    importantNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.ContactType
    status: $Enums.ContactStatus
    lifecycleStage?: $Enums.LifecycleStage | null
    lastContactedDate?: Date | string | null
    followUpDate?: Date | string | null
    householdId?: Uint8Array | null
    householdStatus?: $Enums.HouseholdRelationshipStatus | null
    companyId?: Uint8Array | null
    position?: string | null
    companyStatus?: $Enums.CompanyRelationshipStatus | null
    headOfHouseholdId?: Uint8Array | null
    industry?: string | null
    website?: string | null
    size?: number | null
    primaryContactId?: Uint8Array | null
    deleted?: boolean
    deletedAt?: Date | string | null
    notes?: NoteUncheckedCreateNestedManyWithoutContactInput
    timelineEvents?: ContactTimelineEventContactJoinUncheckedCreateNestedManyWithoutContactRelationInput
    emails?: ContactEmailUncheckedCreateNestedManyWithoutContactInput
    phones?: ContactPhoneUncheckedCreateNestedManyWithoutContactInput
    importantDates?: ImportantDateUncheckedCreateNestedManyWithoutContactInput
    activities?: ActivityContactJoinUncheckedCreateNestedManyWithoutContactRelationInput
    headOfHouseholdFor?: ContactUncheckedCreateNestedOneWithoutHeadOfHouseholdInput
    primaryContactFor?: ContactUncheckedCreateNestedOneWithoutPrimaryContactInput
    householdMembers?: ContactUncheckedCreateNestedManyWithoutHouseholdInput
    employees?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    opportunities?: ContactOpportunityJoinUncheckedCreateNestedManyWithoutContactRelationInput
    relationAsSource?: ContactRelationshipUncheckedCreateNestedManyWithoutSourceInput
    relationAsTarget?: ContactRelationshipUncheckedCreateNestedManyWithoutTargetInput
  }

  export type ContactCreateOrConnectWithoutAddressesInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutAddressesInput, ContactUncheckedCreateWithoutAddressesInput>
  }

  export type TenetCreateWithoutAddressesInput = {
    id: Uint8Array
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenetInput
    logs?: LogCreateNestedManyWithoutTenetInput
    contacts?: ContactCreateNestedManyWithoutTenetInput
    activities?: ActivityCreateNestedManyWithoutTenetInput
    contactEmails?: ContactEmailCreateNestedManyWithoutTenetInput
    contactPhones?: ContactPhoneCreateNestedManyWithoutTenetInput
    importantDates?: ImportantDateCreateNestedManyWithoutTenetInput
    attachments?: AttachmentCreateNestedManyWithoutTenetInput
    notes?: NoteCreateNestedManyWithoutTenetInput
    auditEvents?: AuditEventCreateNestedManyWithoutTenetInput
    contactTimelineEvents?: ContactTimelineEventCreateNestedManyWithoutTenetInput
    activitySteps?: ActivityStepCreateNestedManyWithoutTenetInput
    activityWaypoints?: ActivityWaypointCreateNestedManyWithoutTenetInput
    templateAssignments?: TemplateAssignmentCreateNestedManyWithoutTenetInput
    activityWaypointTemplates?: ActivityWaypointTemplateCreateNestedManyWithoutTenetInput
    activityTemplates?: ActivityTemplateCreateNestedManyWithoutTenetInput
    activityTemplateSteps?: ActivityTemplateStepCreateNestedManyWithoutTenetInput
    opportunities?: OpportunityCreateNestedManyWithoutTenetInput
    products?: ProductTypeCreateNestedManyWithoutTenetInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentCreateNestedManyWithoutTenetInput
  }

  export type TenetUncheckedCreateWithoutAddressesInput = {
    id: Uint8Array
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenetInput
    logs?: LogUncheckedCreateNestedManyWithoutTenetInput
    contacts?: ContactUncheckedCreateNestedManyWithoutTenetInput
    activities?: ActivityUncheckedCreateNestedManyWithoutTenetInput
    contactEmails?: ContactEmailUncheckedCreateNestedManyWithoutTenetInput
    contactPhones?: ContactPhoneUncheckedCreateNestedManyWithoutTenetInput
    importantDates?: ImportantDateUncheckedCreateNestedManyWithoutTenetInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTenetInput
    notes?: NoteUncheckedCreateNestedManyWithoutTenetInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutTenetInput
    contactTimelineEvents?: ContactTimelineEventUncheckedCreateNestedManyWithoutTenetInput
    activitySteps?: ActivityStepUncheckedCreateNestedManyWithoutTenetInput
    activityWaypoints?: ActivityWaypointUncheckedCreateNestedManyWithoutTenetInput
    templateAssignments?: TemplateAssignmentUncheckedCreateNestedManyWithoutTenetInput
    activityWaypointTemplates?: ActivityWaypointTemplateUncheckedCreateNestedManyWithoutTenetInput
    activityTemplates?: ActivityTemplateUncheckedCreateNestedManyWithoutTenetInput
    activityTemplateSteps?: ActivityTemplateStepUncheckedCreateNestedManyWithoutTenetInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutTenetInput
    products?: ProductTypeUncheckedCreateNestedManyWithoutTenetInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentUncheckedCreateNestedManyWithoutTenetInput
  }

  export type TenetCreateOrConnectWithoutAddressesInput = {
    where: TenetWhereUniqueInput
    create: XOR<TenetCreateWithoutAddressesInput, TenetUncheckedCreateWithoutAddressesInput>
  }

  export type ContactUpsertWithoutAddressesInput = {
    update: XOR<ContactUpdateWithoutAddressesInput, ContactUncheckedUpdateWithoutAddressesInput>
    create: XOR<ContactCreateWithoutAddressesInput, ContactUncheckedCreateWithoutAddressesInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutAddressesInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutAddressesInput, ContactUncheckedUpdateWithoutAddressesInput>
  }

  export type ContactUpdateWithoutAddressesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    importantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    lifecycleStage?: NullableEnumLifecycleStageFieldUpdateOperationsInput | $Enums.LifecycleStage | null
    lastContactedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    householdStatus?: NullableEnumHouseholdRelationshipStatusFieldUpdateOperationsInput | $Enums.HouseholdRelationshipStatus | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyStatus?: NullableEnumCompanyRelationshipStatusFieldUpdateOperationsInput | $Enums.CompanyRelationshipStatus | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenet?: TenetUpdateOneRequiredWithoutContactsNestedInput
    notes?: NoteUpdateManyWithoutContactNestedInput
    timelineEvents?: ContactTimelineEventContactJoinUpdateManyWithoutContactRelationNestedInput
    emails?: ContactEmailUpdateManyWithoutContactNestedInput
    phones?: ContactPhoneUpdateManyWithoutContactNestedInput
    importantDates?: ImportantDateUpdateManyWithoutContactNestedInput
    activities?: ActivityContactJoinUpdateManyWithoutContactRelationNestedInput
    household?: ContactUpdateOneWithoutHouseholdMembersNestedInput
    headOfHouseholdFor?: ContactUpdateOneWithoutHeadOfHouseholdNestedInput
    company?: ContactUpdateOneWithoutEmployeesNestedInput
    primaryContactFor?: ContactUpdateOneWithoutPrimaryContactNestedInput
    headOfHousehold?: ContactUpdateOneWithoutHeadOfHouseholdForNestedInput
    householdMembers?: ContactUpdateManyWithoutHouseholdNestedInput
    employees?: ContactUpdateManyWithoutCompanyNestedInput
    primaryContact?: ContactUpdateOneWithoutPrimaryContactForNestedInput
    opportunities?: ContactOpportunityJoinUpdateManyWithoutContactRelationNestedInput
    relationAsSource?: ContactRelationshipUpdateManyWithoutSourceNestedInput
    relationAsTarget?: ContactRelationshipUpdateManyWithoutTargetNestedInput
  }

  export type ContactUncheckedUpdateWithoutAddressesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    importantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    lifecycleStage?: NullableEnumLifecycleStageFieldUpdateOperationsInput | $Enums.LifecycleStage | null
    lastContactedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    householdId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    householdStatus?: NullableEnumHouseholdRelationshipStatusFieldUpdateOperationsInput | $Enums.HouseholdRelationshipStatus | null
    companyId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyStatus?: NullableEnumCompanyRelationshipStatusFieldUpdateOperationsInput | $Enums.CompanyRelationshipStatus | null
    headOfHouseholdId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    primaryContactId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NoteUncheckedUpdateManyWithoutContactNestedInput
    timelineEvents?: ContactTimelineEventContactJoinUncheckedUpdateManyWithoutContactRelationNestedInput
    emails?: ContactEmailUncheckedUpdateManyWithoutContactNestedInput
    phones?: ContactPhoneUncheckedUpdateManyWithoutContactNestedInput
    importantDates?: ImportantDateUncheckedUpdateManyWithoutContactNestedInput
    activities?: ActivityContactJoinUncheckedUpdateManyWithoutContactRelationNestedInput
    headOfHouseholdFor?: ContactUncheckedUpdateOneWithoutHeadOfHouseholdNestedInput
    primaryContactFor?: ContactUncheckedUpdateOneWithoutPrimaryContactNestedInput
    householdMembers?: ContactUncheckedUpdateManyWithoutHouseholdNestedInput
    employees?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    opportunities?: ContactOpportunityJoinUncheckedUpdateManyWithoutContactRelationNestedInput
    relationAsSource?: ContactRelationshipUncheckedUpdateManyWithoutSourceNestedInput
    relationAsTarget?: ContactRelationshipUncheckedUpdateManyWithoutTargetNestedInput
  }

  export type TenetUpsertWithoutAddressesInput = {
    update: XOR<TenetUpdateWithoutAddressesInput, TenetUncheckedUpdateWithoutAddressesInput>
    create: XOR<TenetCreateWithoutAddressesInput, TenetUncheckedCreateWithoutAddressesInput>
    where?: TenetWhereInput
  }

  export type TenetUpdateToOneWithWhereWithoutAddressesInput = {
    where?: TenetWhereInput
    data: XOR<TenetUpdateWithoutAddressesInput, TenetUncheckedUpdateWithoutAddressesInput>
  }

  export type TenetUpdateWithoutAddressesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenetNestedInput
    logs?: LogUpdateManyWithoutTenetNestedInput
    contacts?: ContactUpdateManyWithoutTenetNestedInput
    activities?: ActivityUpdateManyWithoutTenetNestedInput
    contactEmails?: ContactEmailUpdateManyWithoutTenetNestedInput
    contactPhones?: ContactPhoneUpdateManyWithoutTenetNestedInput
    importantDates?: ImportantDateUpdateManyWithoutTenetNestedInput
    attachments?: AttachmentUpdateManyWithoutTenetNestedInput
    notes?: NoteUpdateManyWithoutTenetNestedInput
    auditEvents?: AuditEventUpdateManyWithoutTenetNestedInput
    contactTimelineEvents?: ContactTimelineEventUpdateManyWithoutTenetNestedInput
    activitySteps?: ActivityStepUpdateManyWithoutTenetNestedInput
    activityWaypoints?: ActivityWaypointUpdateManyWithoutTenetNestedInput
    templateAssignments?: TemplateAssignmentUpdateManyWithoutTenetNestedInput
    activityWaypointTemplates?: ActivityWaypointTemplateUpdateManyWithoutTenetNestedInput
    activityTemplates?: ActivityTemplateUpdateManyWithoutTenetNestedInput
    activityTemplateSteps?: ActivityTemplateStepUpdateManyWithoutTenetNestedInput
    opportunities?: OpportunityUpdateManyWithoutTenetNestedInput
    products?: ProductTypeUpdateManyWithoutTenetNestedInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentUpdateManyWithoutTenetNestedInput
  }

  export type TenetUncheckedUpdateWithoutAddressesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenetNestedInput
    logs?: LogUncheckedUpdateManyWithoutTenetNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutTenetNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutTenetNestedInput
    contactEmails?: ContactEmailUncheckedUpdateManyWithoutTenetNestedInput
    contactPhones?: ContactPhoneUncheckedUpdateManyWithoutTenetNestedInput
    importantDates?: ImportantDateUncheckedUpdateManyWithoutTenetNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTenetNestedInput
    notes?: NoteUncheckedUpdateManyWithoutTenetNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutTenetNestedInput
    contactTimelineEvents?: ContactTimelineEventUncheckedUpdateManyWithoutTenetNestedInput
    activitySteps?: ActivityStepUncheckedUpdateManyWithoutTenetNestedInput
    activityWaypoints?: ActivityWaypointUncheckedUpdateManyWithoutTenetNestedInput
    templateAssignments?: TemplateAssignmentUncheckedUpdateManyWithoutTenetNestedInput
    activityWaypointTemplates?: ActivityWaypointTemplateUncheckedUpdateManyWithoutTenetNestedInput
    activityTemplates?: ActivityTemplateUncheckedUpdateManyWithoutTenetNestedInput
    activityTemplateSteps?: ActivityTemplateStepUncheckedUpdateManyWithoutTenetNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutTenetNestedInput
    products?: ProductTypeUncheckedUpdateManyWithoutTenetNestedInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentUncheckedUpdateManyWithoutTenetNestedInput
  }

  export type ContactCreateWithoutImportantDatesInput = {
    id: Uint8Array
    firstName?: string | null
    lastName: string
    fullName: string
    importantNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.ContactType
    status: $Enums.ContactStatus
    lifecycleStage?: $Enums.LifecycleStage | null
    lastContactedDate?: Date | string | null
    followUpDate?: Date | string | null
    householdStatus?: $Enums.HouseholdRelationshipStatus | null
    position?: string | null
    companyStatus?: $Enums.CompanyRelationshipStatus | null
    industry?: string | null
    website?: string | null
    size?: number | null
    deleted?: boolean
    deletedAt?: Date | string | null
    tenet: TenetCreateNestedOneWithoutContactsInput
    notes?: NoteCreateNestedManyWithoutContactInput
    timelineEvents?: ContactTimelineEventContactJoinCreateNestedManyWithoutContactRelationInput
    addresses?: AddressCreateNestedManyWithoutContactInput
    emails?: ContactEmailCreateNestedManyWithoutContactInput
    phones?: ContactPhoneCreateNestedManyWithoutContactInput
    activities?: ActivityContactJoinCreateNestedManyWithoutContactRelationInput
    household?: ContactCreateNestedOneWithoutHouseholdMembersInput
    headOfHouseholdFor?: ContactCreateNestedOneWithoutHeadOfHouseholdInput
    company?: ContactCreateNestedOneWithoutEmployeesInput
    primaryContactFor?: ContactCreateNestedOneWithoutPrimaryContactInput
    headOfHousehold?: ContactCreateNestedOneWithoutHeadOfHouseholdForInput
    householdMembers?: ContactCreateNestedManyWithoutHouseholdInput
    employees?: ContactCreateNestedManyWithoutCompanyInput
    primaryContact?: ContactCreateNestedOneWithoutPrimaryContactForInput
    opportunities?: ContactOpportunityJoinCreateNestedManyWithoutContactRelationInput
    relationAsSource?: ContactRelationshipCreateNestedManyWithoutSourceInput
    relationAsTarget?: ContactRelationshipCreateNestedManyWithoutTargetInput
  }

  export type ContactUncheckedCreateWithoutImportantDatesInput = {
    id: Uint8Array
    firstName?: string | null
    lastName: string
    fullName: string
    tenetId: Uint8Array
    importantNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.ContactType
    status: $Enums.ContactStatus
    lifecycleStage?: $Enums.LifecycleStage | null
    lastContactedDate?: Date | string | null
    followUpDate?: Date | string | null
    householdId?: Uint8Array | null
    householdStatus?: $Enums.HouseholdRelationshipStatus | null
    companyId?: Uint8Array | null
    position?: string | null
    companyStatus?: $Enums.CompanyRelationshipStatus | null
    headOfHouseholdId?: Uint8Array | null
    industry?: string | null
    website?: string | null
    size?: number | null
    primaryContactId?: Uint8Array | null
    deleted?: boolean
    deletedAt?: Date | string | null
    notes?: NoteUncheckedCreateNestedManyWithoutContactInput
    timelineEvents?: ContactTimelineEventContactJoinUncheckedCreateNestedManyWithoutContactRelationInput
    addresses?: AddressUncheckedCreateNestedManyWithoutContactInput
    emails?: ContactEmailUncheckedCreateNestedManyWithoutContactInput
    phones?: ContactPhoneUncheckedCreateNestedManyWithoutContactInput
    activities?: ActivityContactJoinUncheckedCreateNestedManyWithoutContactRelationInput
    headOfHouseholdFor?: ContactUncheckedCreateNestedOneWithoutHeadOfHouseholdInput
    primaryContactFor?: ContactUncheckedCreateNestedOneWithoutPrimaryContactInput
    householdMembers?: ContactUncheckedCreateNestedManyWithoutHouseholdInput
    employees?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    opportunities?: ContactOpportunityJoinUncheckedCreateNestedManyWithoutContactRelationInput
    relationAsSource?: ContactRelationshipUncheckedCreateNestedManyWithoutSourceInput
    relationAsTarget?: ContactRelationshipUncheckedCreateNestedManyWithoutTargetInput
  }

  export type ContactCreateOrConnectWithoutImportantDatesInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutImportantDatesInput, ContactUncheckedCreateWithoutImportantDatesInput>
  }

  export type TenetCreateWithoutImportantDatesInput = {
    id: Uint8Array
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenetInput
    logs?: LogCreateNestedManyWithoutTenetInput
    contacts?: ContactCreateNestedManyWithoutTenetInput
    activities?: ActivityCreateNestedManyWithoutTenetInput
    addresses?: AddressCreateNestedManyWithoutTenetInput
    contactEmails?: ContactEmailCreateNestedManyWithoutTenetInput
    contactPhones?: ContactPhoneCreateNestedManyWithoutTenetInput
    attachments?: AttachmentCreateNestedManyWithoutTenetInput
    notes?: NoteCreateNestedManyWithoutTenetInput
    auditEvents?: AuditEventCreateNestedManyWithoutTenetInput
    contactTimelineEvents?: ContactTimelineEventCreateNestedManyWithoutTenetInput
    activitySteps?: ActivityStepCreateNestedManyWithoutTenetInput
    activityWaypoints?: ActivityWaypointCreateNestedManyWithoutTenetInput
    templateAssignments?: TemplateAssignmentCreateNestedManyWithoutTenetInput
    activityWaypointTemplates?: ActivityWaypointTemplateCreateNestedManyWithoutTenetInput
    activityTemplates?: ActivityTemplateCreateNestedManyWithoutTenetInput
    activityTemplateSteps?: ActivityTemplateStepCreateNestedManyWithoutTenetInput
    opportunities?: OpportunityCreateNestedManyWithoutTenetInput
    products?: ProductTypeCreateNestedManyWithoutTenetInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentCreateNestedManyWithoutTenetInput
  }

  export type TenetUncheckedCreateWithoutImportantDatesInput = {
    id: Uint8Array
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenetInput
    logs?: LogUncheckedCreateNestedManyWithoutTenetInput
    contacts?: ContactUncheckedCreateNestedManyWithoutTenetInput
    activities?: ActivityUncheckedCreateNestedManyWithoutTenetInput
    addresses?: AddressUncheckedCreateNestedManyWithoutTenetInput
    contactEmails?: ContactEmailUncheckedCreateNestedManyWithoutTenetInput
    contactPhones?: ContactPhoneUncheckedCreateNestedManyWithoutTenetInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTenetInput
    notes?: NoteUncheckedCreateNestedManyWithoutTenetInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutTenetInput
    contactTimelineEvents?: ContactTimelineEventUncheckedCreateNestedManyWithoutTenetInput
    activitySteps?: ActivityStepUncheckedCreateNestedManyWithoutTenetInput
    activityWaypoints?: ActivityWaypointUncheckedCreateNestedManyWithoutTenetInput
    templateAssignments?: TemplateAssignmentUncheckedCreateNestedManyWithoutTenetInput
    activityWaypointTemplates?: ActivityWaypointTemplateUncheckedCreateNestedManyWithoutTenetInput
    activityTemplates?: ActivityTemplateUncheckedCreateNestedManyWithoutTenetInput
    activityTemplateSteps?: ActivityTemplateStepUncheckedCreateNestedManyWithoutTenetInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutTenetInput
    products?: ProductTypeUncheckedCreateNestedManyWithoutTenetInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentUncheckedCreateNestedManyWithoutTenetInput
  }

  export type TenetCreateOrConnectWithoutImportantDatesInput = {
    where: TenetWhereUniqueInput
    create: XOR<TenetCreateWithoutImportantDatesInput, TenetUncheckedCreateWithoutImportantDatesInput>
  }

  export type ContactUpsertWithoutImportantDatesInput = {
    update: XOR<ContactUpdateWithoutImportantDatesInput, ContactUncheckedUpdateWithoutImportantDatesInput>
    create: XOR<ContactCreateWithoutImportantDatesInput, ContactUncheckedCreateWithoutImportantDatesInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutImportantDatesInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutImportantDatesInput, ContactUncheckedUpdateWithoutImportantDatesInput>
  }

  export type ContactUpdateWithoutImportantDatesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    importantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    lifecycleStage?: NullableEnumLifecycleStageFieldUpdateOperationsInput | $Enums.LifecycleStage | null
    lastContactedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    householdStatus?: NullableEnumHouseholdRelationshipStatusFieldUpdateOperationsInput | $Enums.HouseholdRelationshipStatus | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyStatus?: NullableEnumCompanyRelationshipStatusFieldUpdateOperationsInput | $Enums.CompanyRelationshipStatus | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenet?: TenetUpdateOneRequiredWithoutContactsNestedInput
    notes?: NoteUpdateManyWithoutContactNestedInput
    timelineEvents?: ContactTimelineEventContactJoinUpdateManyWithoutContactRelationNestedInput
    addresses?: AddressUpdateManyWithoutContactNestedInput
    emails?: ContactEmailUpdateManyWithoutContactNestedInput
    phones?: ContactPhoneUpdateManyWithoutContactNestedInput
    activities?: ActivityContactJoinUpdateManyWithoutContactRelationNestedInput
    household?: ContactUpdateOneWithoutHouseholdMembersNestedInput
    headOfHouseholdFor?: ContactUpdateOneWithoutHeadOfHouseholdNestedInput
    company?: ContactUpdateOneWithoutEmployeesNestedInput
    primaryContactFor?: ContactUpdateOneWithoutPrimaryContactNestedInput
    headOfHousehold?: ContactUpdateOneWithoutHeadOfHouseholdForNestedInput
    householdMembers?: ContactUpdateManyWithoutHouseholdNestedInput
    employees?: ContactUpdateManyWithoutCompanyNestedInput
    primaryContact?: ContactUpdateOneWithoutPrimaryContactForNestedInput
    opportunities?: ContactOpportunityJoinUpdateManyWithoutContactRelationNestedInput
    relationAsSource?: ContactRelationshipUpdateManyWithoutSourceNestedInput
    relationAsTarget?: ContactRelationshipUpdateManyWithoutTargetNestedInput
  }

  export type ContactUncheckedUpdateWithoutImportantDatesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    importantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    lifecycleStage?: NullableEnumLifecycleStageFieldUpdateOperationsInput | $Enums.LifecycleStage | null
    lastContactedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    householdId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    householdStatus?: NullableEnumHouseholdRelationshipStatusFieldUpdateOperationsInput | $Enums.HouseholdRelationshipStatus | null
    companyId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyStatus?: NullableEnumCompanyRelationshipStatusFieldUpdateOperationsInput | $Enums.CompanyRelationshipStatus | null
    headOfHouseholdId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    primaryContactId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NoteUncheckedUpdateManyWithoutContactNestedInput
    timelineEvents?: ContactTimelineEventContactJoinUncheckedUpdateManyWithoutContactRelationNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutContactNestedInput
    emails?: ContactEmailUncheckedUpdateManyWithoutContactNestedInput
    phones?: ContactPhoneUncheckedUpdateManyWithoutContactNestedInput
    activities?: ActivityContactJoinUncheckedUpdateManyWithoutContactRelationNestedInput
    headOfHouseholdFor?: ContactUncheckedUpdateOneWithoutHeadOfHouseholdNestedInput
    primaryContactFor?: ContactUncheckedUpdateOneWithoutPrimaryContactNestedInput
    householdMembers?: ContactUncheckedUpdateManyWithoutHouseholdNestedInput
    employees?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    opportunities?: ContactOpportunityJoinUncheckedUpdateManyWithoutContactRelationNestedInput
    relationAsSource?: ContactRelationshipUncheckedUpdateManyWithoutSourceNestedInput
    relationAsTarget?: ContactRelationshipUncheckedUpdateManyWithoutTargetNestedInput
  }

  export type TenetUpsertWithoutImportantDatesInput = {
    update: XOR<TenetUpdateWithoutImportantDatesInput, TenetUncheckedUpdateWithoutImportantDatesInput>
    create: XOR<TenetCreateWithoutImportantDatesInput, TenetUncheckedCreateWithoutImportantDatesInput>
    where?: TenetWhereInput
  }

  export type TenetUpdateToOneWithWhereWithoutImportantDatesInput = {
    where?: TenetWhereInput
    data: XOR<TenetUpdateWithoutImportantDatesInput, TenetUncheckedUpdateWithoutImportantDatesInput>
  }

  export type TenetUpdateWithoutImportantDatesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenetNestedInput
    logs?: LogUpdateManyWithoutTenetNestedInput
    contacts?: ContactUpdateManyWithoutTenetNestedInput
    activities?: ActivityUpdateManyWithoutTenetNestedInput
    addresses?: AddressUpdateManyWithoutTenetNestedInput
    contactEmails?: ContactEmailUpdateManyWithoutTenetNestedInput
    contactPhones?: ContactPhoneUpdateManyWithoutTenetNestedInput
    attachments?: AttachmentUpdateManyWithoutTenetNestedInput
    notes?: NoteUpdateManyWithoutTenetNestedInput
    auditEvents?: AuditEventUpdateManyWithoutTenetNestedInput
    contactTimelineEvents?: ContactTimelineEventUpdateManyWithoutTenetNestedInput
    activitySteps?: ActivityStepUpdateManyWithoutTenetNestedInput
    activityWaypoints?: ActivityWaypointUpdateManyWithoutTenetNestedInput
    templateAssignments?: TemplateAssignmentUpdateManyWithoutTenetNestedInput
    activityWaypointTemplates?: ActivityWaypointTemplateUpdateManyWithoutTenetNestedInput
    activityTemplates?: ActivityTemplateUpdateManyWithoutTenetNestedInput
    activityTemplateSteps?: ActivityTemplateStepUpdateManyWithoutTenetNestedInput
    opportunities?: OpportunityUpdateManyWithoutTenetNestedInput
    products?: ProductTypeUpdateManyWithoutTenetNestedInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentUpdateManyWithoutTenetNestedInput
  }

  export type TenetUncheckedUpdateWithoutImportantDatesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenetNestedInput
    logs?: LogUncheckedUpdateManyWithoutTenetNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutTenetNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutTenetNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutTenetNestedInput
    contactEmails?: ContactEmailUncheckedUpdateManyWithoutTenetNestedInput
    contactPhones?: ContactPhoneUncheckedUpdateManyWithoutTenetNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTenetNestedInput
    notes?: NoteUncheckedUpdateManyWithoutTenetNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutTenetNestedInput
    contactTimelineEvents?: ContactTimelineEventUncheckedUpdateManyWithoutTenetNestedInput
    activitySteps?: ActivityStepUncheckedUpdateManyWithoutTenetNestedInput
    activityWaypoints?: ActivityWaypointUncheckedUpdateManyWithoutTenetNestedInput
    templateAssignments?: TemplateAssignmentUncheckedUpdateManyWithoutTenetNestedInput
    activityWaypointTemplates?: ActivityWaypointTemplateUncheckedUpdateManyWithoutTenetNestedInput
    activityTemplates?: ActivityTemplateUncheckedUpdateManyWithoutTenetNestedInput
    activityTemplateSteps?: ActivityTemplateStepUncheckedUpdateManyWithoutTenetNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutTenetNestedInput
    products?: ProductTypeUncheckedUpdateManyWithoutTenetNestedInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentUncheckedUpdateManyWithoutTenetNestedInput
  }

  export type ContactOpportunityJoinCreateWithoutOpportunityRelationInput = {
    contactRelation: ContactCreateNestedOneWithoutOpportunitiesInput
  }

  export type ContactOpportunityJoinUncheckedCreateWithoutOpportunityRelationInput = {
    contactId: Uint8Array
  }

  export type ContactOpportunityJoinCreateOrConnectWithoutOpportunityRelationInput = {
    where: ContactOpportunityJoinWhereUniqueInput
    create: XOR<ContactOpportunityJoinCreateWithoutOpportunityRelationInput, ContactOpportunityJoinUncheckedCreateWithoutOpportunityRelationInput>
  }

  export type ContactOpportunityJoinCreateManyOpportunityRelationInputEnvelope = {
    data: ContactOpportunityJoinCreateManyOpportunityRelationInput | ContactOpportunityJoinCreateManyOpportunityRelationInput[]
    skipDuplicates?: boolean
  }

  export type UserOpportunityJoinCreateWithoutOpportunityRelationInput = {
    userRelation: UserCreateNestedOneWithoutOpportunitiesInput
  }

  export type UserOpportunityJoinUncheckedCreateWithoutOpportunityRelationInput = {
    userId: Uint8Array
  }

  export type UserOpportunityJoinCreateOrConnectWithoutOpportunityRelationInput = {
    where: UserOpportunityJoinWhereUniqueInput
    create: XOR<UserOpportunityJoinCreateWithoutOpportunityRelationInput, UserOpportunityJoinUncheckedCreateWithoutOpportunityRelationInput>
  }

  export type UserOpportunityJoinCreateManyOpportunityRelationInputEnvelope = {
    data: UserOpportunityJoinCreateManyOpportunityRelationInput | UserOpportunityJoinCreateManyOpportunityRelationInput[]
    skipDuplicates?: boolean
  }

  export type ActivityCreateWithoutOpportunityInput = {
    id: Uint8Array
    title: string
    type: $Enums.ActivityType
    taskScheduleType?: $Enums.TaskScheduleType | null
    startDate: Date | string
    endDate: Date | string
    completedAt?: Date | string | null
    description?: string | null
    priority?: $Enums.ActivityPriority
    status: $Enums.ActivityStatus
    phoneNumber?: string | null
    location?: string | null
    holdReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean
    deletedAt?: Date | string | null
    order?: number | null
    steps?: ActivityStepCreateNestedManyWithoutActivityInput
    waypoints?: ActivityWaypointCreateNestedManyWithoutActivityInput
    activities?: ActivityCreateNestedManyWithoutParentActivityInput
    parentActivity?: ActivityCreateNestedOneWithoutActivitiesInput
    parentWaypoint?: ActivityWaypointCreateNestedOneWithoutChildActivitiesInput
    template?: ActivityTemplateCreateNestedOneWithoutActivitiesInput
    assignedBy: UserCreateNestedOneWithoutAssignedActivitiesInput
    contacts?: ActivityContactJoinCreateNestedManyWithoutActivityRelationInput
    users?: ActivityUserJoinCreateNestedManyWithoutActivityRelationInput
    tenet: TenetCreateNestedOneWithoutActivitiesInput
    attachments?: AttachmentCreateNestedManyWithoutActivityInput
    notes?: NoteCreateNestedManyWithoutActivityInput
    events?: ContactTimelineEventCreateNestedManyWithoutActivityInput
  }

  export type ActivityUncheckedCreateWithoutOpportunityInput = {
    id: Uint8Array
    title: string
    type: $Enums.ActivityType
    parentActivityId?: Uint8Array | null
    parentWaypointId?: Uint8Array | null
    templateId?: Uint8Array | null
    taskScheduleType?: $Enums.TaskScheduleType | null
    startDate: Date | string
    endDate: Date | string
    completedAt?: Date | string | null
    description?: string | null
    priority?: $Enums.ActivityPriority
    status: $Enums.ActivityStatus
    assignedById: Uint8Array
    phoneNumber?: string | null
    location?: string | null
    holdReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
    deleted?: boolean
    deletedAt?: Date | string | null
    order?: number | null
    steps?: ActivityStepUncheckedCreateNestedManyWithoutActivityInput
    waypoints?: ActivityWaypointUncheckedCreateNestedManyWithoutActivityInput
    activities?: ActivityUncheckedCreateNestedManyWithoutParentActivityInput
    contacts?: ActivityContactJoinUncheckedCreateNestedManyWithoutActivityRelationInput
    users?: ActivityUserJoinUncheckedCreateNestedManyWithoutActivityRelationInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutActivityInput
    notes?: NoteUncheckedCreateNestedManyWithoutActivityInput
    events?: ContactTimelineEventUncheckedCreateNestedManyWithoutActivityInput
  }

  export type ActivityCreateOrConnectWithoutOpportunityInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutOpportunityInput, ActivityUncheckedCreateWithoutOpportunityInput>
  }

  export type ActivityCreateManyOpportunityInputEnvelope = {
    data: ActivityCreateManyOpportunityInput | ActivityCreateManyOpportunityInput[]
    skipDuplicates?: boolean
  }

  export type OpportunityProductCreateWithoutOpportunityInput = {
    id: Uint8Array
    price: number
    order: number
    commission: number
    createdAt?: Date | string
    updatedAt?: Date | string
    productType: ProductTypeCreateNestedOneWithoutOpportunitiesInput
  }

  export type OpportunityProductUncheckedCreateWithoutOpportunityInput = {
    id: Uint8Array
    price: number
    order: number
    commission: number
    productTypeId: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OpportunityProductCreateOrConnectWithoutOpportunityInput = {
    where: OpportunityProductWhereUniqueInput
    create: XOR<OpportunityProductCreateWithoutOpportunityInput, OpportunityProductUncheckedCreateWithoutOpportunityInput>
  }

  export type OpportunityProductCreateManyOpportunityInputEnvelope = {
    data: OpportunityProductCreateManyOpportunityInput | OpportunityProductCreateManyOpportunityInput[]
    skipDuplicates?: boolean
  }

  export type TenetCreateWithoutOpportunitiesInput = {
    id: Uint8Array
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenetInput
    logs?: LogCreateNestedManyWithoutTenetInput
    contacts?: ContactCreateNestedManyWithoutTenetInput
    activities?: ActivityCreateNestedManyWithoutTenetInput
    addresses?: AddressCreateNestedManyWithoutTenetInput
    contactEmails?: ContactEmailCreateNestedManyWithoutTenetInput
    contactPhones?: ContactPhoneCreateNestedManyWithoutTenetInput
    importantDates?: ImportantDateCreateNestedManyWithoutTenetInput
    attachments?: AttachmentCreateNestedManyWithoutTenetInput
    notes?: NoteCreateNestedManyWithoutTenetInput
    auditEvents?: AuditEventCreateNestedManyWithoutTenetInput
    contactTimelineEvents?: ContactTimelineEventCreateNestedManyWithoutTenetInput
    activitySteps?: ActivityStepCreateNestedManyWithoutTenetInput
    activityWaypoints?: ActivityWaypointCreateNestedManyWithoutTenetInput
    templateAssignments?: TemplateAssignmentCreateNestedManyWithoutTenetInput
    activityWaypointTemplates?: ActivityWaypointTemplateCreateNestedManyWithoutTenetInput
    activityTemplates?: ActivityTemplateCreateNestedManyWithoutTenetInput
    activityTemplateSteps?: ActivityTemplateStepCreateNestedManyWithoutTenetInput
    products?: ProductTypeCreateNestedManyWithoutTenetInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentCreateNestedManyWithoutTenetInput
  }

  export type TenetUncheckedCreateWithoutOpportunitiesInput = {
    id: Uint8Array
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenetInput
    logs?: LogUncheckedCreateNestedManyWithoutTenetInput
    contacts?: ContactUncheckedCreateNestedManyWithoutTenetInput
    activities?: ActivityUncheckedCreateNestedManyWithoutTenetInput
    addresses?: AddressUncheckedCreateNestedManyWithoutTenetInput
    contactEmails?: ContactEmailUncheckedCreateNestedManyWithoutTenetInput
    contactPhones?: ContactPhoneUncheckedCreateNestedManyWithoutTenetInput
    importantDates?: ImportantDateUncheckedCreateNestedManyWithoutTenetInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTenetInput
    notes?: NoteUncheckedCreateNestedManyWithoutTenetInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutTenetInput
    contactTimelineEvents?: ContactTimelineEventUncheckedCreateNestedManyWithoutTenetInput
    activitySteps?: ActivityStepUncheckedCreateNestedManyWithoutTenetInput
    activityWaypoints?: ActivityWaypointUncheckedCreateNestedManyWithoutTenetInput
    templateAssignments?: TemplateAssignmentUncheckedCreateNestedManyWithoutTenetInput
    activityWaypointTemplates?: ActivityWaypointTemplateUncheckedCreateNestedManyWithoutTenetInput
    activityTemplates?: ActivityTemplateUncheckedCreateNestedManyWithoutTenetInput
    activityTemplateSteps?: ActivityTemplateStepUncheckedCreateNestedManyWithoutTenetInput
    products?: ProductTypeUncheckedCreateNestedManyWithoutTenetInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentUncheckedCreateNestedManyWithoutTenetInput
  }

  export type TenetCreateOrConnectWithoutOpportunitiesInput = {
    where: TenetWhereUniqueInput
    create: XOR<TenetCreateWithoutOpportunitiesInput, TenetUncheckedCreateWithoutOpportunitiesInput>
  }

  export type ContactTimelineEventCreateWithoutOpportunityInput = {
    id: Uint8Array
    extraInfo?: string | null
    eventType: $Enums.ContactTimelineEventType
    relationshipType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    activity?: ActivityCreateNestedOneWithoutEventsInput
    waypoint?: ActivityWaypointCreateNestedOneWithoutEventsInput
    note?: NoteCreateNestedOneWithoutEventsInput
    contacts?: ContactTimelineEventContactJoinCreateNestedManyWithoutContactEventRelationInput
    user: UserCreateNestedOneWithoutEventsInput
    tenet: TenetCreateNestedOneWithoutContactTimelineEventsInput
  }

  export type ContactTimelineEventUncheckedCreateWithoutOpportunityInput = {
    id: Uint8Array
    activityId?: Uint8Array | null
    waypointId?: Uint8Array | null
    noteId?: Uint8Array | null
    extraInfo?: string | null
    userId: Uint8Array
    tenetId: Uint8Array
    eventType: $Enums.ContactTimelineEventType
    relationshipType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: ContactTimelineEventContactJoinUncheckedCreateNestedManyWithoutContactEventRelationInput
  }

  export type ContactTimelineEventCreateOrConnectWithoutOpportunityInput = {
    where: ContactTimelineEventWhereUniqueInput
    create: XOR<ContactTimelineEventCreateWithoutOpportunityInput, ContactTimelineEventUncheckedCreateWithoutOpportunityInput>
  }

  export type ContactTimelineEventCreateManyOpportunityInputEnvelope = {
    data: ContactTimelineEventCreateManyOpportunityInput | ContactTimelineEventCreateManyOpportunityInput[]
    skipDuplicates?: boolean
  }

  export type NoteCreateWithoutOpportunityInput = {
    id: Uint8Array
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean
    deletedAt?: Date | string | null
    noteType?: $Enums.NoteType
    waypoint?: ActivityWaypointCreateNestedOneWithoutNoteInput
    activity?: ActivityCreateNestedOneWithoutNotesInput
    contact?: ContactCreateNestedOneWithoutNotesInput
    tenet: TenetCreateNestedOneWithoutNotesInput
    author: UserCreateNestedOneWithoutNotesInput
    events?: ContactTimelineEventCreateNestedManyWithoutNoteInput
  }

  export type NoteUncheckedCreateWithoutOpportunityInput = {
    id: Uint8Array
    content: string
    waypointId?: Uint8Array | null
    activityId?: Uint8Array | null
    contactId?: Uint8Array | null
    tenetId: Uint8Array
    authorId: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean
    deletedAt?: Date | string | null
    noteType?: $Enums.NoteType
    events?: ContactTimelineEventUncheckedCreateNestedManyWithoutNoteInput
  }

  export type NoteCreateOrConnectWithoutOpportunityInput = {
    where: NoteWhereUniqueInput
    create: XOR<NoteCreateWithoutOpportunityInput, NoteUncheckedCreateWithoutOpportunityInput>
  }

  export type NoteCreateManyOpportunityInputEnvelope = {
    data: NoteCreateManyOpportunityInput | NoteCreateManyOpportunityInput[]
    skipDuplicates?: boolean
  }

  export type ContactOpportunityJoinUpsertWithWhereUniqueWithoutOpportunityRelationInput = {
    where: ContactOpportunityJoinWhereUniqueInput
    update: XOR<ContactOpportunityJoinUpdateWithoutOpportunityRelationInput, ContactOpportunityJoinUncheckedUpdateWithoutOpportunityRelationInput>
    create: XOR<ContactOpportunityJoinCreateWithoutOpportunityRelationInput, ContactOpportunityJoinUncheckedCreateWithoutOpportunityRelationInput>
  }

  export type ContactOpportunityJoinUpdateWithWhereUniqueWithoutOpportunityRelationInput = {
    where: ContactOpportunityJoinWhereUniqueInput
    data: XOR<ContactOpportunityJoinUpdateWithoutOpportunityRelationInput, ContactOpportunityJoinUncheckedUpdateWithoutOpportunityRelationInput>
  }

  export type ContactOpportunityJoinUpdateManyWithWhereWithoutOpportunityRelationInput = {
    where: ContactOpportunityJoinScalarWhereInput
    data: XOR<ContactOpportunityJoinUpdateManyMutationInput, ContactOpportunityJoinUncheckedUpdateManyWithoutOpportunityRelationInput>
  }

  export type UserOpportunityJoinUpsertWithWhereUniqueWithoutOpportunityRelationInput = {
    where: UserOpportunityJoinWhereUniqueInput
    update: XOR<UserOpportunityJoinUpdateWithoutOpportunityRelationInput, UserOpportunityJoinUncheckedUpdateWithoutOpportunityRelationInput>
    create: XOR<UserOpportunityJoinCreateWithoutOpportunityRelationInput, UserOpportunityJoinUncheckedCreateWithoutOpportunityRelationInput>
  }

  export type UserOpportunityJoinUpdateWithWhereUniqueWithoutOpportunityRelationInput = {
    where: UserOpportunityJoinWhereUniqueInput
    data: XOR<UserOpportunityJoinUpdateWithoutOpportunityRelationInput, UserOpportunityJoinUncheckedUpdateWithoutOpportunityRelationInput>
  }

  export type UserOpportunityJoinUpdateManyWithWhereWithoutOpportunityRelationInput = {
    where: UserOpportunityJoinScalarWhereInput
    data: XOR<UserOpportunityJoinUpdateManyMutationInput, UserOpportunityJoinUncheckedUpdateManyWithoutOpportunityRelationInput>
  }

  export type ActivityUpsertWithWhereUniqueWithoutOpportunityInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutOpportunityInput, ActivityUncheckedUpdateWithoutOpportunityInput>
    create: XOR<ActivityCreateWithoutOpportunityInput, ActivityUncheckedCreateWithoutOpportunityInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutOpportunityInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutOpportunityInput, ActivityUncheckedUpdateWithoutOpportunityInput>
  }

  export type ActivityUpdateManyWithWhereWithoutOpportunityInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutOpportunityInput>
  }

  export type OpportunityProductUpsertWithWhereUniqueWithoutOpportunityInput = {
    where: OpportunityProductWhereUniqueInput
    update: XOR<OpportunityProductUpdateWithoutOpportunityInput, OpportunityProductUncheckedUpdateWithoutOpportunityInput>
    create: XOR<OpportunityProductCreateWithoutOpportunityInput, OpportunityProductUncheckedCreateWithoutOpportunityInput>
  }

  export type OpportunityProductUpdateWithWhereUniqueWithoutOpportunityInput = {
    where: OpportunityProductWhereUniqueInput
    data: XOR<OpportunityProductUpdateWithoutOpportunityInput, OpportunityProductUncheckedUpdateWithoutOpportunityInput>
  }

  export type OpportunityProductUpdateManyWithWhereWithoutOpportunityInput = {
    where: OpportunityProductScalarWhereInput
    data: XOR<OpportunityProductUpdateManyMutationInput, OpportunityProductUncheckedUpdateManyWithoutOpportunityInput>
  }

  export type OpportunityProductScalarWhereInput = {
    AND?: OpportunityProductScalarWhereInput | OpportunityProductScalarWhereInput[]
    OR?: OpportunityProductScalarWhereInput[]
    NOT?: OpportunityProductScalarWhereInput | OpportunityProductScalarWhereInput[]
    id?: BytesFilter<"OpportunityProduct"> | Uint8Array
    price?: FloatFilter<"OpportunityProduct"> | number
    order?: IntFilter<"OpportunityProduct"> | number
    commission?: FloatFilter<"OpportunityProduct"> | number
    opportunityId?: BytesFilter<"OpportunityProduct"> | Uint8Array
    productTypeId?: BytesFilter<"OpportunityProduct"> | Uint8Array
    createdAt?: DateTimeFilter<"OpportunityProduct"> | Date | string
    updatedAt?: DateTimeFilter<"OpportunityProduct"> | Date | string
  }

  export type TenetUpsertWithoutOpportunitiesInput = {
    update: XOR<TenetUpdateWithoutOpportunitiesInput, TenetUncheckedUpdateWithoutOpportunitiesInput>
    create: XOR<TenetCreateWithoutOpportunitiesInput, TenetUncheckedCreateWithoutOpportunitiesInput>
    where?: TenetWhereInput
  }

  export type TenetUpdateToOneWithWhereWithoutOpportunitiesInput = {
    where?: TenetWhereInput
    data: XOR<TenetUpdateWithoutOpportunitiesInput, TenetUncheckedUpdateWithoutOpportunitiesInput>
  }

  export type TenetUpdateWithoutOpportunitiesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenetNestedInput
    logs?: LogUpdateManyWithoutTenetNestedInput
    contacts?: ContactUpdateManyWithoutTenetNestedInput
    activities?: ActivityUpdateManyWithoutTenetNestedInput
    addresses?: AddressUpdateManyWithoutTenetNestedInput
    contactEmails?: ContactEmailUpdateManyWithoutTenetNestedInput
    contactPhones?: ContactPhoneUpdateManyWithoutTenetNestedInput
    importantDates?: ImportantDateUpdateManyWithoutTenetNestedInput
    attachments?: AttachmentUpdateManyWithoutTenetNestedInput
    notes?: NoteUpdateManyWithoutTenetNestedInput
    auditEvents?: AuditEventUpdateManyWithoutTenetNestedInput
    contactTimelineEvents?: ContactTimelineEventUpdateManyWithoutTenetNestedInput
    activitySteps?: ActivityStepUpdateManyWithoutTenetNestedInput
    activityWaypoints?: ActivityWaypointUpdateManyWithoutTenetNestedInput
    templateAssignments?: TemplateAssignmentUpdateManyWithoutTenetNestedInput
    activityWaypointTemplates?: ActivityWaypointTemplateUpdateManyWithoutTenetNestedInput
    activityTemplates?: ActivityTemplateUpdateManyWithoutTenetNestedInput
    activityTemplateSteps?: ActivityTemplateStepUpdateManyWithoutTenetNestedInput
    products?: ProductTypeUpdateManyWithoutTenetNestedInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentUpdateManyWithoutTenetNestedInput
  }

  export type TenetUncheckedUpdateWithoutOpportunitiesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenetNestedInput
    logs?: LogUncheckedUpdateManyWithoutTenetNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutTenetNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutTenetNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutTenetNestedInput
    contactEmails?: ContactEmailUncheckedUpdateManyWithoutTenetNestedInput
    contactPhones?: ContactPhoneUncheckedUpdateManyWithoutTenetNestedInput
    importantDates?: ImportantDateUncheckedUpdateManyWithoutTenetNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTenetNestedInput
    notes?: NoteUncheckedUpdateManyWithoutTenetNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutTenetNestedInput
    contactTimelineEvents?: ContactTimelineEventUncheckedUpdateManyWithoutTenetNestedInput
    activitySteps?: ActivityStepUncheckedUpdateManyWithoutTenetNestedInput
    activityWaypoints?: ActivityWaypointUncheckedUpdateManyWithoutTenetNestedInput
    templateAssignments?: TemplateAssignmentUncheckedUpdateManyWithoutTenetNestedInput
    activityWaypointTemplates?: ActivityWaypointTemplateUncheckedUpdateManyWithoutTenetNestedInput
    activityTemplates?: ActivityTemplateUncheckedUpdateManyWithoutTenetNestedInput
    activityTemplateSteps?: ActivityTemplateStepUncheckedUpdateManyWithoutTenetNestedInput
    products?: ProductTypeUncheckedUpdateManyWithoutTenetNestedInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentUncheckedUpdateManyWithoutTenetNestedInput
  }

  export type ContactTimelineEventUpsertWithWhereUniqueWithoutOpportunityInput = {
    where: ContactTimelineEventWhereUniqueInput
    update: XOR<ContactTimelineEventUpdateWithoutOpportunityInput, ContactTimelineEventUncheckedUpdateWithoutOpportunityInput>
    create: XOR<ContactTimelineEventCreateWithoutOpportunityInput, ContactTimelineEventUncheckedCreateWithoutOpportunityInput>
  }

  export type ContactTimelineEventUpdateWithWhereUniqueWithoutOpportunityInput = {
    where: ContactTimelineEventWhereUniqueInput
    data: XOR<ContactTimelineEventUpdateWithoutOpportunityInput, ContactTimelineEventUncheckedUpdateWithoutOpportunityInput>
  }

  export type ContactTimelineEventUpdateManyWithWhereWithoutOpportunityInput = {
    where: ContactTimelineEventScalarWhereInput
    data: XOR<ContactTimelineEventUpdateManyMutationInput, ContactTimelineEventUncheckedUpdateManyWithoutOpportunityInput>
  }

  export type NoteUpsertWithWhereUniqueWithoutOpportunityInput = {
    where: NoteWhereUniqueInput
    update: XOR<NoteUpdateWithoutOpportunityInput, NoteUncheckedUpdateWithoutOpportunityInput>
    create: XOR<NoteCreateWithoutOpportunityInput, NoteUncheckedCreateWithoutOpportunityInput>
  }

  export type NoteUpdateWithWhereUniqueWithoutOpportunityInput = {
    where: NoteWhereUniqueInput
    data: XOR<NoteUpdateWithoutOpportunityInput, NoteUncheckedUpdateWithoutOpportunityInput>
  }

  export type NoteUpdateManyWithWhereWithoutOpportunityInput = {
    where: NoteScalarWhereInput
    data: XOR<NoteUpdateManyMutationInput, NoteUncheckedUpdateManyWithoutOpportunityInput>
  }

  export type ContactCreateWithoutOpportunitiesInput = {
    id: Uint8Array
    firstName?: string | null
    lastName: string
    fullName: string
    importantNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.ContactType
    status: $Enums.ContactStatus
    lifecycleStage?: $Enums.LifecycleStage | null
    lastContactedDate?: Date | string | null
    followUpDate?: Date | string | null
    householdStatus?: $Enums.HouseholdRelationshipStatus | null
    position?: string | null
    companyStatus?: $Enums.CompanyRelationshipStatus | null
    industry?: string | null
    website?: string | null
    size?: number | null
    deleted?: boolean
    deletedAt?: Date | string | null
    tenet: TenetCreateNestedOneWithoutContactsInput
    notes?: NoteCreateNestedManyWithoutContactInput
    timelineEvents?: ContactTimelineEventContactJoinCreateNestedManyWithoutContactRelationInput
    addresses?: AddressCreateNestedManyWithoutContactInput
    emails?: ContactEmailCreateNestedManyWithoutContactInput
    phones?: ContactPhoneCreateNestedManyWithoutContactInput
    importantDates?: ImportantDateCreateNestedManyWithoutContactInput
    activities?: ActivityContactJoinCreateNestedManyWithoutContactRelationInput
    household?: ContactCreateNestedOneWithoutHouseholdMembersInput
    headOfHouseholdFor?: ContactCreateNestedOneWithoutHeadOfHouseholdInput
    company?: ContactCreateNestedOneWithoutEmployeesInput
    primaryContactFor?: ContactCreateNestedOneWithoutPrimaryContactInput
    headOfHousehold?: ContactCreateNestedOneWithoutHeadOfHouseholdForInput
    householdMembers?: ContactCreateNestedManyWithoutHouseholdInput
    employees?: ContactCreateNestedManyWithoutCompanyInput
    primaryContact?: ContactCreateNestedOneWithoutPrimaryContactForInput
    relationAsSource?: ContactRelationshipCreateNestedManyWithoutSourceInput
    relationAsTarget?: ContactRelationshipCreateNestedManyWithoutTargetInput
  }

  export type ContactUncheckedCreateWithoutOpportunitiesInput = {
    id: Uint8Array
    firstName?: string | null
    lastName: string
    fullName: string
    tenetId: Uint8Array
    importantNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.ContactType
    status: $Enums.ContactStatus
    lifecycleStage?: $Enums.LifecycleStage | null
    lastContactedDate?: Date | string | null
    followUpDate?: Date | string | null
    householdId?: Uint8Array | null
    householdStatus?: $Enums.HouseholdRelationshipStatus | null
    companyId?: Uint8Array | null
    position?: string | null
    companyStatus?: $Enums.CompanyRelationshipStatus | null
    headOfHouseholdId?: Uint8Array | null
    industry?: string | null
    website?: string | null
    size?: number | null
    primaryContactId?: Uint8Array | null
    deleted?: boolean
    deletedAt?: Date | string | null
    notes?: NoteUncheckedCreateNestedManyWithoutContactInput
    timelineEvents?: ContactTimelineEventContactJoinUncheckedCreateNestedManyWithoutContactRelationInput
    addresses?: AddressUncheckedCreateNestedManyWithoutContactInput
    emails?: ContactEmailUncheckedCreateNestedManyWithoutContactInput
    phones?: ContactPhoneUncheckedCreateNestedManyWithoutContactInput
    importantDates?: ImportantDateUncheckedCreateNestedManyWithoutContactInput
    activities?: ActivityContactJoinUncheckedCreateNestedManyWithoutContactRelationInput
    headOfHouseholdFor?: ContactUncheckedCreateNestedOneWithoutHeadOfHouseholdInput
    primaryContactFor?: ContactUncheckedCreateNestedOneWithoutPrimaryContactInput
    householdMembers?: ContactUncheckedCreateNestedManyWithoutHouseholdInput
    employees?: ContactUncheckedCreateNestedManyWithoutCompanyInput
    relationAsSource?: ContactRelationshipUncheckedCreateNestedManyWithoutSourceInput
    relationAsTarget?: ContactRelationshipUncheckedCreateNestedManyWithoutTargetInput
  }

  export type ContactCreateOrConnectWithoutOpportunitiesInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutOpportunitiesInput, ContactUncheckedCreateWithoutOpportunitiesInput>
  }

  export type OpportunityCreateWithoutContactsInput = {
    id: Uint8Array
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    value: number
    probability: number
    expectedCloseDate: Date | string
    actualCloseDate?: Date | string | null
    status: $Enums.OpportunityStatus
    statusHistory?: OpportunityCreatestatusHistoryInput | $Enums.OpportunityStatus[]
    deleted?: boolean
    deletedAt?: Date | string | null
    expectedValue: number
    teamMembers?: UserOpportunityJoinCreateNestedManyWithoutOpportunityRelationInput
    activities?: ActivityCreateNestedManyWithoutOpportunityInput
    products?: OpportunityProductCreateNestedManyWithoutOpportunityInput
    tenet: TenetCreateNestedOneWithoutOpportunitiesInput
    events?: ContactTimelineEventCreateNestedManyWithoutOpportunityInput
    notes?: NoteCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityUncheckedCreateWithoutContactsInput = {
    id: Uint8Array
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    value: number
    probability: number
    expectedCloseDate: Date | string
    actualCloseDate?: Date | string | null
    status: $Enums.OpportunityStatus
    statusHistory?: OpportunityCreatestatusHistoryInput | $Enums.OpportunityStatus[]
    deleted?: boolean
    deletedAt?: Date | string | null
    tenetId: Uint8Array
    expectedValue: number
    teamMembers?: UserOpportunityJoinUncheckedCreateNestedManyWithoutOpportunityRelationInput
    activities?: ActivityUncheckedCreateNestedManyWithoutOpportunityInput
    products?: OpportunityProductUncheckedCreateNestedManyWithoutOpportunityInput
    events?: ContactTimelineEventUncheckedCreateNestedManyWithoutOpportunityInput
    notes?: NoteUncheckedCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityCreateOrConnectWithoutContactsInput = {
    where: OpportunityWhereUniqueInput
    create: XOR<OpportunityCreateWithoutContactsInput, OpportunityUncheckedCreateWithoutContactsInput>
  }

  export type ContactUpsertWithoutOpportunitiesInput = {
    update: XOR<ContactUpdateWithoutOpportunitiesInput, ContactUncheckedUpdateWithoutOpportunitiesInput>
    create: XOR<ContactCreateWithoutOpportunitiesInput, ContactUncheckedCreateWithoutOpportunitiesInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutOpportunitiesInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutOpportunitiesInput, ContactUncheckedUpdateWithoutOpportunitiesInput>
  }

  export type ContactUpdateWithoutOpportunitiesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    importantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    lifecycleStage?: NullableEnumLifecycleStageFieldUpdateOperationsInput | $Enums.LifecycleStage | null
    lastContactedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    householdStatus?: NullableEnumHouseholdRelationshipStatusFieldUpdateOperationsInput | $Enums.HouseholdRelationshipStatus | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyStatus?: NullableEnumCompanyRelationshipStatusFieldUpdateOperationsInput | $Enums.CompanyRelationshipStatus | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenet?: TenetUpdateOneRequiredWithoutContactsNestedInput
    notes?: NoteUpdateManyWithoutContactNestedInput
    timelineEvents?: ContactTimelineEventContactJoinUpdateManyWithoutContactRelationNestedInput
    addresses?: AddressUpdateManyWithoutContactNestedInput
    emails?: ContactEmailUpdateManyWithoutContactNestedInput
    phones?: ContactPhoneUpdateManyWithoutContactNestedInput
    importantDates?: ImportantDateUpdateManyWithoutContactNestedInput
    activities?: ActivityContactJoinUpdateManyWithoutContactRelationNestedInput
    household?: ContactUpdateOneWithoutHouseholdMembersNestedInput
    headOfHouseholdFor?: ContactUpdateOneWithoutHeadOfHouseholdNestedInput
    company?: ContactUpdateOneWithoutEmployeesNestedInput
    primaryContactFor?: ContactUpdateOneWithoutPrimaryContactNestedInput
    headOfHousehold?: ContactUpdateOneWithoutHeadOfHouseholdForNestedInput
    householdMembers?: ContactUpdateManyWithoutHouseholdNestedInput
    employees?: ContactUpdateManyWithoutCompanyNestedInput
    primaryContact?: ContactUpdateOneWithoutPrimaryContactForNestedInput
    relationAsSource?: ContactRelationshipUpdateManyWithoutSourceNestedInput
    relationAsTarget?: ContactRelationshipUpdateManyWithoutTargetNestedInput
  }

  export type ContactUncheckedUpdateWithoutOpportunitiesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    importantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    lifecycleStage?: NullableEnumLifecycleStageFieldUpdateOperationsInput | $Enums.LifecycleStage | null
    lastContactedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    householdId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    householdStatus?: NullableEnumHouseholdRelationshipStatusFieldUpdateOperationsInput | $Enums.HouseholdRelationshipStatus | null
    companyId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyStatus?: NullableEnumCompanyRelationshipStatusFieldUpdateOperationsInput | $Enums.CompanyRelationshipStatus | null
    headOfHouseholdId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    primaryContactId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NoteUncheckedUpdateManyWithoutContactNestedInput
    timelineEvents?: ContactTimelineEventContactJoinUncheckedUpdateManyWithoutContactRelationNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutContactNestedInput
    emails?: ContactEmailUncheckedUpdateManyWithoutContactNestedInput
    phones?: ContactPhoneUncheckedUpdateManyWithoutContactNestedInput
    importantDates?: ImportantDateUncheckedUpdateManyWithoutContactNestedInput
    activities?: ActivityContactJoinUncheckedUpdateManyWithoutContactRelationNestedInput
    headOfHouseholdFor?: ContactUncheckedUpdateOneWithoutHeadOfHouseholdNestedInput
    primaryContactFor?: ContactUncheckedUpdateOneWithoutPrimaryContactNestedInput
    householdMembers?: ContactUncheckedUpdateManyWithoutHouseholdNestedInput
    employees?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    relationAsSource?: ContactRelationshipUncheckedUpdateManyWithoutSourceNestedInput
    relationAsTarget?: ContactRelationshipUncheckedUpdateManyWithoutTargetNestedInput
  }

  export type OpportunityUpsertWithoutContactsInput = {
    update: XOR<OpportunityUpdateWithoutContactsInput, OpportunityUncheckedUpdateWithoutContactsInput>
    create: XOR<OpportunityCreateWithoutContactsInput, OpportunityUncheckedCreateWithoutContactsInput>
    where?: OpportunityWhereInput
  }

  export type OpportunityUpdateToOneWithWhereWithoutContactsInput = {
    where?: OpportunityWhereInput
    data: XOR<OpportunityUpdateWithoutContactsInput, OpportunityUncheckedUpdateWithoutContactsInput>
  }

  export type OpportunityUpdateWithoutContactsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    probability?: FloatFieldUpdateOperationsInput | number
    expectedCloseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumOpportunityStatusFieldUpdateOperationsInput | $Enums.OpportunityStatus
    statusHistory?: OpportunityUpdatestatusHistoryInput | $Enums.OpportunityStatus[]
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedValue?: FloatFieldUpdateOperationsInput | number
    teamMembers?: UserOpportunityJoinUpdateManyWithoutOpportunityRelationNestedInput
    activities?: ActivityUpdateManyWithoutOpportunityNestedInput
    products?: OpportunityProductUpdateManyWithoutOpportunityNestedInput
    tenet?: TenetUpdateOneRequiredWithoutOpportunitiesNestedInput
    events?: ContactTimelineEventUpdateManyWithoutOpportunityNestedInput
    notes?: NoteUpdateManyWithoutOpportunityNestedInput
  }

  export type OpportunityUncheckedUpdateWithoutContactsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    probability?: FloatFieldUpdateOperationsInput | number
    expectedCloseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumOpportunityStatusFieldUpdateOperationsInput | $Enums.OpportunityStatus
    statusHistory?: OpportunityUpdatestatusHistoryInput | $Enums.OpportunityStatus[]
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    expectedValue?: FloatFieldUpdateOperationsInput | number
    teamMembers?: UserOpportunityJoinUncheckedUpdateManyWithoutOpportunityRelationNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutOpportunityNestedInput
    products?: OpportunityProductUncheckedUpdateManyWithoutOpportunityNestedInput
    events?: ContactTimelineEventUncheckedUpdateManyWithoutOpportunityNestedInput
    notes?: NoteUncheckedUpdateManyWithoutOpportunityNestedInput
  }

  export type UserCreateWithoutOpportunitiesInput = {
    id: Uint8Array
    email: string
    firstName: string
    lastName: string
    fullName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password: string
    enabled?: boolean
    type?: $Enums.AccessGroup
    system?: boolean
    deleted?: boolean
    deletedAt?: Date | string | null
    tokens?: TokenCreateNestedManyWithoutUserInput
    tenet?: TenetCreateNestedOneWithoutUsersInput
    activities?: ActivityUserJoinCreateNestedManyWithoutUserRelationInput
    notes?: NoteCreateNestedManyWithoutAuthorInput
    waypoints?: UserWaypointJoinCreateNestedManyWithoutUserRelationInput
    events?: ContactTimelineEventCreateNestedManyWithoutUserInput
    auditEvents?: AuditEventCreateNestedManyWithoutUserInput
    templateAssignments?: TemplateAssignmentCreateNestedManyWithoutSpecificUserInput
    assignedActivities?: ActivityCreateNestedManyWithoutAssignedByInput
    activitySteps?: ActivityStepUserJoinCreateNestedManyWithoutUserRelationInput
    templateStepAssignments?: ActivityTemplateStepAssignmentCreateNestedManyWithoutSpecificUserInput
  }

  export type UserUncheckedCreateWithoutOpportunitiesInput = {
    id: Uint8Array
    email: string
    firstName: string
    lastName: string
    fullName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password: string
    enabled?: boolean
    type?: $Enums.AccessGroup
    tenetId?: Uint8Array | null
    system?: boolean
    deleted?: boolean
    deletedAt?: Date | string | null
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUserJoinUncheckedCreateNestedManyWithoutUserRelationInput
    notes?: NoteUncheckedCreateNestedManyWithoutAuthorInput
    waypoints?: UserWaypointJoinUncheckedCreateNestedManyWithoutUserRelationInput
    events?: ContactTimelineEventUncheckedCreateNestedManyWithoutUserInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutUserInput
    templateAssignments?: TemplateAssignmentUncheckedCreateNestedManyWithoutSpecificUserInput
    assignedActivities?: ActivityUncheckedCreateNestedManyWithoutAssignedByInput
    activitySteps?: ActivityStepUserJoinUncheckedCreateNestedManyWithoutUserRelationInput
    templateStepAssignments?: ActivityTemplateStepAssignmentUncheckedCreateNestedManyWithoutSpecificUserInput
  }

  export type UserCreateOrConnectWithoutOpportunitiesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOpportunitiesInput, UserUncheckedCreateWithoutOpportunitiesInput>
  }

  export type OpportunityCreateWithoutTeamMembersInput = {
    id: Uint8Array
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    value: number
    probability: number
    expectedCloseDate: Date | string
    actualCloseDate?: Date | string | null
    status: $Enums.OpportunityStatus
    statusHistory?: OpportunityCreatestatusHistoryInput | $Enums.OpportunityStatus[]
    deleted?: boolean
    deletedAt?: Date | string | null
    expectedValue: number
    contacts?: ContactOpportunityJoinCreateNestedManyWithoutOpportunityRelationInput
    activities?: ActivityCreateNestedManyWithoutOpportunityInput
    products?: OpportunityProductCreateNestedManyWithoutOpportunityInput
    tenet: TenetCreateNestedOneWithoutOpportunitiesInput
    events?: ContactTimelineEventCreateNestedManyWithoutOpportunityInput
    notes?: NoteCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityUncheckedCreateWithoutTeamMembersInput = {
    id: Uint8Array
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    value: number
    probability: number
    expectedCloseDate: Date | string
    actualCloseDate?: Date | string | null
    status: $Enums.OpportunityStatus
    statusHistory?: OpportunityCreatestatusHistoryInput | $Enums.OpportunityStatus[]
    deleted?: boolean
    deletedAt?: Date | string | null
    tenetId: Uint8Array
    expectedValue: number
    contacts?: ContactOpportunityJoinUncheckedCreateNestedManyWithoutOpportunityRelationInput
    activities?: ActivityUncheckedCreateNestedManyWithoutOpportunityInput
    products?: OpportunityProductUncheckedCreateNestedManyWithoutOpportunityInput
    events?: ContactTimelineEventUncheckedCreateNestedManyWithoutOpportunityInput
    notes?: NoteUncheckedCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityCreateOrConnectWithoutTeamMembersInput = {
    where: OpportunityWhereUniqueInput
    create: XOR<OpportunityCreateWithoutTeamMembersInput, OpportunityUncheckedCreateWithoutTeamMembersInput>
  }

  export type UserUpsertWithoutOpportunitiesInput = {
    update: XOR<UserUpdateWithoutOpportunitiesInput, UserUncheckedUpdateWithoutOpportunitiesInput>
    create: XOR<UserCreateWithoutOpportunitiesInput, UserUncheckedCreateWithoutOpportunitiesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOpportunitiesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOpportunitiesInput, UserUncheckedUpdateWithoutOpportunitiesInput>
  }

  export type UserUpdateWithoutOpportunitiesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumAccessGroupFieldUpdateOperationsInput | $Enums.AccessGroup
    system?: BoolFieldUpdateOperationsInput | boolean
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokens?: TokenUpdateManyWithoutUserNestedInput
    tenet?: TenetUpdateOneWithoutUsersNestedInput
    activities?: ActivityUserJoinUpdateManyWithoutUserRelationNestedInput
    notes?: NoteUpdateManyWithoutAuthorNestedInput
    waypoints?: UserWaypointJoinUpdateManyWithoutUserRelationNestedInput
    events?: ContactTimelineEventUpdateManyWithoutUserNestedInput
    auditEvents?: AuditEventUpdateManyWithoutUserNestedInput
    templateAssignments?: TemplateAssignmentUpdateManyWithoutSpecificUserNestedInput
    assignedActivities?: ActivityUpdateManyWithoutAssignedByNestedInput
    activitySteps?: ActivityStepUserJoinUpdateManyWithoutUserRelationNestedInput
    templateStepAssignments?: ActivityTemplateStepAssignmentUpdateManyWithoutSpecificUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOpportunitiesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumAccessGroupFieldUpdateOperationsInput | $Enums.AccessGroup
    tenetId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    system?: BoolFieldUpdateOperationsInput | boolean
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUserJoinUncheckedUpdateManyWithoutUserRelationNestedInput
    notes?: NoteUncheckedUpdateManyWithoutAuthorNestedInput
    waypoints?: UserWaypointJoinUncheckedUpdateManyWithoutUserRelationNestedInput
    events?: ContactTimelineEventUncheckedUpdateManyWithoutUserNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutUserNestedInput
    templateAssignments?: TemplateAssignmentUncheckedUpdateManyWithoutSpecificUserNestedInput
    assignedActivities?: ActivityUncheckedUpdateManyWithoutAssignedByNestedInput
    activitySteps?: ActivityStepUserJoinUncheckedUpdateManyWithoutUserRelationNestedInput
    templateStepAssignments?: ActivityTemplateStepAssignmentUncheckedUpdateManyWithoutSpecificUserNestedInput
  }

  export type OpportunityUpsertWithoutTeamMembersInput = {
    update: XOR<OpportunityUpdateWithoutTeamMembersInput, OpportunityUncheckedUpdateWithoutTeamMembersInput>
    create: XOR<OpportunityCreateWithoutTeamMembersInput, OpportunityUncheckedCreateWithoutTeamMembersInput>
    where?: OpportunityWhereInput
  }

  export type OpportunityUpdateToOneWithWhereWithoutTeamMembersInput = {
    where?: OpportunityWhereInput
    data: XOR<OpportunityUpdateWithoutTeamMembersInput, OpportunityUncheckedUpdateWithoutTeamMembersInput>
  }

  export type OpportunityUpdateWithoutTeamMembersInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    probability?: FloatFieldUpdateOperationsInput | number
    expectedCloseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumOpportunityStatusFieldUpdateOperationsInput | $Enums.OpportunityStatus
    statusHistory?: OpportunityUpdatestatusHistoryInput | $Enums.OpportunityStatus[]
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedValue?: FloatFieldUpdateOperationsInput | number
    contacts?: ContactOpportunityJoinUpdateManyWithoutOpportunityRelationNestedInput
    activities?: ActivityUpdateManyWithoutOpportunityNestedInput
    products?: OpportunityProductUpdateManyWithoutOpportunityNestedInput
    tenet?: TenetUpdateOneRequiredWithoutOpportunitiesNestedInput
    events?: ContactTimelineEventUpdateManyWithoutOpportunityNestedInput
    notes?: NoteUpdateManyWithoutOpportunityNestedInput
  }

  export type OpportunityUncheckedUpdateWithoutTeamMembersInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    probability?: FloatFieldUpdateOperationsInput | number
    expectedCloseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumOpportunityStatusFieldUpdateOperationsInput | $Enums.OpportunityStatus
    statusHistory?: OpportunityUpdatestatusHistoryInput | $Enums.OpportunityStatus[]
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    expectedValue?: FloatFieldUpdateOperationsInput | number
    contacts?: ContactOpportunityJoinUncheckedUpdateManyWithoutOpportunityRelationNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutOpportunityNestedInput
    products?: OpportunityProductUncheckedUpdateManyWithoutOpportunityNestedInput
    events?: ContactTimelineEventUncheckedUpdateManyWithoutOpportunityNestedInput
    notes?: NoteUncheckedUpdateManyWithoutOpportunityNestedInput
  }

  export type OpportunityCreateWithoutProductsInput = {
    id: Uint8Array
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    value: number
    probability: number
    expectedCloseDate: Date | string
    actualCloseDate?: Date | string | null
    status: $Enums.OpportunityStatus
    statusHistory?: OpportunityCreatestatusHistoryInput | $Enums.OpportunityStatus[]
    deleted?: boolean
    deletedAt?: Date | string | null
    expectedValue: number
    contacts?: ContactOpportunityJoinCreateNestedManyWithoutOpportunityRelationInput
    teamMembers?: UserOpportunityJoinCreateNestedManyWithoutOpportunityRelationInput
    activities?: ActivityCreateNestedManyWithoutOpportunityInput
    tenet: TenetCreateNestedOneWithoutOpportunitiesInput
    events?: ContactTimelineEventCreateNestedManyWithoutOpportunityInput
    notes?: NoteCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityUncheckedCreateWithoutProductsInput = {
    id: Uint8Array
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    value: number
    probability: number
    expectedCloseDate: Date | string
    actualCloseDate?: Date | string | null
    status: $Enums.OpportunityStatus
    statusHistory?: OpportunityCreatestatusHistoryInput | $Enums.OpportunityStatus[]
    deleted?: boolean
    deletedAt?: Date | string | null
    tenetId: Uint8Array
    expectedValue: number
    contacts?: ContactOpportunityJoinUncheckedCreateNestedManyWithoutOpportunityRelationInput
    teamMembers?: UserOpportunityJoinUncheckedCreateNestedManyWithoutOpportunityRelationInput
    activities?: ActivityUncheckedCreateNestedManyWithoutOpportunityInput
    events?: ContactTimelineEventUncheckedCreateNestedManyWithoutOpportunityInput
    notes?: NoteUncheckedCreateNestedManyWithoutOpportunityInput
  }

  export type OpportunityCreateOrConnectWithoutProductsInput = {
    where: OpportunityWhereUniqueInput
    create: XOR<OpportunityCreateWithoutProductsInput, OpportunityUncheckedCreateWithoutProductsInput>
  }

  export type ProductTypeCreateWithoutOpportunitiesInput = {
    id: Uint8Array
    title: string
    description?: string | null
    defaultCommission: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tenet: TenetCreateNestedOneWithoutProductsInput
  }

  export type ProductTypeUncheckedCreateWithoutOpportunitiesInput = {
    id: Uint8Array
    title: string
    description?: string | null
    defaultCommission: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
  }

  export type ProductTypeCreateOrConnectWithoutOpportunitiesInput = {
    where: ProductTypeWhereUniqueInput
    create: XOR<ProductTypeCreateWithoutOpportunitiesInput, ProductTypeUncheckedCreateWithoutOpportunitiesInput>
  }

  export type OpportunityUpsertWithoutProductsInput = {
    update: XOR<OpportunityUpdateWithoutProductsInput, OpportunityUncheckedUpdateWithoutProductsInput>
    create: XOR<OpportunityCreateWithoutProductsInput, OpportunityUncheckedCreateWithoutProductsInput>
    where?: OpportunityWhereInput
  }

  export type OpportunityUpdateToOneWithWhereWithoutProductsInput = {
    where?: OpportunityWhereInput
    data: XOR<OpportunityUpdateWithoutProductsInput, OpportunityUncheckedUpdateWithoutProductsInput>
  }

  export type OpportunityUpdateWithoutProductsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    probability?: FloatFieldUpdateOperationsInput | number
    expectedCloseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumOpportunityStatusFieldUpdateOperationsInput | $Enums.OpportunityStatus
    statusHistory?: OpportunityUpdatestatusHistoryInput | $Enums.OpportunityStatus[]
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedValue?: FloatFieldUpdateOperationsInput | number
    contacts?: ContactOpportunityJoinUpdateManyWithoutOpportunityRelationNestedInput
    teamMembers?: UserOpportunityJoinUpdateManyWithoutOpportunityRelationNestedInput
    activities?: ActivityUpdateManyWithoutOpportunityNestedInput
    tenet?: TenetUpdateOneRequiredWithoutOpportunitiesNestedInput
    events?: ContactTimelineEventUpdateManyWithoutOpportunityNestedInput
    notes?: NoteUpdateManyWithoutOpportunityNestedInput
  }

  export type OpportunityUncheckedUpdateWithoutProductsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    probability?: FloatFieldUpdateOperationsInput | number
    expectedCloseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumOpportunityStatusFieldUpdateOperationsInput | $Enums.OpportunityStatus
    statusHistory?: OpportunityUpdatestatusHistoryInput | $Enums.OpportunityStatus[]
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    expectedValue?: FloatFieldUpdateOperationsInput | number
    contacts?: ContactOpportunityJoinUncheckedUpdateManyWithoutOpportunityRelationNestedInput
    teamMembers?: UserOpportunityJoinUncheckedUpdateManyWithoutOpportunityRelationNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutOpportunityNestedInput
    events?: ContactTimelineEventUncheckedUpdateManyWithoutOpportunityNestedInput
    notes?: NoteUncheckedUpdateManyWithoutOpportunityNestedInput
  }

  export type ProductTypeUpsertWithoutOpportunitiesInput = {
    update: XOR<ProductTypeUpdateWithoutOpportunitiesInput, ProductTypeUncheckedUpdateWithoutOpportunitiesInput>
    create: XOR<ProductTypeCreateWithoutOpportunitiesInput, ProductTypeUncheckedCreateWithoutOpportunitiesInput>
    where?: ProductTypeWhereInput
  }

  export type ProductTypeUpdateToOneWithWhereWithoutOpportunitiesInput = {
    where?: ProductTypeWhereInput
    data: XOR<ProductTypeUpdateWithoutOpportunitiesInput, ProductTypeUncheckedUpdateWithoutOpportunitiesInput>
  }

  export type ProductTypeUpdateWithoutOpportunitiesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCommission?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenet?: TenetUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ProductTypeUncheckedUpdateWithoutOpportunitiesInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCommission?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type OpportunityProductCreateWithoutProductTypeInput = {
    id: Uint8Array
    price: number
    order: number
    commission: number
    createdAt?: Date | string
    updatedAt?: Date | string
    opportunity: OpportunityCreateNestedOneWithoutProductsInput
  }

  export type OpportunityProductUncheckedCreateWithoutProductTypeInput = {
    id: Uint8Array
    price: number
    order: number
    commission: number
    opportunityId: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OpportunityProductCreateOrConnectWithoutProductTypeInput = {
    where: OpportunityProductWhereUniqueInput
    create: XOR<OpportunityProductCreateWithoutProductTypeInput, OpportunityProductUncheckedCreateWithoutProductTypeInput>
  }

  export type OpportunityProductCreateManyProductTypeInputEnvelope = {
    data: OpportunityProductCreateManyProductTypeInput | OpportunityProductCreateManyProductTypeInput[]
    skipDuplicates?: boolean
  }

  export type TenetCreateWithoutProductsInput = {
    id: Uint8Array
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenetInput
    logs?: LogCreateNestedManyWithoutTenetInput
    contacts?: ContactCreateNestedManyWithoutTenetInput
    activities?: ActivityCreateNestedManyWithoutTenetInput
    addresses?: AddressCreateNestedManyWithoutTenetInput
    contactEmails?: ContactEmailCreateNestedManyWithoutTenetInput
    contactPhones?: ContactPhoneCreateNestedManyWithoutTenetInput
    importantDates?: ImportantDateCreateNestedManyWithoutTenetInput
    attachments?: AttachmentCreateNestedManyWithoutTenetInput
    notes?: NoteCreateNestedManyWithoutTenetInput
    auditEvents?: AuditEventCreateNestedManyWithoutTenetInput
    contactTimelineEvents?: ContactTimelineEventCreateNestedManyWithoutTenetInput
    activitySteps?: ActivityStepCreateNestedManyWithoutTenetInput
    activityWaypoints?: ActivityWaypointCreateNestedManyWithoutTenetInput
    templateAssignments?: TemplateAssignmentCreateNestedManyWithoutTenetInput
    activityWaypointTemplates?: ActivityWaypointTemplateCreateNestedManyWithoutTenetInput
    activityTemplates?: ActivityTemplateCreateNestedManyWithoutTenetInput
    activityTemplateSteps?: ActivityTemplateStepCreateNestedManyWithoutTenetInput
    opportunities?: OpportunityCreateNestedManyWithoutTenetInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentCreateNestedManyWithoutTenetInput
  }

  export type TenetUncheckedCreateWithoutProductsInput = {
    id: Uint8Array
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenetInput
    logs?: LogUncheckedCreateNestedManyWithoutTenetInput
    contacts?: ContactUncheckedCreateNestedManyWithoutTenetInput
    activities?: ActivityUncheckedCreateNestedManyWithoutTenetInput
    addresses?: AddressUncheckedCreateNestedManyWithoutTenetInput
    contactEmails?: ContactEmailUncheckedCreateNestedManyWithoutTenetInput
    contactPhones?: ContactPhoneUncheckedCreateNestedManyWithoutTenetInput
    importantDates?: ImportantDateUncheckedCreateNestedManyWithoutTenetInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTenetInput
    notes?: NoteUncheckedCreateNestedManyWithoutTenetInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutTenetInput
    contactTimelineEvents?: ContactTimelineEventUncheckedCreateNestedManyWithoutTenetInput
    activitySteps?: ActivityStepUncheckedCreateNestedManyWithoutTenetInput
    activityWaypoints?: ActivityWaypointUncheckedCreateNestedManyWithoutTenetInput
    templateAssignments?: TemplateAssignmentUncheckedCreateNestedManyWithoutTenetInput
    activityWaypointTemplates?: ActivityWaypointTemplateUncheckedCreateNestedManyWithoutTenetInput
    activityTemplates?: ActivityTemplateUncheckedCreateNestedManyWithoutTenetInput
    activityTemplateSteps?: ActivityTemplateStepUncheckedCreateNestedManyWithoutTenetInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutTenetInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentUncheckedCreateNestedManyWithoutTenetInput
  }

  export type TenetCreateOrConnectWithoutProductsInput = {
    where: TenetWhereUniqueInput
    create: XOR<TenetCreateWithoutProductsInput, TenetUncheckedCreateWithoutProductsInput>
  }

  export type OpportunityProductUpsertWithWhereUniqueWithoutProductTypeInput = {
    where: OpportunityProductWhereUniqueInput
    update: XOR<OpportunityProductUpdateWithoutProductTypeInput, OpportunityProductUncheckedUpdateWithoutProductTypeInput>
    create: XOR<OpportunityProductCreateWithoutProductTypeInput, OpportunityProductUncheckedCreateWithoutProductTypeInput>
  }

  export type OpportunityProductUpdateWithWhereUniqueWithoutProductTypeInput = {
    where: OpportunityProductWhereUniqueInput
    data: XOR<OpportunityProductUpdateWithoutProductTypeInput, OpportunityProductUncheckedUpdateWithoutProductTypeInput>
  }

  export type OpportunityProductUpdateManyWithWhereWithoutProductTypeInput = {
    where: OpportunityProductScalarWhereInput
    data: XOR<OpportunityProductUpdateManyMutationInput, OpportunityProductUncheckedUpdateManyWithoutProductTypeInput>
  }

  export type TenetUpsertWithoutProductsInput = {
    update: XOR<TenetUpdateWithoutProductsInput, TenetUncheckedUpdateWithoutProductsInput>
    create: XOR<TenetCreateWithoutProductsInput, TenetUncheckedCreateWithoutProductsInput>
    where?: TenetWhereInput
  }

  export type TenetUpdateToOneWithWhereWithoutProductsInput = {
    where?: TenetWhereInput
    data: XOR<TenetUpdateWithoutProductsInput, TenetUncheckedUpdateWithoutProductsInput>
  }

  export type TenetUpdateWithoutProductsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenetNestedInput
    logs?: LogUpdateManyWithoutTenetNestedInput
    contacts?: ContactUpdateManyWithoutTenetNestedInput
    activities?: ActivityUpdateManyWithoutTenetNestedInput
    addresses?: AddressUpdateManyWithoutTenetNestedInput
    contactEmails?: ContactEmailUpdateManyWithoutTenetNestedInput
    contactPhones?: ContactPhoneUpdateManyWithoutTenetNestedInput
    importantDates?: ImportantDateUpdateManyWithoutTenetNestedInput
    attachments?: AttachmentUpdateManyWithoutTenetNestedInput
    notes?: NoteUpdateManyWithoutTenetNestedInput
    auditEvents?: AuditEventUpdateManyWithoutTenetNestedInput
    contactTimelineEvents?: ContactTimelineEventUpdateManyWithoutTenetNestedInput
    activitySteps?: ActivityStepUpdateManyWithoutTenetNestedInput
    activityWaypoints?: ActivityWaypointUpdateManyWithoutTenetNestedInput
    templateAssignments?: TemplateAssignmentUpdateManyWithoutTenetNestedInput
    activityWaypointTemplates?: ActivityWaypointTemplateUpdateManyWithoutTenetNestedInput
    activityTemplates?: ActivityTemplateUpdateManyWithoutTenetNestedInput
    activityTemplateSteps?: ActivityTemplateStepUpdateManyWithoutTenetNestedInput
    opportunities?: OpportunityUpdateManyWithoutTenetNestedInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentUpdateManyWithoutTenetNestedInput
  }

  export type TenetUncheckedUpdateWithoutProductsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenetNestedInput
    logs?: LogUncheckedUpdateManyWithoutTenetNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutTenetNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutTenetNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutTenetNestedInput
    contactEmails?: ContactEmailUncheckedUpdateManyWithoutTenetNestedInput
    contactPhones?: ContactPhoneUncheckedUpdateManyWithoutTenetNestedInput
    importantDates?: ImportantDateUncheckedUpdateManyWithoutTenetNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTenetNestedInput
    notes?: NoteUncheckedUpdateManyWithoutTenetNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutTenetNestedInput
    contactTimelineEvents?: ContactTimelineEventUncheckedUpdateManyWithoutTenetNestedInput
    activitySteps?: ActivityStepUncheckedUpdateManyWithoutTenetNestedInput
    activityWaypoints?: ActivityWaypointUncheckedUpdateManyWithoutTenetNestedInput
    templateAssignments?: TemplateAssignmentUncheckedUpdateManyWithoutTenetNestedInput
    activityWaypointTemplates?: ActivityWaypointTemplateUncheckedUpdateManyWithoutTenetNestedInput
    activityTemplates?: ActivityTemplateUncheckedUpdateManyWithoutTenetNestedInput
    activityTemplateSteps?: ActivityTemplateStepUncheckedUpdateManyWithoutTenetNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutTenetNestedInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentUncheckedUpdateManyWithoutTenetNestedInput
  }

  export type TenetCreateWithoutLogsInput = {
    id: Uint8Array
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenetInput
    contacts?: ContactCreateNestedManyWithoutTenetInput
    activities?: ActivityCreateNestedManyWithoutTenetInput
    addresses?: AddressCreateNestedManyWithoutTenetInput
    contactEmails?: ContactEmailCreateNestedManyWithoutTenetInput
    contactPhones?: ContactPhoneCreateNestedManyWithoutTenetInput
    importantDates?: ImportantDateCreateNestedManyWithoutTenetInput
    attachments?: AttachmentCreateNestedManyWithoutTenetInput
    notes?: NoteCreateNestedManyWithoutTenetInput
    auditEvents?: AuditEventCreateNestedManyWithoutTenetInput
    contactTimelineEvents?: ContactTimelineEventCreateNestedManyWithoutTenetInput
    activitySteps?: ActivityStepCreateNestedManyWithoutTenetInput
    activityWaypoints?: ActivityWaypointCreateNestedManyWithoutTenetInput
    templateAssignments?: TemplateAssignmentCreateNestedManyWithoutTenetInput
    activityWaypointTemplates?: ActivityWaypointTemplateCreateNestedManyWithoutTenetInput
    activityTemplates?: ActivityTemplateCreateNestedManyWithoutTenetInput
    activityTemplateSteps?: ActivityTemplateStepCreateNestedManyWithoutTenetInput
    opportunities?: OpportunityCreateNestedManyWithoutTenetInput
    products?: ProductTypeCreateNestedManyWithoutTenetInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentCreateNestedManyWithoutTenetInput
  }

  export type TenetUncheckedCreateWithoutLogsInput = {
    id: Uint8Array
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenetInput
    contacts?: ContactUncheckedCreateNestedManyWithoutTenetInput
    activities?: ActivityUncheckedCreateNestedManyWithoutTenetInput
    addresses?: AddressUncheckedCreateNestedManyWithoutTenetInput
    contactEmails?: ContactEmailUncheckedCreateNestedManyWithoutTenetInput
    contactPhones?: ContactPhoneUncheckedCreateNestedManyWithoutTenetInput
    importantDates?: ImportantDateUncheckedCreateNestedManyWithoutTenetInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutTenetInput
    notes?: NoteUncheckedCreateNestedManyWithoutTenetInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutTenetInput
    contactTimelineEvents?: ContactTimelineEventUncheckedCreateNestedManyWithoutTenetInput
    activitySteps?: ActivityStepUncheckedCreateNestedManyWithoutTenetInput
    activityWaypoints?: ActivityWaypointUncheckedCreateNestedManyWithoutTenetInput
    templateAssignments?: TemplateAssignmentUncheckedCreateNestedManyWithoutTenetInput
    activityWaypointTemplates?: ActivityWaypointTemplateUncheckedCreateNestedManyWithoutTenetInput
    activityTemplates?: ActivityTemplateUncheckedCreateNestedManyWithoutTenetInput
    activityTemplateSteps?: ActivityTemplateStepUncheckedCreateNestedManyWithoutTenetInput
    opportunities?: OpportunityUncheckedCreateNestedManyWithoutTenetInput
    products?: ProductTypeUncheckedCreateNestedManyWithoutTenetInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentUncheckedCreateNestedManyWithoutTenetInput
  }

  export type TenetCreateOrConnectWithoutLogsInput = {
    where: TenetWhereUniqueInput
    create: XOR<TenetCreateWithoutLogsInput, TenetUncheckedCreateWithoutLogsInput>
  }

  export type TenetUpsertWithoutLogsInput = {
    update: XOR<TenetUpdateWithoutLogsInput, TenetUncheckedUpdateWithoutLogsInput>
    create: XOR<TenetCreateWithoutLogsInput, TenetUncheckedCreateWithoutLogsInput>
    where?: TenetWhereInput
  }

  export type TenetUpdateToOneWithWhereWithoutLogsInput = {
    where?: TenetWhereInput
    data: XOR<TenetUpdateWithoutLogsInput, TenetUncheckedUpdateWithoutLogsInput>
  }

  export type TenetUpdateWithoutLogsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenetNestedInput
    contacts?: ContactUpdateManyWithoutTenetNestedInput
    activities?: ActivityUpdateManyWithoutTenetNestedInput
    addresses?: AddressUpdateManyWithoutTenetNestedInput
    contactEmails?: ContactEmailUpdateManyWithoutTenetNestedInput
    contactPhones?: ContactPhoneUpdateManyWithoutTenetNestedInput
    importantDates?: ImportantDateUpdateManyWithoutTenetNestedInput
    attachments?: AttachmentUpdateManyWithoutTenetNestedInput
    notes?: NoteUpdateManyWithoutTenetNestedInput
    auditEvents?: AuditEventUpdateManyWithoutTenetNestedInput
    contactTimelineEvents?: ContactTimelineEventUpdateManyWithoutTenetNestedInput
    activitySteps?: ActivityStepUpdateManyWithoutTenetNestedInput
    activityWaypoints?: ActivityWaypointUpdateManyWithoutTenetNestedInput
    templateAssignments?: TemplateAssignmentUpdateManyWithoutTenetNestedInput
    activityWaypointTemplates?: ActivityWaypointTemplateUpdateManyWithoutTenetNestedInput
    activityTemplates?: ActivityTemplateUpdateManyWithoutTenetNestedInput
    activityTemplateSteps?: ActivityTemplateStepUpdateManyWithoutTenetNestedInput
    opportunities?: OpportunityUpdateManyWithoutTenetNestedInput
    products?: ProductTypeUpdateManyWithoutTenetNestedInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentUpdateManyWithoutTenetNestedInput
  }

  export type TenetUncheckedUpdateWithoutLogsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenetNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutTenetNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutTenetNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutTenetNestedInput
    contactEmails?: ContactEmailUncheckedUpdateManyWithoutTenetNestedInput
    contactPhones?: ContactPhoneUncheckedUpdateManyWithoutTenetNestedInput
    importantDates?: ImportantDateUncheckedUpdateManyWithoutTenetNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutTenetNestedInput
    notes?: NoteUncheckedUpdateManyWithoutTenetNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutTenetNestedInput
    contactTimelineEvents?: ContactTimelineEventUncheckedUpdateManyWithoutTenetNestedInput
    activitySteps?: ActivityStepUncheckedUpdateManyWithoutTenetNestedInput
    activityWaypoints?: ActivityWaypointUncheckedUpdateManyWithoutTenetNestedInput
    templateAssignments?: TemplateAssignmentUncheckedUpdateManyWithoutTenetNestedInput
    activityWaypointTemplates?: ActivityWaypointTemplateUncheckedUpdateManyWithoutTenetNestedInput
    activityTemplates?: ActivityTemplateUncheckedUpdateManyWithoutTenetNestedInput
    activityTemplateSteps?: ActivityTemplateStepUncheckedUpdateManyWithoutTenetNestedInput
    opportunities?: OpportunityUncheckedUpdateManyWithoutTenetNestedInput
    products?: ProductTypeUncheckedUpdateManyWithoutTenetNestedInput
    activityTemplateStepAssignment?: ActivityTemplateStepAssignmentUncheckedUpdateManyWithoutTenetNestedInput
  }

  export type UserCreateWithoutTokensInput = {
    id: Uint8Array
    email: string
    firstName: string
    lastName: string
    fullName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password: string
    enabled?: boolean
    type?: $Enums.AccessGroup
    system?: boolean
    deleted?: boolean
    deletedAt?: Date | string | null
    tenet?: TenetCreateNestedOneWithoutUsersInput
    activities?: ActivityUserJoinCreateNestedManyWithoutUserRelationInput
    notes?: NoteCreateNestedManyWithoutAuthorInput
    waypoints?: UserWaypointJoinCreateNestedManyWithoutUserRelationInput
    events?: ContactTimelineEventCreateNestedManyWithoutUserInput
    auditEvents?: AuditEventCreateNestedManyWithoutUserInput
    templateAssignments?: TemplateAssignmentCreateNestedManyWithoutSpecificUserInput
    assignedActivities?: ActivityCreateNestedManyWithoutAssignedByInput
    opportunities?: UserOpportunityJoinCreateNestedManyWithoutUserRelationInput
    activitySteps?: ActivityStepUserJoinCreateNestedManyWithoutUserRelationInput
    templateStepAssignments?: ActivityTemplateStepAssignmentCreateNestedManyWithoutSpecificUserInput
  }

  export type UserUncheckedCreateWithoutTokensInput = {
    id: Uint8Array
    email: string
    firstName: string
    lastName: string
    fullName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password: string
    enabled?: boolean
    type?: $Enums.AccessGroup
    tenetId?: Uint8Array | null
    system?: boolean
    deleted?: boolean
    deletedAt?: Date | string | null
    activities?: ActivityUserJoinUncheckedCreateNestedManyWithoutUserRelationInput
    notes?: NoteUncheckedCreateNestedManyWithoutAuthorInput
    waypoints?: UserWaypointJoinUncheckedCreateNestedManyWithoutUserRelationInput
    events?: ContactTimelineEventUncheckedCreateNestedManyWithoutUserInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutUserInput
    templateAssignments?: TemplateAssignmentUncheckedCreateNestedManyWithoutSpecificUserInput
    assignedActivities?: ActivityUncheckedCreateNestedManyWithoutAssignedByInput
    opportunities?: UserOpportunityJoinUncheckedCreateNestedManyWithoutUserRelationInput
    activitySteps?: ActivityStepUserJoinUncheckedCreateNestedManyWithoutUserRelationInput
    templateStepAssignments?: ActivityTemplateStepAssignmentUncheckedCreateNestedManyWithoutSpecificUserInput
  }

  export type UserCreateOrConnectWithoutTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTokensInput, UserUncheckedCreateWithoutTokensInput>
  }

  export type UserUpsertWithoutTokensInput = {
    update: XOR<UserUpdateWithoutTokensInput, UserUncheckedUpdateWithoutTokensInput>
    create: XOR<UserCreateWithoutTokensInput, UserUncheckedCreateWithoutTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTokensInput, UserUncheckedUpdateWithoutTokensInput>
  }

  export type UserUpdateWithoutTokensInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumAccessGroupFieldUpdateOperationsInput | $Enums.AccessGroup
    system?: BoolFieldUpdateOperationsInput | boolean
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenet?: TenetUpdateOneWithoutUsersNestedInput
    activities?: ActivityUserJoinUpdateManyWithoutUserRelationNestedInput
    notes?: NoteUpdateManyWithoutAuthorNestedInput
    waypoints?: UserWaypointJoinUpdateManyWithoutUserRelationNestedInput
    events?: ContactTimelineEventUpdateManyWithoutUserNestedInput
    auditEvents?: AuditEventUpdateManyWithoutUserNestedInput
    templateAssignments?: TemplateAssignmentUpdateManyWithoutSpecificUserNestedInput
    assignedActivities?: ActivityUpdateManyWithoutAssignedByNestedInput
    opportunities?: UserOpportunityJoinUpdateManyWithoutUserRelationNestedInput
    activitySteps?: ActivityStepUserJoinUpdateManyWithoutUserRelationNestedInput
    templateStepAssignments?: ActivityTemplateStepAssignmentUpdateManyWithoutSpecificUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTokensInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumAccessGroupFieldUpdateOperationsInput | $Enums.AccessGroup
    tenetId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    system?: BoolFieldUpdateOperationsInput | boolean
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activities?: ActivityUserJoinUncheckedUpdateManyWithoutUserRelationNestedInput
    notes?: NoteUncheckedUpdateManyWithoutAuthorNestedInput
    waypoints?: UserWaypointJoinUncheckedUpdateManyWithoutUserRelationNestedInput
    events?: ContactTimelineEventUncheckedUpdateManyWithoutUserNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutUserNestedInput
    templateAssignments?: TemplateAssignmentUncheckedUpdateManyWithoutSpecificUserNestedInput
    assignedActivities?: ActivityUncheckedUpdateManyWithoutAssignedByNestedInput
    opportunities?: UserOpportunityJoinUncheckedUpdateManyWithoutUserRelationNestedInput
    activitySteps?: ActivityStepUserJoinUncheckedUpdateManyWithoutUserRelationNestedInput
    templateStepAssignments?: ActivityTemplateStepAssignmentUncheckedUpdateManyWithoutSpecificUserNestedInput
  }

  export type WrappedObjectCreateWithoutTestObjectInput = {
    id: Uint8Array
    persisted?: string | null
  }

  export type WrappedObjectUncheckedCreateWithoutTestObjectInput = {
    id: Uint8Array
    persisted?: string | null
  }

  export type WrappedObjectCreateOrConnectWithoutTestObjectInput = {
    where: WrappedObjectWhereUniqueInput
    create: XOR<WrappedObjectCreateWithoutTestObjectInput, WrappedObjectUncheckedCreateWithoutTestObjectInput>
  }

  export type WrappedObjectCreateManyTestObjectInputEnvelope = {
    data: WrappedObjectCreateManyTestObjectInput | WrappedObjectCreateManyTestObjectInput[]
    skipDuplicates?: boolean
  }

  export type JoinTestObjectCreateWithoutTestObjectRelationInput = {
    joinProperty: string
    joinedObjectRelation: JoinedObject1CreateNestedOneWithoutTestObjectsInput
  }

  export type JoinTestObjectUncheckedCreateWithoutTestObjectRelationInput = {
    joinedObjectId: Uint8Array
    joinProperty: string
  }

  export type JoinTestObjectCreateOrConnectWithoutTestObjectRelationInput = {
    where: JoinTestObjectWhereUniqueInput
    create: XOR<JoinTestObjectCreateWithoutTestObjectRelationInput, JoinTestObjectUncheckedCreateWithoutTestObjectRelationInput>
  }

  export type JoinTestObjectCreateManyTestObjectRelationInputEnvelope = {
    data: JoinTestObjectCreateManyTestObjectRelationInput | JoinTestObjectCreateManyTestObjectRelationInput[]
    skipDuplicates?: boolean
  }

  export type JoinTestObject2CreateWithoutTestObjectRelationInput = {
    id: Uint8Array
    joinProperty: string
    joinedObjectRelation: JoinedObject2CreateNestedOneWithoutTestObjectsInput
  }

  export type JoinTestObject2UncheckedCreateWithoutTestObjectRelationInput = {
    id: Uint8Array
    joinedObjectId: Uint8Array
    joinProperty: string
  }

  export type JoinTestObject2CreateOrConnectWithoutTestObjectRelationInput = {
    where: JoinTestObject2WhereUniqueInput
    create: XOR<JoinTestObject2CreateWithoutTestObjectRelationInput, JoinTestObject2UncheckedCreateWithoutTestObjectRelationInput>
  }

  export type JoinTestObject2CreateManyTestObjectRelationInputEnvelope = {
    data: JoinTestObject2CreateManyTestObjectRelationInput | JoinTestObject2CreateManyTestObjectRelationInput[]
    skipDuplicates?: boolean
  }

  export type WrappedObjectUpsertWithWhereUniqueWithoutTestObjectInput = {
    where: WrappedObjectWhereUniqueInput
    update: XOR<WrappedObjectUpdateWithoutTestObjectInput, WrappedObjectUncheckedUpdateWithoutTestObjectInput>
    create: XOR<WrappedObjectCreateWithoutTestObjectInput, WrappedObjectUncheckedCreateWithoutTestObjectInput>
  }

  export type WrappedObjectUpdateWithWhereUniqueWithoutTestObjectInput = {
    where: WrappedObjectWhereUniqueInput
    data: XOR<WrappedObjectUpdateWithoutTestObjectInput, WrappedObjectUncheckedUpdateWithoutTestObjectInput>
  }

  export type WrappedObjectUpdateManyWithWhereWithoutTestObjectInput = {
    where: WrappedObjectScalarWhereInput
    data: XOR<WrappedObjectUpdateManyMutationInput, WrappedObjectUncheckedUpdateManyWithoutTestObjectInput>
  }

  export type WrappedObjectScalarWhereInput = {
    AND?: WrappedObjectScalarWhereInput | WrappedObjectScalarWhereInput[]
    OR?: WrappedObjectScalarWhereInput[]
    NOT?: WrappedObjectScalarWhereInput | WrappedObjectScalarWhereInput[]
    id?: BytesFilter<"WrappedObject"> | Uint8Array
    persisted?: StringNullableFilter<"WrappedObject"> | string | null
    testObjectId?: BytesFilter<"WrappedObject"> | Uint8Array
  }

  export type JoinTestObjectUpsertWithWhereUniqueWithoutTestObjectRelationInput = {
    where: JoinTestObjectWhereUniqueInput
    update: XOR<JoinTestObjectUpdateWithoutTestObjectRelationInput, JoinTestObjectUncheckedUpdateWithoutTestObjectRelationInput>
    create: XOR<JoinTestObjectCreateWithoutTestObjectRelationInput, JoinTestObjectUncheckedCreateWithoutTestObjectRelationInput>
  }

  export type JoinTestObjectUpdateWithWhereUniqueWithoutTestObjectRelationInput = {
    where: JoinTestObjectWhereUniqueInput
    data: XOR<JoinTestObjectUpdateWithoutTestObjectRelationInput, JoinTestObjectUncheckedUpdateWithoutTestObjectRelationInput>
  }

  export type JoinTestObjectUpdateManyWithWhereWithoutTestObjectRelationInput = {
    where: JoinTestObjectScalarWhereInput
    data: XOR<JoinTestObjectUpdateManyMutationInput, JoinTestObjectUncheckedUpdateManyWithoutTestObjectRelationInput>
  }

  export type JoinTestObjectScalarWhereInput = {
    AND?: JoinTestObjectScalarWhereInput | JoinTestObjectScalarWhereInput[]
    OR?: JoinTestObjectScalarWhereInput[]
    NOT?: JoinTestObjectScalarWhereInput | JoinTestObjectScalarWhereInput[]
    testObjectId?: BytesFilter<"JoinTestObject"> | Uint8Array
    joinedObjectId?: BytesFilter<"JoinTestObject"> | Uint8Array
    joinProperty?: StringFilter<"JoinTestObject"> | string
  }

  export type JoinTestObject2UpsertWithWhereUniqueWithoutTestObjectRelationInput = {
    where: JoinTestObject2WhereUniqueInput
    update: XOR<JoinTestObject2UpdateWithoutTestObjectRelationInput, JoinTestObject2UncheckedUpdateWithoutTestObjectRelationInput>
    create: XOR<JoinTestObject2CreateWithoutTestObjectRelationInput, JoinTestObject2UncheckedCreateWithoutTestObjectRelationInput>
  }

  export type JoinTestObject2UpdateWithWhereUniqueWithoutTestObjectRelationInput = {
    where: JoinTestObject2WhereUniqueInput
    data: XOR<JoinTestObject2UpdateWithoutTestObjectRelationInput, JoinTestObject2UncheckedUpdateWithoutTestObjectRelationInput>
  }

  export type JoinTestObject2UpdateManyWithWhereWithoutTestObjectRelationInput = {
    where: JoinTestObject2ScalarWhereInput
    data: XOR<JoinTestObject2UpdateManyMutationInput, JoinTestObject2UncheckedUpdateManyWithoutTestObjectRelationInput>
  }

  export type JoinTestObject2ScalarWhereInput = {
    AND?: JoinTestObject2ScalarWhereInput | JoinTestObject2ScalarWhereInput[]
    OR?: JoinTestObject2ScalarWhereInput[]
    NOT?: JoinTestObject2ScalarWhereInput | JoinTestObject2ScalarWhereInput[]
    id?: BytesFilter<"JoinTestObject2"> | Uint8Array
    testObjectId?: BytesFilter<"JoinTestObject2"> | Uint8Array
    joinedObjectId?: BytesFilter<"JoinTestObject2"> | Uint8Array
    joinProperty?: StringFilter<"JoinTestObject2"> | string
  }

  export type TestObjectCreateWithoutWrappedInput = {
    id: Uint8Array
    required: string
    persisted?: string | null
    join1?: JoinTestObjectCreateNestedManyWithoutTestObjectRelationInput
    join2?: JoinTestObject2CreateNestedManyWithoutTestObjectRelationInput
  }

  export type TestObjectUncheckedCreateWithoutWrappedInput = {
    id: Uint8Array
    required: string
    persisted?: string | null
    join1?: JoinTestObjectUncheckedCreateNestedManyWithoutTestObjectRelationInput
    join2?: JoinTestObject2UncheckedCreateNestedManyWithoutTestObjectRelationInput
  }

  export type TestObjectCreateOrConnectWithoutWrappedInput = {
    where: TestObjectWhereUniqueInput
    create: XOR<TestObjectCreateWithoutWrappedInput, TestObjectUncheckedCreateWithoutWrappedInput>
  }

  export type TestObjectUpsertWithoutWrappedInput = {
    update: XOR<TestObjectUpdateWithoutWrappedInput, TestObjectUncheckedUpdateWithoutWrappedInput>
    create: XOR<TestObjectCreateWithoutWrappedInput, TestObjectUncheckedCreateWithoutWrappedInput>
    where?: TestObjectWhereInput
  }

  export type TestObjectUpdateToOneWithWhereWithoutWrappedInput = {
    where?: TestObjectWhereInput
    data: XOR<TestObjectUpdateWithoutWrappedInput, TestObjectUncheckedUpdateWithoutWrappedInput>
  }

  export type TestObjectUpdateWithoutWrappedInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    required?: StringFieldUpdateOperationsInput | string
    persisted?: NullableStringFieldUpdateOperationsInput | string | null
    join1?: JoinTestObjectUpdateManyWithoutTestObjectRelationNestedInput
    join2?: JoinTestObject2UpdateManyWithoutTestObjectRelationNestedInput
  }

  export type TestObjectUncheckedUpdateWithoutWrappedInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    required?: StringFieldUpdateOperationsInput | string
    persisted?: NullableStringFieldUpdateOperationsInput | string | null
    join1?: JoinTestObjectUncheckedUpdateManyWithoutTestObjectRelationNestedInput
    join2?: JoinTestObject2UncheckedUpdateManyWithoutTestObjectRelationNestedInput
  }

  export type TestObjectCreateWithoutJoin1Input = {
    id: Uint8Array
    required: string
    persisted?: string | null
    wrapped?: WrappedObjectCreateNestedManyWithoutTestObjectInput
    join2?: JoinTestObject2CreateNestedManyWithoutTestObjectRelationInput
  }

  export type TestObjectUncheckedCreateWithoutJoin1Input = {
    id: Uint8Array
    required: string
    persisted?: string | null
    wrapped?: WrappedObjectUncheckedCreateNestedManyWithoutTestObjectInput
    join2?: JoinTestObject2UncheckedCreateNestedManyWithoutTestObjectRelationInput
  }

  export type TestObjectCreateOrConnectWithoutJoin1Input = {
    where: TestObjectWhereUniqueInput
    create: XOR<TestObjectCreateWithoutJoin1Input, TestObjectUncheckedCreateWithoutJoin1Input>
  }

  export type JoinedObject1CreateWithoutTestObjectsInput = {
    id: Uint8Array
    persisted?: string | null
  }

  export type JoinedObject1UncheckedCreateWithoutTestObjectsInput = {
    id: Uint8Array
    persisted?: string | null
  }

  export type JoinedObject1CreateOrConnectWithoutTestObjectsInput = {
    where: JoinedObject1WhereUniqueInput
    create: XOR<JoinedObject1CreateWithoutTestObjectsInput, JoinedObject1UncheckedCreateWithoutTestObjectsInput>
  }

  export type TestObjectUpsertWithoutJoin1Input = {
    update: XOR<TestObjectUpdateWithoutJoin1Input, TestObjectUncheckedUpdateWithoutJoin1Input>
    create: XOR<TestObjectCreateWithoutJoin1Input, TestObjectUncheckedCreateWithoutJoin1Input>
    where?: TestObjectWhereInput
  }

  export type TestObjectUpdateToOneWithWhereWithoutJoin1Input = {
    where?: TestObjectWhereInput
    data: XOR<TestObjectUpdateWithoutJoin1Input, TestObjectUncheckedUpdateWithoutJoin1Input>
  }

  export type TestObjectUpdateWithoutJoin1Input = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    required?: StringFieldUpdateOperationsInput | string
    persisted?: NullableStringFieldUpdateOperationsInput | string | null
    wrapped?: WrappedObjectUpdateManyWithoutTestObjectNestedInput
    join2?: JoinTestObject2UpdateManyWithoutTestObjectRelationNestedInput
  }

  export type TestObjectUncheckedUpdateWithoutJoin1Input = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    required?: StringFieldUpdateOperationsInput | string
    persisted?: NullableStringFieldUpdateOperationsInput | string | null
    wrapped?: WrappedObjectUncheckedUpdateManyWithoutTestObjectNestedInput
    join2?: JoinTestObject2UncheckedUpdateManyWithoutTestObjectRelationNestedInput
  }

  export type JoinedObject1UpsertWithoutTestObjectsInput = {
    update: XOR<JoinedObject1UpdateWithoutTestObjectsInput, JoinedObject1UncheckedUpdateWithoutTestObjectsInput>
    create: XOR<JoinedObject1CreateWithoutTestObjectsInput, JoinedObject1UncheckedCreateWithoutTestObjectsInput>
    where?: JoinedObject1WhereInput
  }

  export type JoinedObject1UpdateToOneWithWhereWithoutTestObjectsInput = {
    where?: JoinedObject1WhereInput
    data: XOR<JoinedObject1UpdateWithoutTestObjectsInput, JoinedObject1UncheckedUpdateWithoutTestObjectsInput>
  }

  export type JoinedObject1UpdateWithoutTestObjectsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    persisted?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JoinedObject1UncheckedUpdateWithoutTestObjectsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    persisted?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TestObjectCreateWithoutJoin2Input = {
    id: Uint8Array
    required: string
    persisted?: string | null
    wrapped?: WrappedObjectCreateNestedManyWithoutTestObjectInput
    join1?: JoinTestObjectCreateNestedManyWithoutTestObjectRelationInput
  }

  export type TestObjectUncheckedCreateWithoutJoin2Input = {
    id: Uint8Array
    required: string
    persisted?: string | null
    wrapped?: WrappedObjectUncheckedCreateNestedManyWithoutTestObjectInput
    join1?: JoinTestObjectUncheckedCreateNestedManyWithoutTestObjectRelationInput
  }

  export type TestObjectCreateOrConnectWithoutJoin2Input = {
    where: TestObjectWhereUniqueInput
    create: XOR<TestObjectCreateWithoutJoin2Input, TestObjectUncheckedCreateWithoutJoin2Input>
  }

  export type JoinedObject2CreateWithoutTestObjectsInput = {
    id: Uint8Array
    persisted?: string | null
  }

  export type JoinedObject2UncheckedCreateWithoutTestObjectsInput = {
    id: Uint8Array
    persisted?: string | null
  }

  export type JoinedObject2CreateOrConnectWithoutTestObjectsInput = {
    where: JoinedObject2WhereUniqueInput
    create: XOR<JoinedObject2CreateWithoutTestObjectsInput, JoinedObject2UncheckedCreateWithoutTestObjectsInput>
  }

  export type TestObjectUpsertWithoutJoin2Input = {
    update: XOR<TestObjectUpdateWithoutJoin2Input, TestObjectUncheckedUpdateWithoutJoin2Input>
    create: XOR<TestObjectCreateWithoutJoin2Input, TestObjectUncheckedCreateWithoutJoin2Input>
    where?: TestObjectWhereInput
  }

  export type TestObjectUpdateToOneWithWhereWithoutJoin2Input = {
    where?: TestObjectWhereInput
    data: XOR<TestObjectUpdateWithoutJoin2Input, TestObjectUncheckedUpdateWithoutJoin2Input>
  }

  export type TestObjectUpdateWithoutJoin2Input = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    required?: StringFieldUpdateOperationsInput | string
    persisted?: NullableStringFieldUpdateOperationsInput | string | null
    wrapped?: WrappedObjectUpdateManyWithoutTestObjectNestedInput
    join1?: JoinTestObjectUpdateManyWithoutTestObjectRelationNestedInput
  }

  export type TestObjectUncheckedUpdateWithoutJoin2Input = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    required?: StringFieldUpdateOperationsInput | string
    persisted?: NullableStringFieldUpdateOperationsInput | string | null
    wrapped?: WrappedObjectUncheckedUpdateManyWithoutTestObjectNestedInput
    join1?: JoinTestObjectUncheckedUpdateManyWithoutTestObjectRelationNestedInput
  }

  export type JoinedObject2UpsertWithoutTestObjectsInput = {
    update: XOR<JoinedObject2UpdateWithoutTestObjectsInput, JoinedObject2UncheckedUpdateWithoutTestObjectsInput>
    create: XOR<JoinedObject2CreateWithoutTestObjectsInput, JoinedObject2UncheckedCreateWithoutTestObjectsInput>
    where?: JoinedObject2WhereInput
  }

  export type JoinedObject2UpdateToOneWithWhereWithoutTestObjectsInput = {
    where?: JoinedObject2WhereInput
    data: XOR<JoinedObject2UpdateWithoutTestObjectsInput, JoinedObject2UncheckedUpdateWithoutTestObjectsInput>
  }

  export type JoinedObject2UpdateWithoutTestObjectsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    persisted?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JoinedObject2UncheckedUpdateWithoutTestObjectsInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    persisted?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JoinTestObjectCreateWithoutJoinedObjectRelationInput = {
    joinProperty: string
    testObjectRelation: TestObjectCreateNestedOneWithoutJoin1Input
  }

  export type JoinTestObjectUncheckedCreateWithoutJoinedObjectRelationInput = {
    testObjectId: Uint8Array
    joinProperty: string
  }

  export type JoinTestObjectCreateOrConnectWithoutJoinedObjectRelationInput = {
    where: JoinTestObjectWhereUniqueInput
    create: XOR<JoinTestObjectCreateWithoutJoinedObjectRelationInput, JoinTestObjectUncheckedCreateWithoutJoinedObjectRelationInput>
  }

  export type JoinTestObjectCreateManyJoinedObjectRelationInputEnvelope = {
    data: JoinTestObjectCreateManyJoinedObjectRelationInput | JoinTestObjectCreateManyJoinedObjectRelationInput[]
    skipDuplicates?: boolean
  }

  export type JoinTestObjectUpsertWithWhereUniqueWithoutJoinedObjectRelationInput = {
    where: JoinTestObjectWhereUniqueInput
    update: XOR<JoinTestObjectUpdateWithoutJoinedObjectRelationInput, JoinTestObjectUncheckedUpdateWithoutJoinedObjectRelationInput>
    create: XOR<JoinTestObjectCreateWithoutJoinedObjectRelationInput, JoinTestObjectUncheckedCreateWithoutJoinedObjectRelationInput>
  }

  export type JoinTestObjectUpdateWithWhereUniqueWithoutJoinedObjectRelationInput = {
    where: JoinTestObjectWhereUniqueInput
    data: XOR<JoinTestObjectUpdateWithoutJoinedObjectRelationInput, JoinTestObjectUncheckedUpdateWithoutJoinedObjectRelationInput>
  }

  export type JoinTestObjectUpdateManyWithWhereWithoutJoinedObjectRelationInput = {
    where: JoinTestObjectScalarWhereInput
    data: XOR<JoinTestObjectUpdateManyMutationInput, JoinTestObjectUncheckedUpdateManyWithoutJoinedObjectRelationInput>
  }

  export type JoinTestObject2CreateWithoutJoinedObjectRelationInput = {
    id: Uint8Array
    joinProperty: string
    testObjectRelation: TestObjectCreateNestedOneWithoutJoin2Input
  }

  export type JoinTestObject2UncheckedCreateWithoutJoinedObjectRelationInput = {
    id: Uint8Array
    testObjectId: Uint8Array
    joinProperty: string
  }

  export type JoinTestObject2CreateOrConnectWithoutJoinedObjectRelationInput = {
    where: JoinTestObject2WhereUniqueInput
    create: XOR<JoinTestObject2CreateWithoutJoinedObjectRelationInput, JoinTestObject2UncheckedCreateWithoutJoinedObjectRelationInput>
  }

  export type JoinTestObject2CreateManyJoinedObjectRelationInputEnvelope = {
    data: JoinTestObject2CreateManyJoinedObjectRelationInput | JoinTestObject2CreateManyJoinedObjectRelationInput[]
    skipDuplicates?: boolean
  }

  export type JoinTestObject2UpsertWithWhereUniqueWithoutJoinedObjectRelationInput = {
    where: JoinTestObject2WhereUniqueInput
    update: XOR<JoinTestObject2UpdateWithoutJoinedObjectRelationInput, JoinTestObject2UncheckedUpdateWithoutJoinedObjectRelationInput>
    create: XOR<JoinTestObject2CreateWithoutJoinedObjectRelationInput, JoinTestObject2UncheckedCreateWithoutJoinedObjectRelationInput>
  }

  export type JoinTestObject2UpdateWithWhereUniqueWithoutJoinedObjectRelationInput = {
    where: JoinTestObject2WhereUniqueInput
    data: XOR<JoinTestObject2UpdateWithoutJoinedObjectRelationInput, JoinTestObject2UncheckedUpdateWithoutJoinedObjectRelationInput>
  }

  export type JoinTestObject2UpdateManyWithWhereWithoutJoinedObjectRelationInput = {
    where: JoinTestObject2ScalarWhereInput
    data: XOR<JoinTestObject2UpdateManyMutationInput, JoinTestObject2UncheckedUpdateManyWithoutJoinedObjectRelationInput>
  }

  export type SelfReferencialJoinModelCreateWithoutJoinsAsSourceInput = {
    id: Uint8Array
    joinsAsTarget?: JoinSelfReferenceCreateNestedManyWithoutTargetInput
  }

  export type SelfReferencialJoinModelUncheckedCreateWithoutJoinsAsSourceInput = {
    id: Uint8Array
    joinsAsTarget?: JoinSelfReferenceUncheckedCreateNestedManyWithoutTargetInput
  }

  export type SelfReferencialJoinModelCreateOrConnectWithoutJoinsAsSourceInput = {
    where: SelfReferencialJoinModelWhereUniqueInput
    create: XOR<SelfReferencialJoinModelCreateWithoutJoinsAsSourceInput, SelfReferencialJoinModelUncheckedCreateWithoutJoinsAsSourceInput>
  }

  export type SelfReferencialJoinModelCreateWithoutJoinsAsTargetInput = {
    id: Uint8Array
    joinsAsSource?: JoinSelfReferenceCreateNestedManyWithoutSourceInput
  }

  export type SelfReferencialJoinModelUncheckedCreateWithoutJoinsAsTargetInput = {
    id: Uint8Array
    joinsAsSource?: JoinSelfReferenceUncheckedCreateNestedManyWithoutSourceInput
  }

  export type SelfReferencialJoinModelCreateOrConnectWithoutJoinsAsTargetInput = {
    where: SelfReferencialJoinModelWhereUniqueInput
    create: XOR<SelfReferencialJoinModelCreateWithoutJoinsAsTargetInput, SelfReferencialJoinModelUncheckedCreateWithoutJoinsAsTargetInput>
  }

  export type SelfReferencialJoinModelUpsertWithoutJoinsAsSourceInput = {
    update: XOR<SelfReferencialJoinModelUpdateWithoutJoinsAsSourceInput, SelfReferencialJoinModelUncheckedUpdateWithoutJoinsAsSourceInput>
    create: XOR<SelfReferencialJoinModelCreateWithoutJoinsAsSourceInput, SelfReferencialJoinModelUncheckedCreateWithoutJoinsAsSourceInput>
    where?: SelfReferencialJoinModelWhereInput
  }

  export type SelfReferencialJoinModelUpdateToOneWithWhereWithoutJoinsAsSourceInput = {
    where?: SelfReferencialJoinModelWhereInput
    data: XOR<SelfReferencialJoinModelUpdateWithoutJoinsAsSourceInput, SelfReferencialJoinModelUncheckedUpdateWithoutJoinsAsSourceInput>
  }

  export type SelfReferencialJoinModelUpdateWithoutJoinsAsSourceInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    joinsAsTarget?: JoinSelfReferenceUpdateManyWithoutTargetNestedInput
  }

  export type SelfReferencialJoinModelUncheckedUpdateWithoutJoinsAsSourceInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    joinsAsTarget?: JoinSelfReferenceUncheckedUpdateManyWithoutTargetNestedInput
  }

  export type SelfReferencialJoinModelUpsertWithoutJoinsAsTargetInput = {
    update: XOR<SelfReferencialJoinModelUpdateWithoutJoinsAsTargetInput, SelfReferencialJoinModelUncheckedUpdateWithoutJoinsAsTargetInput>
    create: XOR<SelfReferencialJoinModelCreateWithoutJoinsAsTargetInput, SelfReferencialJoinModelUncheckedCreateWithoutJoinsAsTargetInput>
    where?: SelfReferencialJoinModelWhereInput
  }

  export type SelfReferencialJoinModelUpdateToOneWithWhereWithoutJoinsAsTargetInput = {
    where?: SelfReferencialJoinModelWhereInput
    data: XOR<SelfReferencialJoinModelUpdateWithoutJoinsAsTargetInput, SelfReferencialJoinModelUncheckedUpdateWithoutJoinsAsTargetInput>
  }

  export type SelfReferencialJoinModelUpdateWithoutJoinsAsTargetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    joinsAsSource?: JoinSelfReferenceUpdateManyWithoutSourceNestedInput
  }

  export type SelfReferencialJoinModelUncheckedUpdateWithoutJoinsAsTargetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    joinsAsSource?: JoinSelfReferenceUncheckedUpdateManyWithoutSourceNestedInput
  }

  export type JoinSelfReferenceCreateWithoutSourceInput = {
    id: Uint8Array
    joinProperty: string
    target: SelfReferencialJoinModelCreateNestedOneWithoutJoinsAsTargetInput
  }

  export type JoinSelfReferenceUncheckedCreateWithoutSourceInput = {
    id: Uint8Array
    targetId: Uint8Array
    joinProperty: string
  }

  export type JoinSelfReferenceCreateOrConnectWithoutSourceInput = {
    where: JoinSelfReferenceWhereUniqueInput
    create: XOR<JoinSelfReferenceCreateWithoutSourceInput, JoinSelfReferenceUncheckedCreateWithoutSourceInput>
  }

  export type JoinSelfReferenceCreateManySourceInputEnvelope = {
    data: JoinSelfReferenceCreateManySourceInput | JoinSelfReferenceCreateManySourceInput[]
    skipDuplicates?: boolean
  }

  export type JoinSelfReferenceCreateWithoutTargetInput = {
    id: Uint8Array
    joinProperty: string
    source: SelfReferencialJoinModelCreateNestedOneWithoutJoinsAsSourceInput
  }

  export type JoinSelfReferenceUncheckedCreateWithoutTargetInput = {
    id: Uint8Array
    sourceId: Uint8Array
    joinProperty: string
  }

  export type JoinSelfReferenceCreateOrConnectWithoutTargetInput = {
    where: JoinSelfReferenceWhereUniqueInput
    create: XOR<JoinSelfReferenceCreateWithoutTargetInput, JoinSelfReferenceUncheckedCreateWithoutTargetInput>
  }

  export type JoinSelfReferenceCreateManyTargetInputEnvelope = {
    data: JoinSelfReferenceCreateManyTargetInput | JoinSelfReferenceCreateManyTargetInput[]
    skipDuplicates?: boolean
  }

  export type JoinSelfReferenceUpsertWithWhereUniqueWithoutSourceInput = {
    where: JoinSelfReferenceWhereUniqueInput
    update: XOR<JoinSelfReferenceUpdateWithoutSourceInput, JoinSelfReferenceUncheckedUpdateWithoutSourceInput>
    create: XOR<JoinSelfReferenceCreateWithoutSourceInput, JoinSelfReferenceUncheckedCreateWithoutSourceInput>
  }

  export type JoinSelfReferenceUpdateWithWhereUniqueWithoutSourceInput = {
    where: JoinSelfReferenceWhereUniqueInput
    data: XOR<JoinSelfReferenceUpdateWithoutSourceInput, JoinSelfReferenceUncheckedUpdateWithoutSourceInput>
  }

  export type JoinSelfReferenceUpdateManyWithWhereWithoutSourceInput = {
    where: JoinSelfReferenceScalarWhereInput
    data: XOR<JoinSelfReferenceUpdateManyMutationInput, JoinSelfReferenceUncheckedUpdateManyWithoutSourceInput>
  }

  export type JoinSelfReferenceScalarWhereInput = {
    AND?: JoinSelfReferenceScalarWhereInput | JoinSelfReferenceScalarWhereInput[]
    OR?: JoinSelfReferenceScalarWhereInput[]
    NOT?: JoinSelfReferenceScalarWhereInput | JoinSelfReferenceScalarWhereInput[]
    id?: BytesFilter<"JoinSelfReference"> | Uint8Array
    sourceId?: BytesFilter<"JoinSelfReference"> | Uint8Array
    targetId?: BytesFilter<"JoinSelfReference"> | Uint8Array
    joinProperty?: StringFilter<"JoinSelfReference"> | string
  }

  export type JoinSelfReferenceUpsertWithWhereUniqueWithoutTargetInput = {
    where: JoinSelfReferenceWhereUniqueInput
    update: XOR<JoinSelfReferenceUpdateWithoutTargetInput, JoinSelfReferenceUncheckedUpdateWithoutTargetInput>
    create: XOR<JoinSelfReferenceCreateWithoutTargetInput, JoinSelfReferenceUncheckedCreateWithoutTargetInput>
  }

  export type JoinSelfReferenceUpdateWithWhereUniqueWithoutTargetInput = {
    where: JoinSelfReferenceWhereUniqueInput
    data: XOR<JoinSelfReferenceUpdateWithoutTargetInput, JoinSelfReferenceUncheckedUpdateWithoutTargetInput>
  }

  export type JoinSelfReferenceUpdateManyWithWhereWithoutTargetInput = {
    where: JoinSelfReferenceScalarWhereInput
    data: XOR<JoinSelfReferenceUpdateManyMutationInput, JoinSelfReferenceUncheckedUpdateManyWithoutTargetInput>
  }

  export type UserCreateManyTenetInput = {
    id: Uint8Array
    email: string
    firstName: string
    lastName: string
    fullName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    password: string
    enabled?: boolean
    type?: $Enums.AccessGroup
    system?: boolean
    deleted?: boolean
    deletedAt?: Date | string | null
  }

  export type LogCreateManyTenetInput = {
    id: Uint8Array
    userEmail?: string | null
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    severity?: $Enums.LogLevel
    stacktrace?: string | null
    source?: string | null
    secureDetails?: string | null
  }

  export type ContactCreateManyTenetInput = {
    id: Uint8Array
    firstName?: string | null
    lastName: string
    fullName: string
    importantNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.ContactType
    status: $Enums.ContactStatus
    lifecycleStage?: $Enums.LifecycleStage | null
    lastContactedDate?: Date | string | null
    followUpDate?: Date | string | null
    householdId?: Uint8Array | null
    householdStatus?: $Enums.HouseholdRelationshipStatus | null
    companyId?: Uint8Array | null
    position?: string | null
    companyStatus?: $Enums.CompanyRelationshipStatus | null
    headOfHouseholdId?: Uint8Array | null
    industry?: string | null
    website?: string | null
    size?: number | null
    primaryContactId?: Uint8Array | null
    deleted?: boolean
    deletedAt?: Date | string | null
  }

  export type ActivityCreateManyTenetInput = {
    id: Uint8Array
    title: string
    type: $Enums.ActivityType
    parentActivityId?: Uint8Array | null
    parentWaypointId?: Uint8Array | null
    templateId?: Uint8Array | null
    taskScheduleType?: $Enums.TaskScheduleType | null
    startDate: Date | string
    endDate: Date | string
    completedAt?: Date | string | null
    description?: string | null
    priority?: $Enums.ActivityPriority
    status: $Enums.ActivityStatus
    assignedById: Uint8Array
    phoneNumber?: string | null
    location?: string | null
    holdReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean
    deletedAt?: Date | string | null
    order?: number | null
    opportunityId?: Uint8Array | null
  }

  export type AddressCreateManyTenetInput = {
    id: Uint8Array
    street: string
    city: string
    state: string
    zip: string
    country: string
    type: $Enums.AddressType
    primary?: boolean
    contactId: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
    timezone?: string | null
  }

  export type ContactEmailCreateManyTenetInput = {
    id: Uint8Array
    email: string
    isPrimary?: boolean
    contactId: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactPhoneCreateManyTenetInput = {
    id: Uint8Array
    number: string
    type: $Enums.PhoneType
    isPrimary?: boolean
    contactId: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImportantDateCreateManyTenetInput = {
    id: Uint8Array
    date: Date | string
    type: $Enums.ImportantDateType
    contactId: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttachmentCreateManyTenetInput = {
    id: Uint8Array
    name: string
    location: string
    activityId?: Uint8Array | null
  }

  export type NoteCreateManyTenetInput = {
    id: Uint8Array
    content: string
    waypointId?: Uint8Array | null
    activityId?: Uint8Array | null
    contactId?: Uint8Array | null
    opportunityId?: Uint8Array | null
    authorId: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean
    deletedAt?: Date | string | null
    noteType?: $Enums.NoteType
  }

  export type AuditEventCreateManyTenetInput = {
    id: Uint8Array
    userId: Uint8Array
    type: $Enums.AuditEventType
    details?: string | null
    referenceId: Uint8Array
    reference: $Enums.Auditable
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactTimelineEventCreateManyTenetInput = {
    id: Uint8Array
    activityId?: Uint8Array | null
    waypointId?: Uint8Array | null
    opportunityId?: Uint8Array | null
    noteId?: Uint8Array | null
    extraInfo?: string | null
    userId: Uint8Array
    eventType: $Enums.ContactTimelineEventType
    relationshipType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityStepCreateManyTenetInput = {
    id: Uint8Array
    title: string
    completed: boolean
    activityId: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
    type?: $Enums.ActivityStepType
    order: number
  }

  export type ActivityWaypointCreateManyTenetInput = {
    id: Uint8Array
    title: string
    description?: string | null
    summary?: string | null
    status: $Enums.ActivityStatus
    order: number
    actualStart: Date | string
    dueDate: Date | string
    actualEnd?: Date | string | null
    activityId: Uint8Array
    templateId?: Uint8Array | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TemplateAssignmentCreateManyTenetInput = {
    id: Uint8Array
    specificUserId?: Uint8Array | null
    specificRole?: $Enums.Role | null
    activityTemplateId?: Uint8Array | null
    waypointTemplateId?: Uint8Array | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityWaypointTemplateCreateManyTenetInput = {
    id: Uint8Array
    title: string
    description?: string | null
    defaultStatus: $Enums.ActivityStatus
    order: number
    dateOffsetType: $Enums.DateOffsetType
    dueDate: number
    parentActivityId: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityTemplateCreateManyTenetInput = {
    id: Uint8Array
    title: string
    description?: string | null
    type: $Enums.ActivityType
    defaultPriority: $Enums.ActivityPriority
    defaultStatus: $Enums.ActivityStatus
    taskScheduleType?: $Enums.TaskScheduleType | null
    dateOffsetType: $Enums.DateOffsetType
    startDate: number
    endDate: number
    startRelativeToId?: Uint8Array | null
    parentWaypointId?: Uint8Array | null
    parentActivityId?: Uint8Array | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: number | null
  }

  export type ActivityTemplateStepCreateManyTenetInput = {
    id: Uint8Array
    order: number
    title: string
    type?: $Enums.ActivityStepType
    activityTemplateId: Uint8Array
  }

  export type OpportunityCreateManyTenetInput = {
    id: Uint8Array
    title: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    value: number
    probability: number
    expectedCloseDate: Date | string
    actualCloseDate?: Date | string | null
    status: $Enums.OpportunityStatus
    statusHistory?: OpportunityCreatestatusHistoryInput | $Enums.OpportunityStatus[]
    deleted?: boolean
    deletedAt?: Date | string | null
    expectedValue: number
  }

  export type ProductTypeCreateManyTenetInput = {
    id: Uint8Array
    title: string
    description?: string | null
    defaultCommission: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityTemplateStepAssignmentCreateManyTenetInput = {
    id: Uint8Array
    specificUserId?: Uint8Array | null
    specificRole?: $Enums.Role | null
    activityTemplateStepId: Uint8Array
  }

  export type UserUpdateWithoutTenetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumAccessGroupFieldUpdateOperationsInput | $Enums.AccessGroup
    system?: BoolFieldUpdateOperationsInput | boolean
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokens?: TokenUpdateManyWithoutUserNestedInput
    activities?: ActivityUserJoinUpdateManyWithoutUserRelationNestedInput
    notes?: NoteUpdateManyWithoutAuthorNestedInput
    waypoints?: UserWaypointJoinUpdateManyWithoutUserRelationNestedInput
    events?: ContactTimelineEventUpdateManyWithoutUserNestedInput
    auditEvents?: AuditEventUpdateManyWithoutUserNestedInput
    templateAssignments?: TemplateAssignmentUpdateManyWithoutSpecificUserNestedInput
    assignedActivities?: ActivityUpdateManyWithoutAssignedByNestedInput
    opportunities?: UserOpportunityJoinUpdateManyWithoutUserRelationNestedInput
    activitySteps?: ActivityStepUserJoinUpdateManyWithoutUserRelationNestedInput
    templateStepAssignments?: ActivityTemplateStepAssignmentUpdateManyWithoutSpecificUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTenetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumAccessGroupFieldUpdateOperationsInput | $Enums.AccessGroup
    system?: BoolFieldUpdateOperationsInput | boolean
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUserJoinUncheckedUpdateManyWithoutUserRelationNestedInput
    notes?: NoteUncheckedUpdateManyWithoutAuthorNestedInput
    waypoints?: UserWaypointJoinUncheckedUpdateManyWithoutUserRelationNestedInput
    events?: ContactTimelineEventUncheckedUpdateManyWithoutUserNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutUserNestedInput
    templateAssignments?: TemplateAssignmentUncheckedUpdateManyWithoutSpecificUserNestedInput
    assignedActivities?: ActivityUncheckedUpdateManyWithoutAssignedByNestedInput
    opportunities?: UserOpportunityJoinUncheckedUpdateManyWithoutUserRelationNestedInput
    activitySteps?: ActivityStepUserJoinUncheckedUpdateManyWithoutUserRelationNestedInput
    templateStepAssignments?: ActivityTemplateStepAssignmentUncheckedUpdateManyWithoutSpecificUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutTenetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    type?: EnumAccessGroupFieldUpdateOperationsInput | $Enums.AccessGroup
    system?: BoolFieldUpdateOperationsInput | boolean
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LogUpdateWithoutTenetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    severity?: EnumLogLevelFieldUpdateOperationsInput | $Enums.LogLevel
    stacktrace?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    secureDetails?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LogUncheckedUpdateWithoutTenetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    severity?: EnumLogLevelFieldUpdateOperationsInput | $Enums.LogLevel
    stacktrace?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    secureDetails?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LogUncheckedUpdateManyWithoutTenetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    severity?: EnumLogLevelFieldUpdateOperationsInput | $Enums.LogLevel
    stacktrace?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    secureDetails?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContactUpdateWithoutTenetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    importantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    lifecycleStage?: NullableEnumLifecycleStageFieldUpdateOperationsInput | $Enums.LifecycleStage | null
    lastContactedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    householdStatus?: NullableEnumHouseholdRelationshipStatusFieldUpdateOperationsInput | $Enums.HouseholdRelationshipStatus | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyStatus?: NullableEnumCompanyRelationshipStatusFieldUpdateOperationsInput | $Enums.CompanyRelationshipStatus | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NoteUpdateManyWithoutContactNestedInput
    timelineEvents?: ContactTimelineEventContactJoinUpdateManyWithoutContactRelationNestedInput
    addresses?: AddressUpdateManyWithoutContactNestedInput
    emails?: ContactEmailUpdateManyWithoutContactNestedInput
    phones?: ContactPhoneUpdateManyWithoutContactNestedInput
    importantDates?: ImportantDateUpdateManyWithoutContactNestedInput
    activities?: ActivityContactJoinUpdateManyWithoutContactRelationNestedInput
    household?: ContactUpdateOneWithoutHouseholdMembersNestedInput
    headOfHouseholdFor?: ContactUpdateOneWithoutHeadOfHouseholdNestedInput
    company?: ContactUpdateOneWithoutEmployeesNestedInput
    primaryContactFor?: ContactUpdateOneWithoutPrimaryContactNestedInput
    headOfHousehold?: ContactUpdateOneWithoutHeadOfHouseholdForNestedInput
    householdMembers?: ContactUpdateManyWithoutHouseholdNestedInput
    employees?: ContactUpdateManyWithoutCompanyNestedInput
    primaryContact?: ContactUpdateOneWithoutPrimaryContactForNestedInput
    opportunities?: ContactOpportunityJoinUpdateManyWithoutContactRelationNestedInput
    relationAsSource?: ContactRelationshipUpdateManyWithoutSourceNestedInput
    relationAsTarget?: ContactRelationshipUpdateManyWithoutTargetNestedInput
  }

  export type ContactUncheckedUpdateWithoutTenetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    importantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    lifecycleStage?: NullableEnumLifecycleStageFieldUpdateOperationsInput | $Enums.LifecycleStage | null
    lastContactedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    householdId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    householdStatus?: NullableEnumHouseholdRelationshipStatusFieldUpdateOperationsInput | $Enums.HouseholdRelationshipStatus | null
    companyId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyStatus?: NullableEnumCompanyRelationshipStatusFieldUpdateOperationsInput | $Enums.CompanyRelationshipStatus | null
    headOfHouseholdId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    primaryContactId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NoteUncheckedUpdateManyWithoutContactNestedInput
    timelineEvents?: ContactTimelineEventContactJoinUncheckedUpdateManyWithoutContactRelationNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutContactNestedInput
    emails?: ContactEmailUncheckedUpdateManyWithoutContactNestedInput
    phones?: ContactPhoneUncheckedUpdateManyWithoutContactNestedInput
    importantDates?: ImportantDateUncheckedUpdateManyWithoutContactNestedInput
    activities?: ActivityContactJoinUncheckedUpdateManyWithoutContactRelationNestedInput
    headOfHouseholdFor?: ContactUncheckedUpdateOneWithoutHeadOfHouseholdNestedInput
    primaryContactFor?: ContactUncheckedUpdateOneWithoutPrimaryContactNestedInput
    householdMembers?: ContactUncheckedUpdateManyWithoutHouseholdNestedInput
    employees?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    opportunities?: ContactOpportunityJoinUncheckedUpdateManyWithoutContactRelationNestedInput
    relationAsSource?: ContactRelationshipUncheckedUpdateManyWithoutSourceNestedInput
    relationAsTarget?: ContactRelationshipUncheckedUpdateManyWithoutTargetNestedInput
  }

  export type ContactUncheckedUpdateManyWithoutTenetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    importantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    lifecycleStage?: NullableEnumLifecycleStageFieldUpdateOperationsInput | $Enums.LifecycleStage | null
    lastContactedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    householdId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    householdStatus?: NullableEnumHouseholdRelationshipStatusFieldUpdateOperationsInput | $Enums.HouseholdRelationshipStatus | null
    companyId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyStatus?: NullableEnumCompanyRelationshipStatusFieldUpdateOperationsInput | $Enums.CompanyRelationshipStatus | null
    headOfHouseholdId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    primaryContactId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ActivityUpdateWithoutTenetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    steps?: ActivityStepUpdateManyWithoutActivityNestedInput
    waypoints?: ActivityWaypointUpdateManyWithoutActivityNestedInput
    activities?: ActivityUpdateManyWithoutParentActivityNestedInput
    parentActivity?: ActivityUpdateOneWithoutActivitiesNestedInput
    parentWaypoint?: ActivityWaypointUpdateOneWithoutChildActivitiesNestedInput
    template?: ActivityTemplateUpdateOneWithoutActivitiesNestedInput
    assignedBy?: UserUpdateOneRequiredWithoutAssignedActivitiesNestedInput
    contacts?: ActivityContactJoinUpdateManyWithoutActivityRelationNestedInput
    users?: ActivityUserJoinUpdateManyWithoutActivityRelationNestedInput
    attachments?: AttachmentUpdateManyWithoutActivityNestedInput
    notes?: NoteUpdateManyWithoutActivityNestedInput
    events?: ContactTimelineEventUpdateManyWithoutActivityNestedInput
    opportunity?: OpportunityUpdateOneWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateWithoutTenetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    parentActivityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    parentWaypointId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    templateId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    assignedById?: BytesFieldUpdateOperationsInput | Uint8Array
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    opportunityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    steps?: ActivityStepUncheckedUpdateManyWithoutActivityNestedInput
    waypoints?: ActivityWaypointUncheckedUpdateManyWithoutActivityNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutParentActivityNestedInput
    contacts?: ActivityContactJoinUncheckedUpdateManyWithoutActivityRelationNestedInput
    users?: ActivityUserJoinUncheckedUpdateManyWithoutActivityRelationNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutActivityNestedInput
    notes?: NoteUncheckedUpdateManyWithoutActivityNestedInput
    events?: ContactTimelineEventUncheckedUpdateManyWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateManyWithoutTenetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    parentActivityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    parentWaypointId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    templateId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    assignedById?: BytesFieldUpdateOperationsInput | Uint8Array
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    opportunityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type AddressUpdateWithoutTenetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    type?: EnumAddressTypeFieldUpdateOperationsInput | $Enums.AddressType
    primary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: ContactUpdateOneRequiredWithoutAddressesNestedInput
  }

  export type AddressUncheckedUpdateWithoutTenetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    type?: EnumAddressTypeFieldUpdateOperationsInput | $Enums.AddressType
    primary?: BoolFieldUpdateOperationsInput | boolean
    contactId?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AddressUncheckedUpdateManyWithoutTenetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    type?: EnumAddressTypeFieldUpdateOperationsInput | $Enums.AddressType
    primary?: BoolFieldUpdateOperationsInput | boolean
    contactId?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContactEmailUpdateWithoutTenetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    email?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: ContactUpdateOneRequiredWithoutEmailsNestedInput
  }

  export type ContactEmailUncheckedUpdateWithoutTenetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    email?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    contactId?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactEmailUncheckedUpdateManyWithoutTenetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    email?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    contactId?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactPhoneUpdateWithoutTenetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    number?: StringFieldUpdateOperationsInput | string
    type?: EnumPhoneTypeFieldUpdateOperationsInput | $Enums.PhoneType
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: ContactUpdateOneRequiredWithoutPhonesNestedInput
  }

  export type ContactPhoneUncheckedUpdateWithoutTenetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    number?: StringFieldUpdateOperationsInput | string
    type?: EnumPhoneTypeFieldUpdateOperationsInput | $Enums.PhoneType
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    contactId?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactPhoneUncheckedUpdateManyWithoutTenetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    number?: StringFieldUpdateOperationsInput | string
    type?: EnumPhoneTypeFieldUpdateOperationsInput | $Enums.PhoneType
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    contactId?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImportantDateUpdateWithoutTenetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumImportantDateTypeFieldUpdateOperationsInput | $Enums.ImportantDateType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: ContactUpdateOneRequiredWithoutImportantDatesNestedInput
  }

  export type ImportantDateUncheckedUpdateWithoutTenetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumImportantDateTypeFieldUpdateOperationsInput | $Enums.ImportantDateType
    contactId?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImportantDateUncheckedUpdateManyWithoutTenetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumImportantDateTypeFieldUpdateOperationsInput | $Enums.ImportantDateType
    contactId?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentUpdateWithoutTenetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    activity?: ActivityUpdateOneWithoutAttachmentsNestedInput
  }

  export type AttachmentUncheckedUpdateWithoutTenetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    activityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type AttachmentUncheckedUpdateManyWithoutTenetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    activityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type NoteUpdateWithoutTenetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noteType?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    waypoint?: ActivityWaypointUpdateOneWithoutNoteNestedInput
    activity?: ActivityUpdateOneWithoutNotesNestedInput
    contact?: ContactUpdateOneWithoutNotesNestedInput
    opportunity?: OpportunityUpdateOneWithoutNotesNestedInput
    author?: UserUpdateOneRequiredWithoutNotesNestedInput
    events?: ContactTimelineEventUpdateManyWithoutNoteNestedInput
  }

  export type NoteUncheckedUpdateWithoutTenetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    content?: StringFieldUpdateOperationsInput | string
    waypointId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    activityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    contactId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    opportunityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    authorId?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noteType?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    events?: ContactTimelineEventUncheckedUpdateManyWithoutNoteNestedInput
  }

  export type NoteUncheckedUpdateManyWithoutTenetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    content?: StringFieldUpdateOperationsInput | string
    waypointId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    activityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    contactId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    opportunityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    authorId?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noteType?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
  }

  export type AuditEventUpdateWithoutTenetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    type?: EnumAuditEventTypeFieldUpdateOperationsInput | $Enums.AuditEventType
    details?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: BytesFieldUpdateOperationsInput | Uint8Array
    reference?: EnumAuditableFieldUpdateOperationsInput | $Enums.Auditable
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAuditEventsNestedInput
  }

  export type AuditEventUncheckedUpdateWithoutTenetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    userId?: BytesFieldUpdateOperationsInput | Uint8Array
    type?: EnumAuditEventTypeFieldUpdateOperationsInput | $Enums.AuditEventType
    details?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: BytesFieldUpdateOperationsInput | Uint8Array
    reference?: EnumAuditableFieldUpdateOperationsInput | $Enums.Auditable
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditEventUncheckedUpdateManyWithoutTenetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    userId?: BytesFieldUpdateOperationsInput | Uint8Array
    type?: EnumAuditEventTypeFieldUpdateOperationsInput | $Enums.AuditEventType
    details?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: BytesFieldUpdateOperationsInput | Uint8Array
    reference?: EnumAuditableFieldUpdateOperationsInput | $Enums.Auditable
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactTimelineEventUpdateWithoutTenetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    extraInfo?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: EnumContactTimelineEventTypeFieldUpdateOperationsInput | $Enums.ContactTimelineEventType
    relationshipType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activity?: ActivityUpdateOneWithoutEventsNestedInput
    waypoint?: ActivityWaypointUpdateOneWithoutEventsNestedInput
    opportunity?: OpportunityUpdateOneWithoutEventsNestedInput
    note?: NoteUpdateOneWithoutEventsNestedInput
    contacts?: ContactTimelineEventContactJoinUpdateManyWithoutContactEventRelationNestedInput
    user?: UserUpdateOneRequiredWithoutEventsNestedInput
  }

  export type ContactTimelineEventUncheckedUpdateWithoutTenetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    activityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    waypointId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    opportunityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    noteId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    extraInfo?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: BytesFieldUpdateOperationsInput | Uint8Array
    eventType?: EnumContactTimelineEventTypeFieldUpdateOperationsInput | $Enums.ContactTimelineEventType
    relationshipType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactTimelineEventContactJoinUncheckedUpdateManyWithoutContactEventRelationNestedInput
  }

  export type ContactTimelineEventUncheckedUpdateManyWithoutTenetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    activityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    waypointId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    opportunityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    noteId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    extraInfo?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: BytesFieldUpdateOperationsInput | Uint8Array
    eventType?: EnumContactTimelineEventTypeFieldUpdateOperationsInput | $Enums.ContactTimelineEventType
    relationshipType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityStepUpdateWithoutTenetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumActivityStepTypeFieldUpdateOperationsInput | $Enums.ActivityStepType
    order?: IntFieldUpdateOperationsInput | number
    activity?: ActivityUpdateOneRequiredWithoutStepsNestedInput
    assignedTo?: ActivityStepUserJoinUpdateManyWithoutStepRelationNestedInput
  }

  export type ActivityStepUncheckedUpdateWithoutTenetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    activityId?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumActivityStepTypeFieldUpdateOperationsInput | $Enums.ActivityStepType
    order?: IntFieldUpdateOperationsInput | number
    assignedTo?: ActivityStepUserJoinUncheckedUpdateManyWithoutStepRelationNestedInput
  }

  export type ActivityStepUncheckedUpdateManyWithoutTenetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    activityId?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumActivityStepTypeFieldUpdateOperationsInput | $Enums.ActivityStepType
    order?: IntFieldUpdateOperationsInput | number
  }

  export type ActivityWaypointUpdateWithoutTenetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    order?: IntFieldUpdateOperationsInput | number
    actualStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserWaypointJoinUpdateManyWithoutWaypointRelationNestedInput
    activity?: ActivityUpdateOneRequiredWithoutWaypointsNestedInput
    childActivities?: ActivityUpdateManyWithoutParentWaypointNestedInput
    template?: ActivityWaypointTemplateUpdateOneWithoutWaypointsNestedInput
    events?: ContactTimelineEventUpdateManyWithoutWaypointNestedInput
    Note?: NoteUpdateManyWithoutWaypointNestedInput
  }

  export type ActivityWaypointUncheckedUpdateWithoutTenetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    order?: IntFieldUpdateOperationsInput | number
    actualStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activityId?: BytesFieldUpdateOperationsInput | Uint8Array
    templateId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserWaypointJoinUncheckedUpdateManyWithoutWaypointRelationNestedInput
    childActivities?: ActivityUncheckedUpdateManyWithoutParentWaypointNestedInput
    events?: ContactTimelineEventUncheckedUpdateManyWithoutWaypointNestedInput
    Note?: NoteUncheckedUpdateManyWithoutWaypointNestedInput
  }

  export type ActivityWaypointUncheckedUpdateManyWithoutTenetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    order?: IntFieldUpdateOperationsInput | number
    actualStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activityId?: BytesFieldUpdateOperationsInput | Uint8Array
    templateId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateAssignmentUpdateWithoutTenetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    specificRole?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    specificUser?: UserUpdateOneWithoutTemplateAssignmentsNestedInput
    activityTemplate?: ActivityTemplateUpdateOneWithoutAssignmentsNestedInput
    waypointTemplate?: ActivityWaypointTemplateUpdateOneWithoutAssignmentsNestedInput
  }

  export type TemplateAssignmentUncheckedUpdateWithoutTenetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    specificUserId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    specificRole?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    activityTemplateId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    waypointTemplateId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateAssignmentUncheckedUpdateManyWithoutTenetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    specificUserId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    specificRole?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    activityTemplateId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    waypointTemplateId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityWaypointTemplateUpdateWithoutTenetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultStatus?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    order?: IntFieldUpdateOperationsInput | number
    dateOffsetType?: EnumDateOffsetTypeFieldUpdateOperationsInput | $Enums.DateOffsetType
    dueDate?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentActivity?: ActivityTemplateUpdateOneRequiredWithoutWaypointsNestedInput
    activities?: ActivityTemplateUpdateManyWithoutParentWaypointNestedInput
    waypoints?: ActivityWaypointUpdateManyWithoutTemplateNestedInput
    assignments?: TemplateAssignmentUpdateManyWithoutWaypointTemplateNestedInput
  }

  export type ActivityWaypointTemplateUncheckedUpdateWithoutTenetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultStatus?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    order?: IntFieldUpdateOperationsInput | number
    dateOffsetType?: EnumDateOffsetTypeFieldUpdateOperationsInput | $Enums.DateOffsetType
    dueDate?: IntFieldUpdateOperationsInput | number
    parentActivityId?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityTemplateUncheckedUpdateManyWithoutParentWaypointNestedInput
    waypoints?: ActivityWaypointUncheckedUpdateManyWithoutTemplateNestedInput
    assignments?: TemplateAssignmentUncheckedUpdateManyWithoutWaypointTemplateNestedInput
  }

  export type ActivityWaypointTemplateUncheckedUpdateManyWithoutTenetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultStatus?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    order?: IntFieldUpdateOperationsInput | number
    dateOffsetType?: EnumDateOffsetTypeFieldUpdateOperationsInput | $Enums.DateOffsetType
    dueDate?: IntFieldUpdateOperationsInput | number
    parentActivityId?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityTemplateUpdateWithoutTenetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    defaultPriority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    defaultStatus?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    dateOffsetType?: EnumDateOffsetTypeFieldUpdateOperationsInput | $Enums.DateOffsetType
    startDate?: IntFieldUpdateOperationsInput | number
    endDate?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    steps?: ActivityTemplateStepUpdateManyWithoutActivityTemplateNestedInput
    startRelativeTo?: ActivityTemplateUpdateOneWithoutDependentsNestedInput
    dependents?: ActivityTemplateUpdateManyWithoutStartRelativeToNestedInput
    parentWaypoint?: ActivityWaypointTemplateUpdateOneWithoutActivitiesNestedInput
    parentActivity?: ActivityTemplateUpdateOneWithoutChildActivitiesNestedInput
    waypoints?: ActivityWaypointTemplateUpdateManyWithoutParentActivityNestedInput
    childActivities?: ActivityTemplateUpdateManyWithoutParentActivityNestedInput
    activities?: ActivityUpdateManyWithoutTemplateNestedInput
    assignments?: TemplateAssignmentUpdateManyWithoutActivityTemplateNestedInput
  }

  export type ActivityTemplateUncheckedUpdateWithoutTenetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    defaultPriority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    defaultStatus?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    dateOffsetType?: EnumDateOffsetTypeFieldUpdateOperationsInput | $Enums.DateOffsetType
    startDate?: IntFieldUpdateOperationsInput | number
    endDate?: IntFieldUpdateOperationsInput | number
    startRelativeToId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    parentWaypointId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    parentActivityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    steps?: ActivityTemplateStepUncheckedUpdateManyWithoutActivityTemplateNestedInput
    dependents?: ActivityTemplateUncheckedUpdateManyWithoutStartRelativeToNestedInput
    waypoints?: ActivityWaypointTemplateUncheckedUpdateManyWithoutParentActivityNestedInput
    childActivities?: ActivityTemplateUncheckedUpdateManyWithoutParentActivityNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutTemplateNestedInput
    assignments?: TemplateAssignmentUncheckedUpdateManyWithoutActivityTemplateNestedInput
  }

  export type ActivityTemplateUncheckedUpdateManyWithoutTenetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    defaultPriority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    defaultStatus?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    dateOffsetType?: EnumDateOffsetTypeFieldUpdateOperationsInput | $Enums.DateOffsetType
    startDate?: IntFieldUpdateOperationsInput | number
    endDate?: IntFieldUpdateOperationsInput | number
    startRelativeToId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    parentWaypointId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    parentActivityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ActivityTemplateStepUpdateWithoutTenetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityStepTypeFieldUpdateOperationsInput | $Enums.ActivityStepType
    activityTemplate?: ActivityTemplateUpdateOneRequiredWithoutStepsNestedInput
    assignedTo?: ActivityTemplateStepAssignmentUpdateManyWithoutActivityTemplateStepNestedInput
  }

  export type ActivityTemplateStepUncheckedUpdateWithoutTenetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityStepTypeFieldUpdateOperationsInput | $Enums.ActivityStepType
    activityTemplateId?: BytesFieldUpdateOperationsInput | Uint8Array
    assignedTo?: ActivityTemplateStepAssignmentUncheckedUpdateManyWithoutActivityTemplateStepNestedInput
  }

  export type ActivityTemplateStepUncheckedUpdateManyWithoutTenetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityStepTypeFieldUpdateOperationsInput | $Enums.ActivityStepType
    activityTemplateId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type OpportunityUpdateWithoutTenetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    probability?: FloatFieldUpdateOperationsInput | number
    expectedCloseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumOpportunityStatusFieldUpdateOperationsInput | $Enums.OpportunityStatus
    statusHistory?: OpportunityUpdatestatusHistoryInput | $Enums.OpportunityStatus[]
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedValue?: FloatFieldUpdateOperationsInput | number
    contacts?: ContactOpportunityJoinUpdateManyWithoutOpportunityRelationNestedInput
    teamMembers?: UserOpportunityJoinUpdateManyWithoutOpportunityRelationNestedInput
    activities?: ActivityUpdateManyWithoutOpportunityNestedInput
    products?: OpportunityProductUpdateManyWithoutOpportunityNestedInput
    events?: ContactTimelineEventUpdateManyWithoutOpportunityNestedInput
    notes?: NoteUpdateManyWithoutOpportunityNestedInput
  }

  export type OpportunityUncheckedUpdateWithoutTenetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    probability?: FloatFieldUpdateOperationsInput | number
    expectedCloseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumOpportunityStatusFieldUpdateOperationsInput | $Enums.OpportunityStatus
    statusHistory?: OpportunityUpdatestatusHistoryInput | $Enums.OpportunityStatus[]
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedValue?: FloatFieldUpdateOperationsInput | number
    contacts?: ContactOpportunityJoinUncheckedUpdateManyWithoutOpportunityRelationNestedInput
    teamMembers?: UserOpportunityJoinUncheckedUpdateManyWithoutOpportunityRelationNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutOpportunityNestedInput
    products?: OpportunityProductUncheckedUpdateManyWithoutOpportunityNestedInput
    events?: ContactTimelineEventUncheckedUpdateManyWithoutOpportunityNestedInput
    notes?: NoteUncheckedUpdateManyWithoutOpportunityNestedInput
  }

  export type OpportunityUncheckedUpdateManyWithoutTenetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    probability?: FloatFieldUpdateOperationsInput | number
    expectedCloseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumOpportunityStatusFieldUpdateOperationsInput | $Enums.OpportunityStatus
    statusHistory?: OpportunityUpdatestatusHistoryInput | $Enums.OpportunityStatus[]
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedValue?: FloatFieldUpdateOperationsInput | number
  }

  export type ProductTypeUpdateWithoutTenetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCommission?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opportunities?: OpportunityProductUpdateManyWithoutProductTypeNestedInput
  }

  export type ProductTypeUncheckedUpdateWithoutTenetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCommission?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opportunities?: OpportunityProductUncheckedUpdateManyWithoutProductTypeNestedInput
  }

  export type ProductTypeUncheckedUpdateManyWithoutTenetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultCommission?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityTemplateStepAssignmentUpdateWithoutTenetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    specificRole?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    specificUser?: UserUpdateOneWithoutTemplateStepAssignmentsNestedInput
    activityTemplateStep?: ActivityTemplateStepUpdateOneRequiredWithoutAssignedToNestedInput
  }

  export type ActivityTemplateStepAssignmentUncheckedUpdateWithoutTenetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    specificUserId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    specificRole?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    activityTemplateStepId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type ActivityTemplateStepAssignmentUncheckedUpdateManyWithoutTenetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    specificUserId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    specificRole?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    activityTemplateStepId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type TokenCreateManyUserInput = {
    id: Uint8Array
    createdAt?: Date | string
    refresh?: boolean
  }

  export type ActivityUserJoinCreateManyUserRelationInput = {
    activityId: Uint8Array
  }

  export type NoteCreateManyAuthorInput = {
    id: Uint8Array
    content: string
    waypointId?: Uint8Array | null
    activityId?: Uint8Array | null
    contactId?: Uint8Array | null
    opportunityId?: Uint8Array | null
    tenetId: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean
    deletedAt?: Date | string | null
    noteType?: $Enums.NoteType
  }

  export type UserWaypointJoinCreateManyUserRelationInput = {
    waypointId: Uint8Array
  }

  export type ContactTimelineEventCreateManyUserInput = {
    id: Uint8Array
    activityId?: Uint8Array | null
    waypointId?: Uint8Array | null
    opportunityId?: Uint8Array | null
    noteId?: Uint8Array | null
    extraInfo?: string | null
    tenetId: Uint8Array
    eventType: $Enums.ContactTimelineEventType
    relationshipType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditEventCreateManyUserInput = {
    id: Uint8Array
    tenetId: Uint8Array
    type: $Enums.AuditEventType
    details?: string | null
    referenceId: Uint8Array
    reference: $Enums.Auditable
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TemplateAssignmentCreateManySpecificUserInput = {
    id: Uint8Array
    specificRole?: $Enums.Role | null
    activityTemplateId?: Uint8Array | null
    waypointTemplateId?: Uint8Array | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
  }

  export type ActivityCreateManyAssignedByInput = {
    id: Uint8Array
    title: string
    type: $Enums.ActivityType
    parentActivityId?: Uint8Array | null
    parentWaypointId?: Uint8Array | null
    templateId?: Uint8Array | null
    taskScheduleType?: $Enums.TaskScheduleType | null
    startDate: Date | string
    endDate: Date | string
    completedAt?: Date | string | null
    description?: string | null
    priority?: $Enums.ActivityPriority
    status: $Enums.ActivityStatus
    phoneNumber?: string | null
    location?: string | null
    holdReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
    deleted?: boolean
    deletedAt?: Date | string | null
    order?: number | null
    opportunityId?: Uint8Array | null
  }

  export type UserOpportunityJoinCreateManyUserRelationInput = {
    opportunityId: Uint8Array
  }

  export type ActivityStepUserJoinCreateManyUserRelationInput = {
    activityStepId: Uint8Array
  }

  export type ActivityTemplateStepAssignmentCreateManySpecificUserInput = {
    id: Uint8Array
    specificRole?: $Enums.Role | null
    activityTemplateStepId: Uint8Array
    tenetId: Uint8Array
  }

  export type TokenUpdateWithoutUserInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refresh?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TokenUncheckedUpdateWithoutUserInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refresh?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TokenUncheckedUpdateManyWithoutUserInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refresh?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ActivityUserJoinUpdateWithoutUserRelationInput = {
    activityRelation?: ActivityUpdateOneRequiredWithoutUsersNestedInput
  }

  export type ActivityUserJoinUncheckedUpdateWithoutUserRelationInput = {
    activityId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type ActivityUserJoinUncheckedUpdateManyWithoutUserRelationInput = {
    activityId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type NoteUpdateWithoutAuthorInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noteType?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    waypoint?: ActivityWaypointUpdateOneWithoutNoteNestedInput
    activity?: ActivityUpdateOneWithoutNotesNestedInput
    contact?: ContactUpdateOneWithoutNotesNestedInput
    opportunity?: OpportunityUpdateOneWithoutNotesNestedInput
    tenet?: TenetUpdateOneRequiredWithoutNotesNestedInput
    events?: ContactTimelineEventUpdateManyWithoutNoteNestedInput
  }

  export type NoteUncheckedUpdateWithoutAuthorInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    content?: StringFieldUpdateOperationsInput | string
    waypointId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    activityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    contactId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    opportunityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noteType?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    events?: ContactTimelineEventUncheckedUpdateManyWithoutNoteNestedInput
  }

  export type NoteUncheckedUpdateManyWithoutAuthorInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    content?: StringFieldUpdateOperationsInput | string
    waypointId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    activityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    contactId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    opportunityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noteType?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
  }

  export type UserWaypointJoinUpdateWithoutUserRelationInput = {
    waypointRelation?: ActivityWaypointUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserWaypointJoinUncheckedUpdateWithoutUserRelationInput = {
    waypointId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type UserWaypointJoinUncheckedUpdateManyWithoutUserRelationInput = {
    waypointId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type ContactTimelineEventUpdateWithoutUserInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    extraInfo?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: EnumContactTimelineEventTypeFieldUpdateOperationsInput | $Enums.ContactTimelineEventType
    relationshipType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activity?: ActivityUpdateOneWithoutEventsNestedInput
    waypoint?: ActivityWaypointUpdateOneWithoutEventsNestedInput
    opportunity?: OpportunityUpdateOneWithoutEventsNestedInput
    note?: NoteUpdateOneWithoutEventsNestedInput
    contacts?: ContactTimelineEventContactJoinUpdateManyWithoutContactEventRelationNestedInput
    tenet?: TenetUpdateOneRequiredWithoutContactTimelineEventsNestedInput
  }

  export type ContactTimelineEventUncheckedUpdateWithoutUserInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    activityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    waypointId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    opportunityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    noteId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    extraInfo?: NullableStringFieldUpdateOperationsInput | string | null
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    eventType?: EnumContactTimelineEventTypeFieldUpdateOperationsInput | $Enums.ContactTimelineEventType
    relationshipType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactTimelineEventContactJoinUncheckedUpdateManyWithoutContactEventRelationNestedInput
  }

  export type ContactTimelineEventUncheckedUpdateManyWithoutUserInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    activityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    waypointId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    opportunityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    noteId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    extraInfo?: NullableStringFieldUpdateOperationsInput | string | null
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    eventType?: EnumContactTimelineEventTypeFieldUpdateOperationsInput | $Enums.ContactTimelineEventType
    relationshipType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditEventUpdateWithoutUserInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    type?: EnumAuditEventTypeFieldUpdateOperationsInput | $Enums.AuditEventType
    details?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: BytesFieldUpdateOperationsInput | Uint8Array
    reference?: EnumAuditableFieldUpdateOperationsInput | $Enums.Auditable
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenet?: TenetUpdateOneRequiredWithoutAuditEventsNestedInput
  }

  export type AuditEventUncheckedUpdateWithoutUserInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    type?: EnumAuditEventTypeFieldUpdateOperationsInput | $Enums.AuditEventType
    details?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: BytesFieldUpdateOperationsInput | Uint8Array
    reference?: EnumAuditableFieldUpdateOperationsInput | $Enums.Auditable
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditEventUncheckedUpdateManyWithoutUserInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    type?: EnumAuditEventTypeFieldUpdateOperationsInput | $Enums.AuditEventType
    details?: NullableStringFieldUpdateOperationsInput | string | null
    referenceId?: BytesFieldUpdateOperationsInput | Uint8Array
    reference?: EnumAuditableFieldUpdateOperationsInput | $Enums.Auditable
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateAssignmentUpdateWithoutSpecificUserInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    specificRole?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activityTemplate?: ActivityTemplateUpdateOneWithoutAssignmentsNestedInput
    waypointTemplate?: ActivityWaypointTemplateUpdateOneWithoutAssignmentsNestedInput
    tenet?: TenetUpdateOneRequiredWithoutTemplateAssignmentsNestedInput
  }

  export type TemplateAssignmentUncheckedUpdateWithoutSpecificUserInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    specificRole?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    activityTemplateId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    waypointTemplateId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type TemplateAssignmentUncheckedUpdateManyWithoutSpecificUserInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    specificRole?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    activityTemplateId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    waypointTemplateId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type ActivityUpdateWithoutAssignedByInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    steps?: ActivityStepUpdateManyWithoutActivityNestedInput
    waypoints?: ActivityWaypointUpdateManyWithoutActivityNestedInput
    activities?: ActivityUpdateManyWithoutParentActivityNestedInput
    parentActivity?: ActivityUpdateOneWithoutActivitiesNestedInput
    parentWaypoint?: ActivityWaypointUpdateOneWithoutChildActivitiesNestedInput
    template?: ActivityTemplateUpdateOneWithoutActivitiesNestedInput
    contacts?: ActivityContactJoinUpdateManyWithoutActivityRelationNestedInput
    users?: ActivityUserJoinUpdateManyWithoutActivityRelationNestedInput
    tenet?: TenetUpdateOneRequiredWithoutActivitiesNestedInput
    attachments?: AttachmentUpdateManyWithoutActivityNestedInput
    notes?: NoteUpdateManyWithoutActivityNestedInput
    events?: ContactTimelineEventUpdateManyWithoutActivityNestedInput
    opportunity?: OpportunityUpdateOneWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateWithoutAssignedByInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    parentActivityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    parentWaypointId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    templateId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    opportunityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    steps?: ActivityStepUncheckedUpdateManyWithoutActivityNestedInput
    waypoints?: ActivityWaypointUncheckedUpdateManyWithoutActivityNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutParentActivityNestedInput
    contacts?: ActivityContactJoinUncheckedUpdateManyWithoutActivityRelationNestedInput
    users?: ActivityUserJoinUncheckedUpdateManyWithoutActivityRelationNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutActivityNestedInput
    notes?: NoteUncheckedUpdateManyWithoutActivityNestedInput
    events?: ContactTimelineEventUncheckedUpdateManyWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateManyWithoutAssignedByInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    parentActivityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    parentWaypointId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    templateId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    opportunityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type UserOpportunityJoinUpdateWithoutUserRelationInput = {
    opportunityRelation?: OpportunityUpdateOneRequiredWithoutTeamMembersNestedInput
  }

  export type UserOpportunityJoinUncheckedUpdateWithoutUserRelationInput = {
    opportunityId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type UserOpportunityJoinUncheckedUpdateManyWithoutUserRelationInput = {
    opportunityId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type ActivityStepUserJoinUpdateWithoutUserRelationInput = {
    stepRelation?: ActivityStepUpdateOneRequiredWithoutAssignedToNestedInput
  }

  export type ActivityStepUserJoinUncheckedUpdateWithoutUserRelationInput = {
    activityStepId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type ActivityStepUserJoinUncheckedUpdateManyWithoutUserRelationInput = {
    activityStepId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type ActivityTemplateStepAssignmentUpdateWithoutSpecificUserInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    specificRole?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    activityTemplateStep?: ActivityTemplateStepUpdateOneRequiredWithoutAssignedToNestedInput
    tenet?: TenetUpdateOneRequiredWithoutActivityTemplateStepAssignmentNestedInput
  }

  export type ActivityTemplateStepAssignmentUncheckedUpdateWithoutSpecificUserInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    specificRole?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    activityTemplateStepId?: BytesFieldUpdateOperationsInput | Uint8Array
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type ActivityTemplateStepAssignmentUncheckedUpdateManyWithoutSpecificUserInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    specificRole?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    activityTemplateStepId?: BytesFieldUpdateOperationsInput | Uint8Array
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type NoteCreateManyContactInput = {
    id: Uint8Array
    content: string
    waypointId?: Uint8Array | null
    activityId?: Uint8Array | null
    opportunityId?: Uint8Array | null
    tenetId: Uint8Array
    authorId: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean
    deletedAt?: Date | string | null
    noteType?: $Enums.NoteType
  }

  export type ContactTimelineEventContactJoinCreateManyContactRelationInput = {
    contactEventId: Uint8Array
    type: $Enums.ContactTimelineEventJoinType
  }

  export type AddressCreateManyContactInput = {
    id: Uint8Array
    street: string
    city: string
    state: string
    zip: string
    country: string
    type: $Enums.AddressType
    primary?: boolean
    tenetId: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
    timezone?: string | null
  }

  export type ContactEmailCreateManyContactInput = {
    id: Uint8Array
    email: string
    isPrimary?: boolean
    tenetId: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactPhoneCreateManyContactInput = {
    id: Uint8Array
    number: string
    type: $Enums.PhoneType
    isPrimary?: boolean
    tenetId: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImportantDateCreateManyContactInput = {
    id: Uint8Array
    date: Date | string
    type: $Enums.ImportantDateType
    tenetId: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityContactJoinCreateManyContactRelationInput = {
    activityId: Uint8Array
  }

  export type ContactCreateManyHouseholdInput = {
    id: Uint8Array
    firstName?: string | null
    lastName: string
    fullName: string
    tenetId: Uint8Array
    importantNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.ContactType
    status: $Enums.ContactStatus
    lifecycleStage?: $Enums.LifecycleStage | null
    lastContactedDate?: Date | string | null
    followUpDate?: Date | string | null
    householdStatus?: $Enums.HouseholdRelationshipStatus | null
    companyId?: Uint8Array | null
    position?: string | null
    companyStatus?: $Enums.CompanyRelationshipStatus | null
    headOfHouseholdId?: Uint8Array | null
    industry?: string | null
    website?: string | null
    size?: number | null
    primaryContactId?: Uint8Array | null
    deleted?: boolean
    deletedAt?: Date | string | null
  }

  export type ContactCreateManyCompanyInput = {
    id: Uint8Array
    firstName?: string | null
    lastName: string
    fullName: string
    tenetId: Uint8Array
    importantNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    type: $Enums.ContactType
    status: $Enums.ContactStatus
    lifecycleStage?: $Enums.LifecycleStage | null
    lastContactedDate?: Date | string | null
    followUpDate?: Date | string | null
    householdId?: Uint8Array | null
    householdStatus?: $Enums.HouseholdRelationshipStatus | null
    position?: string | null
    companyStatus?: $Enums.CompanyRelationshipStatus | null
    headOfHouseholdId?: Uint8Array | null
    industry?: string | null
    website?: string | null
    size?: number | null
    primaryContactId?: Uint8Array | null
    deleted?: boolean
    deletedAt?: Date | string | null
  }

  export type ContactOpportunityJoinCreateManyContactRelationInput = {
    opportunityId: Uint8Array
  }

  export type ContactRelationshipCreateManySourceInput = {
    id: Uint8Array
    targetId: Uint8Array
    type: string
    established?: Date | string | null
    notes?: string | null
  }

  export type ContactRelationshipCreateManyTargetInput = {
    id: Uint8Array
    sourceId: Uint8Array
    type: string
    established?: Date | string | null
    notes?: string | null
  }

  export type NoteUpdateWithoutContactInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noteType?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    waypoint?: ActivityWaypointUpdateOneWithoutNoteNestedInput
    activity?: ActivityUpdateOneWithoutNotesNestedInput
    opportunity?: OpportunityUpdateOneWithoutNotesNestedInput
    tenet?: TenetUpdateOneRequiredWithoutNotesNestedInput
    author?: UserUpdateOneRequiredWithoutNotesNestedInput
    events?: ContactTimelineEventUpdateManyWithoutNoteNestedInput
  }

  export type NoteUncheckedUpdateWithoutContactInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    content?: StringFieldUpdateOperationsInput | string
    waypointId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    activityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    opportunityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    authorId?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noteType?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    events?: ContactTimelineEventUncheckedUpdateManyWithoutNoteNestedInput
  }

  export type NoteUncheckedUpdateManyWithoutContactInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    content?: StringFieldUpdateOperationsInput | string
    waypointId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    activityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    opportunityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    authorId?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noteType?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
  }

  export type ContactTimelineEventContactJoinUpdateWithoutContactRelationInput = {
    type?: EnumContactTimelineEventJoinTypeFieldUpdateOperationsInput | $Enums.ContactTimelineEventJoinType
    contactEventRelation?: ContactTimelineEventUpdateOneRequiredWithoutContactsNestedInput
  }

  export type ContactTimelineEventContactJoinUncheckedUpdateWithoutContactRelationInput = {
    contactEventId?: BytesFieldUpdateOperationsInput | Uint8Array
    type?: EnumContactTimelineEventJoinTypeFieldUpdateOperationsInput | $Enums.ContactTimelineEventJoinType
  }

  export type ContactTimelineEventContactJoinUncheckedUpdateManyWithoutContactRelationInput = {
    contactEventId?: BytesFieldUpdateOperationsInput | Uint8Array
    type?: EnumContactTimelineEventJoinTypeFieldUpdateOperationsInput | $Enums.ContactTimelineEventJoinType
  }

  export type AddressUpdateWithoutContactInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    type?: EnumAddressTypeFieldUpdateOperationsInput | $Enums.AddressType
    primary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    tenet?: TenetUpdateOneRequiredWithoutAddressesNestedInput
  }

  export type AddressUncheckedUpdateWithoutContactInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    type?: EnumAddressTypeFieldUpdateOperationsInput | $Enums.AddressType
    primary?: BoolFieldUpdateOperationsInput | boolean
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AddressUncheckedUpdateManyWithoutContactInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zip?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    type?: EnumAddressTypeFieldUpdateOperationsInput | $Enums.AddressType
    primary?: BoolFieldUpdateOperationsInput | boolean
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContactEmailUpdateWithoutContactInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    email?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenet?: TenetUpdateOneRequiredWithoutContactEmailsNestedInput
  }

  export type ContactEmailUncheckedUpdateWithoutContactInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    email?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactEmailUncheckedUpdateManyWithoutContactInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    email?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactPhoneUpdateWithoutContactInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    number?: StringFieldUpdateOperationsInput | string
    type?: EnumPhoneTypeFieldUpdateOperationsInput | $Enums.PhoneType
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenet?: TenetUpdateOneRequiredWithoutContactPhonesNestedInput
  }

  export type ContactPhoneUncheckedUpdateWithoutContactInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    number?: StringFieldUpdateOperationsInput | string
    type?: EnumPhoneTypeFieldUpdateOperationsInput | $Enums.PhoneType
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactPhoneUncheckedUpdateManyWithoutContactInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    number?: StringFieldUpdateOperationsInput | string
    type?: EnumPhoneTypeFieldUpdateOperationsInput | $Enums.PhoneType
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImportantDateUpdateWithoutContactInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumImportantDateTypeFieldUpdateOperationsInput | $Enums.ImportantDateType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenet?: TenetUpdateOneRequiredWithoutImportantDatesNestedInput
  }

  export type ImportantDateUncheckedUpdateWithoutContactInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumImportantDateTypeFieldUpdateOperationsInput | $Enums.ImportantDateType
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImportantDateUncheckedUpdateManyWithoutContactInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumImportantDateTypeFieldUpdateOperationsInput | $Enums.ImportantDateType
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityContactJoinUpdateWithoutContactRelationInput = {
    activityRelation?: ActivityUpdateOneRequiredWithoutContactsNestedInput
  }

  export type ActivityContactJoinUncheckedUpdateWithoutContactRelationInput = {
    activityId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type ActivityContactJoinUncheckedUpdateManyWithoutContactRelationInput = {
    activityId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type ContactUpdateWithoutHouseholdInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    importantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    lifecycleStage?: NullableEnumLifecycleStageFieldUpdateOperationsInput | $Enums.LifecycleStage | null
    lastContactedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    householdStatus?: NullableEnumHouseholdRelationshipStatusFieldUpdateOperationsInput | $Enums.HouseholdRelationshipStatus | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyStatus?: NullableEnumCompanyRelationshipStatusFieldUpdateOperationsInput | $Enums.CompanyRelationshipStatus | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenet?: TenetUpdateOneRequiredWithoutContactsNestedInput
    notes?: NoteUpdateManyWithoutContactNestedInput
    timelineEvents?: ContactTimelineEventContactJoinUpdateManyWithoutContactRelationNestedInput
    addresses?: AddressUpdateManyWithoutContactNestedInput
    emails?: ContactEmailUpdateManyWithoutContactNestedInput
    phones?: ContactPhoneUpdateManyWithoutContactNestedInput
    importantDates?: ImportantDateUpdateManyWithoutContactNestedInput
    activities?: ActivityContactJoinUpdateManyWithoutContactRelationNestedInput
    headOfHouseholdFor?: ContactUpdateOneWithoutHeadOfHouseholdNestedInput
    company?: ContactUpdateOneWithoutEmployeesNestedInput
    primaryContactFor?: ContactUpdateOneWithoutPrimaryContactNestedInput
    headOfHousehold?: ContactUpdateOneWithoutHeadOfHouseholdForNestedInput
    householdMembers?: ContactUpdateManyWithoutHouseholdNestedInput
    employees?: ContactUpdateManyWithoutCompanyNestedInput
    primaryContact?: ContactUpdateOneWithoutPrimaryContactForNestedInput
    opportunities?: ContactOpportunityJoinUpdateManyWithoutContactRelationNestedInput
    relationAsSource?: ContactRelationshipUpdateManyWithoutSourceNestedInput
    relationAsTarget?: ContactRelationshipUpdateManyWithoutTargetNestedInput
  }

  export type ContactUncheckedUpdateWithoutHouseholdInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    importantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    lifecycleStage?: NullableEnumLifecycleStageFieldUpdateOperationsInput | $Enums.LifecycleStage | null
    lastContactedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    householdStatus?: NullableEnumHouseholdRelationshipStatusFieldUpdateOperationsInput | $Enums.HouseholdRelationshipStatus | null
    companyId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyStatus?: NullableEnumCompanyRelationshipStatusFieldUpdateOperationsInput | $Enums.CompanyRelationshipStatus | null
    headOfHouseholdId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    primaryContactId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NoteUncheckedUpdateManyWithoutContactNestedInput
    timelineEvents?: ContactTimelineEventContactJoinUncheckedUpdateManyWithoutContactRelationNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutContactNestedInput
    emails?: ContactEmailUncheckedUpdateManyWithoutContactNestedInput
    phones?: ContactPhoneUncheckedUpdateManyWithoutContactNestedInput
    importantDates?: ImportantDateUncheckedUpdateManyWithoutContactNestedInput
    activities?: ActivityContactJoinUncheckedUpdateManyWithoutContactRelationNestedInput
    headOfHouseholdFor?: ContactUncheckedUpdateOneWithoutHeadOfHouseholdNestedInput
    primaryContactFor?: ContactUncheckedUpdateOneWithoutPrimaryContactNestedInput
    householdMembers?: ContactUncheckedUpdateManyWithoutHouseholdNestedInput
    employees?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    opportunities?: ContactOpportunityJoinUncheckedUpdateManyWithoutContactRelationNestedInput
    relationAsSource?: ContactRelationshipUncheckedUpdateManyWithoutSourceNestedInput
    relationAsTarget?: ContactRelationshipUncheckedUpdateManyWithoutTargetNestedInput
  }

  export type ContactUncheckedUpdateManyWithoutHouseholdInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    importantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    lifecycleStage?: NullableEnumLifecycleStageFieldUpdateOperationsInput | $Enums.LifecycleStage | null
    lastContactedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    householdStatus?: NullableEnumHouseholdRelationshipStatusFieldUpdateOperationsInput | $Enums.HouseholdRelationshipStatus | null
    companyId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyStatus?: NullableEnumCompanyRelationshipStatusFieldUpdateOperationsInput | $Enums.CompanyRelationshipStatus | null
    headOfHouseholdId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    primaryContactId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContactUpdateWithoutCompanyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    importantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    lifecycleStage?: NullableEnumLifecycleStageFieldUpdateOperationsInput | $Enums.LifecycleStage | null
    lastContactedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    householdStatus?: NullableEnumHouseholdRelationshipStatusFieldUpdateOperationsInput | $Enums.HouseholdRelationshipStatus | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyStatus?: NullableEnumCompanyRelationshipStatusFieldUpdateOperationsInput | $Enums.CompanyRelationshipStatus | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenet?: TenetUpdateOneRequiredWithoutContactsNestedInput
    notes?: NoteUpdateManyWithoutContactNestedInput
    timelineEvents?: ContactTimelineEventContactJoinUpdateManyWithoutContactRelationNestedInput
    addresses?: AddressUpdateManyWithoutContactNestedInput
    emails?: ContactEmailUpdateManyWithoutContactNestedInput
    phones?: ContactPhoneUpdateManyWithoutContactNestedInput
    importantDates?: ImportantDateUpdateManyWithoutContactNestedInput
    activities?: ActivityContactJoinUpdateManyWithoutContactRelationNestedInput
    household?: ContactUpdateOneWithoutHouseholdMembersNestedInput
    headOfHouseholdFor?: ContactUpdateOneWithoutHeadOfHouseholdNestedInput
    primaryContactFor?: ContactUpdateOneWithoutPrimaryContactNestedInput
    headOfHousehold?: ContactUpdateOneWithoutHeadOfHouseholdForNestedInput
    householdMembers?: ContactUpdateManyWithoutHouseholdNestedInput
    employees?: ContactUpdateManyWithoutCompanyNestedInput
    primaryContact?: ContactUpdateOneWithoutPrimaryContactForNestedInput
    opportunities?: ContactOpportunityJoinUpdateManyWithoutContactRelationNestedInput
    relationAsSource?: ContactRelationshipUpdateManyWithoutSourceNestedInput
    relationAsTarget?: ContactRelationshipUpdateManyWithoutTargetNestedInput
  }

  export type ContactUncheckedUpdateWithoutCompanyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    importantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    lifecycleStage?: NullableEnumLifecycleStageFieldUpdateOperationsInput | $Enums.LifecycleStage | null
    lastContactedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    householdId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    householdStatus?: NullableEnumHouseholdRelationshipStatusFieldUpdateOperationsInput | $Enums.HouseholdRelationshipStatus | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyStatus?: NullableEnumCompanyRelationshipStatusFieldUpdateOperationsInput | $Enums.CompanyRelationshipStatus | null
    headOfHouseholdId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    primaryContactId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NoteUncheckedUpdateManyWithoutContactNestedInput
    timelineEvents?: ContactTimelineEventContactJoinUncheckedUpdateManyWithoutContactRelationNestedInput
    addresses?: AddressUncheckedUpdateManyWithoutContactNestedInput
    emails?: ContactEmailUncheckedUpdateManyWithoutContactNestedInput
    phones?: ContactPhoneUncheckedUpdateManyWithoutContactNestedInput
    importantDates?: ImportantDateUncheckedUpdateManyWithoutContactNestedInput
    activities?: ActivityContactJoinUncheckedUpdateManyWithoutContactRelationNestedInput
    headOfHouseholdFor?: ContactUncheckedUpdateOneWithoutHeadOfHouseholdNestedInput
    primaryContactFor?: ContactUncheckedUpdateOneWithoutPrimaryContactNestedInput
    householdMembers?: ContactUncheckedUpdateManyWithoutHouseholdNestedInput
    employees?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
    opportunities?: ContactOpportunityJoinUncheckedUpdateManyWithoutContactRelationNestedInput
    relationAsSource?: ContactRelationshipUncheckedUpdateManyWithoutSourceNestedInput
    relationAsTarget?: ContactRelationshipUncheckedUpdateManyWithoutTargetNestedInput
  }

  export type ContactUncheckedUpdateManyWithoutCompanyInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    importantNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    lifecycleStage?: NullableEnumLifecycleStageFieldUpdateOperationsInput | $Enums.LifecycleStage | null
    lastContactedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    householdId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    householdStatus?: NullableEnumHouseholdRelationshipStatusFieldUpdateOperationsInput | $Enums.HouseholdRelationshipStatus | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyStatus?: NullableEnumCompanyRelationshipStatusFieldUpdateOperationsInput | $Enums.CompanyRelationshipStatus | null
    headOfHouseholdId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    primaryContactId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContactOpportunityJoinUpdateWithoutContactRelationInput = {
    opportunityRelation?: OpportunityUpdateOneRequiredWithoutContactsNestedInput
  }

  export type ContactOpportunityJoinUncheckedUpdateWithoutContactRelationInput = {
    opportunityId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type ContactOpportunityJoinUncheckedUpdateManyWithoutContactRelationInput = {
    opportunityId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type ContactRelationshipUpdateWithoutSourceInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    type?: StringFieldUpdateOperationsInput | string
    established?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    target?: ContactUpdateOneRequiredWithoutRelationAsTargetNestedInput
  }

  export type ContactRelationshipUncheckedUpdateWithoutSourceInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    targetId?: BytesFieldUpdateOperationsInput | Uint8Array
    type?: StringFieldUpdateOperationsInput | string
    established?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContactRelationshipUncheckedUpdateManyWithoutSourceInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    targetId?: BytesFieldUpdateOperationsInput | Uint8Array
    type?: StringFieldUpdateOperationsInput | string
    established?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContactRelationshipUpdateWithoutTargetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    type?: StringFieldUpdateOperationsInput | string
    established?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    source?: ContactUpdateOneRequiredWithoutRelationAsSourceNestedInput
  }

  export type ContactRelationshipUncheckedUpdateWithoutTargetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    sourceId?: BytesFieldUpdateOperationsInput | Uint8Array
    type?: StringFieldUpdateOperationsInput | string
    established?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContactRelationshipUncheckedUpdateManyWithoutTargetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    sourceId?: BytesFieldUpdateOperationsInput | Uint8Array
    type?: StringFieldUpdateOperationsInput | string
    established?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ActivityStepUserJoinCreateManyStepRelationInput = {
    userId: Uint8Array
  }

  export type ActivityStepUserJoinUpdateWithoutStepRelationInput = {
    userRelation?: UserUpdateOneRequiredWithoutActivityStepsNestedInput
  }

  export type ActivityStepUserJoinUncheckedUpdateWithoutStepRelationInput = {
    userId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type ActivityStepUserJoinUncheckedUpdateManyWithoutStepRelationInput = {
    userId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type UserWaypointJoinCreateManyWaypointRelationInput = {
    userId: Uint8Array
  }

  export type ActivityCreateManyParentWaypointInput = {
    id: Uint8Array
    title: string
    type: $Enums.ActivityType
    parentActivityId?: Uint8Array | null
    templateId?: Uint8Array | null
    taskScheduleType?: $Enums.TaskScheduleType | null
    startDate: Date | string
    endDate: Date | string
    completedAt?: Date | string | null
    description?: string | null
    priority?: $Enums.ActivityPriority
    status: $Enums.ActivityStatus
    assignedById: Uint8Array
    phoneNumber?: string | null
    location?: string | null
    holdReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
    deleted?: boolean
    deletedAt?: Date | string | null
    order?: number | null
    opportunityId?: Uint8Array | null
  }

  export type ContactTimelineEventCreateManyWaypointInput = {
    id: Uint8Array
    activityId?: Uint8Array | null
    opportunityId?: Uint8Array | null
    noteId?: Uint8Array | null
    extraInfo?: string | null
    userId: Uint8Array
    tenetId: Uint8Array
    eventType: $Enums.ContactTimelineEventType
    relationshipType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NoteCreateManyWaypointInput = {
    id: Uint8Array
    content: string
    activityId?: Uint8Array | null
    contactId?: Uint8Array | null
    opportunityId?: Uint8Array | null
    tenetId: Uint8Array
    authorId: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean
    deletedAt?: Date | string | null
    noteType?: $Enums.NoteType
  }

  export type UserWaypointJoinUpdateWithoutWaypointRelationInput = {
    userRelation?: UserUpdateOneRequiredWithoutWaypointsNestedInput
  }

  export type UserWaypointJoinUncheckedUpdateWithoutWaypointRelationInput = {
    userId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type UserWaypointJoinUncheckedUpdateManyWithoutWaypointRelationInput = {
    userId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type ActivityUpdateWithoutParentWaypointInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    steps?: ActivityStepUpdateManyWithoutActivityNestedInput
    waypoints?: ActivityWaypointUpdateManyWithoutActivityNestedInput
    activities?: ActivityUpdateManyWithoutParentActivityNestedInput
    parentActivity?: ActivityUpdateOneWithoutActivitiesNestedInput
    template?: ActivityTemplateUpdateOneWithoutActivitiesNestedInput
    assignedBy?: UserUpdateOneRequiredWithoutAssignedActivitiesNestedInput
    contacts?: ActivityContactJoinUpdateManyWithoutActivityRelationNestedInput
    users?: ActivityUserJoinUpdateManyWithoutActivityRelationNestedInput
    tenet?: TenetUpdateOneRequiredWithoutActivitiesNestedInput
    attachments?: AttachmentUpdateManyWithoutActivityNestedInput
    notes?: NoteUpdateManyWithoutActivityNestedInput
    events?: ContactTimelineEventUpdateManyWithoutActivityNestedInput
    opportunity?: OpportunityUpdateOneWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateWithoutParentWaypointInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    parentActivityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    templateId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    assignedById?: BytesFieldUpdateOperationsInput | Uint8Array
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    opportunityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    steps?: ActivityStepUncheckedUpdateManyWithoutActivityNestedInput
    waypoints?: ActivityWaypointUncheckedUpdateManyWithoutActivityNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutParentActivityNestedInput
    contacts?: ActivityContactJoinUncheckedUpdateManyWithoutActivityRelationNestedInput
    users?: ActivityUserJoinUncheckedUpdateManyWithoutActivityRelationNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutActivityNestedInput
    notes?: NoteUncheckedUpdateManyWithoutActivityNestedInput
    events?: ContactTimelineEventUncheckedUpdateManyWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateManyWithoutParentWaypointInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    parentActivityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    templateId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    assignedById?: BytesFieldUpdateOperationsInput | Uint8Array
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    opportunityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type ContactTimelineEventUpdateWithoutWaypointInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    extraInfo?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: EnumContactTimelineEventTypeFieldUpdateOperationsInput | $Enums.ContactTimelineEventType
    relationshipType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activity?: ActivityUpdateOneWithoutEventsNestedInput
    opportunity?: OpportunityUpdateOneWithoutEventsNestedInput
    note?: NoteUpdateOneWithoutEventsNestedInput
    contacts?: ContactTimelineEventContactJoinUpdateManyWithoutContactEventRelationNestedInput
    user?: UserUpdateOneRequiredWithoutEventsNestedInput
    tenet?: TenetUpdateOneRequiredWithoutContactTimelineEventsNestedInput
  }

  export type ContactTimelineEventUncheckedUpdateWithoutWaypointInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    activityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    opportunityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    noteId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    extraInfo?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: BytesFieldUpdateOperationsInput | Uint8Array
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    eventType?: EnumContactTimelineEventTypeFieldUpdateOperationsInput | $Enums.ContactTimelineEventType
    relationshipType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactTimelineEventContactJoinUncheckedUpdateManyWithoutContactEventRelationNestedInput
  }

  export type ContactTimelineEventUncheckedUpdateManyWithoutWaypointInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    activityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    opportunityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    noteId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    extraInfo?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: BytesFieldUpdateOperationsInput | Uint8Array
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    eventType?: EnumContactTimelineEventTypeFieldUpdateOperationsInput | $Enums.ContactTimelineEventType
    relationshipType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoteUpdateWithoutWaypointInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noteType?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    activity?: ActivityUpdateOneWithoutNotesNestedInput
    contact?: ContactUpdateOneWithoutNotesNestedInput
    opportunity?: OpportunityUpdateOneWithoutNotesNestedInput
    tenet?: TenetUpdateOneRequiredWithoutNotesNestedInput
    author?: UserUpdateOneRequiredWithoutNotesNestedInput
    events?: ContactTimelineEventUpdateManyWithoutNoteNestedInput
  }

  export type NoteUncheckedUpdateWithoutWaypointInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    content?: StringFieldUpdateOperationsInput | string
    activityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    contactId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    opportunityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    authorId?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noteType?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    events?: ContactTimelineEventUncheckedUpdateManyWithoutNoteNestedInput
  }

  export type NoteUncheckedUpdateManyWithoutWaypointInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    content?: StringFieldUpdateOperationsInput | string
    activityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    contactId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    opportunityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    authorId?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noteType?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
  }

  export type ActivityTemplateCreateManyParentWaypointInput = {
    id: Uint8Array
    title: string
    description?: string | null
    type: $Enums.ActivityType
    defaultPriority: $Enums.ActivityPriority
    defaultStatus: $Enums.ActivityStatus
    taskScheduleType?: $Enums.TaskScheduleType | null
    dateOffsetType: $Enums.DateOffsetType
    startDate: number
    endDate: number
    startRelativeToId?: Uint8Array | null
    parentActivityId?: Uint8Array | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
    order?: number | null
  }

  export type ActivityWaypointCreateManyTemplateInput = {
    id: Uint8Array
    title: string
    description?: string | null
    summary?: string | null
    status: $Enums.ActivityStatus
    order: number
    actualStart: Date | string
    dueDate: Date | string
    actualEnd?: Date | string | null
    activityId: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
  }

  export type TemplateAssignmentCreateManyWaypointTemplateInput = {
    id: Uint8Array
    specificUserId?: Uint8Array | null
    specificRole?: $Enums.Role | null
    activityTemplateId?: Uint8Array | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
  }

  export type ActivityTemplateUpdateWithoutParentWaypointInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    defaultPriority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    defaultStatus?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    dateOffsetType?: EnumDateOffsetTypeFieldUpdateOperationsInput | $Enums.DateOffsetType
    startDate?: IntFieldUpdateOperationsInput | number
    endDate?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    steps?: ActivityTemplateStepUpdateManyWithoutActivityTemplateNestedInput
    startRelativeTo?: ActivityTemplateUpdateOneWithoutDependentsNestedInput
    dependents?: ActivityTemplateUpdateManyWithoutStartRelativeToNestedInput
    parentActivity?: ActivityTemplateUpdateOneWithoutChildActivitiesNestedInput
    waypoints?: ActivityWaypointTemplateUpdateManyWithoutParentActivityNestedInput
    childActivities?: ActivityTemplateUpdateManyWithoutParentActivityNestedInput
    activities?: ActivityUpdateManyWithoutTemplateNestedInput
    assignments?: TemplateAssignmentUpdateManyWithoutActivityTemplateNestedInput
    tenet?: TenetUpdateOneRequiredWithoutActivityTemplatesNestedInput
  }

  export type ActivityTemplateUncheckedUpdateWithoutParentWaypointInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    defaultPriority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    defaultStatus?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    dateOffsetType?: EnumDateOffsetTypeFieldUpdateOperationsInput | $Enums.DateOffsetType
    startDate?: IntFieldUpdateOperationsInput | number
    endDate?: IntFieldUpdateOperationsInput | number
    startRelativeToId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    parentActivityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    order?: NullableIntFieldUpdateOperationsInput | number | null
    steps?: ActivityTemplateStepUncheckedUpdateManyWithoutActivityTemplateNestedInput
    dependents?: ActivityTemplateUncheckedUpdateManyWithoutStartRelativeToNestedInput
    waypoints?: ActivityWaypointTemplateUncheckedUpdateManyWithoutParentActivityNestedInput
    childActivities?: ActivityTemplateUncheckedUpdateManyWithoutParentActivityNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutTemplateNestedInput
    assignments?: TemplateAssignmentUncheckedUpdateManyWithoutActivityTemplateNestedInput
  }

  export type ActivityTemplateUncheckedUpdateManyWithoutParentWaypointInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    defaultPriority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    defaultStatus?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    dateOffsetType?: EnumDateOffsetTypeFieldUpdateOperationsInput | $Enums.DateOffsetType
    startDate?: IntFieldUpdateOperationsInput | number
    endDate?: IntFieldUpdateOperationsInput | number
    startRelativeToId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    parentActivityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    order?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ActivityWaypointUpdateWithoutTemplateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    order?: IntFieldUpdateOperationsInput | number
    actualStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserWaypointJoinUpdateManyWithoutWaypointRelationNestedInput
    activity?: ActivityUpdateOneRequiredWithoutWaypointsNestedInput
    childActivities?: ActivityUpdateManyWithoutParentWaypointNestedInput
    events?: ContactTimelineEventUpdateManyWithoutWaypointNestedInput
    tenet?: TenetUpdateOneRequiredWithoutActivityWaypointsNestedInput
    Note?: NoteUpdateManyWithoutWaypointNestedInput
  }

  export type ActivityWaypointUncheckedUpdateWithoutTemplateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    order?: IntFieldUpdateOperationsInput | number
    actualStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activityId?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    users?: UserWaypointJoinUncheckedUpdateManyWithoutWaypointRelationNestedInput
    childActivities?: ActivityUncheckedUpdateManyWithoutParentWaypointNestedInput
    events?: ContactTimelineEventUncheckedUpdateManyWithoutWaypointNestedInput
    Note?: NoteUncheckedUpdateManyWithoutWaypointNestedInput
  }

  export type ActivityWaypointUncheckedUpdateManyWithoutTemplateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    order?: IntFieldUpdateOperationsInput | number
    actualStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activityId?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type TemplateAssignmentUpdateWithoutWaypointTemplateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    specificRole?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    specificUser?: UserUpdateOneWithoutTemplateAssignmentsNestedInput
    activityTemplate?: ActivityTemplateUpdateOneWithoutAssignmentsNestedInput
    tenet?: TenetUpdateOneRequiredWithoutTemplateAssignmentsNestedInput
  }

  export type TemplateAssignmentUncheckedUpdateWithoutWaypointTemplateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    specificUserId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    specificRole?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    activityTemplateId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type TemplateAssignmentUncheckedUpdateManyWithoutWaypointTemplateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    specificUserId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    specificRole?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    activityTemplateId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type ActivityTemplateStepAssignmentCreateManyActivityTemplateStepInput = {
    id: Uint8Array
    specificUserId?: Uint8Array | null
    specificRole?: $Enums.Role | null
    tenetId: Uint8Array
  }

  export type ActivityTemplateStepAssignmentUpdateWithoutActivityTemplateStepInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    specificRole?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    specificUser?: UserUpdateOneWithoutTemplateStepAssignmentsNestedInput
    tenet?: TenetUpdateOneRequiredWithoutActivityTemplateStepAssignmentNestedInput
  }

  export type ActivityTemplateStepAssignmentUncheckedUpdateWithoutActivityTemplateStepInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    specificUserId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    specificRole?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type ActivityTemplateStepAssignmentUncheckedUpdateManyWithoutActivityTemplateStepInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    specificUserId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    specificRole?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type ActivityTemplateStepCreateManyActivityTemplateInput = {
    id: Uint8Array
    order: number
    title: string
    type?: $Enums.ActivityStepType
    tenetId: Uint8Array
  }

  export type ActivityTemplateCreateManyStartRelativeToInput = {
    id: Uint8Array
    title: string
    description?: string | null
    type: $Enums.ActivityType
    defaultPriority: $Enums.ActivityPriority
    defaultStatus: $Enums.ActivityStatus
    taskScheduleType?: $Enums.TaskScheduleType | null
    dateOffsetType: $Enums.DateOffsetType
    startDate: number
    endDate: number
    parentWaypointId?: Uint8Array | null
    parentActivityId?: Uint8Array | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
    order?: number | null
  }

  export type ActivityWaypointTemplateCreateManyParentActivityInput = {
    id: Uint8Array
    title: string
    description?: string | null
    defaultStatus: $Enums.ActivityStatus
    order: number
    dateOffsetType: $Enums.DateOffsetType
    dueDate: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
  }

  export type ActivityTemplateCreateManyParentActivityInput = {
    id: Uint8Array
    title: string
    description?: string | null
    type: $Enums.ActivityType
    defaultPriority: $Enums.ActivityPriority
    defaultStatus: $Enums.ActivityStatus
    taskScheduleType?: $Enums.TaskScheduleType | null
    dateOffsetType: $Enums.DateOffsetType
    startDate: number
    endDate: number
    startRelativeToId?: Uint8Array | null
    parentWaypointId?: Uint8Array | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
    order?: number | null
  }

  export type ActivityCreateManyTemplateInput = {
    id: Uint8Array
    title: string
    type: $Enums.ActivityType
    parentActivityId?: Uint8Array | null
    parentWaypointId?: Uint8Array | null
    taskScheduleType?: $Enums.TaskScheduleType | null
    startDate: Date | string
    endDate: Date | string
    completedAt?: Date | string | null
    description?: string | null
    priority?: $Enums.ActivityPriority
    status: $Enums.ActivityStatus
    assignedById: Uint8Array
    phoneNumber?: string | null
    location?: string | null
    holdReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
    deleted?: boolean
    deletedAt?: Date | string | null
    order?: number | null
    opportunityId?: Uint8Array | null
  }

  export type TemplateAssignmentCreateManyActivityTemplateInput = {
    id: Uint8Array
    specificUserId?: Uint8Array | null
    specificRole?: $Enums.Role | null
    waypointTemplateId?: Uint8Array | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
  }

  export type ActivityTemplateStepUpdateWithoutActivityTemplateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityStepTypeFieldUpdateOperationsInput | $Enums.ActivityStepType
    tenet?: TenetUpdateOneRequiredWithoutActivityTemplateStepsNestedInput
    assignedTo?: ActivityTemplateStepAssignmentUpdateManyWithoutActivityTemplateStepNestedInput
  }

  export type ActivityTemplateStepUncheckedUpdateWithoutActivityTemplateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityStepTypeFieldUpdateOperationsInput | $Enums.ActivityStepType
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    assignedTo?: ActivityTemplateStepAssignmentUncheckedUpdateManyWithoutActivityTemplateStepNestedInput
  }

  export type ActivityTemplateStepUncheckedUpdateManyWithoutActivityTemplateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityStepTypeFieldUpdateOperationsInput | $Enums.ActivityStepType
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type ActivityTemplateUpdateWithoutStartRelativeToInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    defaultPriority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    defaultStatus?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    dateOffsetType?: EnumDateOffsetTypeFieldUpdateOperationsInput | $Enums.DateOffsetType
    startDate?: IntFieldUpdateOperationsInput | number
    endDate?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    steps?: ActivityTemplateStepUpdateManyWithoutActivityTemplateNestedInput
    dependents?: ActivityTemplateUpdateManyWithoutStartRelativeToNestedInput
    parentWaypoint?: ActivityWaypointTemplateUpdateOneWithoutActivitiesNestedInput
    parentActivity?: ActivityTemplateUpdateOneWithoutChildActivitiesNestedInput
    waypoints?: ActivityWaypointTemplateUpdateManyWithoutParentActivityNestedInput
    childActivities?: ActivityTemplateUpdateManyWithoutParentActivityNestedInput
    activities?: ActivityUpdateManyWithoutTemplateNestedInput
    assignments?: TemplateAssignmentUpdateManyWithoutActivityTemplateNestedInput
    tenet?: TenetUpdateOneRequiredWithoutActivityTemplatesNestedInput
  }

  export type ActivityTemplateUncheckedUpdateWithoutStartRelativeToInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    defaultPriority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    defaultStatus?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    dateOffsetType?: EnumDateOffsetTypeFieldUpdateOperationsInput | $Enums.DateOffsetType
    startDate?: IntFieldUpdateOperationsInput | number
    endDate?: IntFieldUpdateOperationsInput | number
    parentWaypointId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    parentActivityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    order?: NullableIntFieldUpdateOperationsInput | number | null
    steps?: ActivityTemplateStepUncheckedUpdateManyWithoutActivityTemplateNestedInput
    dependents?: ActivityTemplateUncheckedUpdateManyWithoutStartRelativeToNestedInput
    waypoints?: ActivityWaypointTemplateUncheckedUpdateManyWithoutParentActivityNestedInput
    childActivities?: ActivityTemplateUncheckedUpdateManyWithoutParentActivityNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutTemplateNestedInput
    assignments?: TemplateAssignmentUncheckedUpdateManyWithoutActivityTemplateNestedInput
  }

  export type ActivityTemplateUncheckedUpdateManyWithoutStartRelativeToInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    defaultPriority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    defaultStatus?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    dateOffsetType?: EnumDateOffsetTypeFieldUpdateOperationsInput | $Enums.DateOffsetType
    startDate?: IntFieldUpdateOperationsInput | number
    endDate?: IntFieldUpdateOperationsInput | number
    parentWaypointId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    parentActivityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    order?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ActivityWaypointTemplateUpdateWithoutParentActivityInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultStatus?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    order?: IntFieldUpdateOperationsInput | number
    dateOffsetType?: EnumDateOffsetTypeFieldUpdateOperationsInput | $Enums.DateOffsetType
    dueDate?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: ActivityTemplateUpdateManyWithoutParentWaypointNestedInput
    waypoints?: ActivityWaypointUpdateManyWithoutTemplateNestedInput
    assignments?: TemplateAssignmentUpdateManyWithoutWaypointTemplateNestedInput
    tenet?: TenetUpdateOneRequiredWithoutActivityWaypointTemplatesNestedInput
  }

  export type ActivityWaypointTemplateUncheckedUpdateWithoutParentActivityInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultStatus?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    order?: IntFieldUpdateOperationsInput | number
    dateOffsetType?: EnumDateOffsetTypeFieldUpdateOperationsInput | $Enums.DateOffsetType
    dueDate?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    activities?: ActivityTemplateUncheckedUpdateManyWithoutParentWaypointNestedInput
    waypoints?: ActivityWaypointUncheckedUpdateManyWithoutTemplateNestedInput
    assignments?: TemplateAssignmentUncheckedUpdateManyWithoutWaypointTemplateNestedInput
  }

  export type ActivityWaypointTemplateUncheckedUpdateManyWithoutParentActivityInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultStatus?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    order?: IntFieldUpdateOperationsInput | number
    dateOffsetType?: EnumDateOffsetTypeFieldUpdateOperationsInput | $Enums.DateOffsetType
    dueDate?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type ActivityTemplateUpdateWithoutParentActivityInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    defaultPriority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    defaultStatus?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    dateOffsetType?: EnumDateOffsetTypeFieldUpdateOperationsInput | $Enums.DateOffsetType
    startDate?: IntFieldUpdateOperationsInput | number
    endDate?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: NullableIntFieldUpdateOperationsInput | number | null
    steps?: ActivityTemplateStepUpdateManyWithoutActivityTemplateNestedInput
    startRelativeTo?: ActivityTemplateUpdateOneWithoutDependentsNestedInput
    dependents?: ActivityTemplateUpdateManyWithoutStartRelativeToNestedInput
    parentWaypoint?: ActivityWaypointTemplateUpdateOneWithoutActivitiesNestedInput
    waypoints?: ActivityWaypointTemplateUpdateManyWithoutParentActivityNestedInput
    childActivities?: ActivityTemplateUpdateManyWithoutParentActivityNestedInput
    activities?: ActivityUpdateManyWithoutTemplateNestedInput
    assignments?: TemplateAssignmentUpdateManyWithoutActivityTemplateNestedInput
    tenet?: TenetUpdateOneRequiredWithoutActivityTemplatesNestedInput
  }

  export type ActivityTemplateUncheckedUpdateWithoutParentActivityInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    defaultPriority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    defaultStatus?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    dateOffsetType?: EnumDateOffsetTypeFieldUpdateOperationsInput | $Enums.DateOffsetType
    startDate?: IntFieldUpdateOperationsInput | number
    endDate?: IntFieldUpdateOperationsInput | number
    startRelativeToId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    parentWaypointId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    order?: NullableIntFieldUpdateOperationsInput | number | null
    steps?: ActivityTemplateStepUncheckedUpdateManyWithoutActivityTemplateNestedInput
    dependents?: ActivityTemplateUncheckedUpdateManyWithoutStartRelativeToNestedInput
    waypoints?: ActivityWaypointTemplateUncheckedUpdateManyWithoutParentActivityNestedInput
    childActivities?: ActivityTemplateUncheckedUpdateManyWithoutParentActivityNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutTemplateNestedInput
    assignments?: TemplateAssignmentUncheckedUpdateManyWithoutActivityTemplateNestedInput
  }

  export type ActivityTemplateUncheckedUpdateManyWithoutParentActivityInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    defaultPriority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    defaultStatus?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    dateOffsetType?: EnumDateOffsetTypeFieldUpdateOperationsInput | $Enums.DateOffsetType
    startDate?: IntFieldUpdateOperationsInput | number
    endDate?: IntFieldUpdateOperationsInput | number
    startRelativeToId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    parentWaypointId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    order?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ActivityUpdateWithoutTemplateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    steps?: ActivityStepUpdateManyWithoutActivityNestedInput
    waypoints?: ActivityWaypointUpdateManyWithoutActivityNestedInput
    activities?: ActivityUpdateManyWithoutParentActivityNestedInput
    parentActivity?: ActivityUpdateOneWithoutActivitiesNestedInput
    parentWaypoint?: ActivityWaypointUpdateOneWithoutChildActivitiesNestedInput
    assignedBy?: UserUpdateOneRequiredWithoutAssignedActivitiesNestedInput
    contacts?: ActivityContactJoinUpdateManyWithoutActivityRelationNestedInput
    users?: ActivityUserJoinUpdateManyWithoutActivityRelationNestedInput
    tenet?: TenetUpdateOneRequiredWithoutActivitiesNestedInput
    attachments?: AttachmentUpdateManyWithoutActivityNestedInput
    notes?: NoteUpdateManyWithoutActivityNestedInput
    events?: ContactTimelineEventUpdateManyWithoutActivityNestedInput
    opportunity?: OpportunityUpdateOneWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateWithoutTemplateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    parentActivityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    parentWaypointId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    assignedById?: BytesFieldUpdateOperationsInput | Uint8Array
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    opportunityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    steps?: ActivityStepUncheckedUpdateManyWithoutActivityNestedInput
    waypoints?: ActivityWaypointUncheckedUpdateManyWithoutActivityNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutParentActivityNestedInput
    contacts?: ActivityContactJoinUncheckedUpdateManyWithoutActivityRelationNestedInput
    users?: ActivityUserJoinUncheckedUpdateManyWithoutActivityRelationNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutActivityNestedInput
    notes?: NoteUncheckedUpdateManyWithoutActivityNestedInput
    events?: ContactTimelineEventUncheckedUpdateManyWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateManyWithoutTemplateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    parentActivityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    parentWaypointId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    assignedById?: BytesFieldUpdateOperationsInput | Uint8Array
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    opportunityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type TemplateAssignmentUpdateWithoutActivityTemplateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    specificRole?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    specificUser?: UserUpdateOneWithoutTemplateAssignmentsNestedInput
    waypointTemplate?: ActivityWaypointTemplateUpdateOneWithoutAssignmentsNestedInput
    tenet?: TenetUpdateOneRequiredWithoutTemplateAssignmentsNestedInput
  }

  export type TemplateAssignmentUncheckedUpdateWithoutActivityTemplateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    specificUserId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    specificRole?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    waypointTemplateId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type TemplateAssignmentUncheckedUpdateManyWithoutActivityTemplateInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    specificUserId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    specificRole?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    waypointTemplateId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type ActivityStepCreateManyActivityInput = {
    id: Uint8Array
    title: string
    completed: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
    type?: $Enums.ActivityStepType
    order: number
  }

  export type ActivityWaypointCreateManyActivityInput = {
    id: Uint8Array
    title: string
    description?: string | null
    summary?: string | null
    status: $Enums.ActivityStatus
    order: number
    actualStart: Date | string
    dueDate: Date | string
    actualEnd?: Date | string | null
    templateId?: Uint8Array | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
  }

  export type ActivityCreateManyParentActivityInput = {
    id: Uint8Array
    title: string
    type: $Enums.ActivityType
    parentWaypointId?: Uint8Array | null
    templateId?: Uint8Array | null
    taskScheduleType?: $Enums.TaskScheduleType | null
    startDate: Date | string
    endDate: Date | string
    completedAt?: Date | string | null
    description?: string | null
    priority?: $Enums.ActivityPriority
    status: $Enums.ActivityStatus
    assignedById: Uint8Array
    phoneNumber?: string | null
    location?: string | null
    holdReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
    deleted?: boolean
    deletedAt?: Date | string | null
    order?: number | null
    opportunityId?: Uint8Array | null
  }

  export type ActivityContactJoinCreateManyActivityRelationInput = {
    contactId: Uint8Array
  }

  export type ActivityUserJoinCreateManyActivityRelationInput = {
    userId: Uint8Array
  }

  export type AttachmentCreateManyActivityInput = {
    id: Uint8Array
    name: string
    location: string
    tenetId: Uint8Array
  }

  export type NoteCreateManyActivityInput = {
    id: Uint8Array
    content: string
    waypointId?: Uint8Array | null
    contactId?: Uint8Array | null
    opportunityId?: Uint8Array | null
    tenetId: Uint8Array
    authorId: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean
    deletedAt?: Date | string | null
    noteType?: $Enums.NoteType
  }

  export type ContactTimelineEventCreateManyActivityInput = {
    id: Uint8Array
    waypointId?: Uint8Array | null
    opportunityId?: Uint8Array | null
    noteId?: Uint8Array | null
    extraInfo?: string | null
    userId: Uint8Array
    tenetId: Uint8Array
    eventType: $Enums.ContactTimelineEventType
    relationshipType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActivityStepUpdateWithoutActivityInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumActivityStepTypeFieldUpdateOperationsInput | $Enums.ActivityStepType
    order?: IntFieldUpdateOperationsInput | number
    assignedTo?: ActivityStepUserJoinUpdateManyWithoutStepRelationNestedInput
    tenet?: TenetUpdateOneRequiredWithoutActivityStepsNestedInput
  }

  export type ActivityStepUncheckedUpdateWithoutActivityInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    type?: EnumActivityStepTypeFieldUpdateOperationsInput | $Enums.ActivityStepType
    order?: IntFieldUpdateOperationsInput | number
    assignedTo?: ActivityStepUserJoinUncheckedUpdateManyWithoutStepRelationNestedInput
  }

  export type ActivityStepUncheckedUpdateManyWithoutActivityInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    type?: EnumActivityStepTypeFieldUpdateOperationsInput | $Enums.ActivityStepType
    order?: IntFieldUpdateOperationsInput | number
  }

  export type ActivityWaypointUpdateWithoutActivityInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    order?: IntFieldUpdateOperationsInput | number
    actualStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserWaypointJoinUpdateManyWithoutWaypointRelationNestedInput
    childActivities?: ActivityUpdateManyWithoutParentWaypointNestedInput
    template?: ActivityWaypointTemplateUpdateOneWithoutWaypointsNestedInput
    events?: ContactTimelineEventUpdateManyWithoutWaypointNestedInput
    tenet?: TenetUpdateOneRequiredWithoutActivityWaypointsNestedInput
    Note?: NoteUpdateManyWithoutWaypointNestedInput
  }

  export type ActivityWaypointUncheckedUpdateWithoutActivityInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    order?: IntFieldUpdateOperationsInput | number
    actualStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    templateId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    users?: UserWaypointJoinUncheckedUpdateManyWithoutWaypointRelationNestedInput
    childActivities?: ActivityUncheckedUpdateManyWithoutParentWaypointNestedInput
    events?: ContactTimelineEventUncheckedUpdateManyWithoutWaypointNestedInput
    Note?: NoteUncheckedUpdateManyWithoutWaypointNestedInput
  }

  export type ActivityWaypointUncheckedUpdateManyWithoutActivityInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    order?: IntFieldUpdateOperationsInput | number
    actualStart?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    actualEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    templateId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type ActivityUpdateWithoutParentActivityInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    steps?: ActivityStepUpdateManyWithoutActivityNestedInput
    waypoints?: ActivityWaypointUpdateManyWithoutActivityNestedInput
    activities?: ActivityUpdateManyWithoutParentActivityNestedInput
    parentWaypoint?: ActivityWaypointUpdateOneWithoutChildActivitiesNestedInput
    template?: ActivityTemplateUpdateOneWithoutActivitiesNestedInput
    assignedBy?: UserUpdateOneRequiredWithoutAssignedActivitiesNestedInput
    contacts?: ActivityContactJoinUpdateManyWithoutActivityRelationNestedInput
    users?: ActivityUserJoinUpdateManyWithoutActivityRelationNestedInput
    tenet?: TenetUpdateOneRequiredWithoutActivitiesNestedInput
    attachments?: AttachmentUpdateManyWithoutActivityNestedInput
    notes?: NoteUpdateManyWithoutActivityNestedInput
    events?: ContactTimelineEventUpdateManyWithoutActivityNestedInput
    opportunity?: OpportunityUpdateOneWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateWithoutParentActivityInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    parentWaypointId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    templateId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    assignedById?: BytesFieldUpdateOperationsInput | Uint8Array
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    opportunityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    steps?: ActivityStepUncheckedUpdateManyWithoutActivityNestedInput
    waypoints?: ActivityWaypointUncheckedUpdateManyWithoutActivityNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutParentActivityNestedInput
    contacts?: ActivityContactJoinUncheckedUpdateManyWithoutActivityRelationNestedInput
    users?: ActivityUserJoinUncheckedUpdateManyWithoutActivityRelationNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutActivityNestedInput
    notes?: NoteUncheckedUpdateManyWithoutActivityNestedInput
    events?: ContactTimelineEventUncheckedUpdateManyWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateManyWithoutParentActivityInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    parentWaypointId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    templateId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    assignedById?: BytesFieldUpdateOperationsInput | Uint8Array
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    opportunityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type ActivityContactJoinUpdateWithoutActivityRelationInput = {
    contactRelation?: ContactUpdateOneRequiredWithoutActivitiesNestedInput
  }

  export type ActivityContactJoinUncheckedUpdateWithoutActivityRelationInput = {
    contactId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type ActivityContactJoinUncheckedUpdateManyWithoutActivityRelationInput = {
    contactId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type ActivityUserJoinUpdateWithoutActivityRelationInput = {
    userRelation?: UserUpdateOneRequiredWithoutActivitiesNestedInput
  }

  export type ActivityUserJoinUncheckedUpdateWithoutActivityRelationInput = {
    userId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type ActivityUserJoinUncheckedUpdateManyWithoutActivityRelationInput = {
    userId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type AttachmentUpdateWithoutActivityInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    tenet?: TenetUpdateOneRequiredWithoutAttachmentsNestedInput
  }

  export type AttachmentUncheckedUpdateWithoutActivityInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type AttachmentUncheckedUpdateManyWithoutActivityInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type NoteUpdateWithoutActivityInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noteType?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    waypoint?: ActivityWaypointUpdateOneWithoutNoteNestedInput
    contact?: ContactUpdateOneWithoutNotesNestedInput
    opportunity?: OpportunityUpdateOneWithoutNotesNestedInput
    tenet?: TenetUpdateOneRequiredWithoutNotesNestedInput
    author?: UserUpdateOneRequiredWithoutNotesNestedInput
    events?: ContactTimelineEventUpdateManyWithoutNoteNestedInput
  }

  export type NoteUncheckedUpdateWithoutActivityInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    content?: StringFieldUpdateOperationsInput | string
    waypointId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    contactId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    opportunityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    authorId?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noteType?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    events?: ContactTimelineEventUncheckedUpdateManyWithoutNoteNestedInput
  }

  export type NoteUncheckedUpdateManyWithoutActivityInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    content?: StringFieldUpdateOperationsInput | string
    waypointId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    contactId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    opportunityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    authorId?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noteType?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
  }

  export type ContactTimelineEventUpdateWithoutActivityInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    extraInfo?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: EnumContactTimelineEventTypeFieldUpdateOperationsInput | $Enums.ContactTimelineEventType
    relationshipType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    waypoint?: ActivityWaypointUpdateOneWithoutEventsNestedInput
    opportunity?: OpportunityUpdateOneWithoutEventsNestedInput
    note?: NoteUpdateOneWithoutEventsNestedInput
    contacts?: ContactTimelineEventContactJoinUpdateManyWithoutContactEventRelationNestedInput
    user?: UserUpdateOneRequiredWithoutEventsNestedInput
    tenet?: TenetUpdateOneRequiredWithoutContactTimelineEventsNestedInput
  }

  export type ContactTimelineEventUncheckedUpdateWithoutActivityInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    waypointId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    opportunityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    noteId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    extraInfo?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: BytesFieldUpdateOperationsInput | Uint8Array
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    eventType?: EnumContactTimelineEventTypeFieldUpdateOperationsInput | $Enums.ContactTimelineEventType
    relationshipType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactTimelineEventContactJoinUncheckedUpdateManyWithoutContactEventRelationNestedInput
  }

  export type ContactTimelineEventUncheckedUpdateManyWithoutActivityInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    waypointId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    opportunityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    noteId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    extraInfo?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: BytesFieldUpdateOperationsInput | Uint8Array
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    eventType?: EnumContactTimelineEventTypeFieldUpdateOperationsInput | $Enums.ContactTimelineEventType
    relationshipType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactTimelineEventContactJoinCreateManyContactEventRelationInput = {
    contactId: Uint8Array
    type: $Enums.ContactTimelineEventJoinType
  }

  export type ContactTimelineEventContactJoinUpdateWithoutContactEventRelationInput = {
    type?: EnumContactTimelineEventJoinTypeFieldUpdateOperationsInput | $Enums.ContactTimelineEventJoinType
    contactRelation?: ContactUpdateOneRequiredWithoutTimelineEventsNestedInput
  }

  export type ContactTimelineEventContactJoinUncheckedUpdateWithoutContactEventRelationInput = {
    contactId?: BytesFieldUpdateOperationsInput | Uint8Array
    type?: EnumContactTimelineEventJoinTypeFieldUpdateOperationsInput | $Enums.ContactTimelineEventJoinType
  }

  export type ContactTimelineEventContactJoinUncheckedUpdateManyWithoutContactEventRelationInput = {
    contactId?: BytesFieldUpdateOperationsInput | Uint8Array
    type?: EnumContactTimelineEventJoinTypeFieldUpdateOperationsInput | $Enums.ContactTimelineEventJoinType
  }

  export type ContactTimelineEventCreateManyNoteInput = {
    id: Uint8Array
    activityId?: Uint8Array | null
    waypointId?: Uint8Array | null
    opportunityId?: Uint8Array | null
    extraInfo?: string | null
    userId: Uint8Array
    tenetId: Uint8Array
    eventType: $Enums.ContactTimelineEventType
    relationshipType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactTimelineEventUpdateWithoutNoteInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    extraInfo?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: EnumContactTimelineEventTypeFieldUpdateOperationsInput | $Enums.ContactTimelineEventType
    relationshipType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activity?: ActivityUpdateOneWithoutEventsNestedInput
    waypoint?: ActivityWaypointUpdateOneWithoutEventsNestedInput
    opportunity?: OpportunityUpdateOneWithoutEventsNestedInput
    contacts?: ContactTimelineEventContactJoinUpdateManyWithoutContactEventRelationNestedInput
    user?: UserUpdateOneRequiredWithoutEventsNestedInput
    tenet?: TenetUpdateOneRequiredWithoutContactTimelineEventsNestedInput
  }

  export type ContactTimelineEventUncheckedUpdateWithoutNoteInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    activityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    waypointId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    opportunityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    extraInfo?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: BytesFieldUpdateOperationsInput | Uint8Array
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    eventType?: EnumContactTimelineEventTypeFieldUpdateOperationsInput | $Enums.ContactTimelineEventType
    relationshipType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactTimelineEventContactJoinUncheckedUpdateManyWithoutContactEventRelationNestedInput
  }

  export type ContactTimelineEventUncheckedUpdateManyWithoutNoteInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    activityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    waypointId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    opportunityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    extraInfo?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: BytesFieldUpdateOperationsInput | Uint8Array
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    eventType?: EnumContactTimelineEventTypeFieldUpdateOperationsInput | $Enums.ContactTimelineEventType
    relationshipType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactOpportunityJoinCreateManyOpportunityRelationInput = {
    contactId: Uint8Array
  }

  export type UserOpportunityJoinCreateManyOpportunityRelationInput = {
    userId: Uint8Array
  }

  export type ActivityCreateManyOpportunityInput = {
    id: Uint8Array
    title: string
    type: $Enums.ActivityType
    parentActivityId?: Uint8Array | null
    parentWaypointId?: Uint8Array | null
    templateId?: Uint8Array | null
    taskScheduleType?: $Enums.TaskScheduleType | null
    startDate: Date | string
    endDate: Date | string
    completedAt?: Date | string | null
    description?: string | null
    priority?: $Enums.ActivityPriority
    status: $Enums.ActivityStatus
    assignedById: Uint8Array
    phoneNumber?: string | null
    location?: string | null
    holdReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenetId: Uint8Array
    deleted?: boolean
    deletedAt?: Date | string | null
    order?: number | null
  }

  export type OpportunityProductCreateManyOpportunityInput = {
    id: Uint8Array
    price: number
    order: number
    commission: number
    productTypeId: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactTimelineEventCreateManyOpportunityInput = {
    id: Uint8Array
    activityId?: Uint8Array | null
    waypointId?: Uint8Array | null
    noteId?: Uint8Array | null
    extraInfo?: string | null
    userId: Uint8Array
    tenetId: Uint8Array
    eventType: $Enums.ContactTimelineEventType
    relationshipType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NoteCreateManyOpportunityInput = {
    id: Uint8Array
    content: string
    waypointId?: Uint8Array | null
    activityId?: Uint8Array | null
    contactId?: Uint8Array | null
    tenetId: Uint8Array
    authorId: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
    deleted?: boolean
    deletedAt?: Date | string | null
    noteType?: $Enums.NoteType
  }

  export type ContactOpportunityJoinUpdateWithoutOpportunityRelationInput = {
    contactRelation?: ContactUpdateOneRequiredWithoutOpportunitiesNestedInput
  }

  export type ContactOpportunityJoinUncheckedUpdateWithoutOpportunityRelationInput = {
    contactId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type ContactOpportunityJoinUncheckedUpdateManyWithoutOpportunityRelationInput = {
    contactId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type UserOpportunityJoinUpdateWithoutOpportunityRelationInput = {
    userRelation?: UserUpdateOneRequiredWithoutOpportunitiesNestedInput
  }

  export type UserOpportunityJoinUncheckedUpdateWithoutOpportunityRelationInput = {
    userId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type UserOpportunityJoinUncheckedUpdateManyWithoutOpportunityRelationInput = {
    userId?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type ActivityUpdateWithoutOpportunityInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    steps?: ActivityStepUpdateManyWithoutActivityNestedInput
    waypoints?: ActivityWaypointUpdateManyWithoutActivityNestedInput
    activities?: ActivityUpdateManyWithoutParentActivityNestedInput
    parentActivity?: ActivityUpdateOneWithoutActivitiesNestedInput
    parentWaypoint?: ActivityWaypointUpdateOneWithoutChildActivitiesNestedInput
    template?: ActivityTemplateUpdateOneWithoutActivitiesNestedInput
    assignedBy?: UserUpdateOneRequiredWithoutAssignedActivitiesNestedInput
    contacts?: ActivityContactJoinUpdateManyWithoutActivityRelationNestedInput
    users?: ActivityUserJoinUpdateManyWithoutActivityRelationNestedInput
    tenet?: TenetUpdateOneRequiredWithoutActivitiesNestedInput
    attachments?: AttachmentUpdateManyWithoutActivityNestedInput
    notes?: NoteUpdateManyWithoutActivityNestedInput
    events?: ContactTimelineEventUpdateManyWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateWithoutOpportunityInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    parentActivityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    parentWaypointId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    templateId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    assignedById?: BytesFieldUpdateOperationsInput | Uint8Array
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    steps?: ActivityStepUncheckedUpdateManyWithoutActivityNestedInput
    waypoints?: ActivityWaypointUncheckedUpdateManyWithoutActivityNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutParentActivityNestedInput
    contacts?: ActivityContactJoinUncheckedUpdateManyWithoutActivityRelationNestedInput
    users?: ActivityUserJoinUncheckedUpdateManyWithoutActivityRelationNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutActivityNestedInput
    notes?: NoteUncheckedUpdateManyWithoutActivityNestedInput
    events?: ContactTimelineEventUncheckedUpdateManyWithoutActivityNestedInput
  }

  export type ActivityUncheckedUpdateManyWithoutOpportunityInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    title?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    parentActivityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    parentWaypointId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    templateId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    taskScheduleType?: NullableEnumTaskScheduleTypeFieldUpdateOperationsInput | $Enums.TaskScheduleType | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumActivityPriorityFieldUpdateOperationsInput | $Enums.ActivityPriority
    status?: EnumActivityStatusFieldUpdateOperationsInput | $Enums.ActivityStatus
    assignedById?: BytesFieldUpdateOperationsInput | Uint8Array
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    holdReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OpportunityProductUpdateWithoutOpportunityInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    price?: FloatFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productType?: ProductTypeUpdateOneRequiredWithoutOpportunitiesNestedInput
  }

  export type OpportunityProductUncheckedUpdateWithoutOpportunityInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    price?: FloatFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    productTypeId?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OpportunityProductUncheckedUpdateManyWithoutOpportunityInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    price?: FloatFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    productTypeId?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactTimelineEventUpdateWithoutOpportunityInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    extraInfo?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: EnumContactTimelineEventTypeFieldUpdateOperationsInput | $Enums.ContactTimelineEventType
    relationshipType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activity?: ActivityUpdateOneWithoutEventsNestedInput
    waypoint?: ActivityWaypointUpdateOneWithoutEventsNestedInput
    note?: NoteUpdateOneWithoutEventsNestedInput
    contacts?: ContactTimelineEventContactJoinUpdateManyWithoutContactEventRelationNestedInput
    user?: UserUpdateOneRequiredWithoutEventsNestedInput
    tenet?: TenetUpdateOneRequiredWithoutContactTimelineEventsNestedInput
  }

  export type ContactTimelineEventUncheckedUpdateWithoutOpportunityInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    activityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    waypointId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    noteId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    extraInfo?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: BytesFieldUpdateOperationsInput | Uint8Array
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    eventType?: EnumContactTimelineEventTypeFieldUpdateOperationsInput | $Enums.ContactTimelineEventType
    relationshipType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactTimelineEventContactJoinUncheckedUpdateManyWithoutContactEventRelationNestedInput
  }

  export type ContactTimelineEventUncheckedUpdateManyWithoutOpportunityInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    activityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    waypointId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    noteId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    extraInfo?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: BytesFieldUpdateOperationsInput | Uint8Array
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    eventType?: EnumContactTimelineEventTypeFieldUpdateOperationsInput | $Enums.ContactTimelineEventType
    relationshipType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoteUpdateWithoutOpportunityInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noteType?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    waypoint?: ActivityWaypointUpdateOneWithoutNoteNestedInput
    activity?: ActivityUpdateOneWithoutNotesNestedInput
    contact?: ContactUpdateOneWithoutNotesNestedInput
    tenet?: TenetUpdateOneRequiredWithoutNotesNestedInput
    author?: UserUpdateOneRequiredWithoutNotesNestedInput
    events?: ContactTimelineEventUpdateManyWithoutNoteNestedInput
  }

  export type NoteUncheckedUpdateWithoutOpportunityInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    content?: StringFieldUpdateOperationsInput | string
    waypointId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    activityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    contactId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    authorId?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noteType?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    events?: ContactTimelineEventUncheckedUpdateManyWithoutNoteNestedInput
  }

  export type NoteUncheckedUpdateManyWithoutOpportunityInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    content?: StringFieldUpdateOperationsInput | string
    waypointId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    activityId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    contactId?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    tenetId?: BytesFieldUpdateOperationsInput | Uint8Array
    authorId?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noteType?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
  }

  export type OpportunityProductCreateManyProductTypeInput = {
    id: Uint8Array
    price: number
    order: number
    commission: number
    opportunityId: Uint8Array
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OpportunityProductUpdateWithoutProductTypeInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    price?: FloatFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    opportunity?: OpportunityUpdateOneRequiredWithoutProductsNestedInput
  }

  export type OpportunityProductUncheckedUpdateWithoutProductTypeInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    price?: FloatFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    opportunityId?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OpportunityProductUncheckedUpdateManyWithoutProductTypeInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    price?: FloatFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    opportunityId?: BytesFieldUpdateOperationsInput | Uint8Array
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WrappedObjectCreateManyTestObjectInput = {
    id: Uint8Array
    persisted?: string | null
  }

  export type JoinTestObjectCreateManyTestObjectRelationInput = {
    joinedObjectId: Uint8Array
    joinProperty: string
  }

  export type JoinTestObject2CreateManyTestObjectRelationInput = {
    id: Uint8Array
    joinedObjectId: Uint8Array
    joinProperty: string
  }

  export type WrappedObjectUpdateWithoutTestObjectInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    persisted?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WrappedObjectUncheckedUpdateWithoutTestObjectInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    persisted?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WrappedObjectUncheckedUpdateManyWithoutTestObjectInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    persisted?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JoinTestObjectUpdateWithoutTestObjectRelationInput = {
    joinProperty?: StringFieldUpdateOperationsInput | string
    joinedObjectRelation?: JoinedObject1UpdateOneRequiredWithoutTestObjectsNestedInput
  }

  export type JoinTestObjectUncheckedUpdateWithoutTestObjectRelationInput = {
    joinedObjectId?: BytesFieldUpdateOperationsInput | Uint8Array
    joinProperty?: StringFieldUpdateOperationsInput | string
  }

  export type JoinTestObjectUncheckedUpdateManyWithoutTestObjectRelationInput = {
    joinedObjectId?: BytesFieldUpdateOperationsInput | Uint8Array
    joinProperty?: StringFieldUpdateOperationsInput | string
  }

  export type JoinTestObject2UpdateWithoutTestObjectRelationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    joinProperty?: StringFieldUpdateOperationsInput | string
    joinedObjectRelation?: JoinedObject2UpdateOneRequiredWithoutTestObjectsNestedInput
  }

  export type JoinTestObject2UncheckedUpdateWithoutTestObjectRelationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    joinedObjectId?: BytesFieldUpdateOperationsInput | Uint8Array
    joinProperty?: StringFieldUpdateOperationsInput | string
  }

  export type JoinTestObject2UncheckedUpdateManyWithoutTestObjectRelationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    joinedObjectId?: BytesFieldUpdateOperationsInput | Uint8Array
    joinProperty?: StringFieldUpdateOperationsInput | string
  }

  export type JoinTestObjectCreateManyJoinedObjectRelationInput = {
    testObjectId: Uint8Array
    joinProperty: string
  }

  export type JoinTestObjectUpdateWithoutJoinedObjectRelationInput = {
    joinProperty?: StringFieldUpdateOperationsInput | string
    testObjectRelation?: TestObjectUpdateOneRequiredWithoutJoin1NestedInput
  }

  export type JoinTestObjectUncheckedUpdateWithoutJoinedObjectRelationInput = {
    testObjectId?: BytesFieldUpdateOperationsInput | Uint8Array
    joinProperty?: StringFieldUpdateOperationsInput | string
  }

  export type JoinTestObjectUncheckedUpdateManyWithoutJoinedObjectRelationInput = {
    testObjectId?: BytesFieldUpdateOperationsInput | Uint8Array
    joinProperty?: StringFieldUpdateOperationsInput | string
  }

  export type JoinTestObject2CreateManyJoinedObjectRelationInput = {
    id: Uint8Array
    testObjectId: Uint8Array
    joinProperty: string
  }

  export type JoinTestObject2UpdateWithoutJoinedObjectRelationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    joinProperty?: StringFieldUpdateOperationsInput | string
    testObjectRelation?: TestObjectUpdateOneRequiredWithoutJoin2NestedInput
  }

  export type JoinTestObject2UncheckedUpdateWithoutJoinedObjectRelationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    testObjectId?: BytesFieldUpdateOperationsInput | Uint8Array
    joinProperty?: StringFieldUpdateOperationsInput | string
  }

  export type JoinTestObject2UncheckedUpdateManyWithoutJoinedObjectRelationInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    testObjectId?: BytesFieldUpdateOperationsInput | Uint8Array
    joinProperty?: StringFieldUpdateOperationsInput | string
  }

  export type JoinSelfReferenceCreateManySourceInput = {
    id: Uint8Array
    targetId: Uint8Array
    joinProperty: string
  }

  export type JoinSelfReferenceCreateManyTargetInput = {
    id: Uint8Array
    sourceId: Uint8Array
    joinProperty: string
  }

  export type JoinSelfReferenceUpdateWithoutSourceInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    joinProperty?: StringFieldUpdateOperationsInput | string
    target?: SelfReferencialJoinModelUpdateOneRequiredWithoutJoinsAsTargetNestedInput
  }

  export type JoinSelfReferenceUncheckedUpdateWithoutSourceInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    targetId?: BytesFieldUpdateOperationsInput | Uint8Array
    joinProperty?: StringFieldUpdateOperationsInput | string
  }

  export type JoinSelfReferenceUncheckedUpdateManyWithoutSourceInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    targetId?: BytesFieldUpdateOperationsInput | Uint8Array
    joinProperty?: StringFieldUpdateOperationsInput | string
  }

  export type JoinSelfReferenceUpdateWithoutTargetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    joinProperty?: StringFieldUpdateOperationsInput | string
    source?: SelfReferencialJoinModelUpdateOneRequiredWithoutJoinsAsSourceNestedInput
  }

  export type JoinSelfReferenceUncheckedUpdateWithoutTargetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    sourceId?: BytesFieldUpdateOperationsInput | Uint8Array
    joinProperty?: StringFieldUpdateOperationsInput | string
  }

  export type JoinSelfReferenceUncheckedUpdateManyWithoutTargetInput = {
    id?: BytesFieldUpdateOperationsInput | Uint8Array
    sourceId?: BytesFieldUpdateOperationsInput | Uint8Array
    joinProperty?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}